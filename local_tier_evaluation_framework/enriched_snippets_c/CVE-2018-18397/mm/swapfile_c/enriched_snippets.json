[
  {
    "function_name": "swapfile_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3755-3770",
    "snippet": "static int __init swapfile_init(void)\n{\n\tint nid;\n\n\tswap_avail_heads = kmalloc_array(nr_node_ids, sizeof(struct plist_head),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!swap_avail_heads) {\n\t\tpr_emerg(\"Not enough memory for swap heads, swap is disabled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_node(nid)\n\t\tplist_head_init(&swap_avail_heads[nid]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct plist_head *swap_avail_heads;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Not enough memory for swap heads, swap is disabled\\n\""
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_node_ids",
            "sizeof(struct plist_head)",
            "GFP_KERNEL"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct plist_head *swap_avail_heads;\n\nstatic int __init swapfile_init(void)\n{\n\tint nid;\n\n\tswap_avail_heads = kmalloc_array(nr_node_ids, sizeof(struct plist_head),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!swap_avail_heads) {\n\t\tpr_emerg(\"Not enough memory for swap heads, swap is disabled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_node(nid)\n\t\tplist_head_init(&swap_avail_heads[nid]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_cgroup_throttle_swaprate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3725-3752",
    "snippet": "void mem_cgroup_throttle_swaprate(struct mem_cgroup *memcg, int node,\n\t\t\t\t  gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si, *next;\n\tif (!(gfp_mask & __GFP_IO) || !memcg)\n\t\treturn;\n\n\tif (!blk_cgroup_congested())\n\t\treturn;\n\n\t/*\n\t * We've already scheduled a throttle, avoid taking the global swap\n\t * lock.\n\t */\n\tif (current->throttle_queue)\n\t\treturn;\n\n\tspin_lock(&swap_avail_lock);\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node],\n\t\t\t\t  avail_lists[node]) {\n\t\tif (si->bdev) {\n\t\t\tblkcg_schedule_throttle(bdev_get_queue(si->bdev),\n\t\t\t\t\t\ttrue);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&swap_avail_lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static struct plist_head *swap_avail_heads;",
      "static DEFINE_SPINLOCK(swap_avail_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkcg_schedule_throttle",
          "args": [
            "bdev_get_queue(si->bdev)",
            "true"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "si->bdev"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry_safe",
          "args": [
            "si",
            "next",
            "&swap_avail_heads[node]",
            "avail_lists[node]"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_cgroup_congested",
          "args": [],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nvoid mem_cgroup_throttle_swaprate(struct mem_cgroup *memcg, int node,\n\t\t\t\t  gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si, *next;\n\tif (!(gfp_mask & __GFP_IO) || !memcg)\n\t\treturn;\n\n\tif (!blk_cgroup_congested())\n\t\treturn;\n\n\t/*\n\t * We've already scheduled a throttle, avoid taking the global swap\n\t * lock.\n\t */\n\tif (current->throttle_queue)\n\t\treturn;\n\n\tspin_lock(&swap_avail_lock);\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node],\n\t\t\t\t  avail_lists[node]) {\n\t\tif (si->bdev) {\n\t\t\tblkcg_schedule_throttle(bdev_get_queue(si->bdev),\n\t\t\t\t\t\ttrue);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&swap_avail_lock);\n}"
  },
  {
    "function_name": "free_swap_count_continuations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3706-3722",
    "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "&head->lru",
            "lru"
          ],
          "line": 3716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "head"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "si->swap_map + offset"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "264-267",
          "snippet": "struct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "swap_count_continued",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3618-3700",
    "snippet": "static bool swap_count_continued(struct swap_info_struct *si,\n\t\t\t\t pgoff_t offset, unsigned char count)\n{\n\tstruct page *head;\n\tstruct page *page;\n\tunsigned char *map;\n\tbool ret;\n\n\thead = vmalloc_to_page(si->swap_map + offset);\n\tif (page_private(head) != SWP_CONTINUED) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\treturn false;\t\t/* need to add count continuation */\n\t}\n\n\tspin_lock(&si->cont_lock);\n\toffset &= ~PAGE_MASK;\n\tpage = list_entry(head->lru.next, struct page, lru);\n\tmap = kmap_atomic(page) + offset;\n\n\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n\n\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n\t\t/*\n\t\t * Think of how you add 1 to 999\n\t\t */\n\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tif (*map == SWAP_CONT_MAX) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tif (page == head) {\n\t\t\t\tret = false;\t/* add count continuation */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap = kmap_atomic(page) + offset;\ninit_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n\t\t}\n\t\t*map += 1;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = true;\t\t\t/* incremented */\n\n\t} else {\t\t\t\t/* decrementing */\n\t\t/*\n\t\t * Think of how you subtract 1 from 1000\n\t\t */\n\t\tBUG_ON(count != COUNT_CONTINUED);\n\t\twhile (*map == COUNT_CONTINUED) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tBUG_ON(*map == 0);\n\t\t*map -= 1;\n\t\tif (*map == 0)\n\t\t\tcount = 0;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = SWAP_CONT_MAX | count;\n\t\t\tcount = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = count == COUNT_CONTINUED;\n\t}\nout:\n\tspin_unlock(&si->cont_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->cont_lock"
          ],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page->lru.prev",
            "structpage",
            "lru"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page->lru.prev",
            "structpage",
            "lru"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*map == 0"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page == head"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page->lru.next",
            "structpage",
            "lru"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count != COUNT_CONTINUED"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page->lru.prev",
            "structpage",
            "lru"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page->lru.prev",
            "structpage",
            "lru"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page->lru.next",
            "structpage",
            "lru"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page == head"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page->lru.next",
            "structpage",
            "lru"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->lru.next",
            "structpage",
            "lru"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->cont_lock"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count & COUNT_CONTINUED"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "head"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "si->swap_map + offset"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "264-267",
          "snippet": "struct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool swap_count_continued(struct swap_info_struct *si,\n\t\t\t\t pgoff_t offset, unsigned char count)\n{\n\tstruct page *head;\n\tstruct page *page;\n\tunsigned char *map;\n\tbool ret;\n\n\thead = vmalloc_to_page(si->swap_map + offset);\n\tif (page_private(head) != SWP_CONTINUED) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\treturn false;\t\t/* need to add count continuation */\n\t}\n\n\tspin_lock(&si->cont_lock);\n\toffset &= ~PAGE_MASK;\n\tpage = list_entry(head->lru.next, struct page, lru);\n\tmap = kmap_atomic(page) + offset;\n\n\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n\n\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n\t\t/*\n\t\t * Think of how you add 1 to 999\n\t\t */\n\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tif (*map == SWAP_CONT_MAX) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tif (page == head) {\n\t\t\t\tret = false;\t/* add count continuation */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap = kmap_atomic(page) + offset;\ninit_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n\t\t}\n\t\t*map += 1;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = true;\t\t\t/* incremented */\n\n\t} else {\t\t\t\t/* decrementing */\n\t\t/*\n\t\t * Think of how you subtract 1 from 1000\n\t\t */\n\t\tBUG_ON(count != COUNT_CONTINUED);\n\t\twhile (*map == COUNT_CONTINUED) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tBUG_ON(*map == 0);\n\t\t*map -= 1;\n\t\tif (*map == 0)\n\t\t\tcount = 0;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = SWAP_CONT_MAX | count;\n\t\t\tcount = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = count == COUNT_CONTINUED;\n\t}\nout:\n\tspin_unlock(&si->cont_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_swap_count_continuation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3507-3607",
    "snippet": "int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tstruct page *head;\n\tstruct page *page;\n\tstruct page *list_page;\n\tpgoff_t offset;\n\tunsigned char count;\n\n\t/*\n\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n\t */\n\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n\n\tsi = swap_info_get(entry);\n\tif (!si) {\n\t\t/*\n\t\t * An acceptable race has occurred since the failing\n\t\t * __swap_duplicate(): the swap entry has been freed,\n\t\t * perhaps even the whole swap_map cleared for swapoff.\n\t\t */\n\t\tgoto outer;\n\t}\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster(si, offset);\n\n\tcount = si->swap_map[offset] & ~SWAP_HAS_CACHE;\n\n\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n\t\t/*\n\t\t * The higher the swap count, the more likely it is that tasks\n\t\t * will race to add swap count continuation: we need to avoid\n\t\t * over-provisioning.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!page) {\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We are fortunate that although vmalloc_to_page uses pte_offset_map,\n\t * no architecture is using highmem pages for kernel page tables: so it\n\t * will not corrupt the GFP_ATOMIC caller's atomic page table kmaps.\n\t */\n\thead = vmalloc_to_page(si->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\n\tspin_lock(&si->cont_lock);\n\t/*\n\t * Page allocation does not initialize the page's lru field,\n\t * but it does always reset its private field.\n\t */\n\tif (!page_private(head)) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\tINIT_LIST_HEAD(&head->lru);\n\t\tset_page_private(head, SWP_CONTINUED);\n\t\tsi->flags |= SWP_CONTINUED;\n\t}\n\n\tlist_for_each_entry(list_page, &head->lru, lru) {\n\t\tunsigned char *map;\n\n\t\t/*\n\t\t * If the previous map said no continuation, but we've found\n\t\t * a continuation page, free our allocation and use this one.\n\t\t */\n\t\tif (!(count & COUNT_CONTINUED))\n\t\t\tgoto out_unlock_cont;\n\n\t\tmap = kmap_atomic(list_page) + offset;\n\t\tcount = *map;\n\t\tkunmap_atomic(map);\n\n\t\t/*\n\t\t * If this continuation count now has some space in it,\n\t\t * free our allocation and use this one.\n\t\t */\n\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n\t\t\tgoto out_unlock_cont;\n\t}\n\n\tlist_add_tail(&page->lru, &head->lru);\n\tpage = NULL;\t\t\t/* now it's attached, don't free it */\nout_unlock_cont:\n\tspin_unlock(&si->cont_lock);\nout:\n\tunlock_cluster(ci);\n\tspin_unlock(&si->lock);\nouter:\n\tif (page)\n\t\t__free_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->cont_lock"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&head->lru"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "list_page"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "list_page",
            "&head->lru",
            "lru"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "head",
            "SWP_CONTINUED"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&head->lru"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count & COUNT_CONTINUED"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "head"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->cont_lock"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "si->swap_map + offset"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "264-267",
          "snippet": "struct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "offset"
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_info_get",
          "args": [
            "entry"
          ],
          "line": 3523
        },
        "resolved": true,
        "details": {
          "function_name": "swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1114-1122",
          "snippet": "static struct swap_info_struct *swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\tspin_lock(&p->lock);\n\treturn p;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic struct swap_info_struct *swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\tspin_lock(&p->lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_mask | __GFP_HIGHMEM"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tstruct page *head;\n\tstruct page *page;\n\tstruct page *list_page;\n\tpgoff_t offset;\n\tunsigned char count;\n\n\t/*\n\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n\t */\n\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n\n\tsi = swap_info_get(entry);\n\tif (!si) {\n\t\t/*\n\t\t * An acceptable race has occurred since the failing\n\t\t * __swap_duplicate(): the swap entry has been freed,\n\t\t * perhaps even the whole swap_map cleared for swapoff.\n\t\t */\n\t\tgoto outer;\n\t}\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster(si, offset);\n\n\tcount = si->swap_map[offset] & ~SWAP_HAS_CACHE;\n\n\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n\t\t/*\n\t\t * The higher the swap count, the more likely it is that tasks\n\t\t * will race to add swap count continuation: we need to avoid\n\t\t * over-provisioning.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!page) {\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We are fortunate that although vmalloc_to_page uses pte_offset_map,\n\t * no architecture is using highmem pages for kernel page tables: so it\n\t * will not corrupt the GFP_ATOMIC caller's atomic page table kmaps.\n\t */\n\thead = vmalloc_to_page(si->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\n\tspin_lock(&si->cont_lock);\n\t/*\n\t * Page allocation does not initialize the page's lru field,\n\t * but it does always reset its private field.\n\t */\n\tif (!page_private(head)) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\tINIT_LIST_HEAD(&head->lru);\n\t\tset_page_private(head, SWP_CONTINUED);\n\t\tsi->flags |= SWP_CONTINUED;\n\t}\n\n\tlist_for_each_entry(list_page, &head->lru, lru) {\n\t\tunsigned char *map;\n\n\t\t/*\n\t\t * If the previous map said no continuation, but we've found\n\t\t * a continuation page, free our allocation and use this one.\n\t\t */\n\t\tif (!(count & COUNT_CONTINUED))\n\t\t\tgoto out_unlock_cont;\n\n\t\tmap = kmap_atomic(list_page) + offset;\n\t\tcount = *map;\n\t\tkunmap_atomic(map);\n\n\t\t/*\n\t\t * If this continuation count now has some space in it,\n\t\t * free our allocation and use this one.\n\t\t */\n\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n\t\t\tgoto out_unlock_cont;\n\t}\n\n\tlist_add_tail(&page->lru, &head->lru);\n\tpage = NULL;\t\t\t/* now it's attached, don't free it */\nout_unlock_cont:\n\tspin_unlock(&si->cont_lock);\nout:\n\tunlock_cluster(ci);\n\tspin_unlock(&si->lock);\nouter:\n\tif (page)\n\t\t__free_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "__page_file_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3485-3489",
    "snippet": "pgoff_t __page_file_index(struct page *page)\n{\n\tswp_entry_t swap = { .val = page_private(page) };\n\treturn swp_offset(swap);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "swap"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\n\npgoff_t __page_file_index(struct page *page)\n{\n\tswp_entry_t swap = { .val = page_private(page) };\n\treturn swp_offset(swap);\n}"
  },
  {
    "function_name": "__page_file_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3479-3482",
    "snippet": "struct address_space *__page_file_mapping(struct page *page)\n{\n\treturn page_swap_info(page)->swap_file->f_mapping;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_swap_info",
          "args": [
            "page"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "page_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3470-3474",
          "snippet": "struct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstruct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct address_space *__page_file_mapping(struct page *page)\n{\n\treturn page_swap_info(page)->swap_file->f_mapping;\n}"
  },
  {
    "function_name": "page_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3470-3474",
    "snippet": "struct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swp_swap_info",
          "args": [
            "entry"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "swp_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3465-3468",
          "snippet": "struct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstruct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstruct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}"
  },
  {
    "function_name": "swp_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3465-3468",
    "snippet": "struct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstruct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}"
  },
  {
    "function_name": "swapcache_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3460-3463",
    "snippet": "int swapcache_prepare(swp_entry_t entry)\n{\n\treturn __swap_duplicate(entry, SWAP_HAS_CACHE);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__swap_duplicate",
          "args": [
            "entry",
            "SWAP_HAS_CACHE"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3355-3425",
          "snippet": "static int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static unsigned int nr_swapfiles;",
            "static const char Bad_file[] = \"Bad swap file entry \";",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint swapcache_prepare(swp_entry_t entry)\n{\n\treturn __swap_duplicate(entry, SWAP_HAS_CACHE);\n}"
  },
  {
    "function_name": "swap_duplicate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3443-3450",
    "snippet": "int swap_duplicate(swp_entry_t entry)\n{\n\tint err = 0;\n\n\twhile (!err && __swap_duplicate(entry, 1) == -ENOMEM)\n\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n\treturn err;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_swap_count_continuation",
          "args": [
            "entry",
            "GFP_ATOMIC"
          ],
          "line": 3448
        },
        "resolved": true,
        "details": {
          "function_name": "add_swap_count_continuation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3507-3607",
          "snippet": "int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tstruct page *head;\n\tstruct page *page;\n\tstruct page *list_page;\n\tpgoff_t offset;\n\tunsigned char count;\n\n\t/*\n\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n\t */\n\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n\n\tsi = swap_info_get(entry);\n\tif (!si) {\n\t\t/*\n\t\t * An acceptable race has occurred since the failing\n\t\t * __swap_duplicate(): the swap entry has been freed,\n\t\t * perhaps even the whole swap_map cleared for swapoff.\n\t\t */\n\t\tgoto outer;\n\t}\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster(si, offset);\n\n\tcount = si->swap_map[offset] & ~SWAP_HAS_CACHE;\n\n\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n\t\t/*\n\t\t * The higher the swap count, the more likely it is that tasks\n\t\t * will race to add swap count continuation: we need to avoid\n\t\t * over-provisioning.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!page) {\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We are fortunate that although vmalloc_to_page uses pte_offset_map,\n\t * no architecture is using highmem pages for kernel page tables: so it\n\t * will not corrupt the GFP_ATOMIC caller's atomic page table kmaps.\n\t */\n\thead = vmalloc_to_page(si->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\n\tspin_lock(&si->cont_lock);\n\t/*\n\t * Page allocation does not initialize the page's lru field,\n\t * but it does always reset its private field.\n\t */\n\tif (!page_private(head)) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\tINIT_LIST_HEAD(&head->lru);\n\t\tset_page_private(head, SWP_CONTINUED);\n\t\tsi->flags |= SWP_CONTINUED;\n\t}\n\n\tlist_for_each_entry(list_page, &head->lru, lru) {\n\t\tunsigned char *map;\n\n\t\t/*\n\t\t * If the previous map said no continuation, but we've found\n\t\t * a continuation page, free our allocation and use this one.\n\t\t */\n\t\tif (!(count & COUNT_CONTINUED))\n\t\t\tgoto out_unlock_cont;\n\n\t\tmap = kmap_atomic(list_page) + offset;\n\t\tcount = *map;\n\t\tkunmap_atomic(map);\n\n\t\t/*\n\t\t * If this continuation count now has some space in it,\n\t\t * free our allocation and use this one.\n\t\t */\n\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n\t\t\tgoto out_unlock_cont;\n\t}\n\n\tlist_add_tail(&page->lru, &head->lru);\n\tpage = NULL;\t\t\t/* now it's attached, don't free it */\nout_unlock_cont:\n\tspin_unlock(&si->cont_lock);\nout:\n\tunlock_cluster(ci);\n\tspin_unlock(&si->lock);\nouter:\n\tif (page)\n\t\t__free_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tstruct page *head;\n\tstruct page *page;\n\tstruct page *list_page;\n\tpgoff_t offset;\n\tunsigned char count;\n\n\t/*\n\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n\t */\n\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n\n\tsi = swap_info_get(entry);\n\tif (!si) {\n\t\t/*\n\t\t * An acceptable race has occurred since the failing\n\t\t * __swap_duplicate(): the swap entry has been freed,\n\t\t * perhaps even the whole swap_map cleared for swapoff.\n\t\t */\n\t\tgoto outer;\n\t}\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster(si, offset);\n\n\tcount = si->swap_map[offset] & ~SWAP_HAS_CACHE;\n\n\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n\t\t/*\n\t\t * The higher the swap count, the more likely it is that tasks\n\t\t * will race to add swap count continuation: we need to avoid\n\t\t * over-provisioning.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!page) {\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We are fortunate that although vmalloc_to_page uses pte_offset_map,\n\t * no architecture is using highmem pages for kernel page tables: so it\n\t * will not corrupt the GFP_ATOMIC caller's atomic page table kmaps.\n\t */\n\thead = vmalloc_to_page(si->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\n\tspin_lock(&si->cont_lock);\n\t/*\n\t * Page allocation does not initialize the page's lru field,\n\t * but it does always reset its private field.\n\t */\n\tif (!page_private(head)) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\tINIT_LIST_HEAD(&head->lru);\n\t\tset_page_private(head, SWP_CONTINUED);\n\t\tsi->flags |= SWP_CONTINUED;\n\t}\n\n\tlist_for_each_entry(list_page, &head->lru, lru) {\n\t\tunsigned char *map;\n\n\t\t/*\n\t\t * If the previous map said no continuation, but we've found\n\t\t * a continuation page, free our allocation and use this one.\n\t\t */\n\t\tif (!(count & COUNT_CONTINUED))\n\t\t\tgoto out_unlock_cont;\n\n\t\tmap = kmap_atomic(list_page) + offset;\n\t\tcount = *map;\n\t\tkunmap_atomic(map);\n\n\t\t/*\n\t\t * If this continuation count now has some space in it,\n\t\t * free our allocation and use this one.\n\t\t */\n\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n\t\t\tgoto out_unlock_cont;\n\t}\n\n\tlist_add_tail(&page->lru, &head->lru);\n\tpage = NULL;\t\t\t/* now it's attached, don't free it */\nout_unlock_cont:\n\tspin_unlock(&si->cont_lock);\nout:\n\tunlock_cluster(ci);\n\tspin_unlock(&si->lock);\nouter:\n\tif (page)\n\t\t__free_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__swap_duplicate",
          "args": [
            "entry",
            "1"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3355-3425",
          "snippet": "static int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static unsigned int nr_swapfiles;",
            "static const char Bad_file[] = \"Bad swap file entry \";",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint swap_duplicate(swp_entry_t entry)\n{\n\tint err = 0;\n\n\twhile (!err && __swap_duplicate(entry, 1) == -ENOMEM)\n\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n\treturn err;\n}"
  },
  {
    "function_name": "swap_shmem_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3431-3434",
    "snippet": "void swap_shmem_alloc(swp_entry_t entry)\n{\n\t__swap_duplicate(entry, SWAP_MAP_SHMEM);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__swap_duplicate",
          "args": [
            "entry",
            "SWAP_MAP_SHMEM"
          ],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3355-3425",
          "snippet": "static int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static unsigned int nr_swapfiles;",
            "static const char Bad_file[] = \"Bad swap file entry \";",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid swap_shmem_alloc(swp_entry_t entry)\n{\n\t__swap_duplicate(entry, SWAP_MAP_SHMEM);\n}"
  },
  {
    "function_name": "__swap_duplicate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3355-3425",
    "snippet": "static int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;",
      "static const char Bad_file[] = \"Bad swap file entry \";",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swap_dup: %s%08lx\\n\"",
            "Bad_file",
            "entry.val"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_cluster_or_swap_info",
          "args": [
            "p",
            "ci"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_count_continued",
          "args": [
            "p",
            "offset",
            "count"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "swap_count_continued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3618-3700",
          "snippet": "static bool swap_count_continued(struct swap_info_struct *si,\n\t\t\t\t pgoff_t offset, unsigned char count)\n{\n\tstruct page *head;\n\tstruct page *page;\n\tunsigned char *map;\n\tbool ret;\n\n\thead = vmalloc_to_page(si->swap_map + offset);\n\tif (page_private(head) != SWP_CONTINUED) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\treturn false;\t\t/* need to add count continuation */\n\t}\n\n\tspin_lock(&si->cont_lock);\n\toffset &= ~PAGE_MASK;\n\tpage = list_entry(head->lru.next, struct page, lru);\n\tmap = kmap_atomic(page) + offset;\n\n\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n\n\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n\t\t/*\n\t\t * Think of how you add 1 to 999\n\t\t */\n\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tif (*map == SWAP_CONT_MAX) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tif (page == head) {\n\t\t\t\tret = false;\t/* add count continuation */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap = kmap_atomic(page) + offset;\ninit_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n\t\t}\n\t\t*map += 1;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = true;\t\t\t/* incremented */\n\n\t} else {\t\t\t\t/* decrementing */\n\t\t/*\n\t\t * Think of how you subtract 1 from 1000\n\t\t */\n\t\tBUG_ON(count != COUNT_CONTINUED);\n\t\twhile (*map == COUNT_CONTINUED) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tBUG_ON(*map == 0);\n\t\t*map -= 1;\n\t\tif (*map == 0)\n\t\t\tcount = 0;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = SWAP_CONT_MAX | count;\n\t\t\tcount = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = count == COUNT_CONTINUED;\n\t}\nout:\n\tspin_unlock(&si->cont_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool swap_count_continued(struct swap_info_struct *si,\n\t\t\t\t pgoff_t offset, unsigned char count)\n{\n\tstruct page *head;\n\tstruct page *page;\n\tunsigned char *map;\n\tbool ret;\n\n\thead = vmalloc_to_page(si->swap_map + offset);\n\tif (page_private(head) != SWP_CONTINUED) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\treturn false;\t\t/* need to add count continuation */\n\t}\n\n\tspin_lock(&si->cont_lock);\n\toffset &= ~PAGE_MASK;\n\tpage = list_entry(head->lru.next, struct page, lru);\n\tmap = kmap_atomic(page) + offset;\n\n\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n\n\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n\t\t/*\n\t\t * Think of how you add 1 to 999\n\t\t */\n\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tif (*map == SWAP_CONT_MAX) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tif (page == head) {\n\t\t\t\tret = false;\t/* add count continuation */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap = kmap_atomic(page) + offset;\ninit_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n\t\t}\n\t\t*map += 1;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = true;\t\t\t/* incremented */\n\n\t} else {\t\t\t\t/* decrementing */\n\t\t/*\n\t\t * Think of how you subtract 1 from 1000\n\t\t */\n\t\tBUG_ON(count != COUNT_CONTINUED);\n\t\twhile (*map == COUNT_CONTINUED) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tBUG_ON(*map == 0);\n\t\t*map -= 1;\n\t\tif (*map == 0)\n\t\t\tcount = 0;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = SWAP_CONT_MAX | count;\n\t\t\tcount = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = count == COUNT_CONTINUED;\n\t}\nout:\n\tspin_unlock(&si->cont_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "swap_count(count) == SWAP_MAP_BAD"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "count"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset >= p->max"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic int __swap_duplicate(swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, type;\n\tunsigned char count;\n\tunsigned char has_cache;\n\tint err = -EINVAL;\n\n\tif (non_swap_entry(entry))\n\t\tgoto out;\n\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_file;\n\tp = swap_info[type];\n\toffset = swp_offset(entry);\n\tif (unlikely(offset >= p->max))\n\t\tgoto out;\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = p->swap_map[offset];\n\n\t/*\n\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n\t */\n\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\terr = 0;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\n\t\t/* set SWAP_HAS_CACHE if there is no cache and entry is used */\n\t\tif (!has_cache && count)\n\t\t\thas_cache = SWAP_HAS_CACHE;\n\t\telse if (has_cache)\t\t/* someone else added cache */\n\t\t\terr = -EEXIST;\n\t\telse\t\t\t\t/* no users remaining */\n\t\t\terr = -ENOENT;\n\n\t} else if (count || has_cache) {\n\n\t\tif ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n\t\t\tcount += usage;\n\t\telse if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX)\n\t\t\terr = -EINVAL;\n\t\telse if (swap_count_continued(p, offset, count))\n\t\t\tcount = COUNT_CONTINUED;\n\t\telse\n\t\t\terr = -ENOMEM;\n\t} else\n\t\terr = -ENOENT;\t\t\t/* unused swap entry */\n\n\tp->swap_map[offset] = count | has_cache;\n\nunlock_out:\n\tunlock_cluster_or_swap_info(p, ci);\nout:\n\treturn err;\n\nbad_file:\n\tpr_err(\"swap_dup: %s%08lx\\n\", Bad_file, entry.val);\n\tgoto out;\n}"
  },
  {
    "function_name": "si_swapinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3327-3342",
    "snippet": "void si_swapinfo(struct sysinfo *val)\n{\n\tunsigned int type;\n\tunsigned long nr_to_be_unused = 0;\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tstruct swap_info_struct *si = swap_info[type];\n\n\t\tif ((si->flags & SWP_USED) && !(si->flags & SWP_WRITEOK))\n\t\t\tnr_to_be_unused += si->inuse_pages;\n\t}\n\tval->freeswap = atomic_long_read(&nr_swap_pages) + nr_to_be_unused;\n\tval->totalswap = total_swap_pages + nr_to_be_unused;\n\tspin_unlock(&swap_lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;",
      "atomic_long_t nr_swap_pages;",
      "long total_swap_pages;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&nr_swap_pages"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\natomic_long_t nr_swap_pages;\nlong total_swap_pages;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nvoid si_swapinfo(struct sysinfo *val)\n{\n\tunsigned int type;\n\tunsigned long nr_to_be_unused = 0;\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tstruct swap_info_struct *si = swap_info[type];\n\n\t\tif ((si->flags & SWP_USED) && !(si->flags & SWP_WRITEOK))\n\t\t\tnr_to_be_unused += si->inuse_pages;\n\t}\n\tval->freeswap = atomic_long_read(&nr_swap_pages) + nr_to_be_unused;\n\tval->totalswap = total_swap_pages + nr_to_be_unused;\n\tspin_unlock(&swap_lock);\n}"
  },
  {
    "function_name": "swap_discardable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3078-3086",
    "snippet": "static bool swap_discardable(struct swap_info_struct *si)\n{\n\tstruct request_queue *q = bdev_get_queue(si->bdev);\n\n\tif (!q || !blk_queue_discard(q))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "si->bdev"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool swap_discardable(struct swap_info_struct *si)\n{\n\tstruct request_queue *q = bdev_get_queue(si->bdev);\n\n\tif (!q || !blk_queue_discard(q))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "setup_swap_map_and_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2993-3072",
    "snippet": "static int setup_swap_map_and_extents(struct swap_info_struct *p,\n\t\t\t\t\tunion swap_header *swap_header,\n\t\t\t\t\tunsigned char *swap_map,\n\t\t\t\t\tstruct swap_cluster_info *cluster_info,\n\t\t\t\t\tunsigned long maxpages,\n\t\t\t\t\tsector_t *span)\n{\n\tunsigned int j, k;\n\tunsigned int nr_good_pages;\n\tint nr_extents;\n\tunsigned long nr_clusters = DIV_ROUND_UP(maxpages, SWAPFILE_CLUSTER);\n\tunsigned long col = p->cluster_next / SWAPFILE_CLUSTER % SWAP_CLUSTER_COLS;\n\tunsigned long i, idx;\n\n\tnr_good_pages = maxpages - 1;\t/* omit header page */\n\n\tcluster_list_init(&p->free_clusters);\n\tcluster_list_init(&p->discard_clusters);\n\n\tfor (i = 0; i < swap_header->info.nr_badpages; i++) {\n\t\tunsigned int page_nr = swap_header->info.badpages[i];\n\t\tif (page_nr == 0 || page_nr > swap_header->info.last_page)\n\t\t\treturn -EINVAL;\n\t\tif (page_nr < maxpages) {\n\t\t\tswap_map[page_nr] = SWAP_MAP_BAD;\n\t\t\tnr_good_pages--;\n\t\t\t/*\n\t\t\t * Haven't marked the cluster free yet, no list\n\t\t\t * operation involved\n\t\t\t */\n\t\t\tinc_cluster_info_page(p, cluster_info, page_nr);\n\t\t}\n\t}\n\n\t/* Haven't marked the cluster free yet, no list operation involved */\n\tfor (i = maxpages; i < round_up(maxpages, SWAPFILE_CLUSTER); i++)\n\t\tinc_cluster_info_page(p, cluster_info, i);\n\n\tif (nr_good_pages) {\n\t\tswap_map[0] = SWAP_MAP_BAD;\n\t\t/*\n\t\t * Not mark the cluster free yet, no list\n\t\t * operation involved\n\t\t */\n\t\tinc_cluster_info_page(p, cluster_info, 0);\n\t\tp->max = maxpages;\n\t\tp->pages = nr_good_pages;\n\t\tnr_extents = setup_swap_extents(p, span);\n\t\tif (nr_extents < 0)\n\t\t\treturn nr_extents;\n\t\tnr_good_pages = p->pages;\n\t}\n\tif (!nr_good_pages) {\n\t\tpr_warn(\"Empty swap-file\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cluster_info)\n\t\treturn nr_extents;\n\n\n\t/*\n\t * Reduce false cache line sharing between cluster_info and\n\t * sharing same address space.\n\t */\n\tfor (k = 0; k < SWAP_CLUSTER_COLS; k++) {\n\t\tj = (k + col) % SWAP_CLUSTER_COLS;\n\t\tfor (i = 0; i < DIV_ROUND_UP(nr_clusters, SWAP_CLUSTER_COLS); i++) {\n\t\t\tidx = i * SWAP_CLUSTER_COLS + j;\n\t\t\tif (idx >= nr_clusters)\n\t\t\t\tcontinue;\n\t\t\tif (cluster_count(&cluster_info[idx]))\n\t\t\t\tcontinue;\n\t\t\tcluster_set_flag(&cluster_info[idx], CLUSTER_FLAG_FREE);\n\t\t\tcluster_list_add_tail(&p->free_clusters, cluster_info,\n\t\t\t\t\t      idx);\n\t\t}\n\t}\n\treturn nr_extents;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAP_CLUSTER_COLS\t\t\t\t\t\t\\\n\tmax_t(unsigned int, SWAP_CLUSTER_INFO_COLS, SWAP_CLUSTER_SPACE_COLS)",
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_list_add_tail",
          "args": [
            "&p->free_clusters",
            "cluster_info",
            "idx"
          ],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "365-386",
          "snippet": "static void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_set_flag",
          "args": [
            "&cluster_info[idx]",
            "CLUSTER_FLAG_FREE"
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "233-237",
          "snippet": "static inline void cluster_set_flag(struct swap_cluster_info *info,\n\tunsigned int flag)\n{\n\tinfo->flags = flag;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_flag(struct swap_cluster_info *info,\n\tunsigned int flag)\n{\n\tinfo->flags = flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_count",
          "args": [
            "&cluster_info[idx]"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "239-242",
          "snippet": "static inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nr_clusters",
            "SWAP_CLUSTER_COLS"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Empty swap-file\\n\""
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_swap_extents",
          "args": [
            "p",
            "span"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "setup_swap_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2390-2416",
          "snippet": "static int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)\n{\n\tstruct file *swap_file = sis->swap_file;\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t*span = sis->pages;\n\t\treturn ret;\n\t}\n\n\tif (mapping->a_ops->swap_activate) {\n\t\tret = mapping->a_ops->swap_activate(sis, swap_file, span);\n\t\tif (ret >= 0)\n\t\t\tsis->flags |= SWP_ACTIVATED;\n\t\tif (!ret) {\n\t\t\tsis->flags |= SWP_FS;\n\t\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t\t*span = sis->pages;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn generic_swapfile_activate(sis, swap_file, span);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)\n{\n\tstruct file *swap_file = sis->swap_file;\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t*span = sis->pages;\n\t\treturn ret;\n\t}\n\n\tif (mapping->a_ops->swap_activate) {\n\t\tret = mapping->a_ops->swap_activate(sis, swap_file, span);\n\t\tif (ret >= 0)\n\t\t\tsis->flags |= SWP_ACTIVATED;\n\t\tif (!ret) {\n\t\t\tsis->flags |= SWP_FS;\n\t\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t\t*span = sis->pages;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn generic_swapfile_activate(sis, swap_file, span);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_cluster_info_page",
          "args": [
            "p",
            "cluster_info",
            "0"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "inc_cluster_info_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "500-513",
          "snippet": "static void inc_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\tif (cluster_is_free(&cluster_info[idx]))\n\t\talloc_cluster(p, idx);\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) + 1);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void inc_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\tif (cluster_is_free(&cluster_info[idx]))\n\t\talloc_cluster(p, idx);\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "maxpages",
            "SWAPFILE_CLUSTER"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_list_init",
          "args": [
            "&p->discard_clusters"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "359-363",
          "snippet": "static void cluster_list_init(struct swap_cluster_list *list)\n{\n\tcluster_set_null(&list->head);\n\tcluster_set_null(&list->tail);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void cluster_list_init(struct swap_cluster_list *list)\n{\n\tcluster_set_null(&list->head);\n\tcluster_set_null(&list->tail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "maxpages",
            "SWAPFILE_CLUSTER"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAP_CLUSTER_COLS\t\t\t\t\t\t\\\n\tmax_t(unsigned int, SWAP_CLUSTER_INFO_COLS, SWAP_CLUSTER_SPACE_COLS)\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int setup_swap_map_and_extents(struct swap_info_struct *p,\n\t\t\t\t\tunion swap_header *swap_header,\n\t\t\t\t\tunsigned char *swap_map,\n\t\t\t\t\tstruct swap_cluster_info *cluster_info,\n\t\t\t\t\tunsigned long maxpages,\n\t\t\t\t\tsector_t *span)\n{\n\tunsigned int j, k;\n\tunsigned int nr_good_pages;\n\tint nr_extents;\n\tunsigned long nr_clusters = DIV_ROUND_UP(maxpages, SWAPFILE_CLUSTER);\n\tunsigned long col = p->cluster_next / SWAPFILE_CLUSTER % SWAP_CLUSTER_COLS;\n\tunsigned long i, idx;\n\n\tnr_good_pages = maxpages - 1;\t/* omit header page */\n\n\tcluster_list_init(&p->free_clusters);\n\tcluster_list_init(&p->discard_clusters);\n\n\tfor (i = 0; i < swap_header->info.nr_badpages; i++) {\n\t\tunsigned int page_nr = swap_header->info.badpages[i];\n\t\tif (page_nr == 0 || page_nr > swap_header->info.last_page)\n\t\t\treturn -EINVAL;\n\t\tif (page_nr < maxpages) {\n\t\t\tswap_map[page_nr] = SWAP_MAP_BAD;\n\t\t\tnr_good_pages--;\n\t\t\t/*\n\t\t\t * Haven't marked the cluster free yet, no list\n\t\t\t * operation involved\n\t\t\t */\n\t\t\tinc_cluster_info_page(p, cluster_info, page_nr);\n\t\t}\n\t}\n\n\t/* Haven't marked the cluster free yet, no list operation involved */\n\tfor (i = maxpages; i < round_up(maxpages, SWAPFILE_CLUSTER); i++)\n\t\tinc_cluster_info_page(p, cluster_info, i);\n\n\tif (nr_good_pages) {\n\t\tswap_map[0] = SWAP_MAP_BAD;\n\t\t/*\n\t\t * Not mark the cluster free yet, no list\n\t\t * operation involved\n\t\t */\n\t\tinc_cluster_info_page(p, cluster_info, 0);\n\t\tp->max = maxpages;\n\t\tp->pages = nr_good_pages;\n\t\tnr_extents = setup_swap_extents(p, span);\n\t\tif (nr_extents < 0)\n\t\t\treturn nr_extents;\n\t\tnr_good_pages = p->pages;\n\t}\n\tif (!nr_good_pages) {\n\t\tpr_warn(\"Empty swap-file\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cluster_info)\n\t\treturn nr_extents;\n\n\n\t/*\n\t * Reduce false cache line sharing between cluster_info and\n\t * sharing same address space.\n\t */\n\tfor (k = 0; k < SWAP_CLUSTER_COLS; k++) {\n\t\tj = (k + col) % SWAP_CLUSTER_COLS;\n\t\tfor (i = 0; i < DIV_ROUND_UP(nr_clusters, SWAP_CLUSTER_COLS); i++) {\n\t\t\tidx = i * SWAP_CLUSTER_COLS + j;\n\t\t\tif (idx >= nr_clusters)\n\t\t\t\tcontinue;\n\t\t\tif (cluster_count(&cluster_info[idx]))\n\t\t\t\tcontinue;\n\t\t\tcluster_set_flag(&cluster_info[idx], CLUSTER_FLAG_FREE);\n\t\t\tcluster_list_add_tail(&p->free_clusters, cluster_info,\n\t\t\t\t\t      idx);\n\t\t}\n\t}\n\treturn nr_extents;\n}"
  },
  {
    "function_name": "read_swap_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2917-2984",
    "snippet": "static unsigned long read_swap_header(struct swap_info_struct *p,\n\t\t\t\t\tunion swap_header *swap_header,\n\t\t\t\t\tstruct inode *inode)\n{\n\tint i;\n\tunsigned long maxpages;\n\tunsigned long swapfilepages;\n\tunsigned long last_page;\n\n\tif (memcmp(\"SWAPSPACE2\", swap_header->magic.magic, 10)) {\n\t\tpr_err(\"Unable to find swap-space signature\\n\");\n\t\treturn 0;\n\t}\n\n\t/* swap partition endianess hack... */\n\tif (swab32(swap_header->info.version) == 1) {\n\t\tswab32s(&swap_header->info.version);\n\t\tswab32s(&swap_header->info.last_page);\n\t\tswab32s(&swap_header->info.nr_badpages);\n\t\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < swap_header->info.nr_badpages; i++)\n\t\t\tswab32s(&swap_header->info.badpages[i]);\n\t}\n\t/* Check the swap header's sub-version */\n\tif (swap_header->info.version != 1) {\n\t\tpr_warn(\"Unable to handle swap header version %d\\n\",\n\t\t\tswap_header->info.version);\n\t\treturn 0;\n\t}\n\n\tp->lowest_bit  = 1;\n\tp->cluster_next = 1;\n\tp->cluster_nr = 0;\n\n\tmaxpages = max_swapfile_size();\n\tlast_page = swap_header->info.last_page;\n\tif (!last_page) {\n\t\tpr_warn(\"Empty swap-file\\n\");\n\t\treturn 0;\n\t}\n\tif (last_page > maxpages) {\n\t\tpr_warn(\"Truncating oversized swap area, only using %luk out of %luk\\n\",\n\t\t\tmaxpages << (PAGE_SHIFT - 10),\n\t\t\tlast_page << (PAGE_SHIFT - 10));\n\t}\n\tif (maxpages > last_page) {\n\t\tmaxpages = last_page + 1;\n\t\t/* p->max is an unsigned int: don't overflow it */\n\t\tif ((unsigned int)maxpages == 0)\n\t\t\tmaxpages = UINT_MAX;\n\t}\n\tp->highest_bit = maxpages - 1;\n\n\tif (!maxpages)\n\t\treturn 0;\n\tswapfilepages = i_size_read(inode) >> PAGE_SHIFT;\n\tif (swapfilepages && maxpages > swapfilepages) {\n\t\tpr_warn(\"Swap area shorter than signature indicates\\n\");\n\t\treturn 0;\n\t}\n\tif (swap_header->info.nr_badpages && S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)\n\t\treturn 0;\n\n\treturn maxpages;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Swap area shorter than signature indicates\\n\""
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Truncating oversized swap area, only using %luk out of %luk\\n\"",
            "maxpages << (PAGE_SHIFT - 10)",
            "last_page << (PAGE_SHIFT - 10)"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Empty swap-file\\n\""
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_swapfile_size",
          "args": [],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "max_swapfile_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2912-2915",
          "snippet": "__weak unsigned long max_swapfile_size(void)\n{\n\treturn generic_max_swapfile_size();\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n__weak unsigned long max_swapfile_size(void)\n{\n\treturn generic_max_swapfile_size();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to handle swap header version %d\\n\"",
            "swap_header->info.version"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32s",
          "args": [
            "&swap_header->info.badpages[i]"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32s",
          "args": [
            "&swap_header->info.nr_badpages"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32s",
          "args": [
            "&swap_header->info.last_page"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32s",
          "args": [
            "&swap_header->info.version"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32",
          "args": [
            "swap_header->info.version"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to find swap-space signature\\n\""
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"SWAPSPACE2\"",
            "swap_header->magic.magic",
            "10"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned long read_swap_header(struct swap_info_struct *p,\n\t\t\t\t\tunion swap_header *swap_header,\n\t\t\t\t\tstruct inode *inode)\n{\n\tint i;\n\tunsigned long maxpages;\n\tunsigned long swapfilepages;\n\tunsigned long last_page;\n\n\tif (memcmp(\"SWAPSPACE2\", swap_header->magic.magic, 10)) {\n\t\tpr_err(\"Unable to find swap-space signature\\n\");\n\t\treturn 0;\n\t}\n\n\t/* swap partition endianess hack... */\n\tif (swab32(swap_header->info.version) == 1) {\n\t\tswab32s(&swap_header->info.version);\n\t\tswab32s(&swap_header->info.last_page);\n\t\tswab32s(&swap_header->info.nr_badpages);\n\t\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < swap_header->info.nr_badpages; i++)\n\t\t\tswab32s(&swap_header->info.badpages[i]);\n\t}\n\t/* Check the swap header's sub-version */\n\tif (swap_header->info.version != 1) {\n\t\tpr_warn(\"Unable to handle swap header version %d\\n\",\n\t\t\tswap_header->info.version);\n\t\treturn 0;\n\t}\n\n\tp->lowest_bit  = 1;\n\tp->cluster_next = 1;\n\tp->cluster_nr = 0;\n\n\tmaxpages = max_swapfile_size();\n\tlast_page = swap_header->info.last_page;\n\tif (!last_page) {\n\t\tpr_warn(\"Empty swap-file\\n\");\n\t\treturn 0;\n\t}\n\tif (last_page > maxpages) {\n\t\tpr_warn(\"Truncating oversized swap area, only using %luk out of %luk\\n\",\n\t\t\tmaxpages << (PAGE_SHIFT - 10),\n\t\t\tlast_page << (PAGE_SHIFT - 10));\n\t}\n\tif (maxpages > last_page) {\n\t\tmaxpages = last_page + 1;\n\t\t/* p->max is an unsigned int: don't overflow it */\n\t\tif ((unsigned int)maxpages == 0)\n\t\t\tmaxpages = UINT_MAX;\n\t}\n\tp->highest_bit = maxpages - 1;\n\n\tif (!maxpages)\n\t\treturn 0;\n\tswapfilepages = i_size_read(inode) >> PAGE_SHIFT;\n\tif (swapfilepages && maxpages > swapfilepages) {\n\t\tpr_warn(\"Swap area shorter than signature indicates\\n\");\n\t\treturn 0;\n\t}\n\tif (swap_header->info.nr_badpages && S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (swap_header->info.nr_badpages > MAX_SWAP_BADPAGES)\n\t\treturn 0;\n\n\treturn maxpages;\n}"
  },
  {
    "function_name": "max_swapfile_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2912-2915",
    "snippet": "__weak unsigned long max_swapfile_size(void)\n{\n\treturn generic_max_swapfile_size();\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_max_swapfile_size",
          "args": [],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "generic_max_swapfile_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2905-2909",
          "snippet": "unsigned long generic_max_swapfile_size(void)\n{\n\treturn swp_offset(pte_to_swp_entry(\n\t\t\tswp_entry_to_pte(swp_entry(0, ~0UL)))) + 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long generic_max_swapfile_size(void)\n{\n\treturn swp_offset(pte_to_swp_entry(\n\t\t\tswp_entry_to_pte(swp_entry(0, ~0UL)))) + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n__weak unsigned long max_swapfile_size(void)\n{\n\treturn generic_max_swapfile_size();\n}"
  },
  {
    "function_name": "generic_max_swapfile_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2905-2909",
    "snippet": "unsigned long generic_max_swapfile_size(void)\n{\n\treturn swp_offset(pte_to_swp_entry(\n\t\t\tswp_entry_to_pte(swp_entry(0, ~0UL)))) + 1;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "pte_to_swp_entry(\n\t\t\tswp_entry_to_pte(swp_entry(0, ~0UL)))"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "swp_entry_to_pte(swp_entry(0, ~0UL))"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "swp_entry(0, ~0UL)"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "0",
            "~0UL"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long generic_max_swapfile_size(void)\n{\n\treturn swp_offset(pte_to_swp_entry(\n\t\t\tswp_entry_to_pte(swp_entry(0, ~0UL)))) + 1;\n}"
  },
  {
    "function_name": "claim_swapfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2860-2886",
    "snippet": "static int claim_swapfile(struct swap_info_struct *p, struct inode *inode)\n{\n\tint error;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tp->bdev = bdgrab(I_BDEV(inode));\n\t\terror = blkdev_get(p->bdev,\n\t\t\t\t   FMODE_READ | FMODE_WRITE | FMODE_EXCL, p);\n\t\tif (error < 0) {\n\t\t\tp->bdev = NULL;\n\t\t\treturn error;\n\t\t}\n\t\tp->old_block_size = block_size(p->bdev);\n\t\terror = set_blocksize(p->bdev, PAGE_SIZE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tp->flags |= SWP_BLKDEV;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tp->bdev = inode->i_sb->s_bdev;\n\t\tinode_lock(inode);\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -EBUSY;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "p->bdev",
            "PAGE_SIZE"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_size",
          "args": [
            "p->bdev"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "p->bdev",
            "FMODE_READ | FMODE_WRITE | FMODE_EXCL",
            "p"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdgrab",
          "args": [
            "I_BDEV(inode)"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int claim_swapfile(struct swap_info_struct *p, struct inode *inode)\n{\n\tint error;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tp->bdev = bdgrab(I_BDEV(inode));\n\t\terror = blkdev_get(p->bdev,\n\t\t\t\t   FMODE_READ | FMODE_WRITE | FMODE_EXCL, p);\n\t\tif (error < 0) {\n\t\t\tp->bdev = NULL;\n\t\t\treturn error;\n\t\t}\n\t\tp->old_block_size = block_size(p->bdev);\n\t\terror = set_blocksize(p->bdev, PAGE_SIZE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tp->flags |= SWP_BLKDEV;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tp->bdev = inode->i_sb->s_bdev;\n\t\tinode_lock(inode);\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -EBUSY;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2810-2858",
    "snippet": "static struct swap_info_struct *alloc_swap_info(void)\n{\n\tstruct swap_info_struct *p;\n\tunsigned int type;\n\tint i;\n\n\tp = kvzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tif (!(swap_info[type]->flags & SWP_USED))\n\t\t\tbreak;\n\t}\n\tif (type >= MAX_SWAPFILES) {\n\t\tspin_unlock(&swap_lock);\n\t\tkvfree(p);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\tif (type >= nr_swapfiles) {\n\t\tp->type = type;\n\t\tswap_info[type] = p;\n\t\t/*\n\t\t * Write swap_info[type] before nr_swapfiles, in case a\n\t\t * racing procfs swap_start() or swap_next() is reading them.\n\t\t * (We never shrink nr_swapfiles, we never free this entry.)\n\t\t */\n\t\tsmp_wmb();\n\t\tnr_swapfiles++;\n\t} else {\n\t\tkvfree(p);\n\t\tp = swap_info[type];\n\t\t/*\n\t\t * Do not memset this entry: a racing procfs swap_next()\n\t\t * would be relying on p->type to remain valid.\n\t\t */\n\t}\n\tINIT_LIST_HEAD(&p->first_swap_extent.list);\n\tplist_node_init(&p->list, 0);\n\tfor_each_node(i)\n\t\tplist_node_init(&p->avail_lists[i], 0);\n\tp->flags = SWP_USED;\n\tspin_unlock(&swap_lock);\n\tspin_lock_init(&p->lock);\n\tspin_lock_init(&p->cont_lock);\n\n\treturn p;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&p->cont_lock"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&p->lock"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_init",
          "args": [
            "&p->list",
            "0"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&p->first_swap_extent.list"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "p"
          ],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "sizeof(*p)",
            "GFP_KERNEL"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic struct swap_info_struct *alloc_swap_info(void)\n{\n\tstruct swap_info_struct *p;\n\tunsigned int type;\n\tint i;\n\n\tp = kvzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tif (!(swap_info[type]->flags & SWP_USED))\n\t\t\tbreak;\n\t}\n\tif (type >= MAX_SWAPFILES) {\n\t\tspin_unlock(&swap_lock);\n\t\tkvfree(p);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\tif (type >= nr_swapfiles) {\n\t\tp->type = type;\n\t\tswap_info[type] = p;\n\t\t/*\n\t\t * Write swap_info[type] before nr_swapfiles, in case a\n\t\t * racing procfs swap_start() or swap_next() is reading them.\n\t\t * (We never shrink nr_swapfiles, we never free this entry.)\n\t\t */\n\t\tsmp_wmb();\n\t\tnr_swapfiles++;\n\t} else {\n\t\tkvfree(p);\n\t\tp = swap_info[type];\n\t\t/*\n\t\t * Do not memset this entry: a racing procfs swap_next()\n\t\t * would be relying on p->type to remain valid.\n\t\t */\n\t}\n\tINIT_LIST_HEAD(&p->first_swap_extent.list);\n\tplist_node_init(&p->list, 0);\n\tfor_each_node(i)\n\t\tplist_node_init(&p->avail_lists[i], 0);\n\tp->flags = SWP_USED;\n\tspin_unlock(&swap_lock);\n\tspin_lock_init(&p->lock);\n\tspin_lock_init(&p->cont_lock);\n\n\treturn p;\n}"
  },
  {
    "function_name": "max_swapfiles_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2802-2806",
    "snippet": "static int __init max_swapfiles_check(void)\n{\n\tMAX_SWAPFILES_CHECK();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAX_SWAPFILES_CHECK",
          "args": [],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int __init max_swapfiles_check(void)\n{\n\tMAX_SWAPFILES_CHECK();\n\treturn 0;\n}"
  },
  {
    "function_name": "procswaps_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2793-2797",
    "snippet": "static int __init procswaps_init(void)\n{\n\tproc_create(\"swaps\", 0, NULL, &proc_swaps_operations);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"swaps\"",
            "0",
            "NULL",
            "&proc_swaps_operations"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int __init procswaps_init(void)\n{\n\tproc_create(\"swaps\", 0, NULL, &proc_swaps_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "swaps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2771-2783",
    "snippet": "static int swaps_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &swaps_op);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->poll_event = atomic_read(&proc_poll_event);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t proc_poll_event = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&proc_poll_event"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&swaps_op"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic atomic_t proc_poll_event = ATOMIC_INIT(0);\n\nstatic int swaps_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &swaps_op);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->poll_event = atomic_read(&proc_poll_event);\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2741-2762",
    "snippet": "static int swap_show(struct seq_file *swap, void *v)\n{\n\tstruct swap_info_struct *si = v;\n\tstruct file *file;\n\tint len;\n\n\tif (si == SEQ_START_TOKEN) {\n\t\tseq_puts(swap,\"Filename\\t\\t\\t\\tType\\t\\tSize\\tUsed\\tPriority\\n\");\n\t\treturn 0;\n\t}\n\n\tfile = si->swap_file;\n\tlen = seq_file_path(swap, file, \" \\t\\n\\\\\");\n\tseq_printf(swap, \"%*s%s\\t%u\\t%u\\t%d\\n\",\n\t\t\tlen < 40 ? 40 - len : 1, \" \",\n\t\t\tS_ISBLK(file_inode(file)->i_mode) ?\n\t\t\t\t\"partition\" : \"file\\t\",\n\t\t\tsi->pages << (PAGE_SHIFT - 10),\n\t\t\tsi->inuse_pages << (PAGE_SHIFT - 10),\n\t\t\tsi->prio);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "swap",
            "\"%*s%s\\t%u\\t%u\\t%d\\n\"",
            "len < 40 ? 40 - len : 1",
            "\" \"",
            "S_ISBLK(file_inode(file)->i_mode) ?\n\t\t\t\t\"partition\" : \"file\\t\"",
            "si->pages << (PAGE_SHIFT - 10)",
            "si->inuse_pages << (PAGE_SHIFT - 10)",
            "si->prio"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "file_inode(file)->i_mode"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_file_path",
          "args": [
            "swap",
            "file",
            "\" \\t\\n\\\\\""
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "swap",
            "\"Filename\\t\\t\\t\\tType\\t\\tSize\\tUsed\\tPriority\\n\""
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int swap_show(struct seq_file *swap, void *v)\n{\n\tstruct swap_info_struct *si = v;\n\tstruct file *file;\n\tint len;\n\n\tif (si == SEQ_START_TOKEN) {\n\t\tseq_puts(swap,\"Filename\\t\\t\\t\\tType\\t\\tSize\\tUsed\\tPriority\\n\");\n\t\treturn 0;\n\t}\n\n\tfile = si->swap_file;\n\tlen = seq_file_path(swap, file, \" \\t\\n\\\\\");\n\tseq_printf(swap, \"%*s%s\\t%u\\t%u\\t%d\\n\",\n\t\t\tlen < 40 ? 40 - len : 1, \" \",\n\t\t\tS_ISBLK(file_inode(file)->i_mode) ?\n\t\t\t\t\"partition\" : \"file\\t\",\n\t\t\tsi->pages << (PAGE_SHIFT - 10),\n\t\t\tsi->inuse_pages << (PAGE_SHIFT - 10),\n\t\t\tsi->prio);\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2736-2739",
    "snippet": "static void swap_stop(struct seq_file *swap, void *v)\n{\n\tmutex_unlock(&swapon_mutex);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(swapon_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swapon_mutex"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(swapon_mutex);\n\nstatic void swap_stop(struct seq_file *swap, void *v)\n{\n\tmutex_unlock(&swapon_mutex);\n}"
  },
  {
    "function_name": "swap_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2714-2734",
    "snippet": "static void *swap_next(struct seq_file *swap, void *v, loff_t *pos)\n{\n\tstruct swap_info_struct *si = v;\n\tint type;\n\n\tif (v == SEQ_START_TOKEN)\n\t\ttype = 0;\n\telse\n\t\ttype = si->type + 1;\n\n\tfor (; type < nr_swapfiles; type++) {\n\t\tsmp_rmb();\t/* read nr_swapfiles before swap_info[type] */\n\t\tsi = swap_info[type];\n\t\tif (!(si->flags & SWP_USED) || !si->swap_map)\n\t\t\tcontinue;\n\t\t++*pos;\n\t\treturn si;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic void *swap_next(struct seq_file *swap, void *v, loff_t *pos)\n{\n\tstruct swap_info_struct *si = v;\n\tint type;\n\n\tif (v == SEQ_START_TOKEN)\n\t\ttype = 0;\n\telse\n\t\ttype = si->type + 1;\n\n\tfor (; type < nr_swapfiles; type++) {\n\t\tsmp_rmb();\t/* read nr_swapfiles before swap_info[type] */\n\t\tsi = swap_info[type];\n\t\tif (!(si->flags & SWP_USED) || !si->swap_map)\n\t\t\tcontinue;\n\t\t++*pos;\n\t\treturn si;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "swap_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2691-2712",
    "snippet": "static void *swap_start(struct seq_file *swap, loff_t *pos)\n{\n\tstruct swap_info_struct *si;\n\tint type;\n\tloff_t l = *pos;\n\n\tmutex_lock(&swapon_mutex);\n\n\tif (!l)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tsmp_rmb();\t/* read nr_swapfiles before swap_info[type] */\n\t\tsi = swap_info[type];\n\t\tif (!(si->flags & SWP_USED) || !si->swap_map)\n\t\t\tcontinue;\n\t\tif (!--l)\n\t\t\treturn si;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];",
      "static DEFINE_MUTEX(swapon_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swapon_mutex"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\nstatic DEFINE_MUTEX(swapon_mutex);\n\nstatic void *swap_start(struct seq_file *swap, loff_t *pos)\n{\n\tstruct swap_info_struct *si;\n\tint type;\n\tloff_t l = *pos;\n\n\tmutex_lock(&swapon_mutex);\n\n\tif (!l)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tsmp_rmb();\t/* read nr_swapfiles before swap_info[type] */\n\t\tsi = swap_info[type];\n\t\tif (!(si->flags & SWP_USED) || !si->swap_map)\n\t\t\tcontinue;\n\t\tif (!--l)\n\t\t\treturn si;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "swaps_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2676-2688",
    "snippet": "static __poll_t swaps_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tpoll_wait(file, &proc_poll_wait, wait);\n\n\tif (seq->poll_event != atomic_read(&proc_poll_event)) {\n\t\tseq->poll_event = atomic_read(&proc_poll_event);\n\t\treturn EPOLLIN | EPOLLRDNORM | EPOLLERR | EPOLLPRI;\n\t}\n\n\treturn EPOLLIN | EPOLLRDNORM;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);",
      "static atomic_t proc_poll_event = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&proc_poll_event"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&proc_poll_event"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&proc_poll_wait",
            "wait"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);\nstatic atomic_t proc_poll_event = ATOMIC_INIT(0);\n\nstatic __poll_t swaps_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tpoll_wait(file, &proc_poll_wait, wait);\n\n\tif (seq->poll_event != atomic_read(&proc_poll_event)) {\n\t\tseq->poll_event = atomic_read(&proc_poll_event);\n\t\treturn EPOLLIN | EPOLLRDNORM | EPOLLERR | EPOLLPRI;\n\t}\n\n\treturn EPOLLIN | EPOLLRDNORM;\n}"
  },
  {
    "function_name": "has_usable_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2498-2507",
    "snippet": "bool has_usable_swap(void)\n{\n\tbool ret = true;\n\n\tspin_lock(&swap_lock);\n\tif (plist_head_empty(&swap_active_head))\n\t\tret = false;\n\tspin_unlock(&swap_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_head_empty",
          "args": [
            "&swap_active_head"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool has_usable_swap(void)\n{\n\tbool ret = true;\n\n\tspin_lock(&swap_lock);\n\tif (plist_head_empty(&swap_active_head))\n\t\tret = false;\n\tspin_unlock(&swap_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "reinsert_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2489-2496",
    "snippet": "static void reinsert_swap_info(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\t_enable_swap_info(p, p->prio, p->swap_map, p->cluster_info);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enable_swap_info",
          "args": [
            "p",
            "p->prio",
            "p->swap_map",
            "p->cluster_info"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "_enable_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2430-2474",
          "snippet": "static void _enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info)\n{\n\tint i;\n\n\tif (prio >= 0)\n\t\tp->prio = prio;\n\telse\n\t\tp->prio = --least_priority;\n\t/*\n\t * the plist prio is negated because plist ordering is\n\t * low-to-high, while swap ordering is high-to-low\n\t */\n\tp->list.prio = -p->prio;\n\tfor_each_node(i) {\n\t\tif (p->prio >= 0)\n\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\telse {\n\t\t\tif (swap_node(p) == i)\n\t\t\t\tp->avail_lists[i].prio = 1;\n\t\t\telse\n\t\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\t}\n\t}\n\tp->swap_map = swap_map;\n\tp->cluster_info = cluster_info;\n\tp->flags |= SWP_WRITEOK;\n\tatomic_long_add(p->pages, &nr_swap_pages);\n\ttotal_swap_pages += p->pages;\n\n\tassert_spin_locked(&swap_lock);\n\t/*\n\t * both lists are plists, and thus priority ordered.\n\t * swap_active_head needs to be priority ordered for swapoff(),\n\t * which on removal of any swap_info_struct with an auto-assigned\n\t * (i.e. negative) priority increments the auto-assigned priority\n\t * of any lower-priority swap_info_structs.\n\t * swap_avail_head needs to be priority ordered for get_swap_page(),\n\t * which allocates swap pages from the highest available priority\n\t * swap_info_struct.\n\t */\n\tplist_add(&p->list, &swap_active_head);\n\tadd_to_avail_list(p);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "atomic_long_t nr_swap_pages;",
            "long total_swap_pages;",
            "static int least_priority = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\natomic_long_t nr_swap_pages;\nlong total_swap_pages;\nstatic int least_priority = -1;\n\nstatic void _enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info)\n{\n\tint i;\n\n\tif (prio >= 0)\n\t\tp->prio = prio;\n\telse\n\t\tp->prio = --least_priority;\n\t/*\n\t * the plist prio is negated because plist ordering is\n\t * low-to-high, while swap ordering is high-to-low\n\t */\n\tp->list.prio = -p->prio;\n\tfor_each_node(i) {\n\t\tif (p->prio >= 0)\n\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\telse {\n\t\t\tif (swap_node(p) == i)\n\t\t\t\tp->avail_lists[i].prio = 1;\n\t\t\telse\n\t\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\t}\n\t}\n\tp->swap_map = swap_map;\n\tp->cluster_info = cluster_info;\n\tp->flags |= SWP_WRITEOK;\n\tatomic_long_add(p->pages, &nr_swap_pages);\n\ttotal_swap_pages += p->pages;\n\n\tassert_spin_locked(&swap_lock);\n\t/*\n\t * both lists are plists, and thus priority ordered.\n\t * swap_active_head needs to be priority ordered for swapoff(),\n\t * which on removal of any swap_info_struct with an auto-assigned\n\t * (i.e. negative) priority increments the auto-assigned priority\n\t * of any lower-priority swap_info_structs.\n\t * swap_avail_head needs to be priority ordered for get_swap_page(),\n\t * which allocates swap pages from the highest available priority\n\t * swap_info_struct.\n\t */\n\tplist_add(&p->list, &swap_active_head);\n\tadd_to_avail_list(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->lock"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void reinsert_swap_info(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\t_enable_swap_info(p, p->prio, p->swap_map, p->cluster_info);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n}"
  },
  {
    "function_name": "enable_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2476-2487",
    "snippet": "static void enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info,\n\t\t\t\tunsigned long *frontswap_map)\n{\n\tfrontswap_init(p->type, frontswap_map);\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\t _enable_swap_info(p, prio, swap_map, cluster_info);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enable_swap_info",
          "args": [
            "p",
            "prio",
            "swap_map",
            "cluster_info"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "_enable_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2430-2474",
          "snippet": "static void _enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info)\n{\n\tint i;\n\n\tif (prio >= 0)\n\t\tp->prio = prio;\n\telse\n\t\tp->prio = --least_priority;\n\t/*\n\t * the plist prio is negated because plist ordering is\n\t * low-to-high, while swap ordering is high-to-low\n\t */\n\tp->list.prio = -p->prio;\n\tfor_each_node(i) {\n\t\tif (p->prio >= 0)\n\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\telse {\n\t\t\tif (swap_node(p) == i)\n\t\t\t\tp->avail_lists[i].prio = 1;\n\t\t\telse\n\t\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\t}\n\t}\n\tp->swap_map = swap_map;\n\tp->cluster_info = cluster_info;\n\tp->flags |= SWP_WRITEOK;\n\tatomic_long_add(p->pages, &nr_swap_pages);\n\ttotal_swap_pages += p->pages;\n\n\tassert_spin_locked(&swap_lock);\n\t/*\n\t * both lists are plists, and thus priority ordered.\n\t * swap_active_head needs to be priority ordered for swapoff(),\n\t * which on removal of any swap_info_struct with an auto-assigned\n\t * (i.e. negative) priority increments the auto-assigned priority\n\t * of any lower-priority swap_info_structs.\n\t * swap_avail_head needs to be priority ordered for get_swap_page(),\n\t * which allocates swap pages from the highest available priority\n\t * swap_info_struct.\n\t */\n\tplist_add(&p->list, &swap_active_head);\n\tadd_to_avail_list(p);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "atomic_long_t nr_swap_pages;",
            "long total_swap_pages;",
            "static int least_priority = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\natomic_long_t nr_swap_pages;\nlong total_swap_pages;\nstatic int least_priority = -1;\n\nstatic void _enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info)\n{\n\tint i;\n\n\tif (prio >= 0)\n\t\tp->prio = prio;\n\telse\n\t\tp->prio = --least_priority;\n\t/*\n\t * the plist prio is negated because plist ordering is\n\t * low-to-high, while swap ordering is high-to-low\n\t */\n\tp->list.prio = -p->prio;\n\tfor_each_node(i) {\n\t\tif (p->prio >= 0)\n\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\telse {\n\t\t\tif (swap_node(p) == i)\n\t\t\t\tp->avail_lists[i].prio = 1;\n\t\t\telse\n\t\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\t}\n\t}\n\tp->swap_map = swap_map;\n\tp->cluster_info = cluster_info;\n\tp->flags |= SWP_WRITEOK;\n\tatomic_long_add(p->pages, &nr_swap_pages);\n\ttotal_swap_pages += p->pages;\n\n\tassert_spin_locked(&swap_lock);\n\t/*\n\t * both lists are plists, and thus priority ordered.\n\t * swap_active_head needs to be priority ordered for swapoff(),\n\t * which on removal of any swap_info_struct with an auto-assigned\n\t * (i.e. negative) priority increments the auto-assigned priority\n\t * of any lower-priority swap_info_structs.\n\t * swap_avail_head needs to be priority ordered for get_swap_page(),\n\t * which allocates swap pages from the highest available priority\n\t * swap_info_struct.\n\t */\n\tplist_add(&p->list, &swap_active_head);\n\tadd_to_avail_list(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->lock"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frontswap_init",
          "args": [
            "p->type",
            "frontswap_map"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "191-213",
          "snippet": "void __frontswap_init(unsigned type, unsigned long *map)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * p->frontswap is a bitmap that we MUST have to figure out which page\n\t * has gone in frontswap. Without it there is no point of continuing.\n\t */\n\tif (WARN_ON(!map))\n\t\treturn;\n\t/*\n\t * Irregardless of whether the frontswap backend has been loaded\n\t * before this function or it will be later, we _MUST_ have the\n\t * p->frontswap set to something valid to work properly.\n\t */\n\tfrontswap_map_set(sis, map);\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->init(type);\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct frontswap_ops *frontswap_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\n\nvoid __frontswap_init(unsigned type, unsigned long *map)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * p->frontswap is a bitmap that we MUST have to figure out which page\n\t * has gone in frontswap. Without it there is no point of continuing.\n\t */\n\tif (WARN_ON(!map))\n\t\treturn;\n\t/*\n\t * Irregardless of whether the frontswap backend has been loaded\n\t * before this function or it will be later, we _MUST_ have the\n\t * p->frontswap set to something valid to work properly.\n\t */\n\tfrontswap_map_set(sis, map);\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->init(type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info,\n\t\t\t\tunsigned long *frontswap_map)\n{\n\tfrontswap_init(p->type, frontswap_map);\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\t _enable_swap_info(p, prio, swap_map, cluster_info);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n}"
  },
  {
    "function_name": "_enable_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2430-2474",
    "snippet": "static void _enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info)\n{\n\tint i;\n\n\tif (prio >= 0)\n\t\tp->prio = prio;\n\telse\n\t\tp->prio = --least_priority;\n\t/*\n\t * the plist prio is negated because plist ordering is\n\t * low-to-high, while swap ordering is high-to-low\n\t */\n\tp->list.prio = -p->prio;\n\tfor_each_node(i) {\n\t\tif (p->prio >= 0)\n\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\telse {\n\t\t\tif (swap_node(p) == i)\n\t\t\t\tp->avail_lists[i].prio = 1;\n\t\t\telse\n\t\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\t}\n\t}\n\tp->swap_map = swap_map;\n\tp->cluster_info = cluster_info;\n\tp->flags |= SWP_WRITEOK;\n\tatomic_long_add(p->pages, &nr_swap_pages);\n\ttotal_swap_pages += p->pages;\n\n\tassert_spin_locked(&swap_lock);\n\t/*\n\t * both lists are plists, and thus priority ordered.\n\t * swap_active_head needs to be priority ordered for swapoff(),\n\t * which on removal of any swap_info_struct with an auto-assigned\n\t * (i.e. negative) priority increments the auto-assigned priority\n\t * of any lower-priority swap_info_structs.\n\t * swap_avail_head needs to be priority ordered for get_swap_page(),\n\t * which allocates swap pages from the highest available priority\n\t * swap_info_struct.\n\t */\n\tplist_add(&p->list, &swap_active_head);\n\tadd_to_avail_list(p);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "atomic_long_t nr_swap_pages;",
      "long total_swap_pages;",
      "static int least_priority = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_to_avail_list",
          "args": [
            "p"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_avail_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "655-665",
          "snippet": "static void add_to_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tspin_lock(&swap_avail_lock);\n\tfor_each_node(nid) {\n\t\tWARN_ON(!plist_node_empty(&p->avail_lists[nid]));\n\t\tplist_add(&p->avail_lists[nid], &swap_avail_heads[nid]);\n\t}\n\tspin_unlock(&swap_avail_lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static struct plist_head *swap_avail_heads;",
            "static DEFINE_SPINLOCK(swap_avail_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nstatic void add_to_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tspin_lock(&swap_avail_lock);\n\tfor_each_node(nid) {\n\t\tWARN_ON(!plist_node_empty(&p->avail_lists[nid]));\n\t\tplist_add(&p->avail_lists[nid], &swap_avail_heads[nid]);\n\t}\n\tspin_unlock(&swap_avail_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_add",
          "args": [
            "&p->list",
            "&swap_active_head"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&swap_lock"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "p->pages",
            "&nr_swap_pages"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_node",
          "args": [
            "p"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "swap_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2418-2428",
          "snippet": "static int swap_node(struct swap_info_struct *p)\n{\n\tstruct block_device *bdev;\n\n\tif (p->bdev)\n\t\tbdev = p->bdev;\n\telse\n\t\tbdev = p->swap_file->f_inode->i_sb->s_bdev;\n\n\treturn bdev ? bdev->bd_disk->node_id : NUMA_NO_NODE;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static sector_t map_swap_entry(swp_entry_t, struct block_device**);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\n\nstatic int swap_node(struct swap_info_struct *p)\n{\n\tstruct block_device *bdev;\n\n\tif (p->bdev)\n\t\tbdev = p->bdev;\n\telse\n\t\tbdev = p->swap_file->f_inode->i_sb->s_bdev;\n\n\treturn bdev ? bdev->bd_disk->node_id : NUMA_NO_NODE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\natomic_long_t nr_swap_pages;\nlong total_swap_pages;\nstatic int least_priority = -1;\n\nstatic void _enable_swap_info(struct swap_info_struct *p, int prio,\n\t\t\t\tunsigned char *swap_map,\n\t\t\t\tstruct swap_cluster_info *cluster_info)\n{\n\tint i;\n\n\tif (prio >= 0)\n\t\tp->prio = prio;\n\telse\n\t\tp->prio = --least_priority;\n\t/*\n\t * the plist prio is negated because plist ordering is\n\t * low-to-high, while swap ordering is high-to-low\n\t */\n\tp->list.prio = -p->prio;\n\tfor_each_node(i) {\n\t\tif (p->prio >= 0)\n\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\telse {\n\t\t\tif (swap_node(p) == i)\n\t\t\t\tp->avail_lists[i].prio = 1;\n\t\t\telse\n\t\t\t\tp->avail_lists[i].prio = -p->prio;\n\t\t}\n\t}\n\tp->swap_map = swap_map;\n\tp->cluster_info = cluster_info;\n\tp->flags |= SWP_WRITEOK;\n\tatomic_long_add(p->pages, &nr_swap_pages);\n\ttotal_swap_pages += p->pages;\n\n\tassert_spin_locked(&swap_lock);\n\t/*\n\t * both lists are plists, and thus priority ordered.\n\t * swap_active_head needs to be priority ordered for swapoff(),\n\t * which on removal of any swap_info_struct with an auto-assigned\n\t * (i.e. negative) priority increments the auto-assigned priority\n\t * of any lower-priority swap_info_structs.\n\t * swap_avail_head needs to be priority ordered for get_swap_page(),\n\t * which allocates swap pages from the highest available priority\n\t * swap_info_struct.\n\t */\n\tplist_add(&p->list, &swap_active_head);\n\tadd_to_avail_list(p);\n}"
  },
  {
    "function_name": "swap_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2418-2428",
    "snippet": "static int swap_node(struct swap_info_struct *p)\n{\n\tstruct block_device *bdev;\n\n\tif (p->bdev)\n\t\tbdev = p->bdev;\n\telse\n\t\tbdev = p->swap_file->f_inode->i_sb->s_bdev;\n\n\treturn bdev ? bdev->bd_disk->node_id : NUMA_NO_NODE;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static sector_t map_swap_entry(swp_entry_t, struct block_device**);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\n\nstatic int swap_node(struct swap_info_struct *p)\n{\n\tstruct block_device *bdev;\n\n\tif (p->bdev)\n\t\tbdev = p->bdev;\n\telse\n\t\tbdev = p->swap_file->f_inode->i_sb->s_bdev;\n\n\treturn bdev ? bdev->bd_disk->node_id : NUMA_NO_NODE;\n}"
  },
  {
    "function_name": "setup_swap_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2390-2416",
    "snippet": "static int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)\n{\n\tstruct file *swap_file = sis->swap_file;\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t*span = sis->pages;\n\t\treturn ret;\n\t}\n\n\tif (mapping->a_ops->swap_activate) {\n\t\tret = mapping->a_ops->swap_activate(sis, swap_file, span);\n\t\tif (ret >= 0)\n\t\t\tsis->flags |= SWP_ACTIVATED;\n\t\tif (!ret) {\n\t\t\tsis->flags |= SWP_FS;\n\t\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t\t*span = sis->pages;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn generic_swapfile_activate(sis, swap_file, span);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_swapfile_activate",
          "args": [
            "sis",
            "swap_file",
            "span"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "generic_swapfile_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "147-239",
          "snippet": "int generic_swapfile_activate(struct swap_info_struct *sis,\n\t\t\t\tstruct file *swap_file,\n\t\t\t\tsector_t *span)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tint nr_extents = 0;\n\tint ret;\n\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\n\t/*\n\t * Map all the blocks into the extent list.  This code doesn't try\n\t * to be very smart.\n\t */\n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block &&\n\t\t\tpage_no < sis->max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\n\t\tcond_resched();\n\n\t\tfirst_block = bmap(inode, probe_block);\n\t\tif (first_block == 0)\n\t\t\tgoto bad_bmap;\n\n\t\t/*\n\t\t * It must be PAGE_SIZE aligned on-disk\n\t\t */\n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\n\t\t\tblock = bmap(inode, probe_block + block_in_page);\n\t\t\tif (block == 0)\n\t\t\t\tgoto bad_bmap;\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\t/* Discontiguity */\n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t/* exclude the header page */\n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\n\t\t/*\n\t\t * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks\n\t\t */\n\t\tret = add_swap_extent(sis, page_no, 1, first_block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnr_extents += ret;\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\tret = nr_extents;\n\t*span = 1 + highest_block - lowest_block;\n\tif (page_no == 0)\n\t\tpage_no = 1;\t/* force Empty message */\n\tsis->max = page_no;\n\tsis->pages = page_no - 1;\n\tsis->highest_bit = page_no - 1;\nout:\n\treturn ret;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\tret = -EINVAL;\n\tgoto out;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint generic_swapfile_activate(struct swap_info_struct *sis,\n\t\t\t\tstruct file *swap_file,\n\t\t\t\tsector_t *span)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tint nr_extents = 0;\n\tint ret;\n\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\n\t/*\n\t * Map all the blocks into the extent list.  This code doesn't try\n\t * to be very smart.\n\t */\n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block &&\n\t\t\tpage_no < sis->max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\n\t\tcond_resched();\n\n\t\tfirst_block = bmap(inode, probe_block);\n\t\tif (first_block == 0)\n\t\t\tgoto bad_bmap;\n\n\t\t/*\n\t\t * It must be PAGE_SIZE aligned on-disk\n\t\t */\n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\n\t\t\tblock = bmap(inode, probe_block + block_in_page);\n\t\t\tif (block == 0)\n\t\t\t\tgoto bad_bmap;\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\t/* Discontiguity */\n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t/* exclude the header page */\n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\n\t\t/*\n\t\t * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks\n\t\t */\n\t\tret = add_swap_extent(sis, page_no, 1, first_block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnr_extents += ret;\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\tret = nr_extents;\n\t*span = 1 + highest_block - lowest_block;\n\tif (page_no == 0)\n\t\tpage_no = 1;\t/* force Empty message */\n\tsis->max = page_no;\n\tsis->pages = page_no - 1;\n\tsis->highest_bit = page_no - 1;\nout:\n\treturn ret;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\tret = -EINVAL;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_swap_extent",
          "args": [
            "sis",
            "0",
            "sis->max",
            "0"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "add_swap_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2318-2356",
          "snippet": "int\nadd_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block)\n{\n\tstruct swap_extent *se;\n\tstruct swap_extent *new_se;\n\tstruct list_head *lh;\n\n\tif (start_page == 0) {\n\t\tse = &sis->first_swap_extent;\n\t\tsis->curr_swap_extent = se;\n\t\tse->start_page = 0;\n\t\tse->nr_pages = nr_pages;\n\t\tse->start_block = start_block;\n\t\treturn 1;\n\t} else {\n\t\tlh = sis->first_swap_extent.list.prev;\t/* Highest extent */\n\t\tse = list_entry(lh, struct swap_extent, list);\n\t\tBUG_ON(se->start_page + se->nr_pages != start_page);\n\t\tif (se->start_block + se->nr_pages == start_block) {\n\t\t\t/* Merge it */\n\t\t\tse->nr_pages += nr_pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * No merge.  Insert a new extent, preserving ordering.\n\t */\n\tnew_se = kmalloc(sizeof(*se), GFP_KERNEL);\n\tif (new_se == NULL)\n\t\treturn -ENOMEM;\n\tnew_se->start_page = start_page;\n\tnew_se->nr_pages = nr_pages;\n\tnew_se->start_block = start_block;\n\n\tlist_add_tail(&new_se->list, &sis->first_swap_extent.list);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint\nadd_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block)\n{\n\tstruct swap_extent *se;\n\tstruct swap_extent *new_se;\n\tstruct list_head *lh;\n\n\tif (start_page == 0) {\n\t\tse = &sis->first_swap_extent;\n\t\tsis->curr_swap_extent = se;\n\t\tse->start_page = 0;\n\t\tse->nr_pages = nr_pages;\n\t\tse->start_block = start_block;\n\t\treturn 1;\n\t} else {\n\t\tlh = sis->first_swap_extent.list.prev;\t/* Highest extent */\n\t\tse = list_entry(lh, struct swap_extent, list);\n\t\tBUG_ON(se->start_page + se->nr_pages != start_page);\n\t\tif (se->start_block + se->nr_pages == start_block) {\n\t\t\t/* Merge it */\n\t\t\tse->nr_pages += nr_pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * No merge.  Insert a new extent, preserving ordering.\n\t */\n\tnew_se = kmalloc(sizeof(*se), GFP_KERNEL);\n\tif (new_se == NULL)\n\t\treturn -ENOMEM;\n\tnew_se->start_page = start_page;\n\tnew_se->nr_pages = nr_pages;\n\tnew_se->start_block = start_block;\n\n\tlist_add_tail(&new_se->list, &sis->first_swap_extent.list);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->swap_activate",
          "args": [
            "sis",
            "swap_file",
            "span"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)\n{\n\tstruct file *swap_file = sis->swap_file;\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint ret;\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t*span = sis->pages;\n\t\treturn ret;\n\t}\n\n\tif (mapping->a_ops->swap_activate) {\n\t\tret = mapping->a_ops->swap_activate(sis, swap_file, span);\n\t\tif (ret >= 0)\n\t\t\tsis->flags |= SWP_ACTIVATED;\n\t\tif (!ret) {\n\t\t\tsis->flags |= SWP_FS;\n\t\t\tret = add_swap_extent(sis, 0, sis->max, 0);\n\t\t\t*span = sis->pages;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn generic_swapfile_activate(sis, swap_file, span);\n}"
  },
  {
    "function_name": "add_swap_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2318-2356",
    "snippet": "int\nadd_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block)\n{\n\tstruct swap_extent *se;\n\tstruct swap_extent *new_se;\n\tstruct list_head *lh;\n\n\tif (start_page == 0) {\n\t\tse = &sis->first_swap_extent;\n\t\tsis->curr_swap_extent = se;\n\t\tse->start_page = 0;\n\t\tse->nr_pages = nr_pages;\n\t\tse->start_block = start_block;\n\t\treturn 1;\n\t} else {\n\t\tlh = sis->first_swap_extent.list.prev;\t/* Highest extent */\n\t\tse = list_entry(lh, struct swap_extent, list);\n\t\tBUG_ON(se->start_page + se->nr_pages != start_page);\n\t\tif (se->start_block + se->nr_pages == start_block) {\n\t\t\t/* Merge it */\n\t\t\tse->nr_pages += nr_pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * No merge.  Insert a new extent, preserving ordering.\n\t */\n\tnew_se = kmalloc(sizeof(*se), GFP_KERNEL);\n\tif (new_se == NULL)\n\t\treturn -ENOMEM;\n\tnew_se->start_page = start_page;\n\tnew_se->nr_pages = nr_pages;\n\tnew_se->start_block = start_block;\n\n\tlist_add_tail(&new_se->list, &sis->first_swap_extent.list);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_se->list",
            "&sis->first_swap_extent.list"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*se)",
            "GFP_KERNEL"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "se->start_page + se->nr_pages != start_page"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "lh",
            "structswap_extent",
            "list"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint\nadd_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block)\n{\n\tstruct swap_extent *se;\n\tstruct swap_extent *new_se;\n\tstruct list_head *lh;\n\n\tif (start_page == 0) {\n\t\tse = &sis->first_swap_extent;\n\t\tsis->curr_swap_extent = se;\n\t\tse->start_page = 0;\n\t\tse->nr_pages = nr_pages;\n\t\tse->start_block = start_block;\n\t\treturn 1;\n\t} else {\n\t\tlh = sis->first_swap_extent.list.prev;\t/* Highest extent */\n\t\tse = list_entry(lh, struct swap_extent, list);\n\t\tBUG_ON(se->start_page + se->nr_pages != start_page);\n\t\tif (se->start_block + se->nr_pages == start_block) {\n\t\t\t/* Merge it */\n\t\t\tse->nr_pages += nr_pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * No merge.  Insert a new extent, preserving ordering.\n\t */\n\tnew_se = kmalloc(sizeof(*se), GFP_KERNEL);\n\tif (new_se == NULL)\n\t\treturn -ENOMEM;\n\tnew_se->start_page = start_page;\n\tnew_se->nr_pages = nr_pages;\n\tnew_se->start_block = start_block;\n\n\tlist_add_tail(&new_se->list, &sis->first_swap_extent.list);\n\treturn 1;\n}"
  },
  {
    "function_name": "destroy_swap_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2291-2310",
    "snippet": "static void destroy_swap_extents(struct swap_info_struct *sis)\n{\n\twhile (!list_empty(&sis->first_swap_extent.list)) {\n\t\tstruct swap_extent *se;\n\n\t\tse = list_first_entry(&sis->first_swap_extent.list,\n\t\t\t\tstruct swap_extent, list);\n\t\tlist_del(&se->list);\n\t\tkfree(se);\n\t}\n\n\tif (sis->flags & SWP_ACTIVATED) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tsis->flags &= ~SWP_ACTIVATED;\n\t\tif (mapping->a_ops->swap_deactivate)\n\t\t\tmapping->a_ops->swap_deactivate(swap_file);\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping->a_ops->swap_deactivate",
          "args": [
            "swap_file"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "se"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&se->list"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&sis->first_swap_extent.list",
            "structswap_extent",
            "list"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sis->first_swap_extent.list"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void destroy_swap_extents(struct swap_info_struct *sis)\n{\n\twhile (!list_empty(&sis->first_swap_extent.list)) {\n\t\tstruct swap_extent *se;\n\n\t\tse = list_first_entry(&sis->first_swap_extent.list,\n\t\t\t\tstruct swap_extent, list);\n\t\tlist_del(&se->list);\n\t\tkfree(se);\n\t}\n\n\tif (sis->flags & SWP_ACTIVATED) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tsis->flags &= ~SWP_ACTIVATED;\n\t\tif (mapping->a_ops->swap_deactivate)\n\t\t\tmapping->a_ops->swap_deactivate(swap_file);\n\t}\n}"
  },
  {
    "function_name": "map_swap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2281-2286",
    "snippet": "sector_t map_swap_page(struct page *page, struct block_device **bdev)\n{\n\tswp_entry_t entry;\n\tentry.val = page_private(page);\n\treturn map_swap_entry(entry, bdev);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sector_t map_swap_entry(swp_entry_t, struct block_device**);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_swap_entry",
          "args": [
            "entry",
            "bdev"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "map_swap_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2253-2276",
          "snippet": "static sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)\n{\n\tstruct swap_info_struct *sis;\n\tstruct swap_extent *start_se;\n\tstruct swap_extent *se;\n\tpgoff_t offset;\n\n\tsis = swap_info[swp_type(entry)];\n\t*bdev = sis->bdev;\n\n\toffset = swp_offset(entry);\n\tstart_se = sis->curr_swap_extent;\n\tse = start_se;\n\n\tfor ( ; ; ) {\n\t\tif (se->start_page <= offset &&\n\t\t\t\toffset < (se->start_page + se->nr_pages)) {\n\t\t\treturn se->start_block + (offset - se->start_page);\n\t\t}\n\t\tse = list_next_entry(se, list);\n\t\tsis->curr_swap_extent = se;\n\t\tBUG_ON(se == start_se);\t\t/* It *must* be present */\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)\n{\n\tstruct swap_info_struct *sis;\n\tstruct swap_extent *start_se;\n\tstruct swap_extent *se;\n\tpgoff_t offset;\n\n\tsis = swap_info[swp_type(entry)];\n\t*bdev = sis->bdev;\n\n\toffset = swp_offset(entry);\n\tstart_se = sis->curr_swap_extent;\n\tse = start_se;\n\n\tfor ( ; ; ) {\n\t\tif (se->start_page <= offset &&\n\t\t\t\toffset < (se->start_page + se->nr_pages)) {\n\t\t\treturn se->start_block + (offset - se->start_page);\n\t\t}\n\t\tse = list_next_entry(se, list);\n\t\tsis->curr_swap_extent = se;\n\t\tBUG_ON(se == start_se);\t\t/* It *must* be present */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\n\nsector_t map_swap_page(struct page *page, struct block_device **bdev)\n{\n\tswp_entry_t entry;\n\tentry.val = page_private(page);\n\treturn map_swap_entry(entry, bdev);\n}"
  },
  {
    "function_name": "map_swap_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2253-2276",
    "snippet": "static sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)\n{\n\tstruct swap_info_struct *sis;\n\tstruct swap_extent *start_se;\n\tstruct swap_extent *se;\n\tpgoff_t offset;\n\n\tsis = swap_info[swp_type(entry)];\n\t*bdev = sis->bdev;\n\n\toffset = swp_offset(entry);\n\tstart_se = sis->curr_swap_extent;\n\tse = start_se;\n\n\tfor ( ; ; ) {\n\t\tif (se->start_page <= offset &&\n\t\t\t\toffset < (se->start_page + se->nr_pages)) {\n\t\t\treturn se->start_block + (offset - se->start_page);\n\t\t}\n\t\tse = list_next_entry(se, list);\n\t\tsis->curr_swap_extent = se;\n\t\tBUG_ON(se == start_se);\t\t/* It *must* be present */\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "se == start_se"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "se",
            "list"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)\n{\n\tstruct swap_info_struct *sis;\n\tstruct swap_extent *start_se;\n\tstruct swap_extent *se;\n\tpgoff_t offset;\n\n\tsis = swap_info[swp_type(entry)];\n\t*bdev = sis->bdev;\n\n\toffset = swp_offset(entry);\n\tstart_se = sis->curr_swap_extent;\n\tse = start_se;\n\n\tfor ( ; ; ) {\n\t\tif (se->start_page <= offset &&\n\t\t\t\toffset < (se->start_page + se->nr_pages)) {\n\t\t\treturn se->start_block + (offset - se->start_page);\n\t\t}\n\t\tse = list_next_entry(se, list);\n\t\tsis->curr_swap_extent = se;\n\t\tBUG_ON(se == start_se);\t\t/* It *must* be present */\n\t}\n}"
  },
  {
    "function_name": "drain_mmlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2233-2245",
    "snippet": "static void drain_mmlist(void)\n{\n\tstruct list_head *p, *next;\n\tunsigned int type;\n\n\tfor (type = 0; type < nr_swapfiles; type++)\n\t\tif (swap_info[type]->inuse_pages)\n\t\t\treturn;\n\tspin_lock(&mmlist_lock);\n\tlist_for_each_safe(p, next, &init_mm.mmlist)\n\t\tlist_del_init(p);\n\tspin_unlock(&mmlist_lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int nr_swapfiles;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "p"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "p",
            "next",
            "&init_mm.mmlist"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned int nr_swapfiles;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic void drain_mmlist(void)\n{\n\tstruct list_head *p, *next;\n\tunsigned int type;\n\n\tfor (type = 0; type < nr_swapfiles; type++)\n\t\tif (swap_info[type]->inuse_pages)\n\t\t\treturn;\n\tspin_lock(&mmlist_lock);\n\tlist_for_each_safe(p, next, &init_mm.mmlist)\n\t\tlist_del_init(p);\n\tspin_unlock(&mmlist_lock);\n}"
  },
  {
    "function_name": "try_to_unuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2003-2225",
    "snippet": "int try_to_unuse(unsigned int type, bool frontswap,\n\t\t unsigned long pages_to_unuse)\n{\n\tstruct swap_info_struct *si = swap_info[type];\n\tstruct mm_struct *start_mm;\n\tvolatile unsigned char *swap_map; /* swap_map is accessed without\n\t\t\t\t\t   * locking. Mark it as volatile\n\t\t\t\t\t   * to prevent compiler doing\n\t\t\t\t\t   * something odd.\n\t\t\t\t\t   */\n\tunsigned char swcount;\n\tstruct page *page;\n\tswp_entry_t entry;\n\tunsigned int i = 0;\n\tint retval = 0;\n\n\t/*\n\t * When searching mms for an entry, a good strategy is to\n\t * start at the first mm we freed the previous entry from\n\t * (though actually we don't notice whether we or coincidence\n\t * freed the entry).  Initialize this start_mm with a hold.\n\t *\n\t * A simpler strategy would be to start at the last mm we\n\t * freed the previous entry from; but that would take less\n\t * advantage of mmlist ordering, which clusters forked mms\n\t * together, child after parent.  If we race with dup_mmap(), we\n\t * prefer to resolve parent before child, lest we miss entries\n\t * duplicated after we scanned child: using last mm would invert\n\t * that.\n\t */\n\tstart_mm = &init_mm;\n\tmmget(&init_mm);\n\n\t/*\n\t * Keep on scanning until all entries have gone.  Usually,\n\t * one pass through swap_map is enough, but not necessarily:\n\t * there are races when an instance of an entry might be missed.\n\t */\n\twhile ((i = find_next_to_unuse(si, i, frontswap)) != 0) {\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get a page for the entry, using the existing swap\n\t\t * cache page if there is one.  Otherwise, get a clean\n\t\t * page and read the swap into it.\n\t\t */\n\t\tswap_map = &si->swap_map[i];\n\t\tentry = swp_entry(type, i);\n\t\tpage = read_swap_cache_async(entry,\n\t\t\t\t\tGFP_HIGHUSER_MOVABLE, NULL, 0, false);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Either swap_duplicate() failed because entry\n\t\t\t * has been freed independently, and will not be\n\t\t\t * reused since sys_swapoff() already disabled\n\t\t\t * allocation from here, or alloc_page() failed.\n\t\t\t */\n\t\t\tswcount = *swap_map;\n\t\t\t/*\n\t\t\t * We don't hold lock here, so the swap entry could be\n\t\t\t * SWAP_MAP_BAD (when the cluster is discarding).\n\t\t\t * Instead of fail out, We can just skip the swap\n\t\t\t * entry because swapoff will wait for discarding\n\t\t\t * finish anyway.\n\t\t\t */\n\t\t\tif (!swcount || swcount == SWAP_MAP_BAD)\n\t\t\t\tcontinue;\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't hold on to start_mm if it looks like exiting.\n\t\t */\n\t\tif (atomic_read(&start_mm->mm_users) == 1) {\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = &init_mm;\n\t\t\tmmget(&init_mm);\n\t\t}\n\n\t\t/*\n\t\t * Wait for and lock page.  When do_swap_page races with\n\t\t * try_to_unuse, do_swap_page can handle the fault much\n\t\t * faster than try_to_unuse can locate the entry.  This\n\t\t * apparently redundant \"wait_on_page_locked\" lets try_to_unuse\n\t\t * defer to do_swap_page in such a case - in some tests,\n\t\t * do_swap_page and try_to_unuse repeatedly compete.\n\t\t */\n\t\twait_on_page_locked(page);\n\t\twait_on_page_writeback(page);\n\t\tlock_page(page);\n\t\twait_on_page_writeback(page);\n\n\t\t/*\n\t\t * Remove all references to entry.\n\t\t */\n\t\tswcount = *swap_map;\n\t\tif (swap_count(swcount) == SWAP_MAP_SHMEM) {\n\t\t\tretval = shmem_unuse(entry, page);\n\t\t\t/* page has already been unlocked and released */\n\t\t\tif (retval < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (swap_count(swcount) && start_mm != &init_mm)\n\t\t\tretval = unuse_mm(start_mm, entry, page);\n\n\t\tif (swap_count(*swap_map)) {\n\t\t\tint set_start_mm = (*swap_map >= swcount);\n\t\t\tstruct list_head *p = &start_mm->mmlist;\n\t\t\tstruct mm_struct *new_start_mm = start_mm;\n\t\t\tstruct mm_struct *prev_mm = start_mm;\n\t\t\tstruct mm_struct *mm;\n\n\t\t\tmmget(new_start_mm);\n\t\t\tmmget(prev_mm);\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\twhile (swap_count(*swap_map) && !retval &&\n\t\t\t\t\t(p = p->next) != &start_mm->mmlist) {\n\t\t\t\tmm = list_entry(p, struct mm_struct, mmlist);\n\t\t\t\tif (!mmget_not_zero(mm))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t\tmmput(prev_mm);\n\t\t\t\tprev_mm = mm;\n\n\t\t\t\tcond_resched();\n\n\t\t\t\tswcount = *swap_map;\n\t\t\t\tif (!swap_count(swcount)) /* any usage ? */\n\t\t\t\t\t;\n\t\t\t\telse if (mm == &init_mm)\n\t\t\t\t\tset_start_mm = 1;\n\t\t\t\telse\n\t\t\t\t\tretval = unuse_mm(mm, entry, page);\n\n\t\t\t\tif (set_start_mm && *swap_map < swcount) {\n\t\t\t\t\tmmput(new_start_mm);\n\t\t\t\t\tmmget(mm);\n\t\t\t\t\tnew_start_mm = mm;\n\t\t\t\t\tset_start_mm = 0;\n\t\t\t\t}\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t}\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t\tmmput(prev_mm);\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = new_start_mm;\n\t\t}\n\t\tif (retval) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If a reference remains (rare), we would like to leave\n\t\t * the page in the swap cache; but try_to_unmap could\n\t\t * then re-duplicate the entry once we drop page lock,\n\t\t * so we might loop indefinitely; also, that page could\n\t\t * not be swapped out to other storage meanwhile.  So:\n\t\t * delete from cache even if there's another reference,\n\t\t * after ensuring that the data has been saved to disk -\n\t\t * since if the reference remains (rarer), it will be\n\t\t * read from disk into another page.  Splitting into two\n\t\t * pages would be incorrect if swap supported \"shared\n\t\t * private\" pages, but they are handled by tmpfs files.\n\t\t *\n\t\t * Given how unuse_vma() targets one particular offset\n\t\t * in an anon_vma, once the anon_vma has been determined,\n\t\t * this splitting happens to be just what is needed to\n\t\t * handle where KSM pages have been swapped out: re-reading\n\t\t * is unnecessarily slow, but we can fix that later on.\n\t\t */\n\t\tif (swap_count(*swap_map) &&\n\t\t     PageDirty(page) && PageSwapCache(page)) {\n\t\t\tstruct writeback_control wbc = {\n\t\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t};\n\n\t\t\tswap_writepage(compound_head(page), &wbc);\n\t\t\tlock_page(page);\n\t\t\twait_on_page_writeback(page);\n\t\t}\n\n\t\t/*\n\t\t * It is conceivable that a racing task removed this page from\n\t\t * swap cache just before we acquired the page lock at the top,\n\t\t * or while we dropped it in unuse_mm().  The page might even\n\t\t * be back in swap cache on another swap area: that we must not\n\t\t * delete, since it may not have been written out to swap yet.\n\t\t */\n\t\tif (PageSwapCache(page) &&\n\t\t    likely(page_private(page) == entry.val) &&\n\t\t    !page_swapped(page))\n\t\t\tdelete_from_swap_cache(compound_head(page));\n\n\t\t/*\n\t\t * So we could skip searching mms once swap count went\n\t\t * to 1, we did not mark any present ptes as dirty: must\n\t\t * mark page dirty so shrink_page_list will preserve it.\n\t\t */\n\t\tSetPageDirty(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\t/*\n\t\t * Make sure that we aren't completely killing\n\t\t * interactive performance.\n\t\t */\n\t\tcond_resched();\n\t\tif (frontswap && pages_to_unuse > 0) {\n\t\t\tif (!--pages_to_unuse)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmmput(start_mm);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "start_mm"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_from_swap_cache",
          "args": [
            "compound_head(page)"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "243-254",
          "snippet": "void delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swapped",
          "args": [
            "page"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "page_swapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1456-1470",
          "snippet": "static bool page_swapped(struct page *page)\n{\n\tswp_entry_t entry;\n\tstruct swap_info_struct *si;\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))\n\t\treturn page_swapcount(page) != 0;\n\n\tpage = compound_head(page);\n\tentry.val = page_private(page);\n\tsi = _swap_info_get(entry);\n\tif (si)\n\t\treturn swap_page_trans_huge_swapped(si, entry);\n\treturn false;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool page_swapped(struct page *page)\n{\n\tswp_entry_t entry;\n\tstruct swap_info_struct *si;\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))\n\t\treturn page_swapcount(page) != 0;\n\n\tpage = compound_head(page);\n\tentry.val = page_private(page);\n\tsi = _swap_info_get(entry);\n\tif (si)\n\t\treturn swap_page_trans_huge_swapped(si, entry);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page_private(page) == entry.val"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_writepage",
          "args": [
            "compound_head(page)",
            "&wbc"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "swap_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "245-262",
          "snippet": "int swap_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tif (try_to_free_swap(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tif (frontswap_store(page) == 0) {\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t\tgoto out;\n\t}\n\tret = __swap_writepage(page, wbc, end_swap_bio_write);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tif (try_to_free_swap(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tif (frontswap_store(page) == 0) {\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t\tgoto out;\n\t}\n\tret = __swap_writepage(page, wbc, end_swap_bio_write);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "*swap_map"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "start_mm"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "prev_mm"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget",
          "args": [
            "mm"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "new_start_mm"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unuse_mm",
          "args": [
            "mm",
            "entry",
            "page"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1928-1951",
          "snippet": "static int unuse_mm(struct mm_struct *mm,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tstruct vm_area_struct *vma;\n\tint ret = 0;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\t/*\n\t\t * Activate page so shrink_inactive_list is unlikely to unmap\n\t\t * its ptes while lock is dropped, so swapoff can make progress.\n\t\t */\n\t\tactivate_page(page);\n\t\tunlock_page(page);\n\t\tdown_read(&mm->mmap_sem);\n\t\tlock_page(page);\n\t}\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma && (ret = unuse_vma(vma, entry, page)))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn (ret < 0)? ret: 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_mm(struct mm_struct *mm,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tstruct vm_area_struct *vma;\n\tint ret = 0;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\t/*\n\t\t * Activate page so shrink_inactive_list is unlikely to unmap\n\t\t * its ptes while lock is dropped, so swapoff can make progress.\n\t\t */\n\t\tactivate_page(page);\n\t\tunlock_page(page);\n\t\tdown_read(&mm->mmap_sem);\n\t\tlock_page(page);\n\t}\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma && (ret = unuse_vma(vma, entry, page)))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn (ret < 0)? ret: 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "prev_mm"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "mm"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structmm_struct",
            "mmlist"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget",
          "args": [
            "prev_mm"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget",
          "args": [
            "new_start_mm"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_unuse",
          "args": [
            "entry",
            "page"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_unuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "3817-3820",
          "snippet": "int shmem_unuse(swp_entry_t swap, struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint shmem_unuse(swp_entry_t swap, struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget",
          "args": [
            "&init_mm"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "start_mm"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&start_mm->mm_users"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_swap_cache_async",
          "args": [
            "entry",
            "GFP_HIGHUSER_MOVABLE",
            "NULL",
            "0",
            "false"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "437-448",
          "snippet": "struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "type",
            "i"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_to_unuse",
          "args": [
            "si",
            "i",
            "frontswap"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_to_unuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1958-1993",
          "snippet": "static unsigned int find_next_to_unuse(struct swap_info_struct *si,\n\t\t\t\t\tunsigned int prev, bool frontswap)\n{\n\tunsigned int max = si->max;\n\tunsigned int i = prev;\n\tunsigned char count;\n\n\t/*\n\t * No need for swap_lock here: we're just looking\n\t * for whether an entry is in use, not modifying it; false\n\t * hits are okay, and sys_swapoff() has already prevented new\n\t * allocations from this area (while holding swap_lock).\n\t */\n\tfor (;;) {\n\t\tif (++i >= max) {\n\t\t\tif (!prev) {\n\t\t\t\ti = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * No entries in use at top of swap_map,\n\t\t\t * loop back to start and recheck there.\n\t\t\t */\n\t\t\tmax = prev + 1;\n\t\t\tprev = 0;\n\t\t\ti = 1;\n\t\t}\n\t\tcount = READ_ONCE(si->swap_map[i]);\n\t\tif (count && swap_count(count) != SWAP_MAP_BAD)\n\t\t\tif (!frontswap || frontswap_test(si, i))\n\t\t\t\tbreak;\n\t\tif ((i % LATENCY_LIMIT) == 0)\n\t\t\tcond_resched();\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define LATENCY_LIMIT\t\t256"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define LATENCY_LIMIT\t\t256\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned int find_next_to_unuse(struct swap_info_struct *si,\n\t\t\t\t\tunsigned int prev, bool frontswap)\n{\n\tunsigned int max = si->max;\n\tunsigned int i = prev;\n\tunsigned char count;\n\n\t/*\n\t * No need for swap_lock here: we're just looking\n\t * for whether an entry is in use, not modifying it; false\n\t * hits are okay, and sys_swapoff() has already prevented new\n\t * allocations from this area (while holding swap_lock).\n\t */\n\tfor (;;) {\n\t\tif (++i >= max) {\n\t\t\tif (!prev) {\n\t\t\t\ti = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * No entries in use at top of swap_map,\n\t\t\t * loop back to start and recheck there.\n\t\t\t */\n\t\t\tmax = prev + 1;\n\t\t\tprev = 0;\n\t\t\ti = 1;\n\t\t}\n\t\tcount = READ_ONCE(si->swap_map[i]);\n\t\tif (count && swap_count(count) != SWAP_MAP_BAD)\n\t\t\tif (!frontswap || frontswap_test(si, i))\n\t\t\t\tbreak;\n\t\tif ((i % LATENCY_LIMIT) == 0)\n\t\t\tcond_resched();\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmget",
          "args": [
            "&init_mm"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nint try_to_unuse(unsigned int type, bool frontswap,\n\t\t unsigned long pages_to_unuse)\n{\n\tstruct swap_info_struct *si = swap_info[type];\n\tstruct mm_struct *start_mm;\n\tvolatile unsigned char *swap_map; /* swap_map is accessed without\n\t\t\t\t\t   * locking. Mark it as volatile\n\t\t\t\t\t   * to prevent compiler doing\n\t\t\t\t\t   * something odd.\n\t\t\t\t\t   */\n\tunsigned char swcount;\n\tstruct page *page;\n\tswp_entry_t entry;\n\tunsigned int i = 0;\n\tint retval = 0;\n\n\t/*\n\t * When searching mms for an entry, a good strategy is to\n\t * start at the first mm we freed the previous entry from\n\t * (though actually we don't notice whether we or coincidence\n\t * freed the entry).  Initialize this start_mm with a hold.\n\t *\n\t * A simpler strategy would be to start at the last mm we\n\t * freed the previous entry from; but that would take less\n\t * advantage of mmlist ordering, which clusters forked mms\n\t * together, child after parent.  If we race with dup_mmap(), we\n\t * prefer to resolve parent before child, lest we miss entries\n\t * duplicated after we scanned child: using last mm would invert\n\t * that.\n\t */\n\tstart_mm = &init_mm;\n\tmmget(&init_mm);\n\n\t/*\n\t * Keep on scanning until all entries have gone.  Usually,\n\t * one pass through swap_map is enough, but not necessarily:\n\t * there are races when an instance of an entry might be missed.\n\t */\n\twhile ((i = find_next_to_unuse(si, i, frontswap)) != 0) {\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get a page for the entry, using the existing swap\n\t\t * cache page if there is one.  Otherwise, get a clean\n\t\t * page and read the swap into it.\n\t\t */\n\t\tswap_map = &si->swap_map[i];\n\t\tentry = swp_entry(type, i);\n\t\tpage = read_swap_cache_async(entry,\n\t\t\t\t\tGFP_HIGHUSER_MOVABLE, NULL, 0, false);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Either swap_duplicate() failed because entry\n\t\t\t * has been freed independently, and will not be\n\t\t\t * reused since sys_swapoff() already disabled\n\t\t\t * allocation from here, or alloc_page() failed.\n\t\t\t */\n\t\t\tswcount = *swap_map;\n\t\t\t/*\n\t\t\t * We don't hold lock here, so the swap entry could be\n\t\t\t * SWAP_MAP_BAD (when the cluster is discarding).\n\t\t\t * Instead of fail out, We can just skip the swap\n\t\t\t * entry because swapoff will wait for discarding\n\t\t\t * finish anyway.\n\t\t\t */\n\t\t\tif (!swcount || swcount == SWAP_MAP_BAD)\n\t\t\t\tcontinue;\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't hold on to start_mm if it looks like exiting.\n\t\t */\n\t\tif (atomic_read(&start_mm->mm_users) == 1) {\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = &init_mm;\n\t\t\tmmget(&init_mm);\n\t\t}\n\n\t\t/*\n\t\t * Wait for and lock page.  When do_swap_page races with\n\t\t * try_to_unuse, do_swap_page can handle the fault much\n\t\t * faster than try_to_unuse can locate the entry.  This\n\t\t * apparently redundant \"wait_on_page_locked\" lets try_to_unuse\n\t\t * defer to do_swap_page in such a case - in some tests,\n\t\t * do_swap_page and try_to_unuse repeatedly compete.\n\t\t */\n\t\twait_on_page_locked(page);\n\t\twait_on_page_writeback(page);\n\t\tlock_page(page);\n\t\twait_on_page_writeback(page);\n\n\t\t/*\n\t\t * Remove all references to entry.\n\t\t */\n\t\tswcount = *swap_map;\n\t\tif (swap_count(swcount) == SWAP_MAP_SHMEM) {\n\t\t\tretval = shmem_unuse(entry, page);\n\t\t\t/* page has already been unlocked and released */\n\t\t\tif (retval < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (swap_count(swcount) && start_mm != &init_mm)\n\t\t\tretval = unuse_mm(start_mm, entry, page);\n\n\t\tif (swap_count(*swap_map)) {\n\t\t\tint set_start_mm = (*swap_map >= swcount);\n\t\t\tstruct list_head *p = &start_mm->mmlist;\n\t\t\tstruct mm_struct *new_start_mm = start_mm;\n\t\t\tstruct mm_struct *prev_mm = start_mm;\n\t\t\tstruct mm_struct *mm;\n\n\t\t\tmmget(new_start_mm);\n\t\t\tmmget(prev_mm);\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\twhile (swap_count(*swap_map) && !retval &&\n\t\t\t\t\t(p = p->next) != &start_mm->mmlist) {\n\t\t\t\tmm = list_entry(p, struct mm_struct, mmlist);\n\t\t\t\tif (!mmget_not_zero(mm))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t\tmmput(prev_mm);\n\t\t\t\tprev_mm = mm;\n\n\t\t\t\tcond_resched();\n\n\t\t\t\tswcount = *swap_map;\n\t\t\t\tif (!swap_count(swcount)) /* any usage ? */\n\t\t\t\t\t;\n\t\t\t\telse if (mm == &init_mm)\n\t\t\t\t\tset_start_mm = 1;\n\t\t\t\telse\n\t\t\t\t\tretval = unuse_mm(mm, entry, page);\n\n\t\t\t\tif (set_start_mm && *swap_map < swcount) {\n\t\t\t\t\tmmput(new_start_mm);\n\t\t\t\t\tmmget(mm);\n\t\t\t\t\tnew_start_mm = mm;\n\t\t\t\t\tset_start_mm = 0;\n\t\t\t\t}\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t}\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t\tmmput(prev_mm);\n\t\t\tmmput(start_mm);\n\t\t\tstart_mm = new_start_mm;\n\t\t}\n\t\tif (retval) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If a reference remains (rare), we would like to leave\n\t\t * the page in the swap cache; but try_to_unmap could\n\t\t * then re-duplicate the entry once we drop page lock,\n\t\t * so we might loop indefinitely; also, that page could\n\t\t * not be swapped out to other storage meanwhile.  So:\n\t\t * delete from cache even if there's another reference,\n\t\t * after ensuring that the data has been saved to disk -\n\t\t * since if the reference remains (rarer), it will be\n\t\t * read from disk into another page.  Splitting into two\n\t\t * pages would be incorrect if swap supported \"shared\n\t\t * private\" pages, but they are handled by tmpfs files.\n\t\t *\n\t\t * Given how unuse_vma() targets one particular offset\n\t\t * in an anon_vma, once the anon_vma has been determined,\n\t\t * this splitting happens to be just what is needed to\n\t\t * handle where KSM pages have been swapped out: re-reading\n\t\t * is unnecessarily slow, but we can fix that later on.\n\t\t */\n\t\tif (swap_count(*swap_map) &&\n\t\t     PageDirty(page) && PageSwapCache(page)) {\n\t\t\tstruct writeback_control wbc = {\n\t\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t};\n\n\t\t\tswap_writepage(compound_head(page), &wbc);\n\t\t\tlock_page(page);\n\t\t\twait_on_page_writeback(page);\n\t\t}\n\n\t\t/*\n\t\t * It is conceivable that a racing task removed this page from\n\t\t * swap cache just before we acquired the page lock at the top,\n\t\t * or while we dropped it in unuse_mm().  The page might even\n\t\t * be back in swap cache on another swap area: that we must not\n\t\t * delete, since it may not have been written out to swap yet.\n\t\t */\n\t\tif (PageSwapCache(page) &&\n\t\t    likely(page_private(page) == entry.val) &&\n\t\t    !page_swapped(page))\n\t\t\tdelete_from_swap_cache(compound_head(page));\n\n\t\t/*\n\t\t * So we could skip searching mms once swap count went\n\t\t * to 1, we did not mark any present ptes as dirty: must\n\t\t * mark page dirty so shrink_page_list will preserve it.\n\t\t */\n\t\tSetPageDirty(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\t/*\n\t\t * Make sure that we aren't completely killing\n\t\t * interactive performance.\n\t\t */\n\t\tcond_resched();\n\t\tif (frontswap && pages_to_unuse > 0) {\n\t\t\tif (!--pages_to_unuse)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmmput(start_mm);\n\treturn retval;\n}"
  },
  {
    "function_name": "find_next_to_unuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1958-1993",
    "snippet": "static unsigned int find_next_to_unuse(struct swap_info_struct *si,\n\t\t\t\t\tunsigned int prev, bool frontswap)\n{\n\tunsigned int max = si->max;\n\tunsigned int i = prev;\n\tunsigned char count;\n\n\t/*\n\t * No need for swap_lock here: we're just looking\n\t * for whether an entry is in use, not modifying it; false\n\t * hits are okay, and sys_swapoff() has already prevented new\n\t * allocations from this area (while holding swap_lock).\n\t */\n\tfor (;;) {\n\t\tif (++i >= max) {\n\t\t\tif (!prev) {\n\t\t\t\ti = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * No entries in use at top of swap_map,\n\t\t\t * loop back to start and recheck there.\n\t\t\t */\n\t\t\tmax = prev + 1;\n\t\t\tprev = 0;\n\t\t\ti = 1;\n\t\t}\n\t\tcount = READ_ONCE(si->swap_map[i]);\n\t\tif (count && swap_count(count) != SWAP_MAP_BAD)\n\t\t\tif (!frontswap || frontswap_test(si, i))\n\t\t\t\tbreak;\n\t\tif ((i % LATENCY_LIMIT) == 0)\n\t\t\tcond_resched();\n\t}\n\treturn i;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define LATENCY_LIMIT\t\t256"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frontswap_test",
          "args": [
            "si",
            "i"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "216-222",
          "snippet": "bool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nbool __frontswap_test(struct swap_info_struct *sis,\n\t\t\t\tpgoff_t offset)\n{\n\tif (sis->frontswap_map)\n\t\treturn test_bit(offset, sis->frontswap_map);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "count"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "si->swap_map[i]"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define LATENCY_LIMIT\t\t256\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned int find_next_to_unuse(struct swap_info_struct *si,\n\t\t\t\t\tunsigned int prev, bool frontswap)\n{\n\tunsigned int max = si->max;\n\tunsigned int i = prev;\n\tunsigned char count;\n\n\t/*\n\t * No need for swap_lock here: we're just looking\n\t * for whether an entry is in use, not modifying it; false\n\t * hits are okay, and sys_swapoff() has already prevented new\n\t * allocations from this area (while holding swap_lock).\n\t */\n\tfor (;;) {\n\t\tif (++i >= max) {\n\t\t\tif (!prev) {\n\t\t\t\ti = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * No entries in use at top of swap_map,\n\t\t\t * loop back to start and recheck there.\n\t\t\t */\n\t\t\tmax = prev + 1;\n\t\t\tprev = 0;\n\t\t\ti = 1;\n\t\t}\n\t\tcount = READ_ONCE(si->swap_map[i]);\n\t\tif (count && swap_count(count) != SWAP_MAP_BAD)\n\t\t\tif (!frontswap || frontswap_test(si, i))\n\t\t\t\tbreak;\n\t\tif ((i % LATENCY_LIMIT) == 0)\n\t\t\tcond_resched();\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "unuse_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1928-1951",
    "snippet": "static int unuse_mm(struct mm_struct *mm,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tstruct vm_area_struct *vma;\n\tint ret = 0;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\t/*\n\t\t * Activate page so shrink_inactive_list is unlikely to unmap\n\t\t * its ptes while lock is dropped, so swapoff can make progress.\n\t\t */\n\t\tactivate_page(page);\n\t\tunlock_page(page);\n\t\tdown_read(&mm->mmap_sem);\n\t\tlock_page(page);\n\t}\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma && (ret = unuse_vma(vma, entry, page)))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn (ret < 0)? ret: 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unuse_vma",
          "args": [
            "vma",
            "entry",
            "page"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1898-1926",
          "snippet": "static int unuse_vma(struct vm_area_struct *vma,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpgd_t *pgd;\n\tunsigned long addr, end, next;\n\tint ret;\n\n\tif (page_anon_vma(page)) {\n\t\taddr = page_address_in_vma(page, vma);\n\t\tif (addr == -EFAULT)\n\t\t\treturn 0;\n\t\telse\n\t\t\tend = addr + PAGE_SIZE;\n\t} else {\n\t\taddr = vma->vm_start;\n\t\tend = vma->vm_end;\n\t}\n\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tret = unuse_p4d_range(vma, pgd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pgd++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_vma(struct vm_area_struct *vma,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpgd_t *pgd;\n\tunsigned long addr, end, next;\n\tint ret;\n\n\tif (page_anon_vma(page)) {\n\t\taddr = page_address_in_vma(page, vma);\n\t\tif (addr == -EFAULT)\n\t\t\treturn 0;\n\t\telse\n\t\t\tend = addr + PAGE_SIZE;\n\t} else {\n\t\taddr = vma->vm_start;\n\t\tend = vma->vm_end;\n\t}\n\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tret = unuse_p4d_range(vma, pgd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pgd++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "activate_page",
          "args": [
            "page"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "__lru_cache_activate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "339-364",
          "snippet": "static void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_mm(struct mm_struct *mm,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tstruct vm_area_struct *vma;\n\tint ret = 0;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\t/*\n\t\t * Activate page so shrink_inactive_list is unlikely to unmap\n\t\t * its ptes while lock is dropped, so swapoff can make progress.\n\t\t */\n\t\tactivate_page(page);\n\t\tunlock_page(page);\n\t\tdown_read(&mm->mmap_sem);\n\t\tlock_page(page);\n\t}\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma && (ret = unuse_vma(vma, entry, page)))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn (ret < 0)? ret: 0;\n}"
  },
  {
    "function_name": "unuse_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1898-1926",
    "snippet": "static int unuse_vma(struct vm_area_struct *vma,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpgd_t *pgd;\n\tunsigned long addr, end, next;\n\tint ret;\n\n\tif (page_anon_vma(page)) {\n\t\taddr = page_address_in_vma(page, vma);\n\t\tif (addr == -EFAULT)\n\t\t\treturn 0;\n\t\telse\n\t\t\tend = addr + PAGE_SIZE;\n\t} else {\n\t\taddr = vma->vm_start;\n\t\tend = vma->vm_end;\n\t}\n\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tret = unuse_p4d_range(vma, pgd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pgd++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unuse_p4d_range",
          "args": [
            "vma",
            "pgd",
            "addr",
            "next",
            "entry",
            "page"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1878-1896",
          "snippet": "static inline int unuse_p4d_range(struct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint ret;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tret = unuse_pud_range(vma, p4d, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int unuse_p4d_range(struct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint ret;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tret = unuse_pud_range(vma, p4d, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "pgd"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "vma->vm_mm",
            "addr"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address_in_vma",
          "args": [
            "page",
            "vma"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "page_address_in_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "687-708",
          "snippet": "unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_anon_vma",
          "args": [
            "page"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "page_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "489-498",
          "snippet": "struct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_vma(struct vm_area_struct *vma,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpgd_t *pgd;\n\tunsigned long addr, end, next;\n\tint ret;\n\n\tif (page_anon_vma(page)) {\n\t\taddr = page_address_in_vma(page, vma);\n\t\tif (addr == -EFAULT)\n\t\t\treturn 0;\n\t\telse\n\t\t\tend = addr + PAGE_SIZE;\n\t} else {\n\t\taddr = vma->vm_start;\n\t\tend = vma->vm_end;\n\t}\n\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tret = unuse_p4d_range(vma, pgd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pgd++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "unuse_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1878-1896",
    "snippet": "static inline int unuse_p4d_range(struct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint ret;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tret = unuse_pud_range(vma, p4d, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unuse_pud_range",
          "args": [
            "vma",
            "p4d",
            "addr",
            "next",
            "entry",
            "page"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1858-1876",
          "snippet": "static inline int unuse_pud_range(struct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint ret;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tret = unuse_pmd_range(vma, pud, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int unuse_pud_range(struct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint ret;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tret = unuse_pmd_range(vma, pud, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "p4d"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int unuse_p4d_range(struct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint ret;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tret = unuse_pud_range(vma, p4d, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "unuse_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1858-1876",
    "snippet": "static inline int unuse_pud_range(struct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint ret;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tret = unuse_pmd_range(vma, pud, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unuse_pmd_range",
          "args": [
            "vma",
            "pud",
            "addr",
            "next",
            "entry",
            "page"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1837-1856",
          "snippet": "static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tcond_resched();\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tcond_resched();\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none_or_clear_bad",
          "args": [
            "pud"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int unuse_pud_range(struct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint ret;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tret = unuse_pmd_range(vma, pud, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "unuse_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1837-1856",
    "snippet": "static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tcond_resched();\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unuse_pte_range",
          "args": [
            "vma",
            "pmd",
            "addr",
            "next",
            "entry",
            "page"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1801-1835",
          "snippet": "static int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpte_t swp_pte = swp_entry_to_pte(entry);\n\tpte_t *pte;\n\tint ret = 0;\n\n\t/*\n\t * We don't actually need pte lock while scanning for swp_pte: since\n\t * we hold page lock and mmap_sem, swp_pte cannot be inserted into the\n\t * page table while we're scanning; though it could get zapped, and on\n\t * some architectures (e.g. x86_32 with PAE) we might catch a glimpse\n\t * of unmatched parts which look like swp_pte, so unuse_pte must\n\t * recheck under pte lock.  Scanning without pte lock lets it be\n\t * preemptable whenever CONFIG_PREEMPT but not CONFIG_HIGHPTE.\n\t */\n\tpte = pte_offset_map(pmd, addr);\n\tdo {\n\t\t/*\n\t\t * swapoff spends a _lot_ of time in this loop!\n\t\t * Test inline before going to call unuse_pte.\n\t\t */\n\t\tif (unlikely(pte_same_as_swp(*pte, swp_pte))) {\n\t\t\tpte_unmap(pte);\n\t\t\tret = unuse_pte(vma, pmd, addr, entry, page);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpte = pte_offset_map(pmd, addr);\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap(pte - 1);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpte_t swp_pte = swp_entry_to_pte(entry);\n\tpte_t *pte;\n\tint ret = 0;\n\n\t/*\n\t * We don't actually need pte lock while scanning for swp_pte: since\n\t * we hold page lock and mmap_sem, swp_pte cannot be inserted into the\n\t * page table while we're scanning; though it could get zapped, and on\n\t * some architectures (e.g. x86_32 with PAE) we might catch a glimpse\n\t * of unmatched parts which look like swp_pte, so unuse_pte must\n\t * recheck under pte lock.  Scanning without pte lock lets it be\n\t * preemptable whenever CONFIG_PREEMPT but not CONFIG_HIGHPTE.\n\t */\n\tpte = pte_offset_map(pmd, addr);\n\tdo {\n\t\t/*\n\t\t * swapoff spends a _lot_ of time in this loop!\n\t\t * Test inline before going to call unuse_pte.\n\t\t */\n\t\tif (unlikely(pte_same_as_swp(*pte, swp_pte))) {\n\t\t\tpte_unmap(pte);\n\t\t\tret = unuse_pte(vma, pmd, addr, entry, page);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpte = pte_offset_map(pmd, addr);\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap(pte - 1);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none_or_trans_huge_or_clear_bad",
          "args": [
            "pmd"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tcond_resched();\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "unuse_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1801-1835",
    "snippet": "static int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpte_t swp_pte = swp_entry_to_pte(entry);\n\tpte_t *pte;\n\tint ret = 0;\n\n\t/*\n\t * We don't actually need pte lock while scanning for swp_pte: since\n\t * we hold page lock and mmap_sem, swp_pte cannot be inserted into the\n\t * page table while we're scanning; though it could get zapped, and on\n\t * some architectures (e.g. x86_32 with PAE) we might catch a glimpse\n\t * of unmatched parts which look like swp_pte, so unuse_pte must\n\t * recheck under pte lock.  Scanning without pte lock lets it be\n\t * preemptable whenever CONFIG_PREEMPT but not CONFIG_HIGHPTE.\n\t */\n\tpte = pte_offset_map(pmd, addr);\n\tdo {\n\t\t/*\n\t\t * swapoff spends a _lot_ of time in this loop!\n\t\t * Test inline before going to call unuse_pte.\n\t\t */\n\t\tif (unlikely(pte_same_as_swp(*pte, swp_pte))) {\n\t\t\tpte_unmap(pte);\n\t\t\tret = unuse_pte(vma, pmd, addr, entry, page);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpte = pte_offset_map(pmd, addr);\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap(pte - 1);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte - 1"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "addr"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unuse_pte",
          "args": [
            "vma",
            "pmd",
            "addr",
            "entry",
            "page"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1745-1799",
          "snippet": "static int unuse_pte(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, swp_entry_t entry, struct page *page)\n{\n\tstruct page *swapcache;\n\tstruct mem_cgroup *memcg;\n\tspinlock_t *ptl;\n\tpte_t *pte;\n\tint ret = 1;\n\n\tswapcache = page;\n\tpage = ksm_might_need_to_copy(page, vma, addr);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&memcg, false)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nolock;\n\t}\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_same_as_swp(*pte, swp_entry_to_pte(entry)))) {\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdec_mm_counter(vma->vm_mm, MM_SWAPENTS);\n\tinc_mm_counter(vma->vm_mm, MM_ANONPAGES);\n\tget_page(page);\n\tset_pte_at(vma->vm_mm, addr, pte,\n\t\t   pte_mkold(mk_pte(page, vma->vm_page_prot)));\n\tif (page == swapcache) {\n\t\tpage_add_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t} else { /* ksm created a completely new copy */\n\t\tpage_add_new_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t}\n\tswap_free(entry);\n\t/*\n\t * Move the page to the active list so it is not\n\t * immediately swapped out again after swapon.\n\t */\n\tactivate_page(page);\nout:\n\tpte_unmap_unlock(pte, ptl);\nout_nolock:\n\tif (page != swapcache) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_pte(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, swp_entry_t entry, struct page *page)\n{\n\tstruct page *swapcache;\n\tstruct mem_cgroup *memcg;\n\tspinlock_t *ptl;\n\tpte_t *pte;\n\tint ret = 1;\n\n\tswapcache = page;\n\tpage = ksm_might_need_to_copy(page, vma, addr);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&memcg, false)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nolock;\n\t}\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_same_as_swp(*pte, swp_entry_to_pte(entry)))) {\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdec_mm_counter(vma->vm_mm, MM_SWAPENTS);\n\tinc_mm_counter(vma->vm_mm, MM_ANONPAGES);\n\tget_page(page);\n\tset_pte_at(vma->vm_mm, addr, pte,\n\t\t   pte_mkold(mk_pte(page, vma->vm_page_prot)));\n\tif (page == swapcache) {\n\t\tpage_add_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t} else { /* ksm created a completely new copy */\n\t\tpage_add_new_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t}\n\tswap_free(entry);\n\t/*\n\t * Move the page to the active list so it is not\n\t * immediately swapped out again after swapon.\n\t */\n\tactivate_page(page);\nout:\n\tpte_unmap_unlock(pte, ptl);\nout_nolock:\n\tif (page != swapcache) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pte_same_as_swp(*pte, swp_pte)"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same_as_swp",
          "args": [
            "*pte",
            "swp_pte"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "addr"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpte_t swp_pte = swp_entry_to_pte(entry);\n\tpte_t *pte;\n\tint ret = 0;\n\n\t/*\n\t * We don't actually need pte lock while scanning for swp_pte: since\n\t * we hold page lock and mmap_sem, swp_pte cannot be inserted into the\n\t * page table while we're scanning; though it could get zapped, and on\n\t * some architectures (e.g. x86_32 with PAE) we might catch a glimpse\n\t * of unmatched parts which look like swp_pte, so unuse_pte must\n\t * recheck under pte lock.  Scanning without pte lock lets it be\n\t * preemptable whenever CONFIG_PREEMPT but not CONFIG_HIGHPTE.\n\t */\n\tpte = pte_offset_map(pmd, addr);\n\tdo {\n\t\t/*\n\t\t * swapoff spends a _lot_ of time in this loop!\n\t\t * Test inline before going to call unuse_pte.\n\t\t */\n\t\tif (unlikely(pte_same_as_swp(*pte, swp_pte))) {\n\t\t\tpte_unmap(pte);\n\t\t\tret = unuse_pte(vma, pmd, addr, entry, page);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpte = pte_offset_map(pmd, addr);\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap(pte - 1);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "unuse_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1745-1799",
    "snippet": "static int unuse_pte(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, swp_entry_t entry, struct page *page)\n{\n\tstruct page *swapcache;\n\tstruct mem_cgroup *memcg;\n\tspinlock_t *ptl;\n\tpte_t *pte;\n\tint ret = 1;\n\n\tswapcache = page;\n\tpage = ksm_might_need_to_copy(page, vma, addr);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&memcg, false)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nolock;\n\t}\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_same_as_swp(*pte, swp_entry_to_pte(entry)))) {\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdec_mm_counter(vma->vm_mm, MM_SWAPENTS);\n\tinc_mm_counter(vma->vm_mm, MM_ANONPAGES);\n\tget_page(page);\n\tset_pte_at(vma->vm_mm, addr, pte,\n\t\t   pte_mkold(mk_pte(page, vma->vm_page_prot)));\n\tif (page == swapcache) {\n\t\tpage_add_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t} else { /* ksm created a completely new copy */\n\t\tpage_add_new_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t}\n\tswap_free(entry);\n\t/*\n\t * Move the page to the active list so it is not\n\t * immediately swapped out again after swapon.\n\t */\n\tactivate_page(page);\nout:\n\tpte_unmap_unlock(pte, ptl);\nout_nolock:\n\tif (page != swapcache) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte",
            "ptl"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "activate_page",
          "args": [
            "page"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "__lru_cache_activate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "339-364",
          "snippet": "static void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_free",
          "args": [
            "entry"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "swap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1213-1220",
          "snippet": "void swap_free(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\t__swap_entry_free(p, entry, 1);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid swap_free(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\t__swap_entry_free(p, entry, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "page",
            "vma"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "page",
            "memcg",
            "false",
            "false"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "page",
            "vma",
            "addr",
            "false"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_anon_rmap",
          "args": [
            "page",
            "vma",
            "addr",
            "false"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1098-1137",
          "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "addr",
            "pte",
            "pte_mkold(mk_pte(page, vma->vm_page_prot))"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkold",
          "args": [
            "mk_pte(page, vma->vm_page_prot)"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_mm_counter",
          "args": [
            "vma->vm_mm",
            "MM_ANONPAGES"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "vma->vm_mm",
            "MM_SWAPENTS"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "page",
            "memcg",
            "false"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_same_as_swp(*pte, swp_entry_to_pte(entry))"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same_as_swp",
          "args": [
            "*pte",
            "swp_entry_to_pte(entry)"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge",
          "args": [
            "page",
            "vma->vm_mm",
            "GFP_KERNEL",
            "&memcg",
            "false"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_might_need_to_copy",
          "args": [
            "page",
            "vma",
            "addr"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_might_need_to_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2548-2577",
          "snippet": "struct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = page_anon_vma(page);\n\tstruct page *new_page;\n\n\tif (PageKsm(page)) {\n\t\tif (page_stable_node(page) &&\n\t\t    !(ksm_run & KSM_RUN_UNMERGE))\n\t\t\treturn page;\t/* no need to copy it */\n\t} else if (!anon_vma) {\n\t\treturn page;\t\t/* no need to copy it */\n\t} else if (anon_vma->root == vma->anon_vma->root &&\n\t\t page->index == linear_page_index(vma, address)) {\n\t\treturn page;\t\t/* still no need to copy it */\n\t}\n\tif (!PageUptodate(page))\n\t\treturn page;\t\t/* let do_swap_page report the error */\n\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\tif (new_page) {\n\t\tcopy_user_highpage(new_page, page, address, vma);\n\n\t\tSetPageDirty(new_page);\n\t\t__SetPageUptodate(new_page);\n\t\t__SetPageLocked(new_page);\n\t}\n\n\treturn new_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define KSM_RUN_UNMERGE\t2"
          ],
          "globals_used": [
            "static unsigned long ksm_run = KSM_RUN_STOP;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_UNMERGE\t2\n\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstruct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = page_anon_vma(page);\n\tstruct page *new_page;\n\n\tif (PageKsm(page)) {\n\t\tif (page_stable_node(page) &&\n\t\t    !(ksm_run & KSM_RUN_UNMERGE))\n\t\t\treturn page;\t/* no need to copy it */\n\t} else if (!anon_vma) {\n\t\treturn page;\t\t/* no need to copy it */\n\t} else if (anon_vma->root == vma->anon_vma->root &&\n\t\t page->index == linear_page_index(vma, address)) {\n\t\treturn page;\t\t/* still no need to copy it */\n\t}\n\tif (!PageUptodate(page))\n\t\treturn page;\t\t/* let do_swap_page report the error */\n\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\tif (new_page) {\n\t\tcopy_user_highpage(new_page, page, address, vma);\n\n\t\tSetPageDirty(new_page);\n\t\t__SetPageUptodate(new_page);\n\t\t__SetPageLocked(new_page);\n\t}\n\n\treturn new_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int unuse_pte(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, swp_entry_t entry, struct page *page)\n{\n\tstruct page *swapcache;\n\tstruct mem_cgroup *memcg;\n\tspinlock_t *ptl;\n\tpte_t *pte;\n\tint ret = 1;\n\n\tswapcache = page;\n\tpage = ksm_might_need_to_copy(page, vma, addr);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&memcg, false)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nolock;\n\t}\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_same_as_swp(*pte, swp_entry_to_pte(entry)))) {\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdec_mm_counter(vma->vm_mm, MM_SWAPENTS);\n\tinc_mm_counter(vma->vm_mm, MM_ANONPAGES);\n\tget_page(page);\n\tset_pte_at(vma->vm_mm, addr, pte,\n\t\t   pte_mkold(mk_pte(page, vma->vm_page_prot)));\n\tif (page == swapcache) {\n\t\tpage_add_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t} else { /* ksm created a completely new copy */\n\t\tpage_add_new_anon_rmap(page, vma, addr, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t}\n\tswap_free(entry);\n\t/*\n\t * Move the page to the active list so it is not\n\t * immediately swapped out again after swapon.\n\t */\n\tactivate_page(page);\nout:\n\tpte_unmap_unlock(pte, ptl);\nout_nolock:\n\tif (page != swapcache) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "pte_same_as_swp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1735-1738",
    "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "pte_swp_clear_soft_dirty(pte)",
            "swp_pte"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pte_swp_clear_soft_dirty",
          "args": [
            "pte"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
  },
  {
    "function_name": "count_swap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1714-1732",
    "snippet": "unsigned int count_swap_pages(int type, int free)\n{\n\tunsigned int n = 0;\n\n\tspin_lock(&swap_lock);\n\tif ((unsigned int)type < nr_swapfiles) {\n\t\tstruct swap_info_struct *sis = swap_info[type];\n\n\t\tspin_lock(&sis->lock);\n\t\tif (sis->flags & SWP_WRITEOK) {\n\t\t\tn = sis->pages;\n\t\t\tif (free)\n\t\t\t\tn -= sis->inuse_pages;\n\t\t}\n\t\tspin_unlock(&sis->lock);\n\t}\n\tspin_unlock(&swap_lock);\n\treturn n;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sis->lock"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sis->lock"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nunsigned int count_swap_pages(int type, int free)\n{\n\tunsigned int n = 0;\n\n\tspin_lock(&swap_lock);\n\tif ((unsigned int)type < nr_swapfiles) {\n\t\tstruct swap_info_struct *sis = swap_info[type];\n\n\t\tspin_lock(&sis->lock);\n\t\tif (sis->flags & SWP_WRITEOK) {\n\t\t\tn = sis->pages;\n\t\t\tif (free)\n\t\t\t\tn -= sis->inuse_pages;\n\t\t}\n\t\tspin_unlock(&sis->lock);\n\t}\n\tspin_unlock(&swap_lock);\n\treturn n;\n}"
  },
  {
    "function_name": "swapdev_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1697-1706",
    "snippet": "sector_t swapdev_block(int type, pgoff_t offset)\n{\n\tstruct block_device *bdev;\n\n\tif ((unsigned int)type >= nr_swapfiles)\n\t\treturn 0;\n\tif (!(swap_info[type]->flags & SWP_WRITEOK))\n\t\treturn 0;\n\treturn map_swap_entry(swp_entry(type, offset), &bdev);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
      "static unsigned int nr_swapfiles;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_swap_entry",
          "args": [
            "swp_entry(type, offset)",
            "&bdev"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "map_swap_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2253-2276",
          "snippet": "static sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)\n{\n\tstruct swap_info_struct *sis;\n\tstruct swap_extent *start_se;\n\tstruct swap_extent *se;\n\tpgoff_t offset;\n\n\tsis = swap_info[swp_type(entry)];\n\t*bdev = sis->bdev;\n\n\toffset = swp_offset(entry);\n\tstart_se = sis->curr_swap_extent;\n\tse = start_se;\n\n\tfor ( ; ; ) {\n\t\tif (se->start_page <= offset &&\n\t\t\t\toffset < (se->start_page + se->nr_pages)) {\n\t\t\treturn se->start_block + (offset - se->start_page);\n\t\t}\n\t\tse = list_next_entry(se, list);\n\t\tsis->curr_swap_extent = se;\n\t\tBUG_ON(se == start_se);\t\t/* It *must* be present */\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)\n{\n\tstruct swap_info_struct *sis;\n\tstruct swap_extent *start_se;\n\tstruct swap_extent *se;\n\tpgoff_t offset;\n\n\tsis = swap_info[swp_type(entry)];\n\t*bdev = sis->bdev;\n\n\toffset = swp_offset(entry);\n\tstart_se = sis->curr_swap_extent;\n\tse = start_se;\n\n\tfor ( ; ; ) {\n\t\tif (se->start_page <= offset &&\n\t\t\t\toffset < (se->start_page + se->nr_pages)) {\n\t\t\treturn se->start_block + (offset - se->start_page);\n\t\t}\n\t\tse = list_next_entry(se, list);\n\t\tsis->curr_swap_extent = se;\n\t\tBUG_ON(se == start_se);\t\t/* It *must* be present */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "type",
            "offset"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\nstatic unsigned int nr_swapfiles;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nsector_t swapdev_block(int type, pgoff_t offset)\n{\n\tstruct block_device *bdev;\n\n\tif ((unsigned int)type >= nr_swapfiles)\n\t\treturn 0;\n\tif (!(swap_info[type]->flags & SWP_WRITEOK))\n\t\treturn 0;\n\treturn map_swap_entry(swp_entry(type, offset), &bdev);\n}"
  },
  {
    "function_name": "swap_type_of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1651-1691",
    "snippet": "int swap_type_of(dev_t device, sector_t offset, struct block_device **bdev_p)\n{\n\tstruct block_device *bdev = NULL;\n\tint type;\n\n\tif (device)\n\t\tbdev = bdget(device);\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tstruct swap_info_struct *sis = swap_info[type];\n\n\t\tif (!(sis->flags & SWP_WRITEOK))\n\t\t\tcontinue;\n\n\t\tif (!bdev) {\n\t\t\tif (bdev_p)\n\t\t\t\t*bdev_p = bdgrab(sis->bdev);\n\n\t\t\tspin_unlock(&swap_lock);\n\t\t\treturn type;\n\t\t}\n\t\tif (bdev == sis->bdev) {\n\t\t\tstruct swap_extent *se = &sis->first_swap_extent;\n\n\t\t\tif (se->start_block == offset) {\n\t\t\t\tif (bdev_p)\n\t\t\t\t\t*bdev_p = bdgrab(sis->bdev);\n\n\t\t\t\tspin_unlock(&swap_lock);\n\t\t\t\tbdput(bdev);\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&swap_lock);\n\tif (bdev)\n\t\tbdput(bdev);\n\n\treturn -ENODEV;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
      "static unsigned int nr_swapfiles;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdgrab",
          "args": [
            "sis->bdev"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_lock"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdgrab",
          "args": [
            "sis->bdev"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_lock"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdget",
          "args": [
            "device"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\nstatic unsigned int nr_swapfiles;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nint swap_type_of(dev_t device, sector_t offset, struct block_device **bdev_p)\n{\n\tstruct block_device *bdev = NULL;\n\tint type;\n\n\tif (device)\n\t\tbdev = bdget(device);\n\n\tspin_lock(&swap_lock);\n\tfor (type = 0; type < nr_swapfiles; type++) {\n\t\tstruct swap_info_struct *sis = swap_info[type];\n\n\t\tif (!(sis->flags & SWP_WRITEOK))\n\t\t\tcontinue;\n\n\t\tif (!bdev) {\n\t\t\tif (bdev_p)\n\t\t\t\t*bdev_p = bdgrab(sis->bdev);\n\n\t\t\tspin_unlock(&swap_lock);\n\t\t\treturn type;\n\t\t}\n\t\tif (bdev == sis->bdev) {\n\t\t\tstruct swap_extent *se = &sis->first_swap_extent;\n\n\t\t\tif (se->start_block == offset) {\n\t\t\t\tif (bdev_p)\n\t\t\t\t\t*bdev_p = bdgrab(sis->bdev);\n\n\t\t\t\tspin_unlock(&swap_lock);\n\t\t\t\tbdput(bdev);\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&swap_lock);\n\tif (bdev)\n\t\tbdput(bdev);\n\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "free_swap_and_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1623-1640",
    "snippet": "int free_swap_and_cache(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned char count;\n\n\tif (non_swap_entry(entry))\n\t\treturn 1;\n\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\tcount = __swap_entry_free(p, entry, 1);\n\t\tif (count == SWAP_HAS_CACHE &&\n\t\t    !swap_page_trans_huge_swapped(p, entry))\n\t\t\t__try_to_reclaim_swap(p, swp_offset(entry),\n\t\t\t\t\t      TTRS_UNMAPPED | TTRS_FULL);\n\t}\n\treturn p != NULL;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define TTRS_FULL\t\t0x4",
      "#define TTRS_UNMAPPED\t\t0x2"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__try_to_reclaim_swap",
          "args": [
            "p",
            "swp_offset(entry)",
            "TTRS_UNMAPPED | TTRS_FULL"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "__try_to_reclaim_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "117-143",
          "snippet": "static int __try_to_reclaim_swap(struct swap_info_struct *si,\n\t\t\t\t unsigned long offset, unsigned long flags)\n{\n\tswp_entry_t entry = swp_entry(si->type, offset);\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = find_get_page(swap_address_space(entry), offset);\n\tif (!page)\n\t\treturn 0;\n\t/*\n\t * When this function is called from scan_swap_map_slots() and it's\n\t * called by vmscan.c at reclaiming pages. So, we hold a lock on a page,\n\t * here. We have to use trylock for avoiding deadlock. This is a special\n\t * case and you should use try_to_free_swap() with explicit lock_page()\n\t * in usual operations.\n\t */\n\tif (trylock_page(page)) {\n\t\tif ((flags & TTRS_ANYWAY) ||\n\t\t    ((flags & TTRS_UNMAPPED) && !page_mapped(page)) ||\n\t\t    ((flags & TTRS_FULL) && mem_cgroup_swap_full(page)))\n\t\t\tret = try_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TTRS_FULL\t\t0x4",
            "#define TTRS_UNMAPPED\t\t0x2",
            "#define TTRS_ANYWAY\t\t0x1"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define TTRS_FULL\t\t0x4\n#define TTRS_UNMAPPED\t\t0x2\n#define TTRS_ANYWAY\t\t0x1\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int __try_to_reclaim_swap(struct swap_info_struct *si,\n\t\t\t\t unsigned long offset, unsigned long flags)\n{\n\tswp_entry_t entry = swp_entry(si->type, offset);\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = find_get_page(swap_address_space(entry), offset);\n\tif (!page)\n\t\treturn 0;\n\t/*\n\t * When this function is called from scan_swap_map_slots() and it's\n\t * called by vmscan.c at reclaiming pages. So, we hold a lock on a page,\n\t * here. We have to use trylock for avoiding deadlock. This is a special\n\t * case and you should use try_to_free_swap() with explicit lock_page()\n\t * in usual operations.\n\t */\n\tif (trylock_page(page)) {\n\t\tif ((flags & TTRS_ANYWAY) ||\n\t\t    ((flags & TTRS_UNMAPPED) && !page_mapped(page)) ||\n\t\t    ((flags & TTRS_FULL) && mem_cgroup_swap_full(page)))\n\t\t\tret = try_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_page_trans_huge_swapped",
          "args": [
            "p",
            "entry"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "swap_page_trans_huge_swapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1429-1454",
          "snippet": "static bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n\t\t\t\t\t swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned char *map = si->swap_map;\n\tunsigned long roffset = swp_offset(entry);\n\tunsigned long offset = round_down(roffset, SWAPFILE_CLUSTER);\n\tint i;\n\tbool ret = false;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (!ci || !cluster_is_huge(ci)) {\n\t\tif (swap_count(map[roffset]))\n\t\t\tret = true;\n\t\tgoto unlock_out;\n\t}\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\tif (swap_count(map[offset + i])) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_out:\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n\t\t\t\t\t swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned char *map = si->swap_map;\n\tunsigned long roffset = swp_offset(entry);\n\tunsigned long offset = round_down(roffset, SWAPFILE_CLUSTER);\n\tint i;\n\tbool ret = false;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (!ci || !cluster_is_huge(ci)) {\n\t\tif (swap_count(map[roffset]))\n\t\t\tret = true;\n\t\tgoto unlock_out;\n\t}\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\tif (swap_count(map[offset + i])) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_out:\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__swap_entry_free",
          "args": [
            "p",
            "entry",
            "1"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1177-1190",
          "snippet": "static unsigned char __swap_entry_free(struct swap_info_struct *p,\n\t\t\t\t       swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\tusage = __swap_entry_free_locked(p, offset, usage);\n\tunlock_cluster_or_swap_info(p, ci);\n\tif (!usage)\n\t\tfree_swap_slot(entry);\n\n\treturn usage;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned char __swap_entry_free(struct swap_info_struct *p,\n\t\t\t\t       swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\tusage = __swap_entry_free_locked(p, offset, usage);\n\tunlock_cluster_or_swap_info(p, ci);\n\tif (!usage)\n\t\tfree_swap_slot(entry);\n\n\treturn usage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define TTRS_FULL\t\t0x4\n#define TTRS_UNMAPPED\t\t0x2\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint free_swap_and_cache(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned char count;\n\n\tif (non_swap_entry(entry))\n\t\treturn 1;\n\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\tcount = __swap_entry_free(p, entry, 1);\n\t\tif (count == SWAP_HAS_CACHE &&\n\t\t    !swap_page_trans_huge_swapped(p, entry))\n\t\t\t__try_to_reclaim_swap(p, swp_offset(entry),\n\t\t\t\t\t      TTRS_UNMAPPED | TTRS_FULL);\n\t}\n\treturn p != NULL;\n}"
  },
  {
    "function_name": "try_to_free_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1584-1617",
    "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_from_swap_cache",
          "args": [
            "page"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "243-254",
          "snippet": "void delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_suspended_storage",
          "args": [],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "pm_suspended_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "182-187",
          "snippet": "bool pm_suspended_storage(void)\n{\n\tif ((gfp_allowed_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "gfp_t gfp_allowed_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\n\nbool pm_suspended_storage(void)\n{\n\tif ((gfp_allowed_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_swapped",
          "args": [
            "page"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "page_swapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1456-1470",
          "snippet": "static bool page_swapped(struct page *page)\n{\n\tswp_entry_t entry;\n\tstruct swap_info_struct *si;\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))\n\t\treturn page_swapcount(page) != 0;\n\n\tpage = compound_head(page);\n\tentry.val = page_private(page);\n\tsi = _swap_info_get(entry);\n\tif (si)\n\t\treturn swap_page_trans_huge_swapped(si, entry);\n\treturn false;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool page_swapped(struct page *page)\n{\n\tswp_entry_t entry;\n\tstruct swap_info_struct *si;\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))\n\t\treturn page_swapcount(page) != 0;\n\n\tpage = compound_head(page);\n\tentry.val = page_private(page);\n\tsi = _swap_info_get(entry);\n\tif (si)\n\t\treturn swap_page_trans_huge_swapped(si, entry);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
  },
  {
    "function_name": "reuse_swap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1544-1578",
    "snippet": "bool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1114-1122",
          "snippet": "static struct swap_info_struct *swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\tspin_lock(&p->lock);\n\treturn p;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic struct swap_info_struct *swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\tspin_lock(&p->lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_from_swap_cache",
          "args": [
            "page"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "243-254",
          "snippet": "void delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swapcount",
          "args": [
            "page"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "page_swapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1329-1346",
          "snippet": "int page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageTransCompound(page)"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_trans_huge_map_swapcount",
          "args": [
            "page",
            "&total_mapcount",
            "&total_swapcount"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "page_trans_huge_map_swapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1472-1532",
          "snippet": "static int page_trans_huge_map_swapcount(struct page *page, int *total_mapcount,\n\t\t\t\t\t int *total_swapcount)\n{\n\tint i, map_swapcount, _total_mapcount, _total_swapcount;\n\tunsigned long offset = 0;\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci = NULL;\n\tunsigned char *map = NULL;\n\tint mapcount, swapcount = 0;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page))) {\n\t\tmapcount = page_trans_huge_mapcount(page, total_mapcount);\n\t\tif (PageSwapCache(page))\n\t\t\tswapcount = page_swapcount(page);\n\t\tif (total_swapcount)\n\t\t\t*total_swapcount = swapcount;\n\t\treturn mapcount + swapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = _total_swapcount = map_swapcount = 0;\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t entry;\n\n\t\tentry.val = page_private(page);\n\t\tsi = _swap_info_get(entry);\n\t\tif (si) {\n\t\t\tmap = si->swap_map;\n\t\t\toffset = swp_offset(entry);\n\t\t}\n\t}\n\tif (map)\n\t\tci = lock_cluster(si, offset);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\t_total_mapcount += mapcount;\n\t\tif (map) {\n\t\t\tswapcount = swap_count(map[offset + i]);\n\t\t\t_total_swapcount += swapcount;\n\t\t}\n\t\tmap_swapcount = max(map_swapcount, mapcount + swapcount);\n\t}\n\tunlock_cluster(ci);\n\tif (PageDoubleMap(page)) {\n\t\tmap_swapcount -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tmap_swapcount += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\tif (total_swapcount)\n\t\t*total_swapcount = _total_swapcount;\n\n\treturn map_swapcount;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int page_trans_huge_map_swapcount(struct page *page, int *total_mapcount,\n\t\t\t\t\t int *total_swapcount)\n{\n\tint i, map_swapcount, _total_mapcount, _total_swapcount;\n\tunsigned long offset = 0;\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci = NULL;\n\tunsigned char *map = NULL;\n\tint mapcount, swapcount = 0;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page))) {\n\t\tmapcount = page_trans_huge_mapcount(page, total_mapcount);\n\t\tif (PageSwapCache(page))\n\t\t\tswapcount = page_swapcount(page);\n\t\tif (total_swapcount)\n\t\t\t*total_swapcount = swapcount;\n\t\treturn mapcount + swapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = _total_swapcount = map_swapcount = 0;\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t entry;\n\n\t\tentry.val = page_private(page);\n\t\tsi = _swap_info_get(entry);\n\t\tif (si) {\n\t\t\tmap = si->swap_map;\n\t\t\toffset = swp_offset(entry);\n\t\t}\n\t}\n\tif (map)\n\t\tci = lock_cluster(si, offset);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\t_total_mapcount += mapcount;\n\t\tif (map) {\n\t\t\tswapcount = swap_count(map[offset + i]);\n\t\t\t_total_swapcount += swapcount;\n\t\t}\n\t\tmap_swapcount = max(map_swapcount, mapcount + swapcount);\n\t}\n\tunlock_cluster(ci);\n\tif (PageDoubleMap(page)) {\n\t\tmap_swapcount -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tmap_swapcount += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\tif (total_swapcount)\n\t\t*total_swapcount = _total_swapcount;\n\n\treturn map_swapcount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageKsm(page)"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nbool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}"
  },
  {
    "function_name": "page_trans_huge_map_swapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1472-1532",
    "snippet": "static int page_trans_huge_map_swapcount(struct page *page, int *total_mapcount,\n\t\t\t\t\t int *total_swapcount)\n{\n\tint i, map_swapcount, _total_mapcount, _total_swapcount;\n\tunsigned long offset = 0;\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci = NULL;\n\tunsigned char *map = NULL;\n\tint mapcount, swapcount = 0;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page))) {\n\t\tmapcount = page_trans_huge_mapcount(page, total_mapcount);\n\t\tif (PageSwapCache(page))\n\t\t\tswapcount = page_swapcount(page);\n\t\tif (total_swapcount)\n\t\t\t*total_swapcount = swapcount;\n\t\treturn mapcount + swapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = _total_swapcount = map_swapcount = 0;\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t entry;\n\n\t\tentry.val = page_private(page);\n\t\tsi = _swap_info_get(entry);\n\t\tif (si) {\n\t\t\tmap = si->swap_map;\n\t\t\toffset = swp_offset(entry);\n\t\t}\n\t}\n\tif (map)\n\t\tci = lock_cluster(si, offset);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\t_total_mapcount += mapcount;\n\t\tif (map) {\n\t\t\tswapcount = swap_count(map[offset + i]);\n\t\t\t_total_swapcount += swapcount;\n\t\t}\n\t\tmap_swapcount = max(map_swapcount, mapcount + swapcount);\n\t}\n\tunlock_cluster(ci);\n\tif (PageDoubleMap(page)) {\n\t\tmap_swapcount -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tmap_swapcount += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\tif (total_swapcount)\n\t\t*total_swapcount = _total_swapcount;\n\n\treturn map_swapcount;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "map_swapcount",
            "mapcount + swapcount"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "map[offset + i]"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "offset"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swapcount",
          "args": [
            "page"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "page_swapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1329-1346",
          "snippet": "int page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_trans_huge_mapcount",
          "args": [
            "page",
            "total_mapcount"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "page_trans_huge_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2552-2584",
          "snippet": "int page_trans_huge_mapcount(struct page *page, int *total_mapcount)\n{\n\tint i, ret, _total_mapcount, mapcount;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (likely(!PageTransCompound(page))) {\n\t\tmapcount = atomic_read(&page->_mapcount) + 1;\n\t\tif (total_mapcount)\n\t\t\t*total_mapcount = mapcount;\n\t\treturn mapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = ret = 0;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\tret = max(ret, mapcount);\n\t\t_total_mapcount += mapcount;\n\t}\n\tif (PageDoubleMap(page)) {\n\t\tret -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tret += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint page_trans_huge_mapcount(struct page *page, int *total_mapcount)\n{\n\tint i, ret, _total_mapcount, mapcount;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (likely(!PageTransCompound(page))) {\n\t\tmapcount = atomic_read(&page->_mapcount) + 1;\n\t\tif (total_mapcount)\n\t\t\t*total_mapcount = mapcount;\n\t\treturn mapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = ret = 0;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\tret = max(ret, mapcount);\n\t\t_total_mapcount += mapcount;\n\t}\n\tif (PageDoubleMap(page)) {\n\t\tret -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tret += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageTransCompound(page)"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_THP_SWAP"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageHuge(page)",
            "page"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int page_trans_huge_map_swapcount(struct page *page, int *total_mapcount,\n\t\t\t\t\t int *total_swapcount)\n{\n\tint i, map_swapcount, _total_mapcount, _total_swapcount;\n\tunsigned long offset = 0;\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci = NULL;\n\tunsigned char *map = NULL;\n\tint mapcount, swapcount = 0;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page))) {\n\t\tmapcount = page_trans_huge_mapcount(page, total_mapcount);\n\t\tif (PageSwapCache(page))\n\t\t\tswapcount = page_swapcount(page);\n\t\tif (total_swapcount)\n\t\t\t*total_swapcount = swapcount;\n\t\treturn mapcount + swapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = _total_swapcount = map_swapcount = 0;\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t entry;\n\n\t\tentry.val = page_private(page);\n\t\tsi = _swap_info_get(entry);\n\t\tif (si) {\n\t\t\tmap = si->swap_map;\n\t\t\toffset = swp_offset(entry);\n\t\t}\n\t}\n\tif (map)\n\t\tci = lock_cluster(si, offset);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\t_total_mapcount += mapcount;\n\t\tif (map) {\n\t\t\tswapcount = swap_count(map[offset + i]);\n\t\t\t_total_swapcount += swapcount;\n\t\t}\n\t\tmap_swapcount = max(map_swapcount, mapcount + swapcount);\n\t}\n\tunlock_cluster(ci);\n\tif (PageDoubleMap(page)) {\n\t\tmap_swapcount -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tmap_swapcount += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\tif (total_swapcount)\n\t\t*total_swapcount = _total_swapcount;\n\n\treturn map_swapcount;\n}"
  },
  {
    "function_name": "page_swapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1456-1470",
    "snippet": "static bool page_swapped(struct page *page)\n{\n\tswp_entry_t entry;\n\tstruct swap_info_struct *si;\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))\n\t\treturn page_swapcount(page) != 0;\n\n\tpage = compound_head(page);\n\tentry.val = page_private(page);\n\tsi = _swap_info_get(entry);\n\tif (si)\n\t\treturn swap_page_trans_huge_swapped(si, entry);\n\treturn false;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_page_trans_huge_swapped",
          "args": [
            "si",
            "entry"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "swap_page_trans_huge_swapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1429-1454",
          "snippet": "static bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n\t\t\t\t\t swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned char *map = si->swap_map;\n\tunsigned long roffset = swp_offset(entry);\n\tunsigned long offset = round_down(roffset, SWAPFILE_CLUSTER);\n\tint i;\n\tbool ret = false;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (!ci || !cluster_is_huge(ci)) {\n\t\tif (swap_count(map[roffset]))\n\t\t\tret = true;\n\t\tgoto unlock_out;\n\t}\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\tif (swap_count(map[offset + i])) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_out:\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n\t\t\t\t\t swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned char *map = si->swap_map;\n\tunsigned long roffset = swp_offset(entry);\n\tunsigned long offset = round_down(roffset, SWAPFILE_CLUSTER);\n\tint i;\n\tbool ret = false;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (!ci || !cluster_is_huge(ci)) {\n\t\tif (swap_count(map[roffset]))\n\t\t\tret = true;\n\t\tgoto unlock_out;\n\t}\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\tif (swap_count(map[offset + i])) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_out:\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swapcount",
          "args": [
            "page"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "page_swapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1329-1346",
          "snippet": "int page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageTransCompound(page)"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_THP_SWAP"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool page_swapped(struct page *page)\n{\n\tswp_entry_t entry;\n\tstruct swap_info_struct *si;\n\n\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))\n\t\treturn page_swapcount(page) != 0;\n\n\tpage = compound_head(page);\n\tentry.val = page_private(page);\n\tsi = _swap_info_get(entry);\n\tif (si)\n\t\treturn swap_page_trans_huge_swapped(si, entry);\n\treturn false;\n}"
  },
  {
    "function_name": "swap_page_trans_huge_swapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1429-1454",
    "snippet": "static bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n\t\t\t\t\t swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned char *map = si->swap_map;\n\tunsigned long roffset = swp_offset(entry);\n\tunsigned long offset = round_down(roffset, SWAPFILE_CLUSTER);\n\tint i;\n\tbool ret = false;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (!ci || !cluster_is_huge(ci)) {\n\t\tif (swap_count(map[roffset]))\n\t\t\tret = true;\n\t\tgoto unlock_out;\n\t}\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\tif (swap_count(map[offset + i])) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_out:\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_cluster_or_swap_info",
          "args": [
            "si",
            "ci"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "map[offset + i]"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_is_huge",
          "args": [
            "ci"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_is_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "291-296",
          "snippet": "static inline bool cluster_is_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\treturn info->flags & CLUSTER_FLAG_HUGE;\n\treturn false;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\treturn info->flags & CLUSTER_FLAG_HUGE;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "roffset",
            "SWAPFILE_CLUSTER"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n\t\t\t\t\t swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned char *map = si->swap_map;\n\tunsigned long roffset = swp_offset(entry);\n\tunsigned long offset = round_down(roffset, SWAPFILE_CLUSTER);\n\tint i;\n\tbool ret = false;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (!ci || !cluster_is_huge(ci)) {\n\t\tif (swap_count(map[roffset]))\n\t\t\tret = true;\n\t\tgoto unlock_out;\n\t}\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\tif (swap_count(map[offset + i])) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_out:\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn ret;\n}"
  },
  {
    "function_name": "swp_swapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1387-1427",
    "snippet": "int swp_swapcount(swp_entry_t entry)\n{\n\tint count, tmp_count, n;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tstruct page *page;\n\tpgoff_t offset;\n\tunsigned char *map;\n\n\tp = _swap_info_get(entry);\n\tif (!p)\n\t\treturn 0;\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = swap_count(p->swap_map[offset]);\n\tif (!(count & COUNT_CONTINUED))\n\t\tgoto out;\n\n\tcount &= ~COUNT_CONTINUED;\n\tn = SWAP_MAP_MAX + 1;\n\n\tpage = vmalloc_to_page(p->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\tVM_BUG_ON(page_private(page) != SWP_CONTINUED);\n\n\tdo {\n\t\tpage = list_next_entry(page, lru);\n\t\tmap = kmap_atomic(page);\n\t\ttmp_count = map[offset];\n\t\tkunmap_atomic(map);\n\n\t\tcount += (tmp_count & ~COUNT_CONTINUED) * n;\n\t\tn *= (SWAP_CONT_MAX + 1);\n\t} while (tmp_count & COUNT_CONTINUED);\nout:\n\tunlock_cluster_or_swap_info(p, ci);\n\treturn count;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_cluster_or_swap_info",
          "args": [
            "p",
            "ci"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "page",
            "lru"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "page_private(page) != SWP_CONTINUED"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "p->swap_map + offset"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "264-267",
          "snippet": "struct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "p->swap_map[offset]"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint swp_swapcount(swp_entry_t entry)\n{\n\tint count, tmp_count, n;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tstruct page *page;\n\tpgoff_t offset;\n\tunsigned char *map;\n\n\tp = _swap_info_get(entry);\n\tif (!p)\n\t\treturn 0;\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\n\tcount = swap_count(p->swap_map[offset]);\n\tif (!(count & COUNT_CONTINUED))\n\t\tgoto out;\n\n\tcount &= ~COUNT_CONTINUED;\n\tn = SWAP_MAP_MAX + 1;\n\n\tpage = vmalloc_to_page(p->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\tVM_BUG_ON(page_private(page) != SWP_CONTINUED);\n\n\tdo {\n\t\tpage = list_next_entry(page, lru);\n\t\tmap = kmap_atomic(page);\n\t\ttmp_count = map[offset];\n\t\tkunmap_atomic(map);\n\n\t\tcount += (tmp_count & ~COUNT_CONTINUED) * n;\n\t\tn *= (SWAP_CONT_MAX + 1);\n\t} while (tmp_count & COUNT_CONTINUED);\nout:\n\tunlock_cluster_or_swap_info(p, ci);\n\treturn count;\n}"
  },
  {
    "function_name": "__swp_swapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1372-1381",
    "snippet": "int __swp_swapcount(swp_entry_t entry)\n{\n\tint count = 0;\n\tstruct swap_info_struct *si;\n\n\tsi = __swap_info_get(entry);\n\tif (si)\n\t\tcount = swap_swapcount(si, entry);\n\treturn count;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_swapcount",
          "args": [
            "si",
            "entry"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "swap_swapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1355-1365",
          "snippet": "static int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tint count = 0;\n\tpgoff_t offset = swp_offset(entry);\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tcount = swap_count(si->swap_map[offset]);\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn count;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tint count = 0;\n\tpgoff_t offset = swp_offset(entry);\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tcount = swap_count(si->swap_map[offset]);\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1066-1094",
          "snippet": "static struct swap_info_struct *__swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned long offset, type;\n\n\tif (!entry.val)\n\t\tgoto out;\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_nofile;\n\tp = swap_info[type];\n\tif (!(p->flags & SWP_USED))\n\t\tgoto bad_device;\n\toffset = swp_offset(entry);\n\tif (offset >= p->max)\n\t\tgoto bad_offset;\n\treturn p;\n\nbad_offset:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_offset, entry.val);\n\tgoto out;\nbad_device:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_file, entry.val);\n\tgoto out;\nbad_nofile:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_file, entry.val);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static unsigned int nr_swapfiles;",
            "static const char Bad_file[] = \"Bad swap file entry \";",
            "static const char Unused_file[] = \"Unused swap file entry \";",
            "static const char Bad_offset[] = \"Bad swap offset entry \";",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstatic const char Unused_file[] = \"Unused swap file entry \";\nstatic const char Bad_offset[] = \"Bad swap offset entry \";\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic struct swap_info_struct *__swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned long offset, type;\n\n\tif (!entry.val)\n\t\tgoto out;\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_nofile;\n\tp = swap_info[type];\n\tif (!(p->flags & SWP_USED))\n\t\tgoto bad_device;\n\toffset = swp_offset(entry);\n\tif (offset >= p->max)\n\t\tgoto bad_offset;\n\treturn p;\n\nbad_offset:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_offset, entry.val);\n\tgoto out;\nbad_device:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_file, entry.val);\n\tgoto out;\nbad_nofile:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_file, entry.val);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint __swp_swapcount(swp_entry_t entry)\n{\n\tint count = 0;\n\tstruct swap_info_struct *si;\n\n\tsi = __swap_info_get(entry);\n\tif (si)\n\t\tcount = swap_swapcount(si, entry);\n\treturn count;\n}"
  },
  {
    "function_name": "swap_swapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1355-1365",
    "snippet": "static int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tint count = 0;\n\tpgoff_t offset = swp_offset(entry);\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tcount = swap_count(si->swap_map[offset]);\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn count;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_cluster_or_swap_info",
          "args": [
            "si",
            "ci"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "si->swap_map[offset]"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tint count = 0;\n\tpgoff_t offset = swp_offset(entry);\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tcount = swap_count(si->swap_map[offset]);\n\tunlock_cluster_or_swap_info(si, ci);\n\treturn count;\n}"
  },
  {
    "function_name": "__swap_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1348-1353",
    "snippet": "int __swap_count(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tpgoff_t offset = swp_offset(entry);\n\n\treturn swap_count(si->swap_map[offset]);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "si->swap_map[offset]"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint __swap_count(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tpgoff_t offset = swp_offset(entry);\n\n\treturn swap_count(si->swap_map[offset]);\n}"
  },
  {
    "function_name": "page_swapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1329-1346",
    "snippet": "int page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_cluster_or_swap_info",
          "args": [
            "p",
            "ci"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_count",
          "args": [
            "p->swap_map[offset]"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_count_continuations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3706-3722",
          "snippet": "static void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_swap_count_continuations(struct swap_info_struct *si)\n{\n\tpgoff_t offset;\n\n\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n\t\tstruct page *head;\n\t\thead = vmalloc_to_page(si->swap_map + offset);\n\t\tif (page_private(head)) {\n\t\t\tstruct page *page, *next;\n\n\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\t__free_page(page);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint page_swapcount(struct page *page)\n{\n\tint count = 0;\n\tstruct swap_info_struct *p;\n\tstruct swap_cluster_info *ci;\n\tswp_entry_t entry;\n\tunsigned long offset;\n\n\tentry.val = page_private(page);\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\toffset = swp_offset(entry);\n\t\tci = lock_cluster_or_swap_info(p, offset);\n\t\tcount = swap_count(p->swap_map[offset]);\n\t\tunlock_cluster_or_swap_info(p, ci);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "swapcache_free_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1296-1322",
    "snippet": "void swapcache_free_entries(swp_entry_t *entries, int n)\n{\n\tstruct swap_info_struct *p, *prev;\n\tint i;\n\n\tif (n <= 0)\n\t\treturn;\n\n\tprev = NULL;\n\tp = NULL;\n\n\t/*\n\t * Sort swap entries by swap device, so each lock is only taken once.\n\t * nr_swapfiles isn't absolutely correct, but the overhead of sort() is\n\t * so low that it isn't necessary to optimize further.\n\t */\n\tif (nr_swapfiles > 1)\n\t\tsort(entries, n, sizeof(entries[0]), swp_entry_cmp, NULL);\n\tfor (i = 0; i < n; ++i) {\n\t\tp = swap_info_get_cont(entries[i], prev);\n\t\tif (p)\n\t\t\tswap_entry_free(p, entries[i]);\n\t\tprev = p;\n\t}\n\tif (p)\n\t\tspin_unlock(&p->lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_entry_free",
          "args": [
            "p",
            "entries[i]"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "swap_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1192-1207",
          "snippet": "static void swap_entry_free(struct swap_info_struct *p, swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\tunsigned char count;\n\n\tci = lock_cluster(p, offset);\n\tcount = p->swap_map[offset];\n\tVM_BUG_ON(count != SWAP_HAS_CACHE);\n\tp->swap_map[offset] = 0;\n\tdec_cluster_info_page(p, p->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tmem_cgroup_uncharge_swap(entry, 1);\n\tswap_range_free(p, offset, 1);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_entry_free(struct swap_info_struct *p, swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\tunsigned char count;\n\n\tci = lock_cluster(p, offset);\n\tcount = p->swap_map[offset];\n\tVM_BUG_ON(count != SWAP_HAS_CACHE);\n\tp->swap_map[offset] = 0;\n\tdec_cluster_info_page(p, p->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tmem_cgroup_uncharge_swap(entry, 1);\n\tswap_range_free(p, offset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_info_get_cont",
          "args": [
            "entries[i]",
            "prev"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "swap_info_get_cont",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1124-1138",
          "snippet": "static struct swap_info_struct *swap_info_get_cont(swp_entry_t entry,\n\t\t\t\t\tstruct swap_info_struct *q)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\n\tif (p != q) {\n\t\tif (q != NULL)\n\t\t\tspin_unlock(&q->lock);\n\t\tif (p != NULL)\n\t\t\tspin_lock(&p->lock);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic struct swap_info_struct *swap_info_get_cont(swp_entry_t entry,\n\t\t\t\t\tstruct swap_info_struct *q)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\n\tif (p != q) {\n\t\tif (q != NULL)\n\t\t\tspin_unlock(&q->lock);\n\t\tif (p != NULL)\n\t\t\tspin_lock(&p->lock);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "entries",
            "n",
            "sizeof(entries[0])",
            "swp_entry_cmp",
            "NULL"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\n\nvoid swapcache_free_entries(swp_entry_t *entries, int n)\n{\n\tstruct swap_info_struct *p, *prev;\n\tint i;\n\n\tif (n <= 0)\n\t\treturn;\n\n\tprev = NULL;\n\tp = NULL;\n\n\t/*\n\t * Sort swap entries by swap device, so each lock is only taken once.\n\t * nr_swapfiles isn't absolutely correct, but the overhead of sort() is\n\t * so low that it isn't necessary to optimize further.\n\t */\n\tif (nr_swapfiles > 1)\n\t\tsort(entries, n, sizeof(entries[0]), swp_entry_cmp, NULL);\n\tfor (i = 0; i < n; ++i) {\n\t\tp = swap_info_get_cont(entries[i], prev);\n\t\tif (p)\n\t\t\tswap_entry_free(p, entries[i]);\n\t\tprev = p;\n\t}\n\tif (p)\n\t\tspin_unlock(&p->lock);\n}"
  },
  {
    "function_name": "swp_entry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1289-1294",
    "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "*e2"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "*e1"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
  },
  {
    "function_name": "split_swap_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1273-1286",
    "snippet": "int split_swap_cluster(swp_entry_t entry)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn -EBUSY;\n\tci = lock_cluster(si, offset);\n\tcluster_clear_huge(ci);\n\tunlock_cluster(ci);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_clear_huge",
          "args": [
            "ci"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_clear_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "298-301",
          "snippet": "static inline void cluster_clear_huge(struct swap_cluster_info *info)\n{\n\tinfo->flags &= ~CLUSTER_FLAG_HUGE;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_clear_huge(struct swap_cluster_info *info)\n{\n\tinfo->flags &= ~CLUSTER_FLAG_HUGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "offset"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint split_swap_cluster(swp_entry_t entry)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn -EBUSY;\n\tci = lock_cluster(si, offset);\n\tcluster_clear_huge(ci);\n\tunlock_cluster(ci);\n\treturn 0;\n}"
  },
  {
    "function_name": "put_swap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1225-1270",
    "snippet": "void put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_cluster_or_swap_info",
          "args": [
            "si",
            "ci"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_swap_slot",
          "args": [
            "entry"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "278-308",
          "snippet": "int free_swap_slot(swp_entry_t entry)\n{\n\tstruct swap_slots_cache *cache;\n\n\tcache = raw_cpu_ptr(&swp_slots);\n\tif (likely(use_swap_slot_cache && cache->slots_ret)) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\t/* Swap slots cache may be deactivated before acquiring lock */\n\t\tif (!use_swap_slot_cache || !cache->slots_ret) {\n\t\t\tspin_unlock_irq(&cache->free_lock);\n\t\t\tgoto direct_free;\n\t\t}\n\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * Return slots to global pool.\n\t\t\t * The current swap_map value is SWAP_HAS_CACHE.\n\t\t\t * Set it to 0 to indicate it is available for\n\t\t\t * allocation in global pool\n\t\t\t */\n\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\t\tcache->n_ret = 0;\n\t\t}\n\t\tcache->slots_ret[cache->n_ret++] = entry;\n\t\tspin_unlock_irq(&cache->free_lock);\n\t} else {\ndirect_free:\n\t\tswapcache_free_entries(&entry, 1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [
            "#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\n\nint free_swap_slot(swp_entry_t entry)\n{\n\tstruct swap_slots_cache *cache;\n\n\tcache = raw_cpu_ptr(&swp_slots);\n\tif (likely(use_swap_slot_cache && cache->slots_ret)) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\t/* Swap slots cache may be deactivated before acquiring lock */\n\t\tif (!use_swap_slot_cache || !cache->slots_ret) {\n\t\t\tspin_unlock_irq(&cache->free_lock);\n\t\t\tgoto direct_free;\n\t\t}\n\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * Return slots to global pool.\n\t\t\t * The current swap_map value is SWAP_HAS_CACHE.\n\t\t\t * Set it to 0 to indicate it is available for\n\t\t\t * allocation in global pool\n\t\t\t */\n\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\t\tcache->n_ret = 0;\n\t\t}\n\t\tcache->slots_ret[cache->n_ret++] = entry;\n\t\tspin_unlock_irq(&cache->free_lock);\n\t} else {\ndirect_free:\n\t\tswapcache_free_entries(&entry, 1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__swap_entry_free_locked",
          "args": [
            "si",
            "offset + i",
            "SWAP_HAS_CACHE"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_entry_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1140-1175",
          "snippet": "static unsigned char __swap_entry_free_locked(struct swap_info_struct *p,\n\t\t\t\t\t      unsigned long offset,\n\t\t\t\t\t      unsigned char usage)\n{\n\tunsigned char count;\n\tunsigned char has_cache;\n\n\tcount = p->swap_map[offset];\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\t\tVM_BUG_ON(!has_cache);\n\t\thas_cache = 0;\n\t} else if (count == SWAP_MAP_SHMEM) {\n\t\t/*\n\t\t * Or we could insist on shmem.c using a special\n\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n\t\t */\n\t\tcount = 0;\n\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n\t\tif (count == COUNT_CONTINUED) {\n\t\t\tif (swap_count_continued(p, offset, count))\n\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n\t\t\telse\n\t\t\t\tcount = SWAP_MAP_MAX;\n\t\t} else\n\t\t\tcount--;\n\t}\n\n\tusage = count | has_cache;\n\tp->swap_map[offset] = usage ? : SWAP_HAS_CACHE;\n\n\treturn usage;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned char __swap_entry_free_locked(struct swap_info_struct *p,\n\t\t\t\t\t      unsigned long offset,\n\t\t\t\t\t      unsigned char usage)\n{\n\tunsigned char count;\n\tunsigned char has_cache;\n\n\tcount = p->swap_map[offset];\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\t\tVM_BUG_ON(!has_cache);\n\t\thas_cache = 0;\n\t} else if (count == SWAP_MAP_SHMEM) {\n\t\t/*\n\t\t * Or we could insist on shmem.c using a special\n\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n\t\t */\n\t\tcount = 0;\n\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n\t\tif (count == COUNT_CONTINUED) {\n\t\t\tif (swap_count_continued(p, offset, count))\n\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n\t\t\telse\n\t\t\t\tcount = SWAP_MAP_MAX;\n\t\t} else\n\t\t\tcount--;\n\t}\n\n\tusage = count | has_cache;\n\tp->swap_map[offset] = usage ? : SWAP_HAS_CACHE;\n\n\treturn usage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_free_cluster",
          "args": [
            "si",
            "idx"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "swap_free_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "929-940",
          "snippet": "static void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge_swap",
          "args": [
            "entry",
            "SWAPFILE_CLUSTER"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6495-6517",
          "snippet": "void mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_clear_huge",
          "args": [
            "ci"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_clear_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "298-301",
          "snippet": "static inline void cluster_clear_huge(struct swap_cluster_info *info)\n{\n\tinfo->flags &= ~CLUSTER_FLAG_HUGE;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_clear_huge(struct swap_cluster_info *info)\n{\n\tinfo->flags &= ~CLUSTER_FLAG_HUGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!(val & SWAP_HAS_CACHE)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!cluster_is_huge(ci)"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_is_huge",
          "args": [
            "ci"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_is_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "291-296",
          "snippet": "static inline bool cluster_is_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\treturn info->flags & CLUSTER_FLAG_HUGE;\n\treturn false;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\treturn info->flags & CLUSTER_FLAG_HUGE;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_entry_size",
          "args": [
            "hpage_nr_pages(page)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}"
  },
  {
    "function_name": "swap_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1213-1220",
    "snippet": "void swap_free(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\t__swap_entry_free(p, entry, 1);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__swap_entry_free",
          "args": [
            "p",
            "entry",
            "1"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1177-1190",
          "snippet": "static unsigned char __swap_entry_free(struct swap_info_struct *p,\n\t\t\t\t       swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\tusage = __swap_entry_free_locked(p, offset, usage);\n\tunlock_cluster_or_swap_info(p, ci);\n\tif (!usage)\n\t\tfree_swap_slot(entry);\n\n\treturn usage;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned char __swap_entry_free(struct swap_info_struct *p,\n\t\t\t\t       swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\tusage = __swap_entry_free_locked(p, offset, usage);\n\tunlock_cluster_or_swap_info(p, ci);\n\tif (!usage)\n\t\tfree_swap_slot(entry);\n\n\treturn usage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid swap_free(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\t__swap_entry_free(p, entry, 1);\n}"
  },
  {
    "function_name": "swap_entry_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1192-1207",
    "snippet": "static void swap_entry_free(struct swap_info_struct *p, swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\tunsigned char count;\n\n\tci = lock_cluster(p, offset);\n\tcount = p->swap_map[offset];\n\tVM_BUG_ON(count != SWAP_HAS_CACHE);\n\tp->swap_map[offset] = 0;\n\tdec_cluster_info_page(p, p->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tmem_cgroup_uncharge_swap(entry, 1);\n\tswap_range_free(p, offset, 1);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_range_free",
          "args": [
            "p",
            "offset",
            "1"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "swap_range_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "667-695",
          "snippet": "static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n\t\t\t    unsigned int nr_entries)\n{\n\tunsigned long end = offset + nr_entries - 1;\n\tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n\n\tif (offset < si->lowest_bit)\n\t\tsi->lowest_bit = offset;\n\tif (end > si->highest_bit) {\n\t\tbool was_full = !si->highest_bit;\n\n\t\tsi->highest_bit = end;\n\t\tif (was_full && (si->flags & SWP_WRITEOK))\n\t\t\tadd_to_avail_list(si);\n\t}\n\tatomic_long_add(nr_entries, &nr_swap_pages);\n\tsi->inuse_pages -= nr_entries;\n\tif (si->flags & SWP_BLKDEV)\n\t\tswap_slot_free_notify =\n\t\t\tsi->bdev->bd_disk->fops->swap_slot_free_notify;\n\telse\n\t\tswap_slot_free_notify = NULL;\n\twhile (offset <= end) {\n\t\tfrontswap_invalidate_page(si->type, offset);\n\t\tif (swap_slot_free_notify)\n\t\t\tswap_slot_free_notify(si->bdev, offset);\n\t\toffset++;\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
            "atomic_long_t nr_swap_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\natomic_long_t nr_swap_pages;\n\nstatic void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n\t\t\t    unsigned int nr_entries)\n{\n\tunsigned long end = offset + nr_entries - 1;\n\tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n\n\tif (offset < si->lowest_bit)\n\t\tsi->lowest_bit = offset;\n\tif (end > si->highest_bit) {\n\t\tbool was_full = !si->highest_bit;\n\n\t\tsi->highest_bit = end;\n\t\tif (was_full && (si->flags & SWP_WRITEOK))\n\t\t\tadd_to_avail_list(si);\n\t}\n\tatomic_long_add(nr_entries, &nr_swap_pages);\n\tsi->inuse_pages -= nr_entries;\n\tif (si->flags & SWP_BLKDEV)\n\t\tswap_slot_free_notify =\n\t\t\tsi->bdev->bd_disk->fops->swap_slot_free_notify;\n\telse\n\t\tswap_slot_free_notify = NULL;\n\twhile (offset <= end) {\n\t\tfrontswap_invalidate_page(si->type, offset);\n\t\tif (swap_slot_free_notify)\n\t\t\tswap_slot_free_notify(si->bdev, offset);\n\t\toffset++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge_swap",
          "args": [
            "entry",
            "1"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6495-6517",
          "snippet": "void mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned short id;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tid = swap_cgroup_record(entry, 0, nr_pages);\n\trcu_read_lock();\n\tmemcg = mem_cgroup_from_id(id);\n\tif (memcg) {\n\t\tif (!mem_cgroup_is_root(memcg)) {\n\t\t\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n\t\t\telse\n\t\t\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\t\t}\n\t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_cluster_info_page",
          "args": [
            "p",
            "p->cluster_info",
            "offset"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "dec_cluster_info_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "520-534",
          "snippet": "static void dec_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) == 0);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) - 1);\n\n\tif (cluster_count(&cluster_info[idx]) == 0)\n\t\tfree_cluster(p, idx);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void dec_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) == 0);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) - 1);\n\n\tif (cluster_count(&cluster_info[idx]) == 0)\n\t\tfree_cluster(p, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "count != SWAP_HAS_CACHE"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "p",
            "offset"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_entry_free(struct swap_info_struct *p, swp_entry_t entry)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\tunsigned char count;\n\n\tci = lock_cluster(p, offset);\n\tcount = p->swap_map[offset];\n\tVM_BUG_ON(count != SWAP_HAS_CACHE);\n\tp->swap_map[offset] = 0;\n\tdec_cluster_info_page(p, p->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tmem_cgroup_uncharge_swap(entry, 1);\n\tswap_range_free(p, offset, 1);\n}"
  },
  {
    "function_name": "__swap_entry_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1177-1190",
    "snippet": "static unsigned char __swap_entry_free(struct swap_info_struct *p,\n\t\t\t\t       swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\tusage = __swap_entry_free_locked(p, offset, usage);\n\tunlock_cluster_or_swap_info(p, ci);\n\tif (!usage)\n\t\tfree_swap_slot(entry);\n\n\treturn usage;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_swap_slot",
          "args": [
            "entry"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "278-308",
          "snippet": "int free_swap_slot(swp_entry_t entry)\n{\n\tstruct swap_slots_cache *cache;\n\n\tcache = raw_cpu_ptr(&swp_slots);\n\tif (likely(use_swap_slot_cache && cache->slots_ret)) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\t/* Swap slots cache may be deactivated before acquiring lock */\n\t\tif (!use_swap_slot_cache || !cache->slots_ret) {\n\t\t\tspin_unlock_irq(&cache->free_lock);\n\t\t\tgoto direct_free;\n\t\t}\n\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * Return slots to global pool.\n\t\t\t * The current swap_map value is SWAP_HAS_CACHE.\n\t\t\t * Set it to 0 to indicate it is available for\n\t\t\t * allocation in global pool\n\t\t\t */\n\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\t\tcache->n_ret = 0;\n\t\t}\n\t\tcache->slots_ret[cache->n_ret++] = entry;\n\t\tspin_unlock_irq(&cache->free_lock);\n\t} else {\ndirect_free:\n\t\tswapcache_free_entries(&entry, 1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [
            "#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\n\nint free_swap_slot(swp_entry_t entry)\n{\n\tstruct swap_slots_cache *cache;\n\n\tcache = raw_cpu_ptr(&swp_slots);\n\tif (likely(use_swap_slot_cache && cache->slots_ret)) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\t/* Swap slots cache may be deactivated before acquiring lock */\n\t\tif (!use_swap_slot_cache || !cache->slots_ret) {\n\t\t\tspin_unlock_irq(&cache->free_lock);\n\t\t\tgoto direct_free;\n\t\t}\n\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * Return slots to global pool.\n\t\t\t * The current swap_map value is SWAP_HAS_CACHE.\n\t\t\t * Set it to 0 to indicate it is available for\n\t\t\t * allocation in global pool\n\t\t\t */\n\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\t\tcache->n_ret = 0;\n\t\t}\n\t\tcache->slots_ret[cache->n_ret++] = entry;\n\t\tspin_unlock_irq(&cache->free_lock);\n\t} else {\ndirect_free:\n\t\tswapcache_free_entries(&entry, 1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_cluster_or_swap_info",
          "args": [
            "p",
            "ci"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__swap_entry_free_locked",
          "args": [
            "p",
            "offset",
            "usage"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_entry_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1140-1175",
          "snippet": "static unsigned char __swap_entry_free_locked(struct swap_info_struct *p,\n\t\t\t\t\t      unsigned long offset,\n\t\t\t\t\t      unsigned char usage)\n{\n\tunsigned char count;\n\tunsigned char has_cache;\n\n\tcount = p->swap_map[offset];\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\t\tVM_BUG_ON(!has_cache);\n\t\thas_cache = 0;\n\t} else if (count == SWAP_MAP_SHMEM) {\n\t\t/*\n\t\t * Or we could insist on shmem.c using a special\n\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n\t\t */\n\t\tcount = 0;\n\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n\t\tif (count == COUNT_CONTINUED) {\n\t\t\tif (swap_count_continued(p, offset, count))\n\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n\t\t\telse\n\t\t\t\tcount = SWAP_MAP_MAX;\n\t\t} else\n\t\t\tcount--;\n\t}\n\n\tusage = count | has_cache;\n\tp->swap_map[offset] = usage ? : SWAP_HAS_CACHE;\n\n\treturn usage;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned char __swap_entry_free_locked(struct swap_info_struct *p,\n\t\t\t\t\t      unsigned long offset,\n\t\t\t\t\t      unsigned char usage)\n{\n\tunsigned char count;\n\tunsigned char has_cache;\n\n\tcount = p->swap_map[offset];\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\t\tVM_BUG_ON(!has_cache);\n\t\thas_cache = 0;\n\t} else if (count == SWAP_MAP_SHMEM) {\n\t\t/*\n\t\t * Or we could insist on shmem.c using a special\n\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n\t\t */\n\t\tcount = 0;\n\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n\t\tif (count == COUNT_CONTINUED) {\n\t\t\tif (swap_count_continued(p, offset, count))\n\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n\t\t\telse\n\t\t\t\tcount = SWAP_MAP_MAX;\n\t\t} else\n\t\t\tcount--;\n\t}\n\n\tusage = count | has_cache;\n\tp->swap_map[offset] = usage ? : SWAP_HAS_CACHE;\n\n\treturn usage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned char __swap_entry_free(struct swap_info_struct *p,\n\t\t\t\t       swp_entry_t entry, unsigned char usage)\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tci = lock_cluster_or_swap_info(p, offset);\n\tusage = __swap_entry_free_locked(p, offset, usage);\n\tunlock_cluster_or_swap_info(p, ci);\n\tif (!usage)\n\t\tfree_swap_slot(entry);\n\n\treturn usage;\n}"
  },
  {
    "function_name": "__swap_entry_free_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1140-1175",
    "snippet": "static unsigned char __swap_entry_free_locked(struct swap_info_struct *p,\n\t\t\t\t\t      unsigned long offset,\n\t\t\t\t\t      unsigned char usage)\n{\n\tunsigned char count;\n\tunsigned char has_cache;\n\n\tcount = p->swap_map[offset];\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\t\tVM_BUG_ON(!has_cache);\n\t\thas_cache = 0;\n\t} else if (count == SWAP_MAP_SHMEM) {\n\t\t/*\n\t\t * Or we could insist on shmem.c using a special\n\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n\t\t */\n\t\tcount = 0;\n\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n\t\tif (count == COUNT_CONTINUED) {\n\t\t\tif (swap_count_continued(p, offset, count))\n\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n\t\t\telse\n\t\t\t\tcount = SWAP_MAP_MAX;\n\t\t} else\n\t\t\tcount--;\n\t}\n\n\tusage = count | has_cache;\n\tp->swap_map[offset] = usage ? : SWAP_HAS_CACHE;\n\n\treturn usage;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_count_continued",
          "args": [
            "p",
            "offset",
            "count"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "swap_count_continued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3618-3700",
          "snippet": "static bool swap_count_continued(struct swap_info_struct *si,\n\t\t\t\t pgoff_t offset, unsigned char count)\n{\n\tstruct page *head;\n\tstruct page *page;\n\tunsigned char *map;\n\tbool ret;\n\n\thead = vmalloc_to_page(si->swap_map + offset);\n\tif (page_private(head) != SWP_CONTINUED) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\treturn false;\t\t/* need to add count continuation */\n\t}\n\n\tspin_lock(&si->cont_lock);\n\toffset &= ~PAGE_MASK;\n\tpage = list_entry(head->lru.next, struct page, lru);\n\tmap = kmap_atomic(page) + offset;\n\n\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n\n\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n\t\t/*\n\t\t * Think of how you add 1 to 999\n\t\t */\n\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tif (*map == SWAP_CONT_MAX) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tif (page == head) {\n\t\t\t\tret = false;\t/* add count continuation */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap = kmap_atomic(page) + offset;\ninit_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n\t\t}\n\t\t*map += 1;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = true;\t\t\t/* incremented */\n\n\t} else {\t\t\t\t/* decrementing */\n\t\t/*\n\t\t * Think of how you subtract 1 from 1000\n\t\t */\n\t\tBUG_ON(count != COUNT_CONTINUED);\n\t\twhile (*map == COUNT_CONTINUED) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tBUG_ON(*map == 0);\n\t\t*map -= 1;\n\t\tif (*map == 0)\n\t\t\tcount = 0;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = SWAP_CONT_MAX | count;\n\t\t\tcount = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = count == COUNT_CONTINUED;\n\t}\nout:\n\tspin_unlock(&si->cont_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool swap_count_continued(struct swap_info_struct *si,\n\t\t\t\t pgoff_t offset, unsigned char count)\n{\n\tstruct page *head;\n\tstruct page *page;\n\tunsigned char *map;\n\tbool ret;\n\n\thead = vmalloc_to_page(si->swap_map + offset);\n\tif (page_private(head) != SWP_CONTINUED) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\treturn false;\t\t/* need to add count continuation */\n\t}\n\n\tspin_lock(&si->cont_lock);\n\toffset &= ~PAGE_MASK;\n\tpage = list_entry(head->lru.next, struct page, lru);\n\tmap = kmap_atomic(page) + offset;\n\n\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n\n\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n\t\t/*\n\t\t * Think of how you add 1 to 999\n\t\t */\n\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tif (*map == SWAP_CONT_MAX) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tif (page == head) {\n\t\t\t\tret = false;\t/* add count continuation */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmap = kmap_atomic(page) + offset;\ninit_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n\t\t}\n\t\t*map += 1;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = true;\t\t\t/* incremented */\n\n\t} else {\t\t\t\t/* decrementing */\n\t\t/*\n\t\t * Think of how you subtract 1 from 1000\n\t\t */\n\t\tBUG_ON(count != COUNT_CONTINUED);\n\t\twhile (*map == COUNT_CONTINUED) {\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.next, struct page, lru);\n\t\t\tBUG_ON(page == head);\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t}\n\t\tBUG_ON(*map == 0);\n\t\t*map -= 1;\n\t\tif (*map == 0)\n\t\t\tcount = 0;\n\t\tkunmap_atomic(map);\n\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\twhile (page != head) {\n\t\t\tmap = kmap_atomic(page) + offset;\n\t\t\t*map = SWAP_CONT_MAX | count;\n\t\t\tcount = COUNT_CONTINUED;\n\t\t\tkunmap_atomic(map);\n\t\t\tpage = list_entry(page->lru.prev, struct page, lru);\n\t\t}\n\t\tret = count == COUNT_CONTINUED;\n\t}\nout:\n\tspin_unlock(&si->cont_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!has_cache"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned char __swap_entry_free_locked(struct swap_info_struct *p,\n\t\t\t\t\t      unsigned long offset,\n\t\t\t\t\t      unsigned char usage)\n{\n\tunsigned char count;\n\tunsigned char has_cache;\n\n\tcount = p->swap_map[offset];\n\n\thas_cache = count & SWAP_HAS_CACHE;\n\tcount &= ~SWAP_HAS_CACHE;\n\n\tif (usage == SWAP_HAS_CACHE) {\n\t\tVM_BUG_ON(!has_cache);\n\t\thas_cache = 0;\n\t} else if (count == SWAP_MAP_SHMEM) {\n\t\t/*\n\t\t * Or we could insist on shmem.c using a special\n\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n\t\t */\n\t\tcount = 0;\n\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n\t\tif (count == COUNT_CONTINUED) {\n\t\t\tif (swap_count_continued(p, offset, count))\n\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n\t\t\telse\n\t\t\t\tcount = SWAP_MAP_MAX;\n\t\t} else\n\t\t\tcount--;\n\t}\n\n\tusage = count | has_cache;\n\tp->swap_map[offset] = usage ? : SWAP_HAS_CACHE;\n\n\treturn usage;\n}"
  },
  {
    "function_name": "swap_info_get_cont",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1124-1138",
    "snippet": "static struct swap_info_struct *swap_info_get_cont(swp_entry_t entry,\n\t\t\t\t\tstruct swap_info_struct *q)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\n\tif (p != q) {\n\t\tif (q != NULL)\n\t\t\tspin_unlock(&q->lock);\n\t\tif (p != NULL)\n\t\t\tspin_lock(&p->lock);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->lock"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&q->lock"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic struct swap_info_struct *swap_info_get_cont(swp_entry_t entry,\n\t\t\t\t\tstruct swap_info_struct *q)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\n\tif (p != q) {\n\t\tif (q != NULL)\n\t\t\tspin_unlock(&q->lock);\n\t\tif (p != NULL)\n\t\t\tspin_lock(&p->lock);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "swap_info_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1114-1122",
    "snippet": "static struct swap_info_struct *swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\tspin_lock(&p->lock);\n\treturn p;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->lock"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "_swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1096-1112",
          "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static const char Unused_offset[] = \"Unused swap offset entry \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic struct swap_info_struct *swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\tspin_lock(&p->lock);\n\treturn p;\n}"
  },
  {
    "function_name": "_swap_info_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1096-1112",
    "snippet": "static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static const char Unused_offset[] = \"Unused swap offset entry \";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swap_info_get: %s%08lx\\n\"",
            "Unused_offset",
            "entry.val"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__swap_info_get",
          "args": [
            "entry"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_info_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1066-1094",
          "snippet": "static struct swap_info_struct *__swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned long offset, type;\n\n\tif (!entry.val)\n\t\tgoto out;\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_nofile;\n\tp = swap_info[type];\n\tif (!(p->flags & SWP_USED))\n\t\tgoto bad_device;\n\toffset = swp_offset(entry);\n\tif (offset >= p->max)\n\t\tgoto bad_offset;\n\treturn p;\n\nbad_offset:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_offset, entry.val);\n\tgoto out;\nbad_device:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_file, entry.val);\n\tgoto out;\nbad_nofile:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_file, entry.val);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static unsigned int nr_swapfiles;",
            "static const char Bad_file[] = \"Bad swap file entry \";",
            "static const char Unused_file[] = \"Unused swap file entry \";",
            "static const char Bad_offset[] = \"Bad swap offset entry \";",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstatic const char Unused_file[] = \"Unused swap file entry \";\nstatic const char Bad_offset[] = \"Bad swap offset entry \";\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic struct swap_info_struct *__swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned long offset, type;\n\n\tif (!entry.val)\n\t\tgoto out;\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_nofile;\n\tp = swap_info[type];\n\tif (!(p->flags & SWP_USED))\n\t\tgoto bad_device;\n\toffset = swp_offset(entry);\n\tif (offset >= p->max)\n\t\tgoto bad_offset;\n\treturn p;\n\nbad_offset:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_offset, entry.val);\n\tgoto out;\nbad_device:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_file, entry.val);\n\tgoto out;\nbad_nofile:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_file, entry.val);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic const char Unused_offset[] = \"Unused swap offset entry \";\n\nstatic struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = __swap_info_get(entry);\n\tif (!p)\n\t\tgoto out;\n\tif (!p->swap_map[swp_offset(entry)])\n\t\tgoto bad_free;\n\treturn p;\n\nbad_free:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_offset, entry.val);\n\tgoto out;\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "__swap_info_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1066-1094",
    "snippet": "static struct swap_info_struct *__swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned long offset, type;\n\n\tif (!entry.val)\n\t\tgoto out;\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_nofile;\n\tp = swap_info[type];\n\tif (!(p->flags & SWP_USED))\n\t\tgoto bad_device;\n\toffset = swp_offset(entry);\n\tif (offset >= p->max)\n\t\tgoto bad_offset;\n\treturn p;\n\nbad_offset:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_offset, entry.val);\n\tgoto out;\nbad_device:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_file, entry.val);\n\tgoto out;\nbad_nofile:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_file, entry.val);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static unsigned int nr_swapfiles;",
      "static const char Bad_file[] = \"Bad swap file entry \";",
      "static const char Unused_file[] = \"Unused swap file entry \";",
      "static const char Bad_offset[] = \"Bad swap offset entry \";",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swap_info_get: %s%08lx\\n\"",
            "Bad_file",
            "entry.val"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swap_info_get: %s%08lx\\n\"",
            "Unused_file",
            "entry.val"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swap_info_get: %s%08lx\\n\"",
            "Bad_offset",
            "entry.val"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\nstatic const char Bad_file[] = \"Bad swap file entry \";\nstatic const char Unused_file[] = \"Unused swap file entry \";\nstatic const char Bad_offset[] = \"Bad swap offset entry \";\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstatic struct swap_info_struct *__swap_info_get(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned long offset, type;\n\n\tif (!entry.val)\n\t\tgoto out;\n\ttype = swp_type(entry);\n\tif (type >= nr_swapfiles)\n\t\tgoto bad_nofile;\n\tp = swap_info[type];\n\tif (!(p->flags & SWP_USED))\n\t\tgoto bad_device;\n\toffset = swp_offset(entry);\n\tif (offset >= p->max)\n\t\tgoto bad_offset;\n\treturn p;\n\nbad_offset:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_offset, entry.val);\n\tgoto out;\nbad_device:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Unused_file, entry.val);\n\tgoto out;\nbad_nofile:\n\tpr_err(\"swap_info_get: %s%08lx\\n\", Bad_file, entry.val);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_swap_page_of_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "1045-1064",
    "snippet": "swp_entry_t get_swap_page_of_type(int type)\n{\n\tstruct swap_info_struct *si;\n\tpgoff_t offset;\n\n\tsi = swap_info[type];\n\tspin_lock(&si->lock);\n\tif (si && (si->flags & SWP_WRITEOK)) {\n\t\tatomic_long_dec(&nr_swap_pages);\n\t\t/* This is called for allocating swap entry, not cache */\n\t\toffset = scan_swap_map(si, 1);\n\t\tif (offset) {\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn swp_entry(type, offset);\n\t\t}\n\t\tatomic_long_inc(&nr_swap_pages);\n\t}\n\tspin_unlock(&si->lock);\n\treturn (swp_entry_t) {0};\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "atomic_long_t nr_swap_pages;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&nr_swap_pages"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "type",
            "offset"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_swap_map",
          "args": [
            "si",
            "1"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "scan_swap_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "942-955",
          "snippet": "static unsigned long scan_swap_map(struct swap_info_struct *si,\n\t\t\t\t   unsigned char usage)\n{\n\tswp_entry_t entry;\n\tint n_ret;\n\n\tn_ret = scan_swap_map_slots(si, usage, 1, &entry);\n\n\tif (n_ret)\n\t\treturn swp_offset(entry);\n\telse\n\t\treturn 0;\n\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned long scan_swap_map(struct swap_info_struct *si,\n\t\t\t\t   unsigned char usage)\n{\n\tswp_entry_t entry;\n\tint n_ret;\n\n\tn_ret = scan_swap_map_slots(si, usage, 1, &entry);\n\n\tif (n_ret)\n\t\treturn swp_offset(entry);\n\telse\n\t\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&nr_swap_pages"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\natomic_long_t nr_swap_pages;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nswp_entry_t get_swap_page_of_type(int type)\n{\n\tstruct swap_info_struct *si;\n\tpgoff_t offset;\n\n\tsi = swap_info[type];\n\tspin_lock(&si->lock);\n\tif (si && (si->flags & SWP_WRITEOK)) {\n\t\tatomic_long_dec(&nr_swap_pages);\n\t\t/* This is called for allocating swap entry, not cache */\n\t\toffset = scan_swap_map(si, 1);\n\t\tif (offset) {\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn swp_entry(type, offset);\n\t\t}\n\t\tatomic_long_inc(&nr_swap_pages);\n\t}\n\tspin_unlock(&si->lock);\n\treturn (swp_entry_t) {0};\n}"
  },
  {
    "function_name": "get_swap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "957-1042",
    "snippet": "int get_swap_pages(int n_goal, swp_entry_t swp_entries[], int entry_size)\n{\n\tunsigned long size = swap_entry_size(entry_size);\n\tstruct swap_info_struct *si, *next;\n\tlong avail_pgs;\n\tint n_ret = 0;\n\tint node;\n\n\t/* Only single cluster request supported */\n\tWARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);\n\n\tavail_pgs = atomic_long_read(&nr_swap_pages) / size;\n\tif (avail_pgs <= 0)\n\t\tgoto noswap;\n\n\tif (n_goal > SWAP_BATCH)\n\t\tn_goal = SWAP_BATCH;\n\n\tif (n_goal > avail_pgs)\n\t\tn_goal = avail_pgs;\n\n\tatomic_long_sub(n_goal * size, &nr_swap_pages);\n\n\tspin_lock(&swap_avail_lock);\n\nstart_over:\n\tnode = numa_node_id();\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {\n\t\t/* requeue si to after same-priority siblings */\n\t\tplist_requeue(&si->avail_lists[node], &swap_avail_heads[node]);\n\t\tspin_unlock(&swap_avail_lock);\n\t\tspin_lock(&si->lock);\n\t\tif (!si->highest_bit || !(si->flags & SWP_WRITEOK)) {\n\t\t\tspin_lock(&swap_avail_lock);\n\t\t\tif (plist_node_empty(&si->avail_lists[node])) {\n\t\t\t\tspin_unlock(&si->lock);\n\t\t\t\tgoto nextsi;\n\t\t\t}\n\t\t\tWARN(!si->highest_bit,\n\t\t\t     \"swap_info %d in list but !highest_bit\\n\",\n\t\t\t     si->type);\n\t\t\tWARN(!(si->flags & SWP_WRITEOK),\n\t\t\t     \"swap_info %d in list but !SWP_WRITEOK\\n\",\n\t\t\t     si->type);\n\t\t\t__del_from_avail_list(si);\n\t\t\tspin_unlock(&si->lock);\n\t\t\tgoto nextsi;\n\t\t}\n\t\tif (size == SWAPFILE_CLUSTER) {\n\t\t\tif (!(si->flags & SWP_FS))\n\t\t\t\tn_ret = swap_alloc_cluster(si, swp_entries);\n\t\t} else\n\t\t\tn_ret = scan_swap_map_slots(si, SWAP_HAS_CACHE,\n\t\t\t\t\t\t    n_goal, swp_entries);\n\t\tspin_unlock(&si->lock);\n\t\tif (n_ret || size == SWAPFILE_CLUSTER)\n\t\t\tgoto check_out;\n\t\tpr_debug(\"scan_swap_map of si %d failed to find offset\\n\",\n\t\t\tsi->type);\n\n\t\tspin_lock(&swap_avail_lock);\nnextsi:\n\t\t/*\n\t\t * if we got here, it's likely that si was almost full before,\n\t\t * and since scan_swap_map() can drop the si->lock, multiple\n\t\t * callers probably all tried to get a page from the same si\n\t\t * and it filled up before we could get one; or, the si filled\n\t\t * up between us dropping swap_avail_lock and taking si->lock.\n\t\t * Since we dropped the swap_avail_lock, the swap_avail_head\n\t\t * list may have been modified; so if next is still in the\n\t\t * swap_avail_head list then try it, otherwise start over\n\t\t * if we have not gotten any slots.\n\t\t */\n\t\tif (plist_node_empty(&next->avail_lists[node]))\n\t\t\tgoto start_over;\n\t}\n\n\tspin_unlock(&swap_avail_lock);\n\ncheck_out:\n\tif (n_ret < n_goal)\n\t\tatomic_long_add((long)(n_goal - n_ret) * size,\n\t\t\t\t&nr_swap_pages);\nnoswap:\n\treturn n_ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "atomic_long_t nr_swap_pages;",
      "static struct plist_head *swap_avail_heads;",
      "static DEFINE_SPINLOCK(swap_avail_lock);",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "(long)(n_goal - n_ret) * size",
            "&nr_swap_pages"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_empty",
          "args": [
            "&next->avail_lists[node]"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"scan_swap_map of si %d failed to find offset\\n\"",
            "si->type"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_swap_map_slots",
          "args": [
            "si",
            "SWAP_HAS_CACHE",
            "n_goal",
            "swp_entries"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "scan_swap_map_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "697-892",
          "snippet": "static int scan_swap_map_slots(struct swap_info_struct *si,\n\t\t\t       unsigned char usage, int nr,\n\t\t\t       swp_entry_t slots[])\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned long scan_base;\n\tunsigned long last_in_cluster = 0;\n\tint latency_ration = LATENCY_LIMIT;\n\tint n_ret = 0;\n\n\tif (nr > SWAP_BATCH)\n\t\tnr = SWAP_BATCH;\n\n\t/*\n\t * We try to cluster swap pages by allocating them sequentially\n\t * in swap.  Once we've allocated SWAPFILE_CLUSTER pages this\n\t * way, however, we resort to first-free allocation, starting\n\t * a new cluster.  This prevents us from scattering swap pages\n\t * all over the entire swap partition, so that we reduce\n\t * overall disk seek times between swap pages.  -- sct\n\t * But we do now try to find an empty cluster.  -Andrea\n\t * And we let swap pages go all over an SSD partition.  Hugh\n\t */\n\n\tsi->flags += SWP_SCANNING;\n\tscan_base = offset = si->cluster_next;\n\n\t/* SSD algorithm */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto scan;\n\t}\n\n\tif (unlikely(!si->cluster_nr--)) {\n\t\tif (si->pages - si->inuse_pages < SWAPFILE_CLUSTER) {\n\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\tgoto checks;\n\t\t}\n\n\t\tspin_unlock(&si->lock);\n\n\t\t/*\n\t\t * If seek is expensive, start searching for new cluster from\n\t\t * start of partition, to minimize the span of allocated swap.\n\t\t * If seek is cheap, that is the SWP_SOLIDSTATE si->cluster_info\n\t\t * case, just handled by scan_swap_map_try_ssd_cluster() above.\n\t\t */\n\t\tscan_base = offset = si->lowest_bit;\n\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER - 1;\n\n\t\t/* Locate the first empty (unaligned) cluster */\n\t\tfor (; last_in_cluster <= si->highest_bit; offset++) {\n\t\t\tif (si->swap_map[offset])\n\t\t\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER;\n\t\t\telse if (offset == last_in_cluster) {\n\t\t\t\tspin_lock(&si->lock);\n\t\t\t\toffset -= SWAPFILE_CLUSTER - 1;\n\t\t\t\tsi->cluster_next = offset;\n\t\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\t\tgoto checks;\n\t\t\t}\n\t\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\t\tcond_resched();\n\t\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\t}\n\t\t}\n\n\t\toffset = scan_base;\n\t\tspin_lock(&si->lock);\n\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t}\n\nchecks:\n\tif (si->cluster_info) {\n\t\twhile (scan_swap_map_ssd_cluster_conflict(si, offset)) {\n\t\t/* take a break if we already got some slots */\n\t\t\tif (n_ret)\n\t\t\t\tgoto done;\n\t\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset,\n\t\t\t\t\t\t\t&scan_base))\n\t\t\t\tgoto scan;\n\t\t}\n\t}\n\tif (!(si->flags & SWP_WRITEOK))\n\t\tgoto no_page;\n\tif (!si->highest_bit)\n\t\tgoto no_page;\n\tif (offset > si->highest_bit)\n\t\tscan_base = offset = si->lowest_bit;\n\n\tci = lock_cluster(si, offset);\n\t/* reuse swap entry of cache-only swap if not busy. */\n\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\tint swap_was_freed;\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\tswap_was_freed = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n\t\tspin_lock(&si->lock);\n\t\t/* entry was freed successfully, try to use this again */\n\t\tif (swap_was_freed)\n\t\t\tgoto checks;\n\t\tgoto scan; /* check next one */\n\t}\n\n\tif (si->swap_map[offset]) {\n\t\tunlock_cluster(ci);\n\t\tif (!n_ret)\n\t\t\tgoto scan;\n\t\telse\n\t\t\tgoto done;\n\t}\n\tsi->swap_map[offset] = usage;\n\tinc_cluster_info_page(si, si->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tswap_range_alloc(si, offset, 1);\n\tsi->cluster_next = offset + 1;\n\tslots[n_ret++] = swp_entry(si->type, offset);\n\n\t/* got enough slots or reach max slots? */\n\tif ((n_ret == nr) || (offset >= si->highest_bit))\n\t\tgoto done;\n\n\t/* search for next available slot */\n\n\t/* time to take a break? */\n\tif (unlikely(--latency_ration < 0)) {\n\t\tif (n_ret)\n\t\t\tgoto done;\n\t\tspin_unlock(&si->lock);\n\t\tcond_resched();\n\t\tspin_lock(&si->lock);\n\t\tlatency_ration = LATENCY_LIMIT;\n\t}\n\n\t/* try to get more slots in cluster */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto done;\n\t}\n\t/* non-ssd case */\n\t++offset;\n\n\t/* non-ssd case, still more slots in cluster? */\n\tif (si->cluster_nr && !si->swap_map[offset]) {\n\t\t--si->cluster_nr;\n\t\tgoto checks;\n\t}\n\ndone:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n\nscan:\n\tspin_unlock(&si->lock);\n\twhile (++offset <= si->highest_bit) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t}\n\toffset = si->lowest_bit;\n\twhile (offset < scan_base) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t\toffset++;\n\t}\n\tspin_lock(&si->lock);\n\nno_page:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define LATENCY_LIMIT\t\t256",
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR",
            "#define TTRS_ANYWAY\t\t0x1"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define LATENCY_LIMIT\t\t256\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n#define TTRS_ANYWAY\t\t0x1\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int scan_swap_map_slots(struct swap_info_struct *si,\n\t\t\t       unsigned char usage, int nr,\n\t\t\t       swp_entry_t slots[])\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned long scan_base;\n\tunsigned long last_in_cluster = 0;\n\tint latency_ration = LATENCY_LIMIT;\n\tint n_ret = 0;\n\n\tif (nr > SWAP_BATCH)\n\t\tnr = SWAP_BATCH;\n\n\t/*\n\t * We try to cluster swap pages by allocating them sequentially\n\t * in swap.  Once we've allocated SWAPFILE_CLUSTER pages this\n\t * way, however, we resort to first-free allocation, starting\n\t * a new cluster.  This prevents us from scattering swap pages\n\t * all over the entire swap partition, so that we reduce\n\t * overall disk seek times between swap pages.  -- sct\n\t * But we do now try to find an empty cluster.  -Andrea\n\t * And we let swap pages go all over an SSD partition.  Hugh\n\t */\n\n\tsi->flags += SWP_SCANNING;\n\tscan_base = offset = si->cluster_next;\n\n\t/* SSD algorithm */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto scan;\n\t}\n\n\tif (unlikely(!si->cluster_nr--)) {\n\t\tif (si->pages - si->inuse_pages < SWAPFILE_CLUSTER) {\n\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\tgoto checks;\n\t\t}\n\n\t\tspin_unlock(&si->lock);\n\n\t\t/*\n\t\t * If seek is expensive, start searching for new cluster from\n\t\t * start of partition, to minimize the span of allocated swap.\n\t\t * If seek is cheap, that is the SWP_SOLIDSTATE si->cluster_info\n\t\t * case, just handled by scan_swap_map_try_ssd_cluster() above.\n\t\t */\n\t\tscan_base = offset = si->lowest_bit;\n\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER - 1;\n\n\t\t/* Locate the first empty (unaligned) cluster */\n\t\tfor (; last_in_cluster <= si->highest_bit; offset++) {\n\t\t\tif (si->swap_map[offset])\n\t\t\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER;\n\t\t\telse if (offset == last_in_cluster) {\n\t\t\t\tspin_lock(&si->lock);\n\t\t\t\toffset -= SWAPFILE_CLUSTER - 1;\n\t\t\t\tsi->cluster_next = offset;\n\t\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\t\tgoto checks;\n\t\t\t}\n\t\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\t\tcond_resched();\n\t\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\t}\n\t\t}\n\n\t\toffset = scan_base;\n\t\tspin_lock(&si->lock);\n\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t}\n\nchecks:\n\tif (si->cluster_info) {\n\t\twhile (scan_swap_map_ssd_cluster_conflict(si, offset)) {\n\t\t/* take a break if we already got some slots */\n\t\t\tif (n_ret)\n\t\t\t\tgoto done;\n\t\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset,\n\t\t\t\t\t\t\t&scan_base))\n\t\t\t\tgoto scan;\n\t\t}\n\t}\n\tif (!(si->flags & SWP_WRITEOK))\n\t\tgoto no_page;\n\tif (!si->highest_bit)\n\t\tgoto no_page;\n\tif (offset > si->highest_bit)\n\t\tscan_base = offset = si->lowest_bit;\n\n\tci = lock_cluster(si, offset);\n\t/* reuse swap entry of cache-only swap if not busy. */\n\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\tint swap_was_freed;\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\tswap_was_freed = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n\t\tspin_lock(&si->lock);\n\t\t/* entry was freed successfully, try to use this again */\n\t\tif (swap_was_freed)\n\t\t\tgoto checks;\n\t\tgoto scan; /* check next one */\n\t}\n\n\tif (si->swap_map[offset]) {\n\t\tunlock_cluster(ci);\n\t\tif (!n_ret)\n\t\t\tgoto scan;\n\t\telse\n\t\t\tgoto done;\n\t}\n\tsi->swap_map[offset] = usage;\n\tinc_cluster_info_page(si, si->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tswap_range_alloc(si, offset, 1);\n\tsi->cluster_next = offset + 1;\n\tslots[n_ret++] = swp_entry(si->type, offset);\n\n\t/* got enough slots or reach max slots? */\n\tif ((n_ret == nr) || (offset >= si->highest_bit))\n\t\tgoto done;\n\n\t/* search for next available slot */\n\n\t/* time to take a break? */\n\tif (unlikely(--latency_ration < 0)) {\n\t\tif (n_ret)\n\t\t\tgoto done;\n\t\tspin_unlock(&si->lock);\n\t\tcond_resched();\n\t\tspin_lock(&si->lock);\n\t\tlatency_ration = LATENCY_LIMIT;\n\t}\n\n\t/* try to get more slots in cluster */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto done;\n\t}\n\t/* non-ssd case */\n\t++offset;\n\n\t/* non-ssd case, still more slots in cluster? */\n\tif (si->cluster_nr && !si->swap_map[offset]) {\n\t\t--si->cluster_nr;\n\t\tgoto checks;\n\t}\n\ndone:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n\nscan:\n\tspin_unlock(&si->lock);\n\twhile (++offset <= si->highest_bit) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t}\n\toffset = si->lowest_bit;\n\twhile (offset < scan_base) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t\toffset++;\n\t}\n\tspin_lock(&si->lock);\n\nno_page:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_alloc_cluster",
          "args": [
            "si",
            "swp_entries"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "swap_alloc_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "894-927",
          "snippet": "static int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__del_from_avail_list",
          "args": [
            "si"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_avail_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "623-629",
          "snippet": "static void __del_from_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tfor_each_node(nid)\n\t\tplist_del(&p->avail_lists[nid], &swap_avail_heads[nid]);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static struct plist_head *swap_avail_heads;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\n\nstatic void __del_from_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tfor_each_node(nid)\n\t\tplist_del(&p->avail_lists[nid], &swap_avail_heads[nid]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!(si->flags & SWP_WRITEOK)",
            "\"swap_info %d in list but !SWP_WRITEOK\\n\"",
            "si->type"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!si->highest_bit",
            "\"swap_info %d in list but !highest_bit\\n\"",
            "si->type"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_empty",
          "args": [
            "&si->avail_lists[node]"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_requeue",
          "args": [
            "&si->avail_lists[node]",
            "&swap_avail_heads[node]"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_for_each_entry_safe",
          "args": [
            "si",
            "next",
            "&swap_avail_heads[node]",
            "avail_lists[node]"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "n_goal * size",
            "&nr_swap_pages"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&nr_swap_pages"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "n_goal > 1 && size == SWAPFILE_CLUSTER"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_entry_size",
          "args": [
            "entry_size"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\natomic_long_t nr_swap_pages;\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nint get_swap_pages(int n_goal, swp_entry_t swp_entries[], int entry_size)\n{\n\tunsigned long size = swap_entry_size(entry_size);\n\tstruct swap_info_struct *si, *next;\n\tlong avail_pgs;\n\tint n_ret = 0;\n\tint node;\n\n\t/* Only single cluster request supported */\n\tWARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);\n\n\tavail_pgs = atomic_long_read(&nr_swap_pages) / size;\n\tif (avail_pgs <= 0)\n\t\tgoto noswap;\n\n\tif (n_goal > SWAP_BATCH)\n\t\tn_goal = SWAP_BATCH;\n\n\tif (n_goal > avail_pgs)\n\t\tn_goal = avail_pgs;\n\n\tatomic_long_sub(n_goal * size, &nr_swap_pages);\n\n\tspin_lock(&swap_avail_lock);\n\nstart_over:\n\tnode = numa_node_id();\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {\n\t\t/* requeue si to after same-priority siblings */\n\t\tplist_requeue(&si->avail_lists[node], &swap_avail_heads[node]);\n\t\tspin_unlock(&swap_avail_lock);\n\t\tspin_lock(&si->lock);\n\t\tif (!si->highest_bit || !(si->flags & SWP_WRITEOK)) {\n\t\t\tspin_lock(&swap_avail_lock);\n\t\t\tif (plist_node_empty(&si->avail_lists[node])) {\n\t\t\t\tspin_unlock(&si->lock);\n\t\t\t\tgoto nextsi;\n\t\t\t}\n\t\t\tWARN(!si->highest_bit,\n\t\t\t     \"swap_info %d in list but !highest_bit\\n\",\n\t\t\t     si->type);\n\t\t\tWARN(!(si->flags & SWP_WRITEOK),\n\t\t\t     \"swap_info %d in list but !SWP_WRITEOK\\n\",\n\t\t\t     si->type);\n\t\t\t__del_from_avail_list(si);\n\t\t\tspin_unlock(&si->lock);\n\t\t\tgoto nextsi;\n\t\t}\n\t\tif (size == SWAPFILE_CLUSTER) {\n\t\t\tif (!(si->flags & SWP_FS))\n\t\t\t\tn_ret = swap_alloc_cluster(si, swp_entries);\n\t\t} else\n\t\t\tn_ret = scan_swap_map_slots(si, SWAP_HAS_CACHE,\n\t\t\t\t\t\t    n_goal, swp_entries);\n\t\tspin_unlock(&si->lock);\n\t\tif (n_ret || size == SWAPFILE_CLUSTER)\n\t\t\tgoto check_out;\n\t\tpr_debug(\"scan_swap_map of si %d failed to find offset\\n\",\n\t\t\tsi->type);\n\n\t\tspin_lock(&swap_avail_lock);\nnextsi:\n\t\t/*\n\t\t * if we got here, it's likely that si was almost full before,\n\t\t * and since scan_swap_map() can drop the si->lock, multiple\n\t\t * callers probably all tried to get a page from the same si\n\t\t * and it filled up before we could get one; or, the si filled\n\t\t * up between us dropping swap_avail_lock and taking si->lock.\n\t\t * Since we dropped the swap_avail_lock, the swap_avail_head\n\t\t * list may have been modified; so if next is still in the\n\t\t * swap_avail_head list then try it, otherwise start over\n\t\t * if we have not gotten any slots.\n\t\t */\n\t\tif (plist_node_empty(&next->avail_lists[node]))\n\t\t\tgoto start_over;\n\t}\n\n\tspin_unlock(&swap_avail_lock);\n\ncheck_out:\n\tif (n_ret < n_goal)\n\t\tatomic_long_add((long)(n_goal - n_ret) * size,\n\t\t\t\t&nr_swap_pages);\nnoswap:\n\treturn n_ret;\n}"
  },
  {
    "function_name": "scan_swap_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "942-955",
    "snippet": "static unsigned long scan_swap_map(struct swap_info_struct *si,\n\t\t\t\t   unsigned char usage)\n{\n\tswp_entry_t entry;\n\tint n_ret;\n\n\tn_ret = scan_swap_map_slots(si, usage, 1, &entry);\n\n\tif (n_ret)\n\t\treturn swp_offset(entry);\n\telse\n\t\treturn 0;\n\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_swap_map_slots",
          "args": [
            "si",
            "usage",
            "1",
            "&entry"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "scan_swap_map_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "697-892",
          "snippet": "static int scan_swap_map_slots(struct swap_info_struct *si,\n\t\t\t       unsigned char usage, int nr,\n\t\t\t       swp_entry_t slots[])\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned long scan_base;\n\tunsigned long last_in_cluster = 0;\n\tint latency_ration = LATENCY_LIMIT;\n\tint n_ret = 0;\n\n\tif (nr > SWAP_BATCH)\n\t\tnr = SWAP_BATCH;\n\n\t/*\n\t * We try to cluster swap pages by allocating them sequentially\n\t * in swap.  Once we've allocated SWAPFILE_CLUSTER pages this\n\t * way, however, we resort to first-free allocation, starting\n\t * a new cluster.  This prevents us from scattering swap pages\n\t * all over the entire swap partition, so that we reduce\n\t * overall disk seek times between swap pages.  -- sct\n\t * But we do now try to find an empty cluster.  -Andrea\n\t * And we let swap pages go all over an SSD partition.  Hugh\n\t */\n\n\tsi->flags += SWP_SCANNING;\n\tscan_base = offset = si->cluster_next;\n\n\t/* SSD algorithm */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto scan;\n\t}\n\n\tif (unlikely(!si->cluster_nr--)) {\n\t\tif (si->pages - si->inuse_pages < SWAPFILE_CLUSTER) {\n\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\tgoto checks;\n\t\t}\n\n\t\tspin_unlock(&si->lock);\n\n\t\t/*\n\t\t * If seek is expensive, start searching for new cluster from\n\t\t * start of partition, to minimize the span of allocated swap.\n\t\t * If seek is cheap, that is the SWP_SOLIDSTATE si->cluster_info\n\t\t * case, just handled by scan_swap_map_try_ssd_cluster() above.\n\t\t */\n\t\tscan_base = offset = si->lowest_bit;\n\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER - 1;\n\n\t\t/* Locate the first empty (unaligned) cluster */\n\t\tfor (; last_in_cluster <= si->highest_bit; offset++) {\n\t\t\tif (si->swap_map[offset])\n\t\t\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER;\n\t\t\telse if (offset == last_in_cluster) {\n\t\t\t\tspin_lock(&si->lock);\n\t\t\t\toffset -= SWAPFILE_CLUSTER - 1;\n\t\t\t\tsi->cluster_next = offset;\n\t\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\t\tgoto checks;\n\t\t\t}\n\t\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\t\tcond_resched();\n\t\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\t}\n\t\t}\n\n\t\toffset = scan_base;\n\t\tspin_lock(&si->lock);\n\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t}\n\nchecks:\n\tif (si->cluster_info) {\n\t\twhile (scan_swap_map_ssd_cluster_conflict(si, offset)) {\n\t\t/* take a break if we already got some slots */\n\t\t\tif (n_ret)\n\t\t\t\tgoto done;\n\t\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset,\n\t\t\t\t\t\t\t&scan_base))\n\t\t\t\tgoto scan;\n\t\t}\n\t}\n\tif (!(si->flags & SWP_WRITEOK))\n\t\tgoto no_page;\n\tif (!si->highest_bit)\n\t\tgoto no_page;\n\tif (offset > si->highest_bit)\n\t\tscan_base = offset = si->lowest_bit;\n\n\tci = lock_cluster(si, offset);\n\t/* reuse swap entry of cache-only swap if not busy. */\n\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\tint swap_was_freed;\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\tswap_was_freed = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n\t\tspin_lock(&si->lock);\n\t\t/* entry was freed successfully, try to use this again */\n\t\tif (swap_was_freed)\n\t\t\tgoto checks;\n\t\tgoto scan; /* check next one */\n\t}\n\n\tif (si->swap_map[offset]) {\n\t\tunlock_cluster(ci);\n\t\tif (!n_ret)\n\t\t\tgoto scan;\n\t\telse\n\t\t\tgoto done;\n\t}\n\tsi->swap_map[offset] = usage;\n\tinc_cluster_info_page(si, si->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tswap_range_alloc(si, offset, 1);\n\tsi->cluster_next = offset + 1;\n\tslots[n_ret++] = swp_entry(si->type, offset);\n\n\t/* got enough slots or reach max slots? */\n\tif ((n_ret == nr) || (offset >= si->highest_bit))\n\t\tgoto done;\n\n\t/* search for next available slot */\n\n\t/* time to take a break? */\n\tif (unlikely(--latency_ration < 0)) {\n\t\tif (n_ret)\n\t\t\tgoto done;\n\t\tspin_unlock(&si->lock);\n\t\tcond_resched();\n\t\tspin_lock(&si->lock);\n\t\tlatency_ration = LATENCY_LIMIT;\n\t}\n\n\t/* try to get more slots in cluster */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto done;\n\t}\n\t/* non-ssd case */\n\t++offset;\n\n\t/* non-ssd case, still more slots in cluster? */\n\tif (si->cluster_nr && !si->swap_map[offset]) {\n\t\t--si->cluster_nr;\n\t\tgoto checks;\n\t}\n\ndone:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n\nscan:\n\tspin_unlock(&si->lock);\n\twhile (++offset <= si->highest_bit) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t}\n\toffset = si->lowest_bit;\n\twhile (offset < scan_base) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t\toffset++;\n\t}\n\tspin_lock(&si->lock);\n\nno_page:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define LATENCY_LIMIT\t\t256",
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR",
            "#define TTRS_ANYWAY\t\t0x1"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define LATENCY_LIMIT\t\t256\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n#define TTRS_ANYWAY\t\t0x1\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int scan_swap_map_slots(struct swap_info_struct *si,\n\t\t\t       unsigned char usage, int nr,\n\t\t\t       swp_entry_t slots[])\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned long scan_base;\n\tunsigned long last_in_cluster = 0;\n\tint latency_ration = LATENCY_LIMIT;\n\tint n_ret = 0;\n\n\tif (nr > SWAP_BATCH)\n\t\tnr = SWAP_BATCH;\n\n\t/*\n\t * We try to cluster swap pages by allocating them sequentially\n\t * in swap.  Once we've allocated SWAPFILE_CLUSTER pages this\n\t * way, however, we resort to first-free allocation, starting\n\t * a new cluster.  This prevents us from scattering swap pages\n\t * all over the entire swap partition, so that we reduce\n\t * overall disk seek times between swap pages.  -- sct\n\t * But we do now try to find an empty cluster.  -Andrea\n\t * And we let swap pages go all over an SSD partition.  Hugh\n\t */\n\n\tsi->flags += SWP_SCANNING;\n\tscan_base = offset = si->cluster_next;\n\n\t/* SSD algorithm */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto scan;\n\t}\n\n\tif (unlikely(!si->cluster_nr--)) {\n\t\tif (si->pages - si->inuse_pages < SWAPFILE_CLUSTER) {\n\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\tgoto checks;\n\t\t}\n\n\t\tspin_unlock(&si->lock);\n\n\t\t/*\n\t\t * If seek is expensive, start searching for new cluster from\n\t\t * start of partition, to minimize the span of allocated swap.\n\t\t * If seek is cheap, that is the SWP_SOLIDSTATE si->cluster_info\n\t\t * case, just handled by scan_swap_map_try_ssd_cluster() above.\n\t\t */\n\t\tscan_base = offset = si->lowest_bit;\n\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER - 1;\n\n\t\t/* Locate the first empty (unaligned) cluster */\n\t\tfor (; last_in_cluster <= si->highest_bit; offset++) {\n\t\t\tif (si->swap_map[offset])\n\t\t\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER;\n\t\t\telse if (offset == last_in_cluster) {\n\t\t\t\tspin_lock(&si->lock);\n\t\t\t\toffset -= SWAPFILE_CLUSTER - 1;\n\t\t\t\tsi->cluster_next = offset;\n\t\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\t\tgoto checks;\n\t\t\t}\n\t\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\t\tcond_resched();\n\t\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\t}\n\t\t}\n\n\t\toffset = scan_base;\n\t\tspin_lock(&si->lock);\n\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t}\n\nchecks:\n\tif (si->cluster_info) {\n\t\twhile (scan_swap_map_ssd_cluster_conflict(si, offset)) {\n\t\t/* take a break if we already got some slots */\n\t\t\tif (n_ret)\n\t\t\t\tgoto done;\n\t\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset,\n\t\t\t\t\t\t\t&scan_base))\n\t\t\t\tgoto scan;\n\t\t}\n\t}\n\tif (!(si->flags & SWP_WRITEOK))\n\t\tgoto no_page;\n\tif (!si->highest_bit)\n\t\tgoto no_page;\n\tif (offset > si->highest_bit)\n\t\tscan_base = offset = si->lowest_bit;\n\n\tci = lock_cluster(si, offset);\n\t/* reuse swap entry of cache-only swap if not busy. */\n\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\tint swap_was_freed;\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\tswap_was_freed = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n\t\tspin_lock(&si->lock);\n\t\t/* entry was freed successfully, try to use this again */\n\t\tif (swap_was_freed)\n\t\t\tgoto checks;\n\t\tgoto scan; /* check next one */\n\t}\n\n\tif (si->swap_map[offset]) {\n\t\tunlock_cluster(ci);\n\t\tif (!n_ret)\n\t\t\tgoto scan;\n\t\telse\n\t\t\tgoto done;\n\t}\n\tsi->swap_map[offset] = usage;\n\tinc_cluster_info_page(si, si->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tswap_range_alloc(si, offset, 1);\n\tsi->cluster_next = offset + 1;\n\tslots[n_ret++] = swp_entry(si->type, offset);\n\n\t/* got enough slots or reach max slots? */\n\tif ((n_ret == nr) || (offset >= si->highest_bit))\n\t\tgoto done;\n\n\t/* search for next available slot */\n\n\t/* time to take a break? */\n\tif (unlikely(--latency_ration < 0)) {\n\t\tif (n_ret)\n\t\t\tgoto done;\n\t\tspin_unlock(&si->lock);\n\t\tcond_resched();\n\t\tspin_lock(&si->lock);\n\t\tlatency_ration = LATENCY_LIMIT;\n\t}\n\n\t/* try to get more slots in cluster */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto done;\n\t}\n\t/* non-ssd case */\n\t++offset;\n\n\t/* non-ssd case, still more slots in cluster? */\n\tif (si->cluster_nr && !si->swap_map[offset]) {\n\t\t--si->cluster_nr;\n\t\tgoto checks;\n\t}\n\ndone:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n\nscan:\n\tspin_unlock(&si->lock);\n\twhile (++offset <= si->highest_bit) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t}\n\toffset = si->lowest_bit;\n\twhile (offset < scan_base) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t\toffset++;\n\t}\n\tspin_lock(&si->lock);\n\nno_page:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic unsigned long scan_swap_map(struct swap_info_struct *si,\n\t\t\t\t   unsigned char usage)\n{\n\tswp_entry_t entry;\n\tint n_ret;\n\n\tn_ret = scan_swap_map_slots(si, usage, 1, &entry);\n\n\tif (n_ret)\n\t\treturn swp_offset(entry);\n\telse\n\t\treturn 0;\n\n}"
  },
  {
    "function_name": "swap_free_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "929-940",
    "snippet": "static void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_range_free",
          "args": [
            "si",
            "offset",
            "SWAPFILE_CLUSTER"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "swap_range_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "667-695",
          "snippet": "static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n\t\t\t    unsigned int nr_entries)\n{\n\tunsigned long end = offset + nr_entries - 1;\n\tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n\n\tif (offset < si->lowest_bit)\n\t\tsi->lowest_bit = offset;\n\tif (end > si->highest_bit) {\n\t\tbool was_full = !si->highest_bit;\n\n\t\tsi->highest_bit = end;\n\t\tif (was_full && (si->flags & SWP_WRITEOK))\n\t\t\tadd_to_avail_list(si);\n\t}\n\tatomic_long_add(nr_entries, &nr_swap_pages);\n\tsi->inuse_pages -= nr_entries;\n\tif (si->flags & SWP_BLKDEV)\n\t\tswap_slot_free_notify =\n\t\t\tsi->bdev->bd_disk->fops->swap_slot_free_notify;\n\telse\n\t\tswap_slot_free_notify = NULL;\n\twhile (offset <= end) {\n\t\tfrontswap_invalidate_page(si->type, offset);\n\t\tif (swap_slot_free_notify)\n\t\t\tswap_slot_free_notify(si->bdev, offset);\n\t\toffset++;\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
            "atomic_long_t nr_swap_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\natomic_long_t nr_swap_pages;\n\nstatic void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n\t\t\t    unsigned int nr_entries)\n{\n\tunsigned long end = offset + nr_entries - 1;\n\tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n\n\tif (offset < si->lowest_bit)\n\t\tsi->lowest_bit = offset;\n\tif (end > si->highest_bit) {\n\t\tbool was_full = !si->highest_bit;\n\n\t\tsi->highest_bit = end;\n\t\tif (was_full && (si->flags & SWP_WRITEOK))\n\t\t\tadd_to_avail_list(si);\n\t}\n\tatomic_long_add(nr_entries, &nr_swap_pages);\n\tsi->inuse_pages -= nr_entries;\n\tif (si->flags & SWP_BLKDEV)\n\t\tswap_slot_free_notify =\n\t\t\tsi->bdev->bd_disk->fops->swap_slot_free_notify;\n\telse\n\t\tswap_slot_free_notify = NULL;\n\twhile (offset <= end) {\n\t\tfrontswap_invalidate_page(si->type, offset);\n\t\tif (swap_slot_free_notify)\n\t\t\tswap_slot_free_notify(si->bdev, offset);\n\t\toffset++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cluster",
          "args": [
            "si",
            "idx"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "swap_free_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "929-940",
          "snippet": "static void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cluster_set_count_flag",
          "args": [
            "ci",
            "0",
            "0"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_count_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "250-255",
          "snippet": "static inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "si->swap_map + offset",
            "0",
            "SWAPFILE_CLUSTER"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "offset"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}"
  },
  {
    "function_name": "swap_alloc_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "894-927",
    "snippet": "static int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "si->type",
            "offset"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_range_alloc",
          "args": [
            "si",
            "offset",
            "SWAPFILE_CLUSTER"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "swap_range_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "638-653",
          "snippet": "static void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,\n\t\t\t     unsigned int nr_entries)\n{\n\tunsigned int end = offset + nr_entries - 1;\n\n\tif (offset == si->lowest_bit)\n\t\tsi->lowest_bit += nr_entries;\n\tif (end == si->highest_bit)\n\t\tsi->highest_bit -= nr_entries;\n\tsi->inuse_pages += nr_entries;\n\tif (si->inuse_pages == si->pages) {\n\t\tsi->lowest_bit = si->max;\n\t\tsi->highest_bit = 0;\n\t\tdel_from_avail_list(si);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,\n\t\t\t     unsigned int nr_entries)\n{\n\tunsigned int end = offset + nr_entries - 1;\n\n\tif (offset == si->lowest_bit)\n\t\tsi->lowest_bit += nr_entries;\n\tif (end == si->highest_bit)\n\t\tsi->highest_bit -= nr_entries;\n\tsi->inuse_pages += nr_entries;\n\tif (si->inuse_pages == si->pages) {\n\t\tsi->lowest_bit = si->max;\n\t\tsi->highest_bit = 0;\n\t\tdel_from_avail_list(si);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_set_count_flag",
          "args": [
            "ci",
            "SWAPFILE_CLUSTER",
            "CLUSTER_FLAG_HUGE"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_count_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "250-255",
          "snippet": "static inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cluster",
          "args": [
            "si",
            "idx"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "swap_alloc_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "894-927",
          "snippet": "static int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "offset"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_first",
          "args": [
            "&si->free_clusters"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "354-357",
          "snippet": "static inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_empty",
          "args": [
            "&si->free_clusters"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_THP_SWAP"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "scan_swap_map_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "697-892",
    "snippet": "static int scan_swap_map_slots(struct swap_info_struct *si,\n\t\t\t       unsigned char usage, int nr,\n\t\t\t       swp_entry_t slots[])\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned long scan_base;\n\tunsigned long last_in_cluster = 0;\n\tint latency_ration = LATENCY_LIMIT;\n\tint n_ret = 0;\n\n\tif (nr > SWAP_BATCH)\n\t\tnr = SWAP_BATCH;\n\n\t/*\n\t * We try to cluster swap pages by allocating them sequentially\n\t * in swap.  Once we've allocated SWAPFILE_CLUSTER pages this\n\t * way, however, we resort to first-free allocation, starting\n\t * a new cluster.  This prevents us from scattering swap pages\n\t * all over the entire swap partition, so that we reduce\n\t * overall disk seek times between swap pages.  -- sct\n\t * But we do now try to find an empty cluster.  -Andrea\n\t * And we let swap pages go all over an SSD partition.  Hugh\n\t */\n\n\tsi->flags += SWP_SCANNING;\n\tscan_base = offset = si->cluster_next;\n\n\t/* SSD algorithm */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto scan;\n\t}\n\n\tif (unlikely(!si->cluster_nr--)) {\n\t\tif (si->pages - si->inuse_pages < SWAPFILE_CLUSTER) {\n\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\tgoto checks;\n\t\t}\n\n\t\tspin_unlock(&si->lock);\n\n\t\t/*\n\t\t * If seek is expensive, start searching for new cluster from\n\t\t * start of partition, to minimize the span of allocated swap.\n\t\t * If seek is cheap, that is the SWP_SOLIDSTATE si->cluster_info\n\t\t * case, just handled by scan_swap_map_try_ssd_cluster() above.\n\t\t */\n\t\tscan_base = offset = si->lowest_bit;\n\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER - 1;\n\n\t\t/* Locate the first empty (unaligned) cluster */\n\t\tfor (; last_in_cluster <= si->highest_bit; offset++) {\n\t\t\tif (si->swap_map[offset])\n\t\t\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER;\n\t\t\telse if (offset == last_in_cluster) {\n\t\t\t\tspin_lock(&si->lock);\n\t\t\t\toffset -= SWAPFILE_CLUSTER - 1;\n\t\t\t\tsi->cluster_next = offset;\n\t\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\t\tgoto checks;\n\t\t\t}\n\t\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\t\tcond_resched();\n\t\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\t}\n\t\t}\n\n\t\toffset = scan_base;\n\t\tspin_lock(&si->lock);\n\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t}\n\nchecks:\n\tif (si->cluster_info) {\n\t\twhile (scan_swap_map_ssd_cluster_conflict(si, offset)) {\n\t\t/* take a break if we already got some slots */\n\t\t\tif (n_ret)\n\t\t\t\tgoto done;\n\t\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset,\n\t\t\t\t\t\t\t&scan_base))\n\t\t\t\tgoto scan;\n\t\t}\n\t}\n\tif (!(si->flags & SWP_WRITEOK))\n\t\tgoto no_page;\n\tif (!si->highest_bit)\n\t\tgoto no_page;\n\tif (offset > si->highest_bit)\n\t\tscan_base = offset = si->lowest_bit;\n\n\tci = lock_cluster(si, offset);\n\t/* reuse swap entry of cache-only swap if not busy. */\n\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\tint swap_was_freed;\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\tswap_was_freed = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n\t\tspin_lock(&si->lock);\n\t\t/* entry was freed successfully, try to use this again */\n\t\tif (swap_was_freed)\n\t\t\tgoto checks;\n\t\tgoto scan; /* check next one */\n\t}\n\n\tif (si->swap_map[offset]) {\n\t\tunlock_cluster(ci);\n\t\tif (!n_ret)\n\t\t\tgoto scan;\n\t\telse\n\t\t\tgoto done;\n\t}\n\tsi->swap_map[offset] = usage;\n\tinc_cluster_info_page(si, si->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tswap_range_alloc(si, offset, 1);\n\tsi->cluster_next = offset + 1;\n\tslots[n_ret++] = swp_entry(si->type, offset);\n\n\t/* got enough slots or reach max slots? */\n\tif ((n_ret == nr) || (offset >= si->highest_bit))\n\t\tgoto done;\n\n\t/* search for next available slot */\n\n\t/* time to take a break? */\n\tif (unlikely(--latency_ration < 0)) {\n\t\tif (n_ret)\n\t\t\tgoto done;\n\t\tspin_unlock(&si->lock);\n\t\tcond_resched();\n\t\tspin_lock(&si->lock);\n\t\tlatency_ration = LATENCY_LIMIT;\n\t}\n\n\t/* try to get more slots in cluster */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto done;\n\t}\n\t/* non-ssd case */\n\t++offset;\n\n\t/* non-ssd case, still more slots in cluster? */\n\tif (si->cluster_nr && !si->swap_map[offset]) {\n\t\t--si->cluster_nr;\n\t\tgoto checks;\n\t}\n\ndone:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n\nscan:\n\tspin_unlock(&si->lock);\n\twhile (++offset <= si->highest_bit) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t}\n\toffset = si->lowest_bit;\n\twhile (offset < scan_base) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t\toffset++;\n\t}\n\tspin_lock(&si->lock);\n\nno_page:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define LATENCY_LIMIT\t\t256",
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR",
      "#define TTRS_ANYWAY\t\t0x1"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "--latency_ration < 0"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_swap_full",
          "args": [],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "--latency_ration < 0"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_swap_full",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_swap_map_try_ssd_cluster",
          "args": [
            "si",
            "&offset",
            "&scan_base"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "scan_swap_map_try_ssd_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "564-621",
          "snippet": "static bool scan_swap_map_try_ssd_cluster(struct swap_info_struct *si,\n\tunsigned long *offset, unsigned long *scan_base)\n{\n\tstruct percpu_cluster *cluster;\n\tstruct swap_cluster_info *ci;\n\tbool found_free;\n\tunsigned long tmp, max;\n\nnew_cluster:\n\tcluster = this_cpu_ptr(si->percpu_cluster);\n\tif (cluster_is_null(&cluster->index)) {\n\t\tif (!cluster_list_empty(&si->free_clusters)) {\n\t\t\tcluster->index = si->free_clusters.head;\n\t\t\tcluster->next = cluster_next(&cluster->index) *\n\t\t\t\t\tSWAPFILE_CLUSTER;\n\t\t} else if (!cluster_list_empty(&si->discard_clusters)) {\n\t\t\t/*\n\t\t\t * we don't have free cluster but have some clusters in\n\t\t\t * discarding, do discard now and reclaim them\n\t\t\t */\n\t\t\tswap_do_scheduled_discard(si);\n\t\t\t*scan_base = *offset = si->cluster_next;\n\t\t\tgoto new_cluster;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tfound_free = false;\n\n\t/*\n\t * Other CPUs can use our cluster if they can't find a free cluster,\n\t * check if there is still free entry in the cluster\n\t */\n\ttmp = cluster->next;\n\tmax = min_t(unsigned long, si->max,\n\t\t    (cluster_next(&cluster->index) + 1) * SWAPFILE_CLUSTER);\n\tif (tmp >= max) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tci = lock_cluster(si, tmp);\n\twhile (tmp < max) {\n\t\tif (!si->swap_map[tmp]) {\n\t\t\tfound_free = true;\n\t\t\tbreak;\n\t\t}\n\t\ttmp++;\n\t}\n\tunlock_cluster(ci);\n\tif (!found_free) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tcluster->next = tmp + 1;\n\t*offset = tmp;\n\t*scan_base = tmp;\n\treturn found_free;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool scan_swap_map_try_ssd_cluster(struct swap_info_struct *si,\n\tunsigned long *offset, unsigned long *scan_base)\n{\n\tstruct percpu_cluster *cluster;\n\tstruct swap_cluster_info *ci;\n\tbool found_free;\n\tunsigned long tmp, max;\n\nnew_cluster:\n\tcluster = this_cpu_ptr(si->percpu_cluster);\n\tif (cluster_is_null(&cluster->index)) {\n\t\tif (!cluster_list_empty(&si->free_clusters)) {\n\t\t\tcluster->index = si->free_clusters.head;\n\t\t\tcluster->next = cluster_next(&cluster->index) *\n\t\t\t\t\tSWAPFILE_CLUSTER;\n\t\t} else if (!cluster_list_empty(&si->discard_clusters)) {\n\t\t\t/*\n\t\t\t * we don't have free cluster but have some clusters in\n\t\t\t * discarding, do discard now and reclaim them\n\t\t\t */\n\t\t\tswap_do_scheduled_discard(si);\n\t\t\t*scan_base = *offset = si->cluster_next;\n\t\t\tgoto new_cluster;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tfound_free = false;\n\n\t/*\n\t * Other CPUs can use our cluster if they can't find a free cluster,\n\t * check if there is still free entry in the cluster\n\t */\n\ttmp = cluster->next;\n\tmax = min_t(unsigned long, si->max,\n\t\t    (cluster_next(&cluster->index) + 1) * SWAPFILE_CLUSTER);\n\tif (tmp >= max) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tci = lock_cluster(si, tmp);\n\twhile (tmp < max) {\n\t\tif (!si->swap_map[tmp]) {\n\t\t\tfound_free = true;\n\t\t\tbreak;\n\t\t}\n\t\ttmp++;\n\t}\n\tunlock_cluster(ci);\n\tif (!found_free) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tcluster->next = tmp + 1;\n\t*offset = tmp;\n\t*scan_base = tmp;\n\treturn found_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "--latency_ration < 0"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "si->type",
            "offset"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_range_alloc",
          "args": [
            "si",
            "offset",
            "1"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "swap_range_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "638-653",
          "snippet": "static void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,\n\t\t\t     unsigned int nr_entries)\n{\n\tunsigned int end = offset + nr_entries - 1;\n\n\tif (offset == si->lowest_bit)\n\t\tsi->lowest_bit += nr_entries;\n\tif (end == si->highest_bit)\n\t\tsi->highest_bit -= nr_entries;\n\tsi->inuse_pages += nr_entries;\n\tif (si->inuse_pages == si->pages) {\n\t\tsi->lowest_bit = si->max;\n\t\tsi->highest_bit = 0;\n\t\tdel_from_avail_list(si);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,\n\t\t\t     unsigned int nr_entries)\n{\n\tunsigned int end = offset + nr_entries - 1;\n\n\tif (offset == si->lowest_bit)\n\t\tsi->lowest_bit += nr_entries;\n\tif (end == si->highest_bit)\n\t\tsi->highest_bit -= nr_entries;\n\tsi->inuse_pages += nr_entries;\n\tif (si->inuse_pages == si->pages) {\n\t\tsi->lowest_bit = si->max;\n\t\tsi->highest_bit = 0;\n\t\tdel_from_avail_list(si);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_cluster_info_page",
          "args": [
            "si",
            "si->cluster_info",
            "offset"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "inc_cluster_info_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "500-513",
          "snippet": "static void inc_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\tif (cluster_is_free(&cluster_info[idx]))\n\t\talloc_cluster(p, idx);\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) + 1);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void inc_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\tif (cluster_is_free(&cluster_info[idx]))\n\t\talloc_cluster(p, idx);\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__try_to_reclaim_swap",
          "args": [
            "si",
            "offset",
            "TTRS_ANYWAY"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "__try_to_reclaim_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "117-143",
          "snippet": "static int __try_to_reclaim_swap(struct swap_info_struct *si,\n\t\t\t\t unsigned long offset, unsigned long flags)\n{\n\tswp_entry_t entry = swp_entry(si->type, offset);\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = find_get_page(swap_address_space(entry), offset);\n\tif (!page)\n\t\treturn 0;\n\t/*\n\t * When this function is called from scan_swap_map_slots() and it's\n\t * called by vmscan.c at reclaiming pages. So, we hold a lock on a page,\n\t * here. We have to use trylock for avoiding deadlock. This is a special\n\t * case and you should use try_to_free_swap() with explicit lock_page()\n\t * in usual operations.\n\t */\n\tif (trylock_page(page)) {\n\t\tif ((flags & TTRS_ANYWAY) ||\n\t\t    ((flags & TTRS_UNMAPPED) && !page_mapped(page)) ||\n\t\t    ((flags & TTRS_FULL) && mem_cgroup_swap_full(page)))\n\t\t\tret = try_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TTRS_FULL\t\t0x4",
            "#define TTRS_UNMAPPED\t\t0x2",
            "#define TTRS_ANYWAY\t\t0x1"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define TTRS_FULL\t\t0x4\n#define TTRS_UNMAPPED\t\t0x2\n#define TTRS_ANYWAY\t\t0x1\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int __try_to_reclaim_swap(struct swap_info_struct *si,\n\t\t\t\t unsigned long offset, unsigned long flags)\n{\n\tswp_entry_t entry = swp_entry(si->type, offset);\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = find_get_page(swap_address_space(entry), offset);\n\tif (!page)\n\t\treturn 0;\n\t/*\n\t * When this function is called from scan_swap_map_slots() and it's\n\t * called by vmscan.c at reclaiming pages. So, we hold a lock on a page,\n\t * here. We have to use trylock for avoiding deadlock. This is a special\n\t * case and you should use try_to_free_swap() with explicit lock_page()\n\t * in usual operations.\n\t */\n\tif (trylock_page(page)) {\n\t\tif ((flags & TTRS_ANYWAY) ||\n\t\t    ((flags & TTRS_UNMAPPED) && !page_mapped(page)) ||\n\t\t    ((flags & TTRS_FULL) && mem_cgroup_swap_full(page)))\n\t\t\tret = try_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_swap_full",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "offset"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_swap_map_ssd_cluster_conflict",
          "args": [
            "si",
            "offset"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "scan_swap_map_ssd_cluster_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "540-558",
          "snippet": "static bool\nscan_swap_map_ssd_cluster_conflict(struct swap_info_struct *si,\n\tunsigned long offset)\n{\n\tstruct percpu_cluster *percpu_cluster;\n\tbool conflict;\n\n\toffset /= SWAPFILE_CLUSTER;\n\tconflict = !cluster_list_empty(&si->free_clusters) &&\n\t\toffset != cluster_list_first(&si->free_clusters) &&\n\t\tcluster_is_free(&si->cluster_info[offset]);\n\n\tif (!conflict)\n\t\treturn false;\n\n\tpercpu_cluster = this_cpu_ptr(si->percpu_cluster);\n\tcluster_set_null(&percpu_cluster->index);\n\treturn true;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool\nscan_swap_map_ssd_cluster_conflict(struct swap_info_struct *si,\n\tunsigned long offset)\n{\n\tstruct percpu_cluster *percpu_cluster;\n\tbool conflict;\n\n\toffset /= SWAPFILE_CLUSTER;\n\tconflict = !cluster_list_empty(&si->free_clusters) &&\n\t\toffset != cluster_list_first(&si->free_clusters) &&\n\t\tcluster_is_free(&si->cluster_info[offset]);\n\n\tif (!conflict)\n\t\treturn false;\n\n\tpercpu_cluster = this_cpu_ptr(si->percpu_cluster);\n\tcluster_set_null(&percpu_cluster->index);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "--latency_ration < 0"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!si->cluster_nr--"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define LATENCY_LIMIT\t\t256\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n#define TTRS_ANYWAY\t\t0x1\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int scan_swap_map_slots(struct swap_info_struct *si,\n\t\t\t       unsigned char usage, int nr,\n\t\t\t       swp_entry_t slots[])\n{\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset;\n\tunsigned long scan_base;\n\tunsigned long last_in_cluster = 0;\n\tint latency_ration = LATENCY_LIMIT;\n\tint n_ret = 0;\n\n\tif (nr > SWAP_BATCH)\n\t\tnr = SWAP_BATCH;\n\n\t/*\n\t * We try to cluster swap pages by allocating them sequentially\n\t * in swap.  Once we've allocated SWAPFILE_CLUSTER pages this\n\t * way, however, we resort to first-free allocation, starting\n\t * a new cluster.  This prevents us from scattering swap pages\n\t * all over the entire swap partition, so that we reduce\n\t * overall disk seek times between swap pages.  -- sct\n\t * But we do now try to find an empty cluster.  -Andrea\n\t * And we let swap pages go all over an SSD partition.  Hugh\n\t */\n\n\tsi->flags += SWP_SCANNING;\n\tscan_base = offset = si->cluster_next;\n\n\t/* SSD algorithm */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto scan;\n\t}\n\n\tif (unlikely(!si->cluster_nr--)) {\n\t\tif (si->pages - si->inuse_pages < SWAPFILE_CLUSTER) {\n\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\tgoto checks;\n\t\t}\n\n\t\tspin_unlock(&si->lock);\n\n\t\t/*\n\t\t * If seek is expensive, start searching for new cluster from\n\t\t * start of partition, to minimize the span of allocated swap.\n\t\t * If seek is cheap, that is the SWP_SOLIDSTATE si->cluster_info\n\t\t * case, just handled by scan_swap_map_try_ssd_cluster() above.\n\t\t */\n\t\tscan_base = offset = si->lowest_bit;\n\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER - 1;\n\n\t\t/* Locate the first empty (unaligned) cluster */\n\t\tfor (; last_in_cluster <= si->highest_bit; offset++) {\n\t\t\tif (si->swap_map[offset])\n\t\t\t\tlast_in_cluster = offset + SWAPFILE_CLUSTER;\n\t\t\telse if (offset == last_in_cluster) {\n\t\t\t\tspin_lock(&si->lock);\n\t\t\t\toffset -= SWAPFILE_CLUSTER - 1;\n\t\t\t\tsi->cluster_next = offset;\n\t\t\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t\t\t\tgoto checks;\n\t\t\t}\n\t\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\t\tcond_resched();\n\t\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t\t}\n\t\t}\n\n\t\toffset = scan_base;\n\t\tspin_lock(&si->lock);\n\t\tsi->cluster_nr = SWAPFILE_CLUSTER - 1;\n\t}\n\nchecks:\n\tif (si->cluster_info) {\n\t\twhile (scan_swap_map_ssd_cluster_conflict(si, offset)) {\n\t\t/* take a break if we already got some slots */\n\t\t\tif (n_ret)\n\t\t\t\tgoto done;\n\t\t\tif (!scan_swap_map_try_ssd_cluster(si, &offset,\n\t\t\t\t\t\t\t&scan_base))\n\t\t\t\tgoto scan;\n\t\t}\n\t}\n\tif (!(si->flags & SWP_WRITEOK))\n\t\tgoto no_page;\n\tif (!si->highest_bit)\n\t\tgoto no_page;\n\tif (offset > si->highest_bit)\n\t\tscan_base = offset = si->lowest_bit;\n\n\tci = lock_cluster(si, offset);\n\t/* reuse swap entry of cache-only swap if not busy. */\n\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\tint swap_was_freed;\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\tswap_was_freed = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n\t\tspin_lock(&si->lock);\n\t\t/* entry was freed successfully, try to use this again */\n\t\tif (swap_was_freed)\n\t\t\tgoto checks;\n\t\tgoto scan; /* check next one */\n\t}\n\n\tif (si->swap_map[offset]) {\n\t\tunlock_cluster(ci);\n\t\tif (!n_ret)\n\t\t\tgoto scan;\n\t\telse\n\t\t\tgoto done;\n\t}\n\tsi->swap_map[offset] = usage;\n\tinc_cluster_info_page(si, si->cluster_info, offset);\n\tunlock_cluster(ci);\n\n\tswap_range_alloc(si, offset, 1);\n\tsi->cluster_next = offset + 1;\n\tslots[n_ret++] = swp_entry(si->type, offset);\n\n\t/* got enough slots or reach max slots? */\n\tif ((n_ret == nr) || (offset >= si->highest_bit))\n\t\tgoto done;\n\n\t/* search for next available slot */\n\n\t/* time to take a break? */\n\tif (unlikely(--latency_ration < 0)) {\n\t\tif (n_ret)\n\t\t\tgoto done;\n\t\tspin_unlock(&si->lock);\n\t\tcond_resched();\n\t\tspin_lock(&si->lock);\n\t\tlatency_ration = LATENCY_LIMIT;\n\t}\n\n\t/* try to get more slots in cluster */\n\tif (si->cluster_info) {\n\t\tif (scan_swap_map_try_ssd_cluster(si, &offset, &scan_base))\n\t\t\tgoto checks;\n\t\telse\n\t\t\tgoto done;\n\t}\n\t/* non-ssd case */\n\t++offset;\n\n\t/* non-ssd case, still more slots in cluster? */\n\tif (si->cluster_nr && !si->swap_map[offset]) {\n\t\t--si->cluster_nr;\n\t\tgoto checks;\n\t}\n\ndone:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n\nscan:\n\tspin_unlock(&si->lock);\n\twhile (++offset <= si->highest_bit) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t}\n\toffset = si->lowest_bit;\n\twhile (offset < scan_base) {\n\t\tif (!si->swap_map[offset]) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {\n\t\t\tspin_lock(&si->lock);\n\t\t\tgoto checks;\n\t\t}\n\t\tif (unlikely(--latency_ration < 0)) {\n\t\t\tcond_resched();\n\t\t\tlatency_ration = LATENCY_LIMIT;\n\t\t}\n\t\toffset++;\n\t}\n\tspin_lock(&si->lock);\n\nno_page:\n\tsi->flags -= SWP_SCANNING;\n\treturn n_ret;\n}"
  },
  {
    "function_name": "swap_range_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "667-695",
    "snippet": "static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n\t\t\t    unsigned int nr_entries)\n{\n\tunsigned long end = offset + nr_entries - 1;\n\tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n\n\tif (offset < si->lowest_bit)\n\t\tsi->lowest_bit = offset;\n\tif (end > si->highest_bit) {\n\t\tbool was_full = !si->highest_bit;\n\n\t\tsi->highest_bit = end;\n\t\tif (was_full && (si->flags & SWP_WRITEOK))\n\t\t\tadd_to_avail_list(si);\n\t}\n\tatomic_long_add(nr_entries, &nr_swap_pages);\n\tsi->inuse_pages -= nr_entries;\n\tif (si->flags & SWP_BLKDEV)\n\t\tswap_slot_free_notify =\n\t\t\tsi->bdev->bd_disk->fops->swap_slot_free_notify;\n\telse\n\t\tswap_slot_free_notify = NULL;\n\twhile (offset <= end) {\n\t\tfrontswap_invalidate_page(si->type, offset);\n\t\tif (swap_slot_free_notify)\n\t\t\tswap_slot_free_notify(si->bdev, offset);\n\t\toffset++;\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
      "atomic_long_t nr_swap_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_slot_free_notify",
          "args": [
            "si->bdev",
            "offset"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frontswap_invalidate_page",
          "args": [
            "si->type",
            "offset"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_invalidate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "332-347",
          "snippet": "void __frontswap_invalidate_page(unsigned type, pgoff_t offset)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn;\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->invalidate_page(type, offset);\n\t__frontswap_clear(sis, offset);\n\tinc_frontswap_invalidates();\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct frontswap_ops *frontswap_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\n\nvoid __frontswap_invalidate_page(unsigned type, pgoff_t offset)\n{\n\tstruct swap_info_struct *sis = swap_info[type];\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn;\n\n\tfor_each_frontswap_ops(ops)\n\t\tops->invalidate_page(type, offset);\n\t__frontswap_clear(sis, offset);\n\tinc_frontswap_invalidates();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "nr_entries",
            "&nr_swap_pages"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_avail_list",
          "args": [
            "si"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_avail_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "655-665",
          "snippet": "static void add_to_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tspin_lock(&swap_avail_lock);\n\tfor_each_node(nid) {\n\t\tWARN_ON(!plist_node_empty(&p->avail_lists[nid]));\n\t\tplist_add(&p->avail_lists[nid], &swap_avail_heads[nid]);\n\t}\n\tspin_unlock(&swap_avail_lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static struct plist_head *swap_avail_heads;",
            "static DEFINE_SPINLOCK(swap_avail_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nstatic void add_to_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tspin_lock(&swap_avail_lock);\n\tfor_each_node(nid) {\n\t\tWARN_ON(!plist_node_empty(&p->avail_lists[nid]));\n\t\tplist_add(&p->avail_lists[nid], &swap_avail_heads[nid]);\n\t}\n\tspin_unlock(&swap_avail_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\natomic_long_t nr_swap_pages;\n\nstatic void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n\t\t\t    unsigned int nr_entries)\n{\n\tunsigned long end = offset + nr_entries - 1;\n\tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n\n\tif (offset < si->lowest_bit)\n\t\tsi->lowest_bit = offset;\n\tif (end > si->highest_bit) {\n\t\tbool was_full = !si->highest_bit;\n\n\t\tsi->highest_bit = end;\n\t\tif (was_full && (si->flags & SWP_WRITEOK))\n\t\t\tadd_to_avail_list(si);\n\t}\n\tatomic_long_add(nr_entries, &nr_swap_pages);\n\tsi->inuse_pages -= nr_entries;\n\tif (si->flags & SWP_BLKDEV)\n\t\tswap_slot_free_notify =\n\t\t\tsi->bdev->bd_disk->fops->swap_slot_free_notify;\n\telse\n\t\tswap_slot_free_notify = NULL;\n\twhile (offset <= end) {\n\t\tfrontswap_invalidate_page(si->type, offset);\n\t\tif (swap_slot_free_notify)\n\t\t\tswap_slot_free_notify(si->bdev, offset);\n\t\toffset++;\n\t}\n}"
  },
  {
    "function_name": "add_to_avail_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "655-665",
    "snippet": "static void add_to_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tspin_lock(&swap_avail_lock);\n\tfor_each_node(nid) {\n\t\tWARN_ON(!plist_node_empty(&p->avail_lists[nid]));\n\t\tplist_add(&p->avail_lists[nid], &swap_avail_heads[nid]);\n\t}\n\tspin_unlock(&swap_avail_lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static struct plist_head *swap_avail_heads;",
      "static DEFINE_SPINLOCK(swap_avail_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_add",
          "args": [
            "&p->avail_lists[nid]",
            "&swap_avail_heads[nid]"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!plist_node_empty(&p->avail_lists[nid])"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_empty",
          "args": [
            "&p->avail_lists[nid]"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nstatic void add_to_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tspin_lock(&swap_avail_lock);\n\tfor_each_node(nid) {\n\t\tWARN_ON(!plist_node_empty(&p->avail_lists[nid]));\n\t\tplist_add(&p->avail_lists[nid], &swap_avail_heads[nid]);\n\t}\n\tspin_unlock(&swap_avail_lock);\n}"
  },
  {
    "function_name": "swap_range_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "638-653",
    "snippet": "static void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,\n\t\t\t     unsigned int nr_entries)\n{\n\tunsigned int end = offset + nr_entries - 1;\n\n\tif (offset == si->lowest_bit)\n\t\tsi->lowest_bit += nr_entries;\n\tif (end == si->highest_bit)\n\t\tsi->highest_bit -= nr_entries;\n\tsi->inuse_pages += nr_entries;\n\tif (si->inuse_pages == si->pages) {\n\t\tsi->lowest_bit = si->max;\n\t\tsi->highest_bit = 0;\n\t\tdel_from_avail_list(si);\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_from_avail_list",
          "args": [
            "si"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "del_from_avail_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "631-636",
          "snippet": "static void del_from_avail_list(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_avail_lock);\n\t__del_from_avail_list(p);\n\tspin_unlock(&swap_avail_lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static DEFINE_SPINLOCK(swap_avail_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nstatic void del_from_avail_list(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_avail_lock);\n\t__del_from_avail_list(p);\n\tspin_unlock(&swap_avail_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_range_alloc(struct swap_info_struct *si, unsigned long offset,\n\t\t\t     unsigned int nr_entries)\n{\n\tunsigned int end = offset + nr_entries - 1;\n\n\tif (offset == si->lowest_bit)\n\t\tsi->lowest_bit += nr_entries;\n\tif (end == si->highest_bit)\n\t\tsi->highest_bit -= nr_entries;\n\tsi->inuse_pages += nr_entries;\n\tif (si->inuse_pages == si->pages) {\n\t\tsi->lowest_bit = si->max;\n\t\tsi->highest_bit = 0;\n\t\tdel_from_avail_list(si);\n\t}\n}"
  },
  {
    "function_name": "del_from_avail_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "631-636",
    "snippet": "static void del_from_avail_list(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_avail_lock);\n\t__del_from_avail_list(p);\n\tspin_unlock(&swap_avail_lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static DEFINE_SPINLOCK(swap_avail_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__del_from_avail_list",
          "args": [
            "p"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_avail_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "623-629",
          "snippet": "static void __del_from_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tfor_each_node(nid)\n\t\tplist_del(&p->avail_lists[nid], &swap_avail_heads[nid]);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static struct plist_head *swap_avail_heads;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\n\nstatic void __del_from_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tfor_each_node(nid)\n\t\tplist_del(&p->avail_lists[nid], &swap_avail_heads[nid]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&swap_avail_lock"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic DEFINE_SPINLOCK(swap_avail_lock);\n\nstatic void del_from_avail_list(struct swap_info_struct *p)\n{\n\tspin_lock(&swap_avail_lock);\n\t__del_from_avail_list(p);\n\tspin_unlock(&swap_avail_lock);\n}"
  },
  {
    "function_name": "__del_from_avail_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "623-629",
    "snippet": "static void __del_from_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tfor_each_node(nid)\n\t\tplist_del(&p->avail_lists[nid], &swap_avail_heads[nid]);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static struct plist_head *swap_avail_heads;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\n\nstatic void __del_from_avail_list(struct swap_info_struct *p)\n{\n\tint nid;\n\n\tfor_each_node(nid)\n\t\tplist_del(&p->avail_lists[nid], &swap_avail_heads[nid]);\n}"
  },
  {
    "function_name": "scan_swap_map_try_ssd_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "564-621",
    "snippet": "static bool scan_swap_map_try_ssd_cluster(struct swap_info_struct *si,\n\tunsigned long *offset, unsigned long *scan_base)\n{\n\tstruct percpu_cluster *cluster;\n\tstruct swap_cluster_info *ci;\n\tbool found_free;\n\tunsigned long tmp, max;\n\nnew_cluster:\n\tcluster = this_cpu_ptr(si->percpu_cluster);\n\tif (cluster_is_null(&cluster->index)) {\n\t\tif (!cluster_list_empty(&si->free_clusters)) {\n\t\t\tcluster->index = si->free_clusters.head;\n\t\t\tcluster->next = cluster_next(&cluster->index) *\n\t\t\t\t\tSWAPFILE_CLUSTER;\n\t\t} else if (!cluster_list_empty(&si->discard_clusters)) {\n\t\t\t/*\n\t\t\t * we don't have free cluster but have some clusters in\n\t\t\t * discarding, do discard now and reclaim them\n\t\t\t */\n\t\t\tswap_do_scheduled_discard(si);\n\t\t\t*scan_base = *offset = si->cluster_next;\n\t\t\tgoto new_cluster;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tfound_free = false;\n\n\t/*\n\t * Other CPUs can use our cluster if they can't find a free cluster,\n\t * check if there is still free entry in the cluster\n\t */\n\ttmp = cluster->next;\n\tmax = min_t(unsigned long, si->max,\n\t\t    (cluster_next(&cluster->index) + 1) * SWAPFILE_CLUSTER);\n\tif (tmp >= max) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tci = lock_cluster(si, tmp);\n\twhile (tmp < max) {\n\t\tif (!si->swap_map[tmp]) {\n\t\t\tfound_free = true;\n\t\t\tbreak;\n\t\t}\n\t\ttmp++;\n\t}\n\tunlock_cluster(ci);\n\tif (!found_free) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tcluster->next = tmp + 1;\n\t*offset = tmp;\n\t*scan_base = tmp;\n\treturn found_free;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_set_null",
          "args": [
            "&cluster->index"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "285-289",
          "snippet": "static inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "tmp"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "si->max",
            "(cluster_next(&cluster->index) + 1) * SWAPFILE_CLUSTER"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_next",
          "args": [
            "&cluster->index"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "257-260",
          "snippet": "static inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_do_scheduled_discard",
          "args": [
            "si"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "swap_do_scheduled_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "434-455",
          "snippet": "static void swap_do_scheduled_discard(struct swap_info_struct *si)\n{\n\tstruct swap_cluster_info *info, *ci;\n\tunsigned int idx;\n\n\tinfo = si->cluster_info;\n\n\twhile (!cluster_list_empty(&si->discard_clusters)) {\n\t\tidx = cluster_list_del_first(&si->discard_clusters, info);\n\t\tspin_unlock(&si->lock);\n\n\t\tdiscard_swap_cluster(si, idx * SWAPFILE_CLUSTER,\n\t\t\t\tSWAPFILE_CLUSTER);\n\n\t\tspin_lock(&si->lock);\n\t\tci = lock_cluster(si, idx * SWAPFILE_CLUSTER);\n\t\t__free_cluster(si, idx);\n\t\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\t\t0, SWAPFILE_CLUSTER);\n\t\tunlock_cluster(ci);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_do_scheduled_discard(struct swap_info_struct *si)\n{\n\tstruct swap_cluster_info *info, *ci;\n\tunsigned int idx;\n\n\tinfo = si->cluster_info;\n\n\twhile (!cluster_list_empty(&si->discard_clusters)) {\n\t\tidx = cluster_list_del_first(&si->discard_clusters, info);\n\t\tspin_unlock(&si->lock);\n\n\t\tdiscard_swap_cluster(si, idx * SWAPFILE_CLUSTER,\n\t\t\t\tSWAPFILE_CLUSTER);\n\n\t\tspin_lock(&si->lock);\n\t\tci = lock_cluster(si, idx * SWAPFILE_CLUSTER);\n\t\t__free_cluster(si, idx);\n\t\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\t\t0, SWAPFILE_CLUSTER);\n\t\tunlock_cluster(ci);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_empty",
          "args": [
            "&si->discard_clusters"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_is_null",
          "args": [
            "&cluster->index"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "280-283",
          "snippet": "static inline bool cluster_is_null(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_NEXT_NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_null(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_NEXT_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "si->percpu_cluster"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool scan_swap_map_try_ssd_cluster(struct swap_info_struct *si,\n\tunsigned long *offset, unsigned long *scan_base)\n{\n\tstruct percpu_cluster *cluster;\n\tstruct swap_cluster_info *ci;\n\tbool found_free;\n\tunsigned long tmp, max;\n\nnew_cluster:\n\tcluster = this_cpu_ptr(si->percpu_cluster);\n\tif (cluster_is_null(&cluster->index)) {\n\t\tif (!cluster_list_empty(&si->free_clusters)) {\n\t\t\tcluster->index = si->free_clusters.head;\n\t\t\tcluster->next = cluster_next(&cluster->index) *\n\t\t\t\t\tSWAPFILE_CLUSTER;\n\t\t} else if (!cluster_list_empty(&si->discard_clusters)) {\n\t\t\t/*\n\t\t\t * we don't have free cluster but have some clusters in\n\t\t\t * discarding, do discard now and reclaim them\n\t\t\t */\n\t\t\tswap_do_scheduled_discard(si);\n\t\t\t*scan_base = *offset = si->cluster_next;\n\t\t\tgoto new_cluster;\n\t\t} else\n\t\t\treturn false;\n\t}\n\n\tfound_free = false;\n\n\t/*\n\t * Other CPUs can use our cluster if they can't find a free cluster,\n\t * check if there is still free entry in the cluster\n\t */\n\ttmp = cluster->next;\n\tmax = min_t(unsigned long, si->max,\n\t\t    (cluster_next(&cluster->index) + 1) * SWAPFILE_CLUSTER);\n\tif (tmp >= max) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tci = lock_cluster(si, tmp);\n\twhile (tmp < max) {\n\t\tif (!si->swap_map[tmp]) {\n\t\t\tfound_free = true;\n\t\t\tbreak;\n\t\t}\n\t\ttmp++;\n\t}\n\tunlock_cluster(ci);\n\tif (!found_free) {\n\t\tcluster_set_null(&cluster->index);\n\t\tgoto new_cluster;\n\t}\n\tcluster->next = tmp + 1;\n\t*offset = tmp;\n\t*scan_base = tmp;\n\treturn found_free;\n}"
  },
  {
    "function_name": "scan_swap_map_ssd_cluster_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "540-558",
    "snippet": "static bool\nscan_swap_map_ssd_cluster_conflict(struct swap_info_struct *si,\n\tunsigned long offset)\n{\n\tstruct percpu_cluster *percpu_cluster;\n\tbool conflict;\n\n\toffset /= SWAPFILE_CLUSTER;\n\tconflict = !cluster_list_empty(&si->free_clusters) &&\n\t\toffset != cluster_list_first(&si->free_clusters) &&\n\t\tcluster_is_free(&si->cluster_info[offset]);\n\n\tif (!conflict)\n\t\treturn false;\n\n\tpercpu_cluster = this_cpu_ptr(si->percpu_cluster);\n\tcluster_set_null(&percpu_cluster->index);\n\treturn true;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_set_null",
          "args": [
            "&percpu_cluster->index"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "285-289",
          "snippet": "static inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "si->percpu_cluster"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_is_free",
          "args": [
            "&si->cluster_info[offset]"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_is_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "275-278",
          "snippet": "static inline bool cluster_is_free(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_FREE;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_free(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_FREE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_first",
          "args": [
            "&si->free_clusters"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "354-357",
          "snippet": "static inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_empty",
          "args": [
            "&si->free_clusters"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic bool\nscan_swap_map_ssd_cluster_conflict(struct swap_info_struct *si,\n\tunsigned long offset)\n{\n\tstruct percpu_cluster *percpu_cluster;\n\tbool conflict;\n\n\toffset /= SWAPFILE_CLUSTER;\n\tconflict = !cluster_list_empty(&si->free_clusters) &&\n\t\toffset != cluster_list_first(&si->free_clusters) &&\n\t\tcluster_is_free(&si->cluster_info[offset]);\n\n\tif (!conflict)\n\t\treturn false;\n\n\tpercpu_cluster = this_cpu_ptr(si->percpu_cluster);\n\tcluster_set_null(&percpu_cluster->index);\n\treturn true;\n}"
  },
  {
    "function_name": "dec_cluster_info_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "520-534",
    "snippet": "static void dec_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) == 0);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) - 1);\n\n\tif (cluster_count(&cluster_info[idx]) == 0)\n\t\tfree_cluster(p, idx);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cluster",
          "args": [
            "p",
            "idx"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "swap_free_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "929-940",
          "snippet": "static void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tunsigned long offset = idx * SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\n\tci = lock_cluster(si, offset);\n\tmemset(si->swap_map + offset, 0, SWAPFILE_CLUSTER);\n\tcluster_set_count_flag(ci, 0, 0);\n\tfree_cluster(si, idx);\n\tunlock_cluster(ci);\n\tswap_range_free(si, offset, SWAPFILE_CLUSTER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_count",
          "args": [
            "&cluster_info[idx]"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "239-242",
          "snippet": "static inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_set_count",
          "args": [
            "&cluster_info[idx]",
            "cluster_count(&cluster_info[idx]) - 1"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "244-248",
          "snippet": "static inline void cluster_set_count(struct swap_cluster_info *info,\n\t\t\t\t     unsigned int c)\n{\n\tinfo->data = c;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_count(struct swap_cluster_info *info,\n\t\t\t\t     unsigned int c)\n{\n\tinfo->data = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "cluster_count(&cluster_info[idx]) == 0"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void dec_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) == 0);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) - 1);\n\n\tif (cluster_count(&cluster_info[idx]) == 0)\n\t\tfree_cluster(p, idx);\n}"
  },
  {
    "function_name": "inc_cluster_info_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "500-513",
    "snippet": "static void inc_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\tif (cluster_is_free(&cluster_info[idx]))\n\t\talloc_cluster(p, idx);\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) + 1);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_set_count",
          "args": [
            "&cluster_info[idx]",
            "cluster_count(&cluster_info[idx]) + 1"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "244-248",
          "snippet": "static inline void cluster_set_count(struct swap_cluster_info *info,\n\t\t\t\t     unsigned int c)\n{\n\tinfo->data = c;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_count(struct swap_cluster_info *info,\n\t\t\t\t     unsigned int c)\n{\n\tinfo->data = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_count",
          "args": [
            "&cluster_info[idx]"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "239-242",
          "snippet": "static inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cluster",
          "args": [
            "p",
            "idx"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "swap_alloc_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "894-927",
          "snippet": "static int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int swap_alloc_cluster(struct swap_info_struct *si, swp_entry_t *slot)\n{\n\tunsigned long idx;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset, i;\n\tunsigned char *map;\n\n\t/*\n\t * Should not even be attempting cluster allocations when huge\n\t * page swap is disabled.  Warn and fail the allocation.\n\t */\n\tif (!IS_ENABLED(CONFIG_THP_SWAP)) {\n\t\tVM_WARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tif (cluster_list_empty(&si->free_clusters))\n\t\treturn 0;\n\n\tidx = cluster_list_first(&si->free_clusters);\n\toffset = idx * SWAPFILE_CLUSTER;\n\tci = lock_cluster(si, offset);\n\talloc_cluster(si, idx);\n\tcluster_set_count_flag(ci, SWAPFILE_CLUSTER, CLUSTER_FLAG_HUGE);\n\n\tmap = si->swap_map + offset;\n\tfor (i = 0; i < SWAPFILE_CLUSTER; i++)\n\t\tmap[i] = SWAP_HAS_CACHE;\n\tunlock_cluster(ci);\n\tswap_range_alloc(si, offset, SWAPFILE_CLUSTER);\n\t*slot = swp_entry(si->type, offset);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_is_free",
          "args": [
            "&cluster_info[idx]"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_is_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "275-278",
          "snippet": "static inline bool cluster_is_free(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_FREE;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_free(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_FREE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void inc_cluster_info_page(struct swap_info_struct *p,\n\tstruct swap_cluster_info *cluster_info, unsigned long page_nr)\n{\n\tunsigned long idx = page_nr / SWAPFILE_CLUSTER;\n\n\tif (!cluster_info)\n\t\treturn;\n\tif (cluster_is_free(&cluster_info[idx]))\n\t\talloc_cluster(p, idx);\n\n\tVM_BUG_ON(cluster_count(&cluster_info[idx]) >= SWAPFILE_CLUSTER);\n\tcluster_set_count(&cluster_info[idx],\n\t\tcluster_count(&cluster_info[idx]) + 1);\n}"
  },
  {
    "function_name": "free_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "477-494",
    "snippet": "static void free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info + idx;\n\n\tVM_BUG_ON(cluster_count(ci) != 0);\n\t/*\n\t * If the swap is discardable, prepare discard the cluster\n\t * instead of free it immediately. The cluster will be freed\n\t * after discard.\n\t */\n\tif ((si->flags & (SWP_WRITEOK | SWP_PAGE_DISCARD)) ==\n\t    (SWP_WRITEOK | SWP_PAGE_DISCARD)) {\n\t\tswap_cluster_schedule_discard(si, idx);\n\t\treturn;\n\t}\n\n\t__free_cluster(si, idx);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_cluster",
          "args": [
            "si",
            "idx"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "__free_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "422-428",
          "snippet": "static void __free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tcluster_set_flag(ci + idx, CLUSTER_FLAG_FREE);\n\tcluster_list_add_tail(&si->free_clusters, ci, idx);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void __free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tcluster_set_flag(ci + idx, CLUSTER_FLAG_FREE);\n\tcluster_list_add_tail(&si->free_clusters, ci, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_cluster_schedule_discard",
          "args": [
            "si",
            "idx"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "swap_cluster_schedule_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "405-420",
          "snippet": "static void swap_cluster_schedule_discard(struct swap_info_struct *si,\n\t\tunsigned int idx)\n{\n\t/*\n\t * If scan_swap_map() can't find a free cluster, it will check\n\t * si->swap_map directly. To make sure the discarding cluster isn't\n\t * taken by scan_swap_map(), mark the swap entries bad (occupied). It\n\t * will be cleared after discard\n\t */\n\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\tSWAP_MAP_BAD, SWAPFILE_CLUSTER);\n\n\tcluster_list_add_tail(&si->discard_clusters, si->cluster_info, idx);\n\n\tschedule_work(&si->discard_work);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_cluster_schedule_discard(struct swap_info_struct *si,\n\t\tunsigned int idx)\n{\n\t/*\n\t * If scan_swap_map() can't find a free cluster, it will check\n\t * si->swap_map directly. To make sure the discarding cluster isn't\n\t * taken by scan_swap_map(), mark the swap entries bad (occupied). It\n\t * will be cleared after discard\n\t */\n\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\tSWAP_MAP_BAD, SWAPFILE_CLUSTER);\n\n\tcluster_list_add_tail(&si->discard_clusters, si->cluster_info, idx);\n\n\tschedule_work(&si->discard_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "cluster_count(ci) != 0"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_count",
          "args": [
            "ci"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "239-242",
          "snippet": "static inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info + idx;\n\n\tVM_BUG_ON(cluster_count(ci) != 0);\n\t/*\n\t * If the swap is discardable, prepare discard the cluster\n\t * instead of free it immediately. The cluster will be freed\n\t * after discard.\n\t */\n\tif ((si->flags & (SWP_WRITEOK | SWP_PAGE_DISCARD)) ==\n\t    (SWP_WRITEOK | SWP_PAGE_DISCARD)) {\n\t\tswap_cluster_schedule_discard(si, idx);\n\t\treturn;\n\t}\n\n\t__free_cluster(si, idx);\n}"
  },
  {
    "function_name": "alloc_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "468-475",
    "snippet": "static void alloc_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tVM_BUG_ON(cluster_list_first(&si->free_clusters) != idx);\n\tcluster_list_del_first(&si->free_clusters, ci);\n\tcluster_set_count_flag(ci + idx, 0, 0);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_set_count_flag",
          "args": [
            "ci + idx",
            "0",
            "0"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_count_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "250-255",
          "snippet": "static inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_del_first",
          "args": [
            "&si->free_clusters",
            "ci"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_del_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "388-402",
          "snippet": "static unsigned int cluster_list_del_first(struct swap_cluster_list *list,\n\t\t\t\t\t   struct swap_cluster_info *ci)\n{\n\tunsigned int idx;\n\n\tidx = cluster_next(&list->head);\n\tif (cluster_next(&list->tail) == idx) {\n\t\tcluster_set_null(&list->head);\n\t\tcluster_set_null(&list->tail);\n\t} else\n\t\tcluster_set_next_flag(&list->head,\n\t\t\t\t      cluster_next(&ci[idx]), 0);\n\n\treturn idx;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned int cluster_list_del_first(struct swap_cluster_list *list,\n\t\t\t\t\t   struct swap_cluster_info *ci)\n{\n\tunsigned int idx;\n\n\tidx = cluster_next(&list->head);\n\tif (cluster_next(&list->tail) == idx) {\n\t\tcluster_set_null(&list->head);\n\t\tcluster_set_null(&list->tail);\n\t} else\n\t\tcluster_set_next_flag(&list->head,\n\t\t\t\t      cluster_next(&ci[idx]), 0);\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "cluster_list_first(&si->free_clusters) != idx"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_list_first",
          "args": [
            "&si->free_clusters"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "354-357",
          "snippet": "static inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void alloc_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tVM_BUG_ON(cluster_list_first(&si->free_clusters) != idx);\n\tcluster_list_del_first(&si->free_clusters, ci);\n\tcluster_set_count_flag(ci + idx, 0, 0);\n}"
  },
  {
    "function_name": "swap_discard_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "457-466",
    "snippet": "static void swap_discard_work(struct work_struct *work)\n{\n\tstruct swap_info_struct *si;\n\n\tsi = container_of(work, struct swap_info_struct, discard_work);\n\n\tspin_lock(&si->lock);\n\tswap_do_scheduled_discard(si);\n\tspin_unlock(&si->lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_do_scheduled_discard",
          "args": [
            "si"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "swap_do_scheduled_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "434-455",
          "snippet": "static void swap_do_scheduled_discard(struct swap_info_struct *si)\n{\n\tstruct swap_cluster_info *info, *ci;\n\tunsigned int idx;\n\n\tinfo = si->cluster_info;\n\n\twhile (!cluster_list_empty(&si->discard_clusters)) {\n\t\tidx = cluster_list_del_first(&si->discard_clusters, info);\n\t\tspin_unlock(&si->lock);\n\n\t\tdiscard_swap_cluster(si, idx * SWAPFILE_CLUSTER,\n\t\t\t\tSWAPFILE_CLUSTER);\n\n\t\tspin_lock(&si->lock);\n\t\tci = lock_cluster(si, idx * SWAPFILE_CLUSTER);\n\t\t__free_cluster(si, idx);\n\t\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\t\t0, SWAPFILE_CLUSTER);\n\t\tunlock_cluster(ci);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_do_scheduled_discard(struct swap_info_struct *si)\n{\n\tstruct swap_cluster_info *info, *ci;\n\tunsigned int idx;\n\n\tinfo = si->cluster_info;\n\n\twhile (!cluster_list_empty(&si->discard_clusters)) {\n\t\tidx = cluster_list_del_first(&si->discard_clusters, info);\n\t\tspin_unlock(&si->lock);\n\n\t\tdiscard_swap_cluster(si, idx * SWAPFILE_CLUSTER,\n\t\t\t\tSWAPFILE_CLUSTER);\n\n\t\tspin_lock(&si->lock);\n\t\tci = lock_cluster(si, idx * SWAPFILE_CLUSTER);\n\t\t__free_cluster(si, idx);\n\t\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\t\t0, SWAPFILE_CLUSTER);\n\t\tunlock_cluster(ci);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structswap_info_struct",
            "discard_work"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_discard_work(struct work_struct *work)\n{\n\tstruct swap_info_struct *si;\n\n\tsi = container_of(work, struct swap_info_struct, discard_work);\n\n\tspin_lock(&si->lock);\n\tswap_do_scheduled_discard(si);\n\tspin_unlock(&si->lock);\n}"
  },
  {
    "function_name": "swap_do_scheduled_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "434-455",
    "snippet": "static void swap_do_scheduled_discard(struct swap_info_struct *si)\n{\n\tstruct swap_cluster_info *info, *ci;\n\tunsigned int idx;\n\n\tinfo = si->cluster_info;\n\n\twhile (!cluster_list_empty(&si->discard_clusters)) {\n\t\tidx = cluster_list_del_first(&si->discard_clusters, info);\n\t\tspin_unlock(&si->lock);\n\n\t\tdiscard_swap_cluster(si, idx * SWAPFILE_CLUSTER,\n\t\t\t\tSWAPFILE_CLUSTER);\n\n\t\tspin_lock(&si->lock);\n\t\tci = lock_cluster(si, idx * SWAPFILE_CLUSTER);\n\t\t__free_cluster(si, idx);\n\t\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\t\t0, SWAPFILE_CLUSTER);\n\t\tunlock_cluster(ci);\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "si->swap_map + idx * SWAPFILE_CLUSTER",
            "0",
            "SWAPFILE_CLUSTER"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_cluster",
          "args": [
            "si",
            "idx"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "__free_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "422-428",
          "snippet": "static void __free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tcluster_set_flag(ci + idx, CLUSTER_FLAG_FREE);\n\tcluster_list_add_tail(&si->free_clusters, ci, idx);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void __free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tcluster_set_flag(ci + idx, CLUSTER_FLAG_FREE);\n\tcluster_list_add_tail(&si->free_clusters, ci, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "idx * SWAPFILE_CLUSTER"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_swap_cluster",
          "args": [
            "si",
            "idx * SWAPFILE_CLUSTER",
            "SWAPFILE_CLUSTER"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "discard_swap_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "186-216",
          "snippet": "static void discard_swap_cluster(struct swap_info_struct *si,\n\t\t\t\t pgoff_t start_page, pgoff_t nr_pages)\n{\n\tstruct swap_extent *se = si->curr_swap_extent;\n\tint found_extent = 0;\n\n\twhile (nr_pages) {\n\t\tif (se->start_page <= start_page &&\n\t\t    start_page < se->start_page + se->nr_pages) {\n\t\t\tpgoff_t offset = start_page - se->start_page;\n\t\t\tsector_t start_block = se->start_block + offset;\n\t\t\tsector_t nr_blocks = se->nr_pages - offset;\n\n\t\t\tif (nr_blocks > nr_pages)\n\t\t\t\tnr_blocks = nr_pages;\n\t\t\tstart_page += nr_blocks;\n\t\t\tnr_pages -= nr_blocks;\n\n\t\t\tif (!found_extent++)\n\t\t\t\tsi->curr_swap_extent = se;\n\n\t\t\tstart_block <<= PAGE_SHIFT - 9;\n\t\t\tnr_blocks <<= PAGE_SHIFT - 9;\n\t\t\tif (blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\t    nr_blocks, GFP_NOIO, 0))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tse = list_next_entry(se, list);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void discard_swap_cluster(struct swap_info_struct *si,\n\t\t\t\t pgoff_t start_page, pgoff_t nr_pages)\n{\n\tstruct swap_extent *se = si->curr_swap_extent;\n\tint found_extent = 0;\n\n\twhile (nr_pages) {\n\t\tif (se->start_page <= start_page &&\n\t\t    start_page < se->start_page + se->nr_pages) {\n\t\t\tpgoff_t offset = start_page - se->start_page;\n\t\t\tsector_t start_block = se->start_block + offset;\n\t\t\tsector_t nr_blocks = se->nr_pages - offset;\n\n\t\t\tif (nr_blocks > nr_pages)\n\t\t\t\tnr_blocks = nr_pages;\n\t\t\tstart_page += nr_blocks;\n\t\t\tnr_pages -= nr_blocks;\n\n\t\t\tif (!found_extent++)\n\t\t\t\tsi->curr_swap_extent = se;\n\n\t\t\tstart_block <<= PAGE_SHIFT - 9;\n\t\t\tnr_blocks <<= PAGE_SHIFT - 9;\n\t\t\tif (blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\t    nr_blocks, GFP_NOIO, 0))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tse = list_next_entry(se, list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_list_del_first",
          "args": [
            "&si->discard_clusters",
            "info"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_del_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "388-402",
          "snippet": "static unsigned int cluster_list_del_first(struct swap_cluster_list *list,\n\t\t\t\t\t   struct swap_cluster_info *ci)\n{\n\tunsigned int idx;\n\n\tidx = cluster_next(&list->head);\n\tif (cluster_next(&list->tail) == idx) {\n\t\tcluster_set_null(&list->head);\n\t\tcluster_set_null(&list->tail);\n\t} else\n\t\tcluster_set_next_flag(&list->head,\n\t\t\t\t      cluster_next(&ci[idx]), 0);\n\n\treturn idx;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned int cluster_list_del_first(struct swap_cluster_list *list,\n\t\t\t\t\t   struct swap_cluster_info *ci)\n{\n\tunsigned int idx;\n\n\tidx = cluster_next(&list->head);\n\tif (cluster_next(&list->tail) == idx) {\n\t\tcluster_set_null(&list->head);\n\t\tcluster_set_null(&list->tail);\n\t} else\n\t\tcluster_set_next_flag(&list->head,\n\t\t\t\t      cluster_next(&ci[idx]), 0);\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_empty",
          "args": [
            "&si->discard_clusters"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_do_scheduled_discard(struct swap_info_struct *si)\n{\n\tstruct swap_cluster_info *info, *ci;\n\tunsigned int idx;\n\n\tinfo = si->cluster_info;\n\n\twhile (!cluster_list_empty(&si->discard_clusters)) {\n\t\tidx = cluster_list_del_first(&si->discard_clusters, info);\n\t\tspin_unlock(&si->lock);\n\n\t\tdiscard_swap_cluster(si, idx * SWAPFILE_CLUSTER,\n\t\t\t\tSWAPFILE_CLUSTER);\n\n\t\tspin_lock(&si->lock);\n\t\tci = lock_cluster(si, idx * SWAPFILE_CLUSTER);\n\t\t__free_cluster(si, idx);\n\t\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\t\t0, SWAPFILE_CLUSTER);\n\t\tunlock_cluster(ci);\n\t}\n}"
  },
  {
    "function_name": "__free_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "422-428",
    "snippet": "static void __free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tcluster_set_flag(ci + idx, CLUSTER_FLAG_FREE);\n\tcluster_list_add_tail(&si->free_clusters, ci, idx);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_list_add_tail",
          "args": [
            "&si->free_clusters",
            "ci",
            "idx"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "365-386",
          "snippet": "static void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_set_flag",
          "args": [
            "ci + idx",
            "CLUSTER_FLAG_FREE"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "233-237",
          "snippet": "static inline void cluster_set_flag(struct swap_cluster_info *info,\n\tunsigned int flag)\n{\n\tinfo->flags = flag;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_flag(struct swap_cluster_info *info,\n\tunsigned int flag)\n{\n\tinfo->flags = flag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void __free_cluster(struct swap_info_struct *si, unsigned long idx)\n{\n\tstruct swap_cluster_info *ci = si->cluster_info;\n\n\tcluster_set_flag(ci + idx, CLUSTER_FLAG_FREE);\n\tcluster_list_add_tail(&si->free_clusters, ci, idx);\n}"
  },
  {
    "function_name": "swap_cluster_schedule_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "405-420",
    "snippet": "static void swap_cluster_schedule_discard(struct swap_info_struct *si,\n\t\tunsigned int idx)\n{\n\t/*\n\t * If scan_swap_map() can't find a free cluster, it will check\n\t * si->swap_map directly. To make sure the discarding cluster isn't\n\t * taken by scan_swap_map(), mark the swap entries bad (occupied). It\n\t * will be cleared after discard\n\t */\n\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\tSWAP_MAP_BAD, SWAPFILE_CLUSTER);\n\n\tcluster_list_add_tail(&si->discard_clusters, si->cluster_info, idx);\n\n\tschedule_work(&si->discard_work);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&si->discard_work"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_list_add_tail",
          "args": [
            "&si->discard_clusters",
            "si->cluster_info",
            "idx"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "365-386",
          "snippet": "static void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "si->swap_map + idx * SWAPFILE_CLUSTER",
            "SWAP_MAP_BAD",
            "SWAPFILE_CLUSTER"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void swap_cluster_schedule_discard(struct swap_info_struct *si,\n\t\tunsigned int idx)\n{\n\t/*\n\t * If scan_swap_map() can't find a free cluster, it will check\n\t * si->swap_map directly. To make sure the discarding cluster isn't\n\t * taken by scan_swap_map(), mark the swap entries bad (occupied). It\n\t * will be cleared after discard\n\t */\n\tmemset(si->swap_map + idx * SWAPFILE_CLUSTER,\n\t\t\tSWAP_MAP_BAD, SWAPFILE_CLUSTER);\n\n\tcluster_list_add_tail(&si->discard_clusters, si->cluster_info, idx);\n\n\tschedule_work(&si->discard_work);\n}"
  },
  {
    "function_name": "cluster_list_del_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "388-402",
    "snippet": "static unsigned int cluster_list_del_first(struct swap_cluster_list *list,\n\t\t\t\t\t   struct swap_cluster_info *ci)\n{\n\tunsigned int idx;\n\n\tidx = cluster_next(&list->head);\n\tif (cluster_next(&list->tail) == idx) {\n\t\tcluster_set_null(&list->head);\n\t\tcluster_set_null(&list->tail);\n\t} else\n\t\tcluster_set_next_flag(&list->head,\n\t\t\t\t      cluster_next(&ci[idx]), 0);\n\n\treturn idx;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_set_next_flag",
          "args": [
            "&list->head",
            "cluster_next(&ci[idx])",
            "0"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_next_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "268-273",
          "snippet": "static inline void cluster_set_next_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int n, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = n;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_next_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int n, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_next",
          "args": [
            "&ci[idx]"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "257-260",
          "snippet": "static inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_set_null",
          "args": [
            "&list->tail"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "285-289",
          "snippet": "static inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned int cluster_list_del_first(struct swap_cluster_list *list,\n\t\t\t\t\t   struct swap_cluster_info *ci)\n{\n\tunsigned int idx;\n\n\tidx = cluster_next(&list->head);\n\tif (cluster_next(&list->tail) == idx) {\n\t\tcluster_set_null(&list->head);\n\t\tcluster_set_null(&list->tail);\n\t} else\n\t\tcluster_set_next_flag(&list->head,\n\t\t\t\t      cluster_next(&ci[idx]), 0);\n\n\treturn idx;\n}"
  },
  {
    "function_name": "cluster_list_add_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "365-386",
    "snippet": "static void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_set_next_flag",
          "args": [
            "&list->tail",
            "idx",
            "0"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_next_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "268-273",
          "snippet": "static inline void cluster_set_next_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int n, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = n;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_next_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int n, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci_tail->lock"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_set_next",
          "args": [
            "ci_tail",
            "idx"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "262-266",
          "snippet": "static inline void cluster_set_next(struct swap_cluster_info *info,\n\t\t\t\t    unsigned int n)\n{\n\tinfo->data = n;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_next(struct swap_cluster_info *info,\n\t\t\t\t    unsigned int n)\n{\n\tinfo->data = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&ci_tail->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_next",
          "args": [
            "&list->tail"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "257-260",
          "snippet": "static inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_list_empty",
          "args": [
            "list"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void cluster_list_add_tail(struct swap_cluster_list *list,\n\t\t\t\t  struct swap_cluster_info *ci,\n\t\t\t\t  unsigned int idx)\n{\n\tif (cluster_list_empty(list)) {\n\t\tcluster_set_next_flag(&list->head, idx, 0);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t} else {\n\t\tstruct swap_cluster_info *ci_tail;\n\t\tunsigned int tail = cluster_next(&list->tail);\n\n\t\t/*\n\t\t * Nested cluster lock, but both cluster locks are\n\t\t * only acquired when we held swap_info_struct->lock\n\t\t */\n\t\tci_tail = ci + tail;\n\t\tspin_lock_nested(&ci_tail->lock, SINGLE_DEPTH_NESTING);\n\t\tcluster_set_next(ci_tail, idx);\n\t\tspin_unlock(&ci_tail->lock);\n\t\tcluster_set_next_flag(&list->tail, idx, 0);\n\t}\n}"
  },
  {
    "function_name": "cluster_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "359-363",
    "snippet": "static void cluster_list_init(struct swap_cluster_list *list)\n{\n\tcluster_set_null(&list->head);\n\tcluster_set_null(&list->tail);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_set_null",
          "args": [
            "&list->tail"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_set_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "285-289",
          "snippet": "static inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void cluster_list_init(struct swap_cluster_list *list)\n{\n\tcluster_set_null(&list->head);\n\tcluster_set_null(&list->tail);\n}"
  },
  {
    "function_name": "cluster_list_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "354-357",
    "snippet": "static inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_next",
          "args": [
            "&list->head"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "257-260",
          "snippet": "static inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_list_first(struct swap_cluster_list *list)\n{\n\treturn cluster_next(&list->head);\n}"
  },
  {
    "function_name": "cluster_list_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "349-352",
    "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cluster_is_null",
          "args": [
            "&list->head"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "280-283",
          "snippet": "static inline bool cluster_is_null(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_NEXT_NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_null(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_NEXT_NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
  },
  {
    "function_name": "unlock_cluster_or_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "340-347",
    "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&si->lock"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_cluster",
          "args": [
            "ci"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "316-320",
          "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
  },
  {
    "function_name": "lock_cluster_or_swap_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "326-338",
    "snippet": "static inline struct swap_cluster_info *lock_cluster_or_swap_info(\n\t\tstruct swap_info_struct *si, unsigned long offset)\n{\n\tstruct swap_cluster_info *ci;\n\n\t/* Try to use fine-grained SSD-style locking if available: */\n\tci = lock_cluster(si, offset);\n\t/* Otherwise, fall back to traditional, coarse locking: */\n\tif (!ci)\n\t\tspin_lock(&si->lock);\n\n\treturn ci;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&si->lock"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_cluster",
          "args": [
            "si",
            "offset"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_cluster_or_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "340-347",
          "snippet": "static inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline void unlock_cluster_or_swap_info(struct swap_info_struct *si,\n\t\t\t\t\t       struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tunlock_cluster(ci);\n\telse\n\t\tspin_unlock(&si->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline struct swap_cluster_info *lock_cluster_or_swap_info(\n\t\tstruct swap_info_struct *si, unsigned long offset)\n{\n\tstruct swap_cluster_info *ci;\n\n\t/* Try to use fine-grained SSD-style locking if available: */\n\tci = lock_cluster(si, offset);\n\t/* Otherwise, fall back to traditional, coarse locking: */\n\tif (!ci)\n\t\tspin_lock(&si->lock);\n\n\treturn ci;\n}"
  },
  {
    "function_name": "unlock_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "316-320",
    "snippet": "static inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->lock"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_cluster(struct swap_cluster_info *ci)\n{\n\tif (ci)\n\t\tspin_unlock(&ci->lock);\n}"
  },
  {
    "function_name": "lock_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "303-314",
    "snippet": "static inline struct swap_cluster_info *lock_cluster(struct swap_info_struct *si,\n\t\t\t\t\t\t     unsigned long offset)\n{\n\tstruct swap_cluster_info *ci;\n\n\tci = si->cluster_info;\n\tif (ci) {\n\t\tci += offset / SWAPFILE_CLUSTER;\n\t\tspin_lock(&ci->lock);\n\t}\n\treturn ci;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->lock"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic inline struct swap_cluster_info *lock_cluster(struct swap_info_struct *si,\n\t\t\t\t\t\t     unsigned long offset)\n{\n\tstruct swap_cluster_info *ci;\n\n\tci = si->cluster_info;\n\tif (ci) {\n\t\tci += offset / SWAPFILE_CLUSTER;\n\t\tspin_lock(&ci->lock);\n\t}\n\treturn ci;\n}"
  },
  {
    "function_name": "cluster_clear_huge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "298-301",
    "snippet": "static inline void cluster_clear_huge(struct swap_cluster_info *info)\n{\n\tinfo->flags &= ~CLUSTER_FLAG_HUGE;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_clear_huge(struct swap_cluster_info *info)\n{\n\tinfo->flags &= ~CLUSTER_FLAG_HUGE;\n}"
  },
  {
    "function_name": "cluster_is_huge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "291-296",
    "snippet": "static inline bool cluster_is_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\treturn info->flags & CLUSTER_FLAG_HUGE;\n\treturn false;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_THP_SWAP"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_huge(struct swap_cluster_info *info)\n{\n\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\treturn info->flags & CLUSTER_FLAG_HUGE;\n\treturn false;\n}"
  },
  {
    "function_name": "cluster_set_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "285-289",
    "snippet": "static inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_null(struct swap_cluster_info *info)\n{\n\tinfo->flags = CLUSTER_FLAG_NEXT_NULL;\n\tinfo->data = 0;\n}"
  },
  {
    "function_name": "cluster_is_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "280-283",
    "snippet": "static inline bool cluster_is_null(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_NEXT_NULL;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_null(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_NEXT_NULL;\n}"
  },
  {
    "function_name": "cluster_is_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "275-278",
    "snippet": "static inline bool cluster_is_free(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_FREE;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_is_free(struct swap_cluster_info *info)\n{\n\treturn info->flags & CLUSTER_FLAG_FREE;\n}"
  },
  {
    "function_name": "cluster_set_next_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "268-273",
    "snippet": "static inline void cluster_set_next_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int n, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = n;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_next_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int n, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = n;\n}"
  },
  {
    "function_name": "cluster_set_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "262-266",
    "snippet": "static inline void cluster_set_next(struct swap_cluster_info *info,\n\t\t\t\t    unsigned int n)\n{\n\tinfo->data = n;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_next(struct swap_cluster_info *info,\n\t\t\t\t    unsigned int n)\n{\n\tinfo->data = n;\n}"
  },
  {
    "function_name": "cluster_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "257-260",
    "snippet": "static inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_next(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
  },
  {
    "function_name": "cluster_set_count_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "250-255",
    "snippet": "static inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_count_flag(struct swap_cluster_info *info,\n\t\t\t\t\t unsigned int c, unsigned int f)\n{\n\tinfo->flags = f;\n\tinfo->data = c;\n}"
  },
  {
    "function_name": "cluster_set_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "244-248",
    "snippet": "static inline void cluster_set_count(struct swap_cluster_info *info,\n\t\t\t\t     unsigned int c)\n{\n\tinfo->data = c;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_count(struct swap_cluster_info *info,\n\t\t\t\t     unsigned int c)\n{\n\tinfo->data = c;\n}"
  },
  {
    "function_name": "cluster_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "239-242",
    "snippet": "static inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int cluster_count(struct swap_cluster_info *info)\n{\n\treturn info->data;\n}"
  },
  {
    "function_name": "cluster_set_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "233-237",
    "snippet": "static inline void cluster_set_flag(struct swap_cluster_info *info,\n\tunsigned int flag)\n{\n\tinfo->flags = flag;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void cluster_set_flag(struct swap_cluster_info *info,\n\tunsigned int flag)\n{\n\tinfo->flags = flag;\n}"
  },
  {
    "function_name": "discard_swap_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "186-216",
    "snippet": "static void discard_swap_cluster(struct swap_info_struct *si,\n\t\t\t\t pgoff_t start_page, pgoff_t nr_pages)\n{\n\tstruct swap_extent *se = si->curr_swap_extent;\n\tint found_extent = 0;\n\n\twhile (nr_pages) {\n\t\tif (se->start_page <= start_page &&\n\t\t    start_page < se->start_page + se->nr_pages) {\n\t\t\tpgoff_t offset = start_page - se->start_page;\n\t\t\tsector_t start_block = se->start_block + offset;\n\t\t\tsector_t nr_blocks = se->nr_pages - offset;\n\n\t\t\tif (nr_blocks > nr_pages)\n\t\t\t\tnr_blocks = nr_pages;\n\t\t\tstart_page += nr_blocks;\n\t\t\tnr_pages -= nr_blocks;\n\n\t\t\tif (!found_extent++)\n\t\t\t\tsi->curr_swap_extent = se;\n\n\t\t\tstart_block <<= PAGE_SHIFT - 9;\n\t\t\tnr_blocks <<= PAGE_SHIFT - 9;\n\t\t\tif (blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\t    nr_blocks, GFP_NOIO, 0))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tse = list_next_entry(se, list);\n\t}\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "se",
            "list"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "si->bdev",
            "start_block",
            "nr_blocks",
            "GFP_NOIO",
            "0"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic void discard_swap_cluster(struct swap_info_struct *si,\n\t\t\t\t pgoff_t start_page, pgoff_t nr_pages)\n{\n\tstruct swap_extent *se = si->curr_swap_extent;\n\tint found_extent = 0;\n\n\twhile (nr_pages) {\n\t\tif (se->start_page <= start_page &&\n\t\t    start_page < se->start_page + se->nr_pages) {\n\t\t\tpgoff_t offset = start_page - se->start_page;\n\t\t\tsector_t start_block = se->start_block + offset;\n\t\t\tsector_t nr_blocks = se->nr_pages - offset;\n\n\t\t\tif (nr_blocks > nr_pages)\n\t\t\t\tnr_blocks = nr_pages;\n\t\t\tstart_page += nr_blocks;\n\t\t\tnr_pages -= nr_blocks;\n\n\t\t\tif (!found_extent++)\n\t\t\t\tsi->curr_swap_extent = se;\n\n\t\t\tstart_block <<= PAGE_SHIFT - 9;\n\t\t\tnr_blocks <<= PAGE_SHIFT - 9;\n\t\t\tif (blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\t    nr_blocks, GFP_NOIO, 0))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tse = list_next_entry(se, list);\n\t}\n}"
  },
  {
    "function_name": "discard_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "149-180",
    "snippet": "static int discard_swap(struct swap_info_struct *si)\n{\n\tstruct swap_extent *se;\n\tsector_t start_block;\n\tsector_t nr_blocks;\n\tint err = 0;\n\n\t/* Do not discard the swap header page! */\n\tse = &si->first_swap_extent;\n\tstart_block = (se->start_block + 1) << (PAGE_SHIFT - 9);\n\tnr_blocks = ((sector_t)se->nr_pages - 1) << (PAGE_SHIFT - 9);\n\tif (nr_blocks) {\n\t\terr = blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\tnr_blocks, GFP_KERNEL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcond_resched();\n\t}\n\n\tlist_for_each_entry(se, &si->first_swap_extent.list, list) {\n\t\tstart_block = se->start_block << (PAGE_SHIFT - 9);\n\t\tnr_blocks = (sector_t)se->nr_pages << (PAGE_SHIFT - 9);\n\n\t\terr = blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\tnr_blocks, GFP_KERNEL, 0);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\treturn err;\t\t/* That will often be -EOPNOTSUPP */\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "si->bdev",
            "start_block",
            "nr_blocks",
            "GFP_KERNEL",
            "0"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "se",
            "&si->first_swap_extent.list",
            "list"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "si->bdev",
            "start_block",
            "nr_blocks",
            "GFP_KERNEL",
            "0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int discard_swap(struct swap_info_struct *si)\n{\n\tstruct swap_extent *se;\n\tsector_t start_block;\n\tsector_t nr_blocks;\n\tint err = 0;\n\n\t/* Do not discard the swap header page! */\n\tse = &si->first_swap_extent;\n\tstart_block = (se->start_block + 1) << (PAGE_SHIFT - 9);\n\tnr_blocks = ((sector_t)se->nr_pages - 1) << (PAGE_SHIFT - 9);\n\tif (nr_blocks) {\n\t\terr = blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\tnr_blocks, GFP_KERNEL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcond_resched();\n\t}\n\n\tlist_for_each_entry(se, &si->first_swap_extent.list, list) {\n\t\tstart_block = se->start_block << (PAGE_SHIFT - 9);\n\t\tnr_blocks = (sector_t)se->nr_pages << (PAGE_SHIFT - 9);\n\n\t\terr = blkdev_issue_discard(si->bdev, start_block,\n\t\t\t\tnr_blocks, GFP_KERNEL, 0);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\treturn err;\t\t/* That will often be -EOPNOTSUPP */\n}"
  },
  {
    "function_name": "__try_to_reclaim_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "117-143",
    "snippet": "static int __try_to_reclaim_swap(struct swap_info_struct *si,\n\t\t\t\t unsigned long offset, unsigned long flags)\n{\n\tswp_entry_t entry = swp_entry(si->type, offset);\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = find_get_page(swap_address_space(entry), offset);\n\tif (!page)\n\t\treturn 0;\n\t/*\n\t * When this function is called from scan_swap_map_slots() and it's\n\t * called by vmscan.c at reclaiming pages. So, we hold a lock on a page,\n\t * here. We have to use trylock for avoiding deadlock. This is a special\n\t * case and you should use try_to_free_swap() with explicit lock_page()\n\t * in usual operations.\n\t */\n\tif (trylock_page(page)) {\n\t\tif ((flags & TTRS_ANYWAY) ||\n\t\t    ((flags & TTRS_UNMAPPED) && !page_mapped(page)) ||\n\t\t    ((flags & TTRS_FULL) && mem_cgroup_swap_full(page)))\n\t\t\tret = try_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define TTRS_FULL\t\t0x4",
      "#define TTRS_UNMAPPED\t\t0x2",
      "#define TTRS_ANYWAY\t\t0x1"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1584-1617",
          "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_swap_full",
          "args": [
            "page"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_swap_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6532-6552",
          "snippet": "bool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nbool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "swap_address_space(entry)",
            "offset"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "si->type",
            "offset"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define TTRS_FULL\t\t0x4\n#define TTRS_UNMAPPED\t\t0x2\n#define TTRS_ANYWAY\t\t0x1\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstatic int __try_to_reclaim_swap(struct swap_info_struct *si,\n\t\t\t\t unsigned long offset, unsigned long flags)\n{\n\tswp_entry_t entry = swp_entry(si->type, offset);\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = find_get_page(swap_address_space(entry), offset);\n\tif (!page)\n\t\treturn 0;\n\t/*\n\t * When this function is called from scan_swap_map_slots() and it's\n\t * called by vmscan.c at reclaiming pages. So, we hold a lock on a page,\n\t * here. We have to use trylock for avoiding deadlock. This is a special\n\t * case and you should use try_to_free_swap() with explicit lock_page()\n\t * in usual operations.\n\t */\n\tif (trylock_page(page)) {\n\t\tif ((flags & TTRS_ANYWAY) ||\n\t\t    ((flags & TTRS_UNMAPPED) && !page_mapped(page)) ||\n\t\t    ((flags & TTRS_FULL) && mem_cgroup_swap_full(page)))\n\t\t\tret = try_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "swap_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "101-104",
    "snippet": "static inline unsigned char swap_count(unsigned char ent)\n{\n\treturn ent & ~SWAP_HAS_CACHE;\t/* may include COUNT_CONTINUED flag */\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned char swap_count(unsigned char ent)\n{\n\treturn ent & ~SWAP_HAS_CACHE;\t/* may include COUNT_CONTINUED flag */\n}"
  },
  {
    "function_name": "swapoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "2509-2673",
    "snippet": "SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n{\n\tstruct swap_info_struct *p = NULL;\n\tunsigned char *swap_map;\n\tstruct swap_cluster_info *cluster_info;\n\tunsigned long *frontswap_map;\n\tstruct file *swap_file, *victim;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct filename *pathname;\n\tint err, found = 0;\n\tunsigned int old_block_size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tBUG_ON(!current->mm);\n\n\tpathname = getname(specialfile);\n\tif (IS_ERR(pathname))\n\t\treturn PTR_ERR(pathname);\n\n\tvictim = file_open_name(pathname, O_RDWR|O_LARGEFILE, 0);\n\terr = PTR_ERR(victim);\n\tif (IS_ERR(victim))\n\t\tgoto out;\n\n\tmapping = victim->f_mapping;\n\tspin_lock(&swap_lock);\n\tplist_for_each_entry(p, &swap_active_head, list) {\n\t\tif (p->flags & SWP_WRITEOK) {\n\t\t\tif (p->swap_file->f_mapping == mapping) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\terr = -EINVAL;\n\t\tspin_unlock(&swap_lock);\n\t\tgoto out_dput;\n\t}\n\tif (!security_vm_enough_memory_mm(current->mm, p->pages))\n\t\tvm_unacct_memory(p->pages);\n\telse {\n\t\terr = -ENOMEM;\n\t\tspin_unlock(&swap_lock);\n\t\tgoto out_dput;\n\t}\n\tdel_from_avail_list(p);\n\tspin_lock(&p->lock);\n\tif (p->prio < 0) {\n\t\tstruct swap_info_struct *si = p;\n\t\tint nid;\n\n\t\tplist_for_each_entry_continue(si, &swap_active_head, list) {\n\t\t\tsi->prio++;\n\t\t\tsi->list.prio--;\n\t\t\tfor_each_node(nid) {\n\t\t\t\tif (si->avail_lists[nid].prio != 1)\n\t\t\t\t\tsi->avail_lists[nid].prio--;\n\t\t\t}\n\t\t}\n\t\tleast_priority++;\n\t}\n\tplist_del(&p->list, &swap_active_head);\n\tatomic_long_sub(p->pages, &nr_swap_pages);\n\ttotal_swap_pages -= p->pages;\n\tp->flags &= ~SWP_WRITEOK;\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\n\tdisable_swap_slots_cache_lock();\n\n\tset_current_oom_origin();\n\terr = try_to_unuse(p->type, false, 0); /* force unuse all pages */\n\tclear_current_oom_origin();\n\n\tif (err) {\n\t\t/* re-insert swap space back into swap_list */\n\t\treinsert_swap_info(p);\n\t\treenable_swap_slots_cache_unlock();\n\t\tgoto out_dput;\n\t}\n\n\treenable_swap_slots_cache_unlock();\n\n\tflush_work(&p->discard_work);\n\n\tdestroy_swap_extents(p);\n\tif (p->flags & SWP_CONTINUED)\n\t\tfree_swap_count_continuations(p);\n\n\tif (!p->bdev || !blk_queue_nonrot(bdev_get_queue(p->bdev)))\n\t\tatomic_dec(&nr_rotate_swap);\n\n\tmutex_lock(&swapon_mutex);\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\tdrain_mmlist();\n\n\t/* wait for anyone still in scan_swap_map */\n\tp->highest_bit = 0;\t\t/* cuts scans short */\n\twhile (p->flags >= SWP_SCANNING) {\n\t\tspin_unlock(&p->lock);\n\t\tspin_unlock(&swap_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&swap_lock);\n\t\tspin_lock(&p->lock);\n\t}\n\n\tswap_file = p->swap_file;\n\told_block_size = p->old_block_size;\n\tp->swap_file = NULL;\n\tp->max = 0;\n\tswap_map = p->swap_map;\n\tp->swap_map = NULL;\n\tcluster_info = p->cluster_info;\n\tp->cluster_info = NULL;\n\tfrontswap_map = frontswap_map_get(p);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\tfrontswap_invalidate_area(p->type);\n\tfrontswap_map_set(p, NULL);\n\tmutex_unlock(&swapon_mutex);\n\tfree_percpu(p->percpu_cluster);\n\tp->percpu_cluster = NULL;\n\tvfree(swap_map);\n\tkvfree(cluster_info);\n\tkvfree(frontswap_map);\n\t/* Destroy swap account information */\n\tswap_cgroup_swapoff(p->type);\n\texit_swap_address_space(p->type);\n\n\tinode = mapping->host;\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tstruct block_device *bdev = I_BDEV(inode);\n\t\tset_blocksize(bdev, old_block_size);\n\t\tblkdev_put(bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);\n\t} else {\n\t\tinode_lock(inode);\n\t\tinode->i_flags &= ~S_SWAPFILE;\n\t\tinode_unlock(inode);\n\t}\n\tfilp_close(swap_file, NULL);\n\n\t/*\n\t * Clear the SWP_USED flag after all resources are freed so that swapon\n\t * can reuse this swap_info in alloc_swap_info() safely.  It is ok to\n\t * not hold p->lock after we cleared its SWP_WRITEOK.\n\t */\n\tspin_lock(&swap_lock);\n\tp->flags = 0;\n\tspin_unlock(&swap_lock);\n\n\terr = 0;\n\tatomic_inc(&proc_poll_event);\n\twake_up_interruptible(&proc_poll_wait);\n\nout_dput:\n\tfilp_close(victim, NULL);\nout:\n\tputname(pathname);\n\treturn err;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static sector_t map_swap_entry(swp_entry_t, struct block_device**);",
      "atomic_long_t nr_swap_pages;",
      "long total_swap_pages;",
      "static int least_priority = -1;",
      "struct swap_info_struct *swap_info[MAX_SWAPFILES];",
      "static DEFINE_MUTEX(swapon_mutex);",
      "static DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);",
      "static atomic_t proc_poll_event = ATOMIC_INIT(0);",
      "atomic_t nr_rotate_swap = ATOMIC_INIT(0);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\natomic_long_t nr_swap_pages;\nlong total_swap_pages;\nstatic int least_priority = -1;\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\nstatic DEFINE_MUTEX(swapon_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);\nstatic atomic_t proc_poll_event = ATOMIC_INIT(0);\natomic_t nr_rotate_swap = ATOMIC_INIT(0);\n\nSYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n{\n\tstruct swap_info_struct *p = NULL;\n\tunsigned char *swap_map;\n\tstruct swap_cluster_info *cluster_info;\n\tunsigned long *frontswap_map;\n\tstruct file *swap_file, *victim;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct filename *pathname;\n\tint err, found = 0;\n\tunsigned int old_block_size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tBUG_ON(!current->mm);\n\n\tpathname = getname(specialfile);\n\tif (IS_ERR(pathname))\n\t\treturn PTR_ERR(pathname);\n\n\tvictim = file_open_name(pathname, O_RDWR|O_LARGEFILE, 0);\n\terr = PTR_ERR(victim);\n\tif (IS_ERR(victim))\n\t\tgoto out;\n\n\tmapping = victim->f_mapping;\n\tspin_lock(&swap_lock);\n\tplist_for_each_entry(p, &swap_active_head, list) {\n\t\tif (p->flags & SWP_WRITEOK) {\n\t\t\tif (p->swap_file->f_mapping == mapping) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\terr = -EINVAL;\n\t\tspin_unlock(&swap_lock);\n\t\tgoto out_dput;\n\t}\n\tif (!security_vm_enough_memory_mm(current->mm, p->pages))\n\t\tvm_unacct_memory(p->pages);\n\telse {\n\t\terr = -ENOMEM;\n\t\tspin_unlock(&swap_lock);\n\t\tgoto out_dput;\n\t}\n\tdel_from_avail_list(p);\n\tspin_lock(&p->lock);\n\tif (p->prio < 0) {\n\t\tstruct swap_info_struct *si = p;\n\t\tint nid;\n\n\t\tplist_for_each_entry_continue(si, &swap_active_head, list) {\n\t\t\tsi->prio++;\n\t\t\tsi->list.prio--;\n\t\t\tfor_each_node(nid) {\n\t\t\t\tif (si->avail_lists[nid].prio != 1)\n\t\t\t\t\tsi->avail_lists[nid].prio--;\n\t\t\t}\n\t\t}\n\t\tleast_priority++;\n\t}\n\tplist_del(&p->list, &swap_active_head);\n\tatomic_long_sub(p->pages, &nr_swap_pages);\n\ttotal_swap_pages -= p->pages;\n\tp->flags &= ~SWP_WRITEOK;\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\n\tdisable_swap_slots_cache_lock();\n\n\tset_current_oom_origin();\n\terr = try_to_unuse(p->type, false, 0); /* force unuse all pages */\n\tclear_current_oom_origin();\n\n\tif (err) {\n\t\t/* re-insert swap space back into swap_list */\n\t\treinsert_swap_info(p);\n\t\treenable_swap_slots_cache_unlock();\n\t\tgoto out_dput;\n\t}\n\n\treenable_swap_slots_cache_unlock();\n\n\tflush_work(&p->discard_work);\n\n\tdestroy_swap_extents(p);\n\tif (p->flags & SWP_CONTINUED)\n\t\tfree_swap_count_continuations(p);\n\n\tif (!p->bdev || !blk_queue_nonrot(bdev_get_queue(p->bdev)))\n\t\tatomic_dec(&nr_rotate_swap);\n\n\tmutex_lock(&swapon_mutex);\n\tspin_lock(&swap_lock);\n\tspin_lock(&p->lock);\n\tdrain_mmlist();\n\n\t/* wait for anyone still in scan_swap_map */\n\tp->highest_bit = 0;\t\t/* cuts scans short */\n\twhile (p->flags >= SWP_SCANNING) {\n\t\tspin_unlock(&p->lock);\n\t\tspin_unlock(&swap_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&swap_lock);\n\t\tspin_lock(&p->lock);\n\t}\n\n\tswap_file = p->swap_file;\n\told_block_size = p->old_block_size;\n\tp->swap_file = NULL;\n\tp->max = 0;\n\tswap_map = p->swap_map;\n\tp->swap_map = NULL;\n\tcluster_info = p->cluster_info;\n\tp->cluster_info = NULL;\n\tfrontswap_map = frontswap_map_get(p);\n\tspin_unlock(&p->lock);\n\tspin_unlock(&swap_lock);\n\tfrontswap_invalidate_area(p->type);\n\tfrontswap_map_set(p, NULL);\n\tmutex_unlock(&swapon_mutex);\n\tfree_percpu(p->percpu_cluster);\n\tp->percpu_cluster = NULL;\n\tvfree(swap_map);\n\tkvfree(cluster_info);\n\tkvfree(frontswap_map);\n\t/* Destroy swap account information */\n\tswap_cgroup_swapoff(p->type);\n\texit_swap_address_space(p->type);\n\n\tinode = mapping->host;\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tstruct block_device *bdev = I_BDEV(inode);\n\t\tset_blocksize(bdev, old_block_size);\n\t\tblkdev_put(bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);\n\t} else {\n\t\tinode_lock(inode);\n\t\tinode->i_flags &= ~S_SWAPFILE;\n\t\tinode_unlock(inode);\n\t}\n\tfilp_close(swap_file, NULL);\n\n\t/*\n\t * Clear the SWP_USED flag after all resources are freed so that swapon\n\t * can reuse this swap_info in alloc_swap_info() safely.  It is ok to\n\t * not hold p->lock after we cleared its SWP_WRITEOK.\n\t */\n\tspin_lock(&swap_lock);\n\tp->flags = 0;\n\tspin_unlock(&swap_lock);\n\n\terr = 0;\n\tatomic_inc(&proc_poll_event);\n\twake_up_interruptible(&proc_poll_wait);\n\nout_dput:\n\tfilp_close(victim, NULL);\nout:\n\tputname(pathname);\n\treturn err;\n}"
  },
  {
    "function_name": "swapon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
    "lines": "3088-3325",
    "snippet": "SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n{\n\tstruct swap_info_struct *p;\n\tstruct filename *name;\n\tstruct file *swap_file = NULL;\n\tstruct address_space *mapping;\n\tint prio;\n\tint error;\n\tunion swap_header *swap_header;\n\tint nr_extents;\n\tsector_t span;\n\tunsigned long maxpages;\n\tunsigned char *swap_map = NULL;\n\tstruct swap_cluster_info *cluster_info = NULL;\n\tunsigned long *frontswap_map = NULL;\n\tstruct page *page = NULL;\n\tstruct inode *inode = NULL;\n\tbool inced_nr_rotate_swap = false;\n\n\tif (swap_flags & ~SWAP_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!swap_avail_heads)\n\t\treturn -ENOMEM;\n\n\tp = alloc_swap_info();\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tINIT_WORK(&p->discard_work, swap_discard_work);\n\n\tname = getname(specialfile);\n\tif (IS_ERR(name)) {\n\t\terror = PTR_ERR(name);\n\t\tname = NULL;\n\t\tgoto bad_swap;\n\t}\n\tswap_file = file_open_name(name, O_RDWR|O_LARGEFILE, 0);\n\tif (IS_ERR(swap_file)) {\n\t\terror = PTR_ERR(swap_file);\n\t\tswap_file = NULL;\n\t\tgoto bad_swap;\n\t}\n\n\tp->swap_file = swap_file;\n\tmapping = swap_file->f_mapping;\n\tinode = mapping->host;\n\n\t/* If S_ISREG(inode->i_mode) will do inode_lock(inode); */\n\terror = claim_swapfile(p, inode);\n\tif (unlikely(error))\n\t\tgoto bad_swap;\n\n\t/*\n\t * Read the swap header.\n\t */\n\tif (!mapping->a_ops->readpage) {\n\t\terror = -EINVAL;\n\t\tgoto bad_swap;\n\t}\n\tpage = read_mapping_page(mapping, 0, swap_file);\n\tif (IS_ERR(page)) {\n\t\terror = PTR_ERR(page);\n\t\tgoto bad_swap;\n\t}\n\tswap_header = kmap(page);\n\n\tmaxpages = read_swap_header(p, swap_header, inode);\n\tif (unlikely(!maxpages)) {\n\t\terror = -EINVAL;\n\t\tgoto bad_swap;\n\t}\n\n\t/* OK, set up the swap map and apply the bad block list */\n\tswap_map = vzalloc(maxpages);\n\tif (!swap_map) {\n\t\terror = -ENOMEM;\n\t\tgoto bad_swap;\n\t}\n\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(inode)))\n\t\tp->flags |= SWP_STABLE_WRITES;\n\n\tif (bdi_cap_synchronous_io(inode_to_bdi(inode)))\n\t\tp->flags |= SWP_SYNCHRONOUS_IO;\n\n\tif (p->bdev && blk_queue_nonrot(bdev_get_queue(p->bdev))) {\n\t\tint cpu;\n\t\tunsigned long ci, nr_cluster;\n\n\t\tp->flags |= SWP_SOLIDSTATE;\n\t\t/*\n\t\t * select a random position to start with to help wear leveling\n\t\t * SSD\n\t\t */\n\t\tp->cluster_next = 1 + (prandom_u32() % p->highest_bit);\n\t\tnr_cluster = DIV_ROUND_UP(maxpages, SWAPFILE_CLUSTER);\n\n\t\tcluster_info = kvcalloc(nr_cluster, sizeof(*cluster_info),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!cluster_info) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto bad_swap;\n\t\t}\n\n\t\tfor (ci = 0; ci < nr_cluster; ci++)\n\t\t\tspin_lock_init(&((cluster_info + ci)->lock));\n\n\t\tp->percpu_cluster = alloc_percpu(struct percpu_cluster);\n\t\tif (!p->percpu_cluster) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto bad_swap;\n\t\t}\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct percpu_cluster *cluster;\n\t\t\tcluster = per_cpu_ptr(p->percpu_cluster, cpu);\n\t\t\tcluster_set_null(&cluster->index);\n\t\t}\n\t} else {\n\t\tatomic_inc(&nr_rotate_swap);\n\t\tinced_nr_rotate_swap = true;\n\t}\n\n\terror = swap_cgroup_swapon(p->type, maxpages);\n\tif (error)\n\t\tgoto bad_swap;\n\n\tnr_extents = setup_swap_map_and_extents(p, swap_header, swap_map,\n\t\tcluster_info, maxpages, &span);\n\tif (unlikely(nr_extents < 0)) {\n\t\terror = nr_extents;\n\t\tgoto bad_swap;\n\t}\n\t/* frontswap enabled? set up bit-per-page map for frontswap */\n\tif (IS_ENABLED(CONFIG_FRONTSWAP))\n\t\tfrontswap_map = kvcalloc(BITS_TO_LONGS(maxpages),\n\t\t\t\t\t sizeof(long),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (p->bdev &&(swap_flags & SWAP_FLAG_DISCARD) && swap_discardable(p)) {\n\t\t/*\n\t\t * When discard is enabled for swap with no particular\n\t\t * policy flagged, we set all swap discard flags here in\n\t\t * order to sustain backward compatibility with older\n\t\t * swapon(8) releases.\n\t\t */\n\t\tp->flags |= (SWP_DISCARDABLE | SWP_AREA_DISCARD |\n\t\t\t     SWP_PAGE_DISCARD);\n\n\t\t/*\n\t\t * By flagging sys_swapon, a sysadmin can tell us to\n\t\t * either do single-time area discards only, or to just\n\t\t * perform discards for released swap page-clusters.\n\t\t * Now it's time to adjust the p->flags accordingly.\n\t\t */\n\t\tif (swap_flags & SWAP_FLAG_DISCARD_ONCE)\n\t\t\tp->flags &= ~SWP_PAGE_DISCARD;\n\t\telse if (swap_flags & SWAP_FLAG_DISCARD_PAGES)\n\t\t\tp->flags &= ~SWP_AREA_DISCARD;\n\n\t\t/* issue a swapon-time discard if it's still required */\n\t\tif (p->flags & SWP_AREA_DISCARD) {\n\t\t\tint err = discard_swap(p);\n\t\t\tif (unlikely(err))\n\t\t\t\tpr_err(\"swapon: discard_swap(%p): %d\\n\",\n\t\t\t\t\tp, err);\n\t\t}\n\t}\n\n\terror = init_swap_address_space(p->type, maxpages);\n\tif (error)\n\t\tgoto bad_swap;\n\n\tmutex_lock(&swapon_mutex);\n\tprio = -1;\n\tif (swap_flags & SWAP_FLAG_PREFER)\n\t\tprio =\n\t\t  (swap_flags & SWAP_FLAG_PRIO_MASK) >> SWAP_FLAG_PRIO_SHIFT;\n\tenable_swap_info(p, prio, swap_map, cluster_info, frontswap_map);\n\n\tpr_info(\"Adding %uk swap on %s.  Priority:%d extents:%d across:%lluk %s%s%s%s%s\\n\",\n\t\tp->pages<<(PAGE_SHIFT-10), name->name, p->prio,\n\t\tnr_extents, (unsigned long long)span<<(PAGE_SHIFT-10),\n\t\t(p->flags & SWP_SOLIDSTATE) ? \"SS\" : \"\",\n\t\t(p->flags & SWP_DISCARDABLE) ? \"D\" : \"\",\n\t\t(p->flags & SWP_AREA_DISCARD) ? \"s\" : \"\",\n\t\t(p->flags & SWP_PAGE_DISCARD) ? \"c\" : \"\",\n\t\t(frontswap_map) ? \"FS\" : \"\");\n\n\tmutex_unlock(&swapon_mutex);\n\tatomic_inc(&proc_poll_event);\n\twake_up_interruptible(&proc_poll_wait);\n\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_flags |= S_SWAPFILE;\n\terror = 0;\n\tgoto out;\nbad_swap:\n\tfree_percpu(p->percpu_cluster);\n\tp->percpu_cluster = NULL;\n\tif (inode && S_ISBLK(inode->i_mode) && p->bdev) {\n\t\tset_blocksize(p->bdev, p->old_block_size);\n\t\tblkdev_put(p->bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);\n\t}\n\tdestroy_swap_extents(p);\n\tswap_cgroup_swapoff(p->type);\n\tspin_lock(&swap_lock);\n\tp->swap_file = NULL;\n\tp->flags = 0;\n\tspin_unlock(&swap_lock);\n\tvfree(swap_map);\n\tkvfree(cluster_info);\n\tkvfree(frontswap_map);\n\tif (inced_nr_rotate_swap)\n\t\tatomic_dec(&nr_rotate_swap);\n\tif (swap_file) {\n\t\tif (inode && S_ISREG(inode->i_mode)) {\n\t\t\tinode_unlock(inode);\n\t\t\tinode = NULL;\n\t\t}\n\t\tfilp_close(swap_file, NULL);\n\t}\nout:\n\tif (page && !IS_ERR(page)) {\n\t\tkunmap(page);\n\t\tput_page(page);\n\t}\n\tif (name)\n\t\tputname(name);\n\tif (inode && S_ISREG(inode->i_mode))\n\t\tinode_unlock(inode);\n\tif (!error)\n\t\tenable_swap_slots_cache();\n\treturn error;\n}",
    "includes": [
      "#include <linux/swap_cgroup.h>",
      "#include <linux/swapops.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/sort.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/export.h>",
      "#include <linux/swapfile.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/oom.h>",
      "#include <linux/poll.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/capability.h>",
      "#include <linux/mutex.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAPFILE_CLUSTER\t256",
      "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
    ],
    "globals_used": [
      "static void free_swap_count_continuations(struct swap_info_struct *);",
      "static struct plist_head *swap_avail_heads;",
      "static DEFINE_MUTEX(swapon_mutex);",
      "static DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);",
      "static atomic_t proc_poll_event = ATOMIC_INIT(0);",
      "atomic_t nr_rotate_swap = ATOMIC_INIT(0);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_MUTEX(swapon_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);\nstatic atomic_t proc_poll_event = ATOMIC_INIT(0);\natomic_t nr_rotate_swap = ATOMIC_INIT(0);\n\nSYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n{\n\tstruct swap_info_struct *p;\n\tstruct filename *name;\n\tstruct file *swap_file = NULL;\n\tstruct address_space *mapping;\n\tint prio;\n\tint error;\n\tunion swap_header *swap_header;\n\tint nr_extents;\n\tsector_t span;\n\tunsigned long maxpages;\n\tunsigned char *swap_map = NULL;\n\tstruct swap_cluster_info *cluster_info = NULL;\n\tunsigned long *frontswap_map = NULL;\n\tstruct page *page = NULL;\n\tstruct inode *inode = NULL;\n\tbool inced_nr_rotate_swap = false;\n\n\tif (swap_flags & ~SWAP_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!swap_avail_heads)\n\t\treturn -ENOMEM;\n\n\tp = alloc_swap_info();\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tINIT_WORK(&p->discard_work, swap_discard_work);\n\n\tname = getname(specialfile);\n\tif (IS_ERR(name)) {\n\t\terror = PTR_ERR(name);\n\t\tname = NULL;\n\t\tgoto bad_swap;\n\t}\n\tswap_file = file_open_name(name, O_RDWR|O_LARGEFILE, 0);\n\tif (IS_ERR(swap_file)) {\n\t\terror = PTR_ERR(swap_file);\n\t\tswap_file = NULL;\n\t\tgoto bad_swap;\n\t}\n\n\tp->swap_file = swap_file;\n\tmapping = swap_file->f_mapping;\n\tinode = mapping->host;\n\n\t/* If S_ISREG(inode->i_mode) will do inode_lock(inode); */\n\terror = claim_swapfile(p, inode);\n\tif (unlikely(error))\n\t\tgoto bad_swap;\n\n\t/*\n\t * Read the swap header.\n\t */\n\tif (!mapping->a_ops->readpage) {\n\t\terror = -EINVAL;\n\t\tgoto bad_swap;\n\t}\n\tpage = read_mapping_page(mapping, 0, swap_file);\n\tif (IS_ERR(page)) {\n\t\terror = PTR_ERR(page);\n\t\tgoto bad_swap;\n\t}\n\tswap_header = kmap(page);\n\n\tmaxpages = read_swap_header(p, swap_header, inode);\n\tif (unlikely(!maxpages)) {\n\t\terror = -EINVAL;\n\t\tgoto bad_swap;\n\t}\n\n\t/* OK, set up the swap map and apply the bad block list */\n\tswap_map = vzalloc(maxpages);\n\tif (!swap_map) {\n\t\terror = -ENOMEM;\n\t\tgoto bad_swap;\n\t}\n\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(inode)))\n\t\tp->flags |= SWP_STABLE_WRITES;\n\n\tif (bdi_cap_synchronous_io(inode_to_bdi(inode)))\n\t\tp->flags |= SWP_SYNCHRONOUS_IO;\n\n\tif (p->bdev && blk_queue_nonrot(bdev_get_queue(p->bdev))) {\n\t\tint cpu;\n\t\tunsigned long ci, nr_cluster;\n\n\t\tp->flags |= SWP_SOLIDSTATE;\n\t\t/*\n\t\t * select a random position to start with to help wear leveling\n\t\t * SSD\n\t\t */\n\t\tp->cluster_next = 1 + (prandom_u32() % p->highest_bit);\n\t\tnr_cluster = DIV_ROUND_UP(maxpages, SWAPFILE_CLUSTER);\n\n\t\tcluster_info = kvcalloc(nr_cluster, sizeof(*cluster_info),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!cluster_info) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto bad_swap;\n\t\t}\n\n\t\tfor (ci = 0; ci < nr_cluster; ci++)\n\t\t\tspin_lock_init(&((cluster_info + ci)->lock));\n\n\t\tp->percpu_cluster = alloc_percpu(struct percpu_cluster);\n\t\tif (!p->percpu_cluster) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto bad_swap;\n\t\t}\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct percpu_cluster *cluster;\n\t\t\tcluster = per_cpu_ptr(p->percpu_cluster, cpu);\n\t\t\tcluster_set_null(&cluster->index);\n\t\t}\n\t} else {\n\t\tatomic_inc(&nr_rotate_swap);\n\t\tinced_nr_rotate_swap = true;\n\t}\n\n\terror = swap_cgroup_swapon(p->type, maxpages);\n\tif (error)\n\t\tgoto bad_swap;\n\n\tnr_extents = setup_swap_map_and_extents(p, swap_header, swap_map,\n\t\tcluster_info, maxpages, &span);\n\tif (unlikely(nr_extents < 0)) {\n\t\terror = nr_extents;\n\t\tgoto bad_swap;\n\t}\n\t/* frontswap enabled? set up bit-per-page map for frontswap */\n\tif (IS_ENABLED(CONFIG_FRONTSWAP))\n\t\tfrontswap_map = kvcalloc(BITS_TO_LONGS(maxpages),\n\t\t\t\t\t sizeof(long),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (p->bdev &&(swap_flags & SWAP_FLAG_DISCARD) && swap_discardable(p)) {\n\t\t/*\n\t\t * When discard is enabled for swap with no particular\n\t\t * policy flagged, we set all swap discard flags here in\n\t\t * order to sustain backward compatibility with older\n\t\t * swapon(8) releases.\n\t\t */\n\t\tp->flags |= (SWP_DISCARDABLE | SWP_AREA_DISCARD |\n\t\t\t     SWP_PAGE_DISCARD);\n\n\t\t/*\n\t\t * By flagging sys_swapon, a sysadmin can tell us to\n\t\t * either do single-time area discards only, or to just\n\t\t * perform discards for released swap page-clusters.\n\t\t * Now it's time to adjust the p->flags accordingly.\n\t\t */\n\t\tif (swap_flags & SWAP_FLAG_DISCARD_ONCE)\n\t\t\tp->flags &= ~SWP_PAGE_DISCARD;\n\t\telse if (swap_flags & SWAP_FLAG_DISCARD_PAGES)\n\t\t\tp->flags &= ~SWP_AREA_DISCARD;\n\n\t\t/* issue a swapon-time discard if it's still required */\n\t\tif (p->flags & SWP_AREA_DISCARD) {\n\t\t\tint err = discard_swap(p);\n\t\t\tif (unlikely(err))\n\t\t\t\tpr_err(\"swapon: discard_swap(%p): %d\\n\",\n\t\t\t\t\tp, err);\n\t\t}\n\t}\n\n\terror = init_swap_address_space(p->type, maxpages);\n\tif (error)\n\t\tgoto bad_swap;\n\n\tmutex_lock(&swapon_mutex);\n\tprio = -1;\n\tif (swap_flags & SWAP_FLAG_PREFER)\n\t\tprio =\n\t\t  (swap_flags & SWAP_FLAG_PRIO_MASK) >> SWAP_FLAG_PRIO_SHIFT;\n\tenable_swap_info(p, prio, swap_map, cluster_info, frontswap_map);\n\n\tpr_info(\"Adding %uk swap on %s.  Priority:%d extents:%d across:%lluk %s%s%s%s%s\\n\",\n\t\tp->pages<<(PAGE_SHIFT-10), name->name, p->prio,\n\t\tnr_extents, (unsigned long long)span<<(PAGE_SHIFT-10),\n\t\t(p->flags & SWP_SOLIDSTATE) ? \"SS\" : \"\",\n\t\t(p->flags & SWP_DISCARDABLE) ? \"D\" : \"\",\n\t\t(p->flags & SWP_AREA_DISCARD) ? \"s\" : \"\",\n\t\t(p->flags & SWP_PAGE_DISCARD) ? \"c\" : \"\",\n\t\t(frontswap_map) ? \"FS\" : \"\");\n\n\tmutex_unlock(&swapon_mutex);\n\tatomic_inc(&proc_poll_event);\n\twake_up_interruptible(&proc_poll_wait);\n\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_flags |= S_SWAPFILE;\n\terror = 0;\n\tgoto out;\nbad_swap:\n\tfree_percpu(p->percpu_cluster);\n\tp->percpu_cluster = NULL;\n\tif (inode && S_ISBLK(inode->i_mode) && p->bdev) {\n\t\tset_blocksize(p->bdev, p->old_block_size);\n\t\tblkdev_put(p->bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);\n\t}\n\tdestroy_swap_extents(p);\n\tswap_cgroup_swapoff(p->type);\n\tspin_lock(&swap_lock);\n\tp->swap_file = NULL;\n\tp->flags = 0;\n\tspin_unlock(&swap_lock);\n\tvfree(swap_map);\n\tkvfree(cluster_info);\n\tkvfree(frontswap_map);\n\tif (inced_nr_rotate_swap)\n\t\tatomic_dec(&nr_rotate_swap);\n\tif (swap_file) {\n\t\tif (inode && S_ISREG(inode->i_mode)) {\n\t\t\tinode_unlock(inode);\n\t\t\tinode = NULL;\n\t\t}\n\t\tfilp_close(swap_file, NULL);\n\t}\nout:\n\tif (page && !IS_ERR(page)) {\n\t\tkunmap(page);\n\t\tput_page(page);\n\t}\n\tif (name)\n\t\tputname(name);\n\tif (inode && S_ISREG(inode->i_mode))\n\t\tinode_unlock(inode);\n\tif (!error)\n\t\tenable_swap_slots_cache();\n\treturn error;\n}"
  }
]