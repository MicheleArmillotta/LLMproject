[
  {
    "function_name": "pcpu_verify_alloc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "375-379",
    "snippet": "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)\n{\n\t/* no extra restriction */\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)\n{\n\t/* no extra restriction */\n\treturn 0;\n}"
  },
  {
    "function_name": "pcpu_addr_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "370-373",
    "snippet": "static struct page *pcpu_addr_to_page(void *addr)\n{\n\treturn vmalloc_to_page(addr);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "addr"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "264-267",
          "snippet": "struct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "static struct page *pcpu_addr_to_page(void *addr)\n{\n\treturn vmalloc_to_page(addr);\n}"
  },
  {
    "function_name": "pcpu_destroy_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "357-368",
    "snippet": "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\n\tpcpu_stats_chunk_dealloc();\n\ttrace_percpu_destroy_chunk(chunk->base_addr);\n\n\tif (chunk->data)\n\t\tpcpu_free_vm_areas(chunk->data, pcpu_nr_groups);\n\tpcpu_free_chunk(chunk);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_free_chunk",
          "args": [
            "chunk"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1211-1219",
          "snippet": "static void pcpu_free_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\tpcpu_mem_free(chunk->md_blocks);\n\tpcpu_mem_free(chunk->bound_map);\n\tpcpu_mem_free(chunk->alloc_map);\n\tpcpu_mem_free(chunk);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_free_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\tpcpu_mem_free(chunk->md_blocks);\n\tpcpu_mem_free(chunk->bound_map);\n\tpcpu_mem_free(chunk->alloc_map);\n\tpcpu_mem_free(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_free_vm_areas",
          "args": [
            "chunk->data",
            "pcpu_nr_groups"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_vm_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2627-2634",
          "snippet": "void pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_vms; i++)\n\t\tfree_vm_area(vms[i]);\n\tkfree(vms);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_vms; i++)\n\t\tfree_vm_area(vms[i]);\n\tkfree(vms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_percpu_destroy_chunk",
          "args": [
            "chunk->base_addr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_stats_chunk_dealloc",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_stats_chunk_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "219-221",
          "snippet": "static inline void pcpu_stats_chunk_dealloc(void)\n{\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline void pcpu_stats_chunk_dealloc(void)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\n\tpcpu_stats_chunk_dealloc();\n\ttrace_percpu_destroy_chunk(chunk->base_addr);\n\n\tif (chunk->data)\n\t\tpcpu_free_vm_areas(chunk->data, pcpu_nr_groups);\n\tpcpu_free_chunk(chunk);\n}"
  },
  {
    "function_name": "pcpu_create_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "332-355",
    "snippet": "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp)\n{\n\tstruct pcpu_chunk *chunk;\n\tstruct vm_struct **vms;\n\n\tchunk = pcpu_alloc_chunk(gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tvms = pcpu_get_vm_areas(pcpu_group_offsets, pcpu_group_sizes,\n\t\t\t\tpcpu_nr_groups, pcpu_atom_size);\n\tif (!vms) {\n\t\tpcpu_free_chunk(chunk);\n\t\treturn NULL;\n\t}\n\n\tchunk->data = vms;\n\tchunk->base_addr = vms[0]->addr - pcpu_group_offsets[0];\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(chunk->base_addr);\n\n\treturn chunk;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_percpu_create_chunk",
          "args": [
            "chunk->base_addr"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_stats_chunk_alloc",
          "args": [],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_stats_chunk_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-internal.h",
          "lines": "215-217",
          "snippet": "static inline void pcpu_stats_chunk_alloc(void)\n{\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/percpu.h>\n#include <linux/types.h>\n\nstatic inline void pcpu_stats_chunk_alloc(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_free_chunk",
          "args": [
            "chunk"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1211-1219",
          "snippet": "static void pcpu_free_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\tpcpu_mem_free(chunk->md_blocks);\n\tpcpu_mem_free(chunk->bound_map);\n\tpcpu_mem_free(chunk->alloc_map);\n\tpcpu_mem_free(chunk);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic void pcpu_free_chunk(struct pcpu_chunk *chunk)\n{\n\tif (!chunk)\n\t\treturn;\n\tpcpu_mem_free(chunk->md_blocks);\n\tpcpu_mem_free(chunk->bound_map);\n\tpcpu_mem_free(chunk->alloc_map);\n\tpcpu_mem_free(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_get_vm_areas",
          "args": [
            "pcpu_group_offsets",
            "pcpu_group_sizes",
            "pcpu_nr_groups",
            "pcpu_atom_size"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_vm_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2470-2618",
          "snippet": "struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,\n\t\t\t\t     const size_t *sizes, int nr_vms,\n\t\t\t\t     size_t align)\n{\n\tconst unsigned long vmalloc_start = ALIGN(VMALLOC_START, align);\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tstruct vmap_area **vas, *prev, *next;\n\tstruct vm_struct **vms;\n\tint area, area2, last_area, term_area;\n\tunsigned long base, start, end, last_end;\n\tbool purged = false;\n\n\t/* verify parameters and allocate data structures */\n\tBUG_ON(offset_in_page(align) || !is_power_of_2(align));\n\tfor (last_area = 0, area = 0; area < nr_vms; area++) {\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\n\t\t/* is everything aligned properly? */\n\t\tBUG_ON(!IS_ALIGNED(offsets[area], align));\n\t\tBUG_ON(!IS_ALIGNED(sizes[area], align));\n\n\t\t/* detect the area with the highest address */\n\t\tif (start > offsets[last_area])\n\t\t\tlast_area = area;\n\n\t\tfor (area2 = area + 1; area2 < nr_vms; area2++) {\n\t\t\tunsigned long start2 = offsets[area2];\n\t\t\tunsigned long end2 = start2 + sizes[area2];\n\n\t\t\tBUG_ON(start2 < end && start < end2);\n\t\t}\n\t}\n\tlast_end = offsets[last_area] + sizes[last_area];\n\n\tif (vmalloc_end - vmalloc_start < last_end) {\n\t\tWARN_ON(true);\n\t\treturn NULL;\n\t}\n\n\tvms = kcalloc(nr_vms, sizeof(vms[0]), GFP_KERNEL);\n\tvas = kcalloc(nr_vms, sizeof(vas[0]), GFP_KERNEL);\n\tif (!vas || !vms)\n\t\tgoto err_free2;\n\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tvas[area] = kzalloc(sizeof(struct vmap_area), GFP_KERNEL);\n\t\tvms[area] = kzalloc(sizeof(struct vm_struct), GFP_KERNEL);\n\t\tif (!vas[area] || !vms[area])\n\t\t\tgoto err_free;\n\t}\nretry:\n\tspin_lock(&vmap_area_lock);\n\n\t/* start scanning - we scan from the top, begin with the last area */\n\tarea = term_area = last_area;\n\tstart = offsets[area];\n\tend = start + sizes[area];\n\n\tif (!pvm_find_next_prev(vmap_area_pcpu_hole, &next, &prev)) {\n\t\tbase = vmalloc_end - last_end;\n\t\tgoto found;\n\t}\n\tbase = pvm_determine_end(&next, &prev, align) - end;\n\n\twhile (true) {\n\t\tBUG_ON(next && next->va_end <= base + end);\n\t\tBUG_ON(prev && prev->va_end > base + end);\n\n\t\t/*\n\t\t * base might have underflowed, add last_end before\n\t\t * comparing.\n\t\t */\n\t\tif (base + last_end < vmalloc_start + last_end) {\n\t\t\tspin_unlock(&vmap_area_lock);\n\t\t\tif (!purged) {\n\t\t\t\tpurge_vmap_area_lazy();\n\t\t\t\tpurged = true;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/*\n\t\t * If next overlaps, move base downwards so that it's\n\t\t * right below next and then recheck.\n\t\t */\n\t\tif (next && next->va_start < base + end) {\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If prev overlaps, shift down next and prev and move\n\t\t * base so that it's right below new next and then\n\t\t * recheck.\n\t\t */\n\t\tif (prev && prev->va_end > base + start)  {\n\t\t\tnext = prev;\n\t\t\tprev = node_to_va(rb_prev(&next->rb_node));\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This area fits, move on to the previous one.  If\n\t\t * the previous one is the terminal one, we're done.\n\t\t */\n\t\tarea = (area + nr_vms - 1) % nr_vms;\n\t\tif (area == term_area)\n\t\t\tbreak;\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\t\tpvm_find_next_prev(base + end, &next, &prev);\n\t}\nfound:\n\t/* we've found a fitting base, insert all va's */\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tstruct vmap_area *va = vas[area];\n\n\t\tva->va_start = base + offsets[area];\n\t\tva->va_end = va->va_start + sizes[area];\n\t\t__insert_vmap_area(va);\n\t}\n\n\tvmap_area_pcpu_hole = base + offsets[last_area];\n\n\tspin_unlock(&vmap_area_lock);\n\n\t/* insert all vm's */\n\tfor (area = 0; area < nr_vms; area++)\n\t\tsetup_vmalloc_vm(vms[area], vas[area], VM_ALLOC,\n\t\t\t\t pcpu_get_vm_areas);\n\n\tkfree(vas);\n\treturn vms;\n\nerr_free:\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tkfree(vas[area]);\n\t\tkfree(vms[area]);\n\t}\nerr_free2:\n\tkfree(vas);\n\tkfree(vms);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static unsigned long vmap_area_pcpu_hole;",
            "static void purge_vmap_area_lazy(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic unsigned long vmap_area_pcpu_hole;\nstatic void purge_vmap_area_lazy(void);\n\nstruct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,\n\t\t\t\t     const size_t *sizes, int nr_vms,\n\t\t\t\t     size_t align)\n{\n\tconst unsigned long vmalloc_start = ALIGN(VMALLOC_START, align);\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tstruct vmap_area **vas, *prev, *next;\n\tstruct vm_struct **vms;\n\tint area, area2, last_area, term_area;\n\tunsigned long base, start, end, last_end;\n\tbool purged = false;\n\n\t/* verify parameters and allocate data structures */\n\tBUG_ON(offset_in_page(align) || !is_power_of_2(align));\n\tfor (last_area = 0, area = 0; area < nr_vms; area++) {\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\n\t\t/* is everything aligned properly? */\n\t\tBUG_ON(!IS_ALIGNED(offsets[area], align));\n\t\tBUG_ON(!IS_ALIGNED(sizes[area], align));\n\n\t\t/* detect the area with the highest address */\n\t\tif (start > offsets[last_area])\n\t\t\tlast_area = area;\n\n\t\tfor (area2 = area + 1; area2 < nr_vms; area2++) {\n\t\t\tunsigned long start2 = offsets[area2];\n\t\t\tunsigned long end2 = start2 + sizes[area2];\n\n\t\t\tBUG_ON(start2 < end && start < end2);\n\t\t}\n\t}\n\tlast_end = offsets[last_area] + sizes[last_area];\n\n\tif (vmalloc_end - vmalloc_start < last_end) {\n\t\tWARN_ON(true);\n\t\treturn NULL;\n\t}\n\n\tvms = kcalloc(nr_vms, sizeof(vms[0]), GFP_KERNEL);\n\tvas = kcalloc(nr_vms, sizeof(vas[0]), GFP_KERNEL);\n\tif (!vas || !vms)\n\t\tgoto err_free2;\n\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tvas[area] = kzalloc(sizeof(struct vmap_area), GFP_KERNEL);\n\t\tvms[area] = kzalloc(sizeof(struct vm_struct), GFP_KERNEL);\n\t\tif (!vas[area] || !vms[area])\n\t\t\tgoto err_free;\n\t}\nretry:\n\tspin_lock(&vmap_area_lock);\n\n\t/* start scanning - we scan from the top, begin with the last area */\n\tarea = term_area = last_area;\n\tstart = offsets[area];\n\tend = start + sizes[area];\n\n\tif (!pvm_find_next_prev(vmap_area_pcpu_hole, &next, &prev)) {\n\t\tbase = vmalloc_end - last_end;\n\t\tgoto found;\n\t}\n\tbase = pvm_determine_end(&next, &prev, align) - end;\n\n\twhile (true) {\n\t\tBUG_ON(next && next->va_end <= base + end);\n\t\tBUG_ON(prev && prev->va_end > base + end);\n\n\t\t/*\n\t\t * base might have underflowed, add last_end before\n\t\t * comparing.\n\t\t */\n\t\tif (base + last_end < vmalloc_start + last_end) {\n\t\t\tspin_unlock(&vmap_area_lock);\n\t\t\tif (!purged) {\n\t\t\t\tpurge_vmap_area_lazy();\n\t\t\t\tpurged = true;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/*\n\t\t * If next overlaps, move base downwards so that it's\n\t\t * right below next and then recheck.\n\t\t */\n\t\tif (next && next->va_start < base + end) {\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If prev overlaps, shift down next and prev and move\n\t\t * base so that it's right below new next and then\n\t\t * recheck.\n\t\t */\n\t\tif (prev && prev->va_end > base + start)  {\n\t\t\tnext = prev;\n\t\t\tprev = node_to_va(rb_prev(&next->rb_node));\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This area fits, move on to the previous one.  If\n\t\t * the previous one is the terminal one, we're done.\n\t\t */\n\t\tarea = (area + nr_vms - 1) % nr_vms;\n\t\tif (area == term_area)\n\t\t\tbreak;\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\t\tpvm_find_next_prev(base + end, &next, &prev);\n\t}\nfound:\n\t/* we've found a fitting base, insert all va's */\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tstruct vmap_area *va = vas[area];\n\n\t\tva->va_start = base + offsets[area];\n\t\tva->va_end = va->va_start + sizes[area];\n\t\t__insert_vmap_area(va);\n\t}\n\n\tvmap_area_pcpu_hole = base + offsets[last_area];\n\n\tspin_unlock(&vmap_area_lock);\n\n\t/* insert all vm's */\n\tfor (area = 0; area < nr_vms; area++)\n\t\tsetup_vmalloc_vm(vms[area], vas[area], VM_ALLOC,\n\t\t\t\t pcpu_get_vm_areas);\n\n\tkfree(vas);\n\treturn vms;\n\nerr_free:\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tkfree(vas[area]);\n\t\tkfree(vms[area]);\n\t}\nerr_free2:\n\tkfree(vas);\n\tkfree(vms);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_alloc_chunk",
          "args": [
            "gfp"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1165-1209",
          "snippet": "static struct pcpu_chunk *pcpu_alloc_chunk(gfp_t gfp)\n{\n\tstruct pcpu_chunk *chunk;\n\tint region_bits;\n\n\tchunk = pcpu_mem_zalloc(pcpu_chunk_struct_size, gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->list);\n\tchunk->nr_pages = pcpu_unit_pages;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits) *\n\t\t\t\t\t   sizeof(chunk->alloc_map[0]), gfp);\n\tif (!chunk->alloc_map)\n\t\tgoto alloc_map_fail;\n\n\tchunk->bound_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits + 1) *\n\t\t\t\t\t   sizeof(chunk->bound_map[0]), gfp);\n\tif (!chunk->bound_map)\n\t\tgoto bound_map_fail;\n\n\tchunk->md_blocks = pcpu_mem_zalloc(pcpu_chunk_nr_blocks(chunk) *\n\t\t\t\t\t   sizeof(chunk->md_blocks[0]), gfp);\n\tif (!chunk->md_blocks)\n\t\tgoto md_blocks_fail;\n\n\tpcpu_init_md_blocks(chunk);\n\n\t/* init metadata */\n\tchunk->contig_bits = region_bits;\n\tchunk->free_bytes = chunk->nr_pages * PAGE_SIZE;\n\n\treturn chunk;\n\nmd_blocks_fail:\n\tpcpu_mem_free(chunk->bound_map);\nbound_map_fail:\n\tpcpu_mem_free(chunk->alloc_map);\nalloc_map_fail:\n\tpcpu_mem_free(chunk);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static size_t pcpu_chunk_struct_size",
            "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
            "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic size_t pcpu_chunk_struct_size;\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic struct pcpu_chunk *pcpu_alloc_chunk(gfp_t gfp)\n{\n\tstruct pcpu_chunk *chunk;\n\tint region_bits;\n\n\tchunk = pcpu_mem_zalloc(pcpu_chunk_struct_size, gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->list);\n\tchunk->nr_pages = pcpu_unit_pages;\n\tregion_bits = pcpu_chunk_map_bits(chunk);\n\n\tchunk->alloc_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits) *\n\t\t\t\t\t   sizeof(chunk->alloc_map[0]), gfp);\n\tif (!chunk->alloc_map)\n\t\tgoto alloc_map_fail;\n\n\tchunk->bound_map = pcpu_mem_zalloc(BITS_TO_LONGS(region_bits + 1) *\n\t\t\t\t\t   sizeof(chunk->bound_map[0]), gfp);\n\tif (!chunk->bound_map)\n\t\tgoto bound_map_fail;\n\n\tchunk->md_blocks = pcpu_mem_zalloc(pcpu_chunk_nr_blocks(chunk) *\n\t\t\t\t\t   sizeof(chunk->md_blocks[0]), gfp);\n\tif (!chunk->md_blocks)\n\t\tgoto md_blocks_fail;\n\n\tpcpu_init_md_blocks(chunk);\n\n\t/* init metadata */\n\tchunk->contig_bits = region_bits;\n\tchunk->free_bytes = chunk->nr_pages * PAGE_SIZE;\n\n\treturn chunk;\n\nmd_blocks_fail:\n\tpcpu_mem_free(chunk->bound_map);\nbound_map_fail:\n\tpcpu_mem_free(chunk->alloc_map);\nalloc_map_fail:\n\tpcpu_mem_free(chunk);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp)\n{\n\tstruct pcpu_chunk *chunk;\n\tstruct vm_struct **vms;\n\n\tchunk = pcpu_alloc_chunk(gfp);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tvms = pcpu_get_vm_areas(pcpu_group_offsets, pcpu_group_sizes,\n\t\t\t\tpcpu_nr_groups, pcpu_atom_size);\n\tif (!vms) {\n\t\tpcpu_free_chunk(chunk);\n\t\treturn NULL;\n\t}\n\n\tchunk->data = vms;\n\tchunk->base_addr = vms[0]->addr - pcpu_group_offsets[0];\n\n\tpcpu_stats_chunk_alloc();\n\ttrace_percpu_create_chunk(chunk->base_addr);\n\n\treturn chunk;\n}"
  },
  {
    "function_name": "pcpu_depopulate_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "309-330",
    "snippet": "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end)\n{\n\tstruct page **pages;\n\n\t/*\n\t * If control reaches here, there must have been at least one\n\t * successful population attempt so the temp pages array must\n\t * be available now.\n\t */\n\tpages = pcpu_get_pages();\n\tBUG_ON(!pages);\n\n\t/* unmap and free */\n\tpcpu_pre_unmap_flush(chunk, page_start, page_end);\n\n\tpcpu_unmap_pages(chunk, pages, page_start, page_end);\n\n\t/* no need to flush tlb, vmalloc will handle it lazily */\n\n\tpcpu_free_pages(chunk, pages, page_start, page_end);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_free_pages",
          "args": [
            "chunk",
            "pages",
            "page_start",
            "page_end"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "54-68",
          "snippet": "static void pcpu_free_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page = pages[pcpu_page_idx(cpu, i)];\n\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void pcpu_free_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page = pages[pcpu_page_idx(cpu, i)];\n\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_unmap_pages",
          "args": [
            "chunk",
            "pages",
            "page_start",
            "page_end"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_unmap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "153-170",
          "snippet": "static void pcpu_unmap_pages(struct pcpu_chunk *chunk,\n\t\t\t     struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = pcpu_chunk_page(chunk, cpu, i);\n\t\t\tWARN_ON(!page);\n\t\t\tpages[pcpu_page_idx(cpu, i)] = page;\n\t\t}\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void pcpu_unmap_pages(struct pcpu_chunk *chunk,\n\t\t\t     struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = pcpu_chunk_page(chunk, cpu, i);\n\t\t\tWARN_ON(!page);\n\t\t\tpages[pcpu_page_idx(cpu, i)] = page;\n\t\t}\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_pre_unmap_flush",
          "args": [
            "chunk",
            "page_start",
            "page_end"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_pre_unmap_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "127-133",
          "snippet": "static void pcpu_pre_unmap_flush(struct pcpu_chunk *chunk,\n\t\t\t\t int page_start, int page_end)\n{\n\tflush_cache_vunmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void pcpu_pre_unmap_flush(struct pcpu_chunk *chunk,\n\t\t\t\t int page_start, int page_end)\n{\n\tflush_cache_vunmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pages"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_get_pages",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "32-42",
          "snippet": "static struct page **pcpu_get_pages(void)\n{\n\tstatic struct page **pages;\n\tsize_t pages_size = pcpu_nr_units * pcpu_unit_pages * sizeof(pages[0]);\n\n\tlockdep_assert_held(&pcpu_alloc_mutex);\n\n\tif (!pages)\n\t\tpages = pcpu_mem_zalloc(pages_size, GFP_KERNEL);\n\treturn pages;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static struct page **pcpu_get_pages(void)\n{\n\tstatic struct page **pages;\n\tsize_t pages_size = pcpu_nr_units * pcpu_unit_pages * sizeof(pages[0]);\n\n\tlockdep_assert_held(&pcpu_alloc_mutex);\n\n\tif (!pages)\n\t\tpages = pcpu_mem_zalloc(pages_size, GFP_KERNEL);\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\n\t\t\t\t  int page_start, int page_end)\n{\n\tstruct page **pages;\n\n\t/*\n\t * If control reaches here, there must have been at least one\n\t * successful population attempt so the temp pages array must\n\t * be available now.\n\t */\n\tpages = pcpu_get_pages();\n\tBUG_ON(!pages);\n\n\t/* unmap and free */\n\tpcpu_pre_unmap_flush(chunk, page_start, page_end);\n\n\tpcpu_unmap_pages(chunk, pages, page_start, page_end);\n\n\t/* no need to flush tlb, vmalloc will handle it lazily */\n\n\tpcpu_free_pages(chunk, pages, page_start, page_end);\n}"
  },
  {
    "function_name": "pcpu_populate_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "276-295",
    "snippet": "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp)\n{\n\tstruct page **pages;\n\n\tpages = pcpu_get_pages();\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tif (pcpu_alloc_pages(chunk, pages, page_start, page_end, gfp))\n\t\treturn -ENOMEM;\n\n\tif (pcpu_map_pages(chunk, pages, page_start, page_end)) {\n\t\tpcpu_free_pages(chunk, pages, page_start, page_end);\n\t\treturn -ENOMEM;\n\t}\n\tpcpu_post_map_flush(chunk, page_start, page_end);\n\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_post_map_flush",
          "args": [
            "chunk",
            "page_start",
            "page_end"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_post_map_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "255-261",
          "snippet": "static void pcpu_post_map_flush(struct pcpu_chunk *chunk,\n\t\t\t\tint page_start, int page_end)\n{\n\tflush_cache_vmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void pcpu_post_map_flush(struct pcpu_chunk *chunk,\n\t\t\t\tint page_start, int page_end)\n{\n\tflush_cache_vmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_free_pages",
          "args": [
            "chunk",
            "pages",
            "page_start",
            "page_end"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "54-68",
          "snippet": "static void pcpu_free_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page = pages[pcpu_page_idx(cpu, i)];\n\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void pcpu_free_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page = pages[pcpu_page_idx(cpu, i)];\n\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_map_pages",
          "args": [
            "chunk",
            "pages",
            "page_start",
            "page_end"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "214-241",
          "snippet": "static int pcpu_map_pages(struct pcpu_chunk *chunk,\n\t\t\t  struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu, tcpu;\n\tint i, err;\n\n\tfor_each_possible_cpu(cpu) {\n\t\terr = __pcpu_map_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t       &pages[pcpu_page_idx(cpu, page_start)],\n\t\t\t\t       page_end - page_start);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\tpcpu_set_page_chunk(pages[pcpu_page_idx(cpu, i)],\n\t\t\t\t\t    chunk);\n\t}\n\treturn 0;\nerr:\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, tcpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n\tpcpu_post_unmap_tlb_flush(chunk, page_start, page_end);\n\treturn err;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int pcpu_map_pages(struct pcpu_chunk *chunk,\n\t\t\t  struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu, tcpu;\n\tint i, err;\n\n\tfor_each_possible_cpu(cpu) {\n\t\terr = __pcpu_map_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t       &pages[pcpu_page_idx(cpu, page_start)],\n\t\t\t\t       page_end - page_start);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\tpcpu_set_page_chunk(pages[pcpu_page_idx(cpu, i)],\n\t\t\t\t\t    chunk);\n\t}\n\treturn 0;\nerr:\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, tcpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n\tpcpu_post_unmap_tlb_flush(chunk, page_start, page_end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_alloc_pages",
          "args": [
            "chunk",
            "pages",
            "page_start",
            "page_end",
            "gfp"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "82-113",
          "snippet": "static int pcpu_alloc_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end,\n\t\t\t    gfp_t gfp)\n{\n\tunsigned int cpu, tcpu;\n\tint i;\n\n\tgfp |= __GFP_HIGHMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page **pagep = &pages[pcpu_page_idx(cpu, i)];\n\n\t\t\t*pagep = alloc_pages_node(cpu_to_node(cpu), gfp, 0);\n\t\t\tif (!*pagep)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\twhile (--i >= page_start)\n\t\t__free_page(pages[pcpu_page_idx(cpu, i)]);\n\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\t__free_page(pages[pcpu_page_idx(tcpu, i)]);\n\t}\n\treturn -ENOMEM;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int pcpu_alloc_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end,\n\t\t\t    gfp_t gfp)\n{\n\tunsigned int cpu, tcpu;\n\tint i;\n\n\tgfp |= __GFP_HIGHMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page **pagep = &pages[pcpu_page_idx(cpu, i)];\n\n\t\t\t*pagep = alloc_pages_node(cpu_to_node(cpu), gfp, 0);\n\t\t\tif (!*pagep)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\twhile (--i >= page_start)\n\t\t__free_page(pages[pcpu_page_idx(cpu, i)]);\n\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\t__free_page(pages[pcpu_page_idx(tcpu, i)]);\n\t}\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_get_pages",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "32-42",
          "snippet": "static struct page **pcpu_get_pages(void)\n{\n\tstatic struct page **pages;\n\tsize_t pages_size = pcpu_nr_units * pcpu_unit_pages * sizeof(pages[0]);\n\n\tlockdep_assert_held(&pcpu_alloc_mutex);\n\n\tif (!pages)\n\t\tpages = pcpu_mem_zalloc(pages_size, GFP_KERNEL);\n\treturn pages;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static struct page **pcpu_get_pages(void)\n{\n\tstatic struct page **pages;\n\tsize_t pages_size = pcpu_nr_units * pcpu_unit_pages * sizeof(pages[0]);\n\n\tlockdep_assert_held(&pcpu_alloc_mutex);\n\n\tif (!pages)\n\t\tpages = pcpu_mem_zalloc(pages_size, GFP_KERNEL);\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp)\n{\n\tstruct page **pages;\n\n\tpages = pcpu_get_pages();\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tif (pcpu_alloc_pages(chunk, pages, page_start, page_end, gfp))\n\t\treturn -ENOMEM;\n\n\tif (pcpu_map_pages(chunk, pages, page_start, page_end)) {\n\t\tpcpu_free_pages(chunk, pages, page_start, page_end);\n\t\treturn -ENOMEM;\n\t}\n\tpcpu_post_map_flush(chunk, page_start, page_end);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcpu_post_map_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "255-261",
    "snippet": "static void pcpu_post_map_flush(struct pcpu_chunk *chunk,\n\t\t\t\tint page_start, int page_end)\n{\n\tflush_cache_vmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_cache_vmap",
          "args": [
            "pcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start)",
            "pcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr",
          "args": [
            "chunk",
            "pcpu_high_unit_cpu",
            "page_end"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "262-267",
          "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
        }
      }
    ],
    "contextual_snippet": "static void pcpu_post_map_flush(struct pcpu_chunk *chunk,\n\t\t\t\tint page_start, int page_end)\n{\n\tflush_cache_vmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}"
  },
  {
    "function_name": "pcpu_map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "214-241",
    "snippet": "static int pcpu_map_pages(struct pcpu_chunk *chunk,\n\t\t\t  struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu, tcpu;\n\tint i, err;\n\n\tfor_each_possible_cpu(cpu) {\n\t\terr = __pcpu_map_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t       &pages[pcpu_page_idx(cpu, page_start)],\n\t\t\t\t       page_end - page_start);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\tpcpu_set_page_chunk(pages[pcpu_page_idx(cpu, i)],\n\t\t\t\t\t    chunk);\n\t}\n\treturn 0;\nerr:\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, tcpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n\tpcpu_post_unmap_tlb_flush(chunk, page_start, page_end);\n\treturn err;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_post_unmap_tlb_flush",
          "args": [
            "chunk",
            "page_start",
            "page_end"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_post_unmap_tlb_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "185-191",
          "snippet": "static void pcpu_post_unmap_tlb_flush(struct pcpu_chunk *chunk,\n\t\t\t\t      int page_start, int page_end)\n{\n\tflush_tlb_kernel_range(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void pcpu_post_unmap_tlb_flush(struct pcpu_chunk *chunk,\n\t\t\t\t      int page_start, int page_end)\n{\n\tflush_tlb_kernel_range(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pcpu_unmap_pages",
          "args": [
            "pcpu_chunk_addr(chunk, tcpu, page_start)",
            "page_end - page_start"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_unmap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "135-138",
          "snippet": "static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)\n{\n\tunmap_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)\n{\n\tunmap_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr",
          "args": [
            "chunk",
            "tcpu",
            "page_start"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "262-267",
          "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_set_page_chunk",
          "args": [
            "pages[pcpu_page_idx(cpu, i)]",
            "chunk"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_set_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "241-244",
          "snippet": "static void pcpu_set_page_chunk(struct page *page, struct pcpu_chunk *pcpu)\n{\n\tpage->index = (unsigned long)pcpu;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_set_page_chunk(struct page *page, struct pcpu_chunk *pcpu)\n{\n\tpage->index = (unsigned long)pcpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_page_idx",
          "args": [
            "cpu",
            "i"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_page_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "252-255",
          "snippet": "static int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static const int *pcpu_unit_map"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic const int *pcpu_unit_map;\n\nstatic int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pcpu_map_pages",
          "args": [
            "pcpu_chunk_addr(chunk, cpu, page_start)",
            "&pages[pcpu_page_idx(cpu, page_start)]",
            "page_end - page_start"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "193-198",
          "snippet": "static int __pcpu_map_pages(unsigned long addr, struct page **pages,\n\t\t\t    int nr_pages)\n{\n\treturn map_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT,\n\t\t\t\t\tPAGE_KERNEL, pages);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int __pcpu_map_pages(unsigned long addr, struct page **pages,\n\t\t\t    int nr_pages)\n{\n\treturn map_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT,\n\t\t\t\t\tPAGE_KERNEL, pages);\n}"
        }
      }
    ],
    "contextual_snippet": "static int pcpu_map_pages(struct pcpu_chunk *chunk,\n\t\t\t  struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu, tcpu;\n\tint i, err;\n\n\tfor_each_possible_cpu(cpu) {\n\t\terr = __pcpu_map_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t       &pages[pcpu_page_idx(cpu, page_start)],\n\t\t\t\t       page_end - page_start);\n\t\tif (err < 0)\n\t\t\tgoto err;\n\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\tpcpu_set_page_chunk(pages[pcpu_page_idx(cpu, i)],\n\t\t\t\t\t    chunk);\n\t}\n\treturn 0;\nerr:\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, tcpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n\tpcpu_post_unmap_tlb_flush(chunk, page_start, page_end);\n\treturn err;\n}"
  },
  {
    "function_name": "__pcpu_map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "193-198",
    "snippet": "static int __pcpu_map_pages(unsigned long addr, struct page **pages,\n\t\t\t    int nr_pages)\n{\n\treturn map_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT,\n\t\t\t\t\tPAGE_KERNEL, pages);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_kernel_range_noflush",
          "args": [
            "addr",
            "nr_pages << PAGE_SHIFT",
            "PAGE_KERNEL",
            "pages"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "map_kernel_range_noflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1293-1297",
          "snippet": "int map_kernel_range_noflush(unsigned long addr, unsigned long size,\n\t\t\t     pgprot_t prot, struct page **pages)\n{\n\treturn vmap_page_range_noflush(addr, addr + size, prot, pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint map_kernel_range_noflush(unsigned long addr, unsigned long size,\n\t\t\t     pgprot_t prot, struct page **pages)\n{\n\treturn vmap_page_range_noflush(addr, addr + size, prot, pages);\n}"
        }
      }
    ],
    "contextual_snippet": "static int __pcpu_map_pages(unsigned long addr, struct page **pages,\n\t\t\t    int nr_pages)\n{\n\treturn map_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT,\n\t\t\t\t\tPAGE_KERNEL, pages);\n}"
  },
  {
    "function_name": "pcpu_post_unmap_tlb_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "185-191",
    "snippet": "static void pcpu_post_unmap_tlb_flush(struct pcpu_chunk *chunk,\n\t\t\t\t      int page_start, int page_end)\n{\n\tflush_tlb_kernel_range(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_tlb_kernel_range",
          "args": [
            "pcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start)",
            "pcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr",
          "args": [
            "chunk",
            "pcpu_high_unit_cpu",
            "page_end"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "262-267",
          "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
        }
      }
    ],
    "contextual_snippet": "static void pcpu_post_unmap_tlb_flush(struct pcpu_chunk *chunk,\n\t\t\t\t      int page_start, int page_end)\n{\n\tflush_tlb_kernel_range(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}"
  },
  {
    "function_name": "pcpu_unmap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "153-170",
    "snippet": "static void pcpu_unmap_pages(struct pcpu_chunk *chunk,\n\t\t\t     struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = pcpu_chunk_page(chunk, cpu, i);\n\t\t\tWARN_ON(!page);\n\t\t\tpages[pcpu_page_idx(cpu, i)] = page;\n\t\t}\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pcpu_unmap_pages",
          "args": [
            "pcpu_chunk_addr(chunk, cpu, page_start)",
            "page_end - page_start"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__pcpu_unmap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "135-138",
          "snippet": "static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)\n{\n\tunmap_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)\n{\n\tunmap_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr",
          "args": [
            "chunk",
            "cpu",
            "page_start"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "262-267",
          "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_page_idx",
          "args": [
            "cpu",
            "i"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_page_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "252-255",
          "snippet": "static int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static const int *pcpu_unit_map"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic const int *pcpu_unit_map;\n\nstatic int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_page",
          "args": [
            "chunk",
            "cpu",
            "i"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
          "lines": "13-20",
          "snippet": "static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,\n\t\t\t\t    unsigned int cpu, int page_idx)\n{\n\t/* must not be used on pre-mapped chunk */\n\tWARN_ON(chunk->immutable);\n\n\treturn vmalloc_to_page((void *)pcpu_chunk_addr(chunk, cpu, page_idx));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,\n\t\t\t\t    unsigned int cpu, int page_idx)\n{\n\t/* must not be used on pre-mapped chunk */\n\tWARN_ON(chunk->immutable);\n\n\treturn vmalloc_to_page((void *)pcpu_chunk_addr(chunk, cpu, page_idx));\n}"
        }
      }
    ],
    "contextual_snippet": "static void pcpu_unmap_pages(struct pcpu_chunk *chunk,\n\t\t\t     struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = pcpu_chunk_page(chunk, cpu, i);\n\t\t\tWARN_ON(!page);\n\t\t\tpages[pcpu_page_idx(cpu, i)] = page;\n\t\t}\n\t\t__pcpu_unmap_pages(pcpu_chunk_addr(chunk, cpu, page_start),\n\t\t\t\t   page_end - page_start);\n\t}\n}"
  },
  {
    "function_name": "__pcpu_unmap_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "135-138",
    "snippet": "static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)\n{\n\tunmap_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_kernel_range_noflush",
          "args": [
            "addr",
            "nr_pages << PAGE_SHIFT"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_kernel_range_noflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1313-1316",
          "snippet": "void unmap_kernel_range_noflush(unsigned long addr, unsigned long size)\n{\n\tvunmap_page_range(addr, addr + size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid unmap_kernel_range_noflush(unsigned long addr, unsigned long size)\n{\n\tvunmap_page_range(addr, addr + size);\n}"
        }
      }
    ],
    "contextual_snippet": "static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)\n{\n\tunmap_kernel_range_noflush(addr, nr_pages << PAGE_SHIFT);\n}"
  },
  {
    "function_name": "pcpu_pre_unmap_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "127-133",
    "snippet": "static void pcpu_pre_unmap_flush(struct pcpu_chunk *chunk,\n\t\t\t\t int page_start, int page_end)\n{\n\tflush_cache_vunmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_cache_vunmap",
          "args": [
            "pcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start)",
            "pcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr",
          "args": [
            "chunk",
            "pcpu_high_unit_cpu",
            "page_end"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "262-267",
          "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
        }
      }
    ],
    "contextual_snippet": "static void pcpu_pre_unmap_flush(struct pcpu_chunk *chunk,\n\t\t\t\t int page_start, int page_end)\n{\n\tflush_cache_vunmap(\n\t\tpcpu_chunk_addr(chunk, pcpu_low_unit_cpu, page_start),\n\t\tpcpu_chunk_addr(chunk, pcpu_high_unit_cpu, page_end));\n}"
  },
  {
    "function_name": "pcpu_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "82-113",
    "snippet": "static int pcpu_alloc_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end,\n\t\t\t    gfp_t gfp)\n{\n\tunsigned int cpu, tcpu;\n\tint i;\n\n\tgfp |= __GFP_HIGHMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page **pagep = &pages[pcpu_page_idx(cpu, i)];\n\n\t\t\t*pagep = alloc_pages_node(cpu_to_node(cpu), gfp, 0);\n\t\t\tif (!*pagep)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\twhile (--i >= page_start)\n\t\t__free_page(pages[pcpu_page_idx(cpu, i)]);\n\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\t__free_page(pages[pcpu_page_idx(tcpu, i)]);\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages[pcpu_page_idx(tcpu, i)]"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_page_idx",
          "args": [
            "tcpu",
            "i"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_page_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "252-255",
          "snippet": "static int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static const int *pcpu_unit_map"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic const int *pcpu_unit_map;\n\nstatic int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "cpu_to_node(cpu)",
            "gfp",
            "0"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int pcpu_alloc_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end,\n\t\t\t    gfp_t gfp)\n{\n\tunsigned int cpu, tcpu;\n\tint i;\n\n\tgfp |= __GFP_HIGHMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page **pagep = &pages[pcpu_page_idx(cpu, i)];\n\n\t\t\t*pagep = alloc_pages_node(cpu_to_node(cpu), gfp, 0);\n\t\t\tif (!*pagep)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\twhile (--i >= page_start)\n\t\t__free_page(pages[pcpu_page_idx(cpu, i)]);\n\n\tfor_each_possible_cpu(tcpu) {\n\t\tif (tcpu == cpu)\n\t\t\tbreak;\n\t\tfor (i = page_start; i < page_end; i++)\n\t\t\t__free_page(pages[pcpu_page_idx(tcpu, i)]);\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "pcpu_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "54-68",
    "snippet": "static void pcpu_free_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page = pages[pcpu_page_idx(cpu, i)];\n\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t}\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_page_idx",
          "args": [
            "cpu",
            "i"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_page_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "252-255",
          "snippet": "static int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_pages",
            "static const int *pcpu_unit_map"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_pages;\nstatic const int *pcpu_unit_map;\n\nstatic int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)\n{\n\treturn pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;\n}"
        }
      }
    ],
    "contextual_snippet": "static void pcpu_free_pages(struct pcpu_chunk *chunk,\n\t\t\t    struct page **pages, int page_start, int page_end)\n{\n\tunsigned int cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = page_start; i < page_end; i++) {\n\t\t\tstruct page *page = pages[pcpu_page_idx(cpu, i)];\n\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pcpu_get_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "32-42",
    "snippet": "static struct page **pcpu_get_pages(void)\n{\n\tstatic struct page **pages;\n\tsize_t pages_size = pcpu_nr_units * pcpu_unit_pages * sizeof(pages[0]);\n\n\tlockdep_assert_held(&pcpu_alloc_mutex);\n\n\tif (!pages)\n\t\tpages = pcpu_mem_zalloc(pages_size, GFP_KERNEL);\n\treturn pages;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_mem_zalloc",
          "args": [
            "pages_size",
            "GFP_KERNEL"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_mem_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "469-478",
          "snippet": "static void *pcpu_mem_zalloc(size_t size, gfp_t gfp)\n{\n\tif (WARN_ON_ONCE(!slab_is_available()))\n\t\treturn NULL;\n\n\tif (size <= PAGE_SIZE)\n\t\treturn kzalloc(size, gfp);\n\telse\n\t\treturn __vmalloc(size, gfp | __GFP_ZERO, PAGE_KERNEL);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);",
            "static struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_populate_chunk(struct pcpu_chunk *chunk,\n\t\t\t       int page_start, int page_end, gfp_t gfp);\nstatic struct pcpu_chunk *pcpu_create_chunk(gfp_t gfp);\n\nstatic void *pcpu_mem_zalloc(size_t size, gfp_t gfp)\n{\n\tif (WARN_ON_ONCE(!slab_is_available()))\n\t\treturn NULL;\n\n\tif (size <= PAGE_SIZE)\n\t\treturn kzalloc(size, gfp);\n\telse\n\t\treturn __vmalloc(size, gfp | __GFP_ZERO, PAGE_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pcpu_alloc_mutex"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static struct page **pcpu_get_pages(void)\n{\n\tstatic struct page **pages;\n\tsize_t pages_size = pcpu_nr_units * pcpu_unit_pages * sizeof(pages[0]);\n\n\tlockdep_assert_held(&pcpu_alloc_mutex);\n\n\tif (!pages)\n\t\tpages = pcpu_mem_zalloc(pages_size, GFP_KERNEL);\n\treturn pages;\n}"
  },
  {
    "function_name": "pcpu_chunk_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu-vm.c",
    "lines": "13-20",
    "snippet": "static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,\n\t\t\t\t    unsigned int cpu, int page_idx)\n{\n\t/* must not be used on pre-mapped chunk */\n\tWARN_ON(chunk->immutable);\n\n\treturn vmalloc_to_page((void *)pcpu_chunk_addr(chunk, cpu, page_idx));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "(void *)pcpu_chunk_addr(chunk, cpu, page_idx)"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "264-267",
          "snippet": "struct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *vmalloc_to_page(const void *addr)\n{\n\treturn virt_to_page(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_chunk_addr",
          "args": [
            "chunk",
            "cpu",
            "page_idx"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_chunk_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "262-267",
          "snippet": "static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\n\nstatic unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,\n\t\t\t\t     unsigned int cpu, int page_idx)\n{\n\treturn (unsigned long)chunk->base_addr +\n\t       pcpu_unit_page_offset(cpu, page_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "chunk->immutable"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,\n\t\t\t\t    unsigned int cpu, int page_idx)\n{\n\t/* must not be used on pre-mapped chunk */\n\tWARN_ON(chunk->immutable);\n\n\treturn vmalloc_to_page((void *)pcpu_chunk_addr(chunk, cpu, page_idx));\n}"
  }
]