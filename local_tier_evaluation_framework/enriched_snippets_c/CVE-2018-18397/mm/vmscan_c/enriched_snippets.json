[
  {
    "function_name": "check_move_unevictable_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "4195-4235",
    "snippet": "void check_move_unevictable_pages(struct page **pages, int nr_pages)\n{\n\tstruct lruvec *lruvec;\n\tstruct pglist_data *pgdat = NULL;\n\tint pgscanned = 0;\n\tint pgrescued = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tpgscanned++;\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t}\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tif (!PageLRU(page) || !PageUnevictable(page))\n\t\t\tcontinue;\n\n\t\tif (page_evictable(page)) {\n\t\t\tenum lru_list lru = page_lru_base_type(page);\n\n\t\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\t\tClearPageUnevictable(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, LRU_UNEVICTABLE);\n\t\t\tadd_page_to_lru_list(page, lruvec, lru);\n\t\t\tpgrescued++;\n\t\t}\n\t}\n\n\tif (pgdat) {\n\t\t__count_vm_events(UNEVICTABLE_PGRESCUED, pgrescued);\n\t\t__count_vm_events(UNEVICTABLE_PGSCANNED, pgscanned);\n\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "UNEVICTABLE_PGSCANNED",
            "pgscanned"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "UNEVICTABLE_PGRESCUED",
            "pgrescued"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "LRU_UNEVICTABLE"
          ],
          "line": 4224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUnevictable",
          "args": [
            "page"
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageActive(page)",
            "page"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru_base_type",
          "args": [
            "page"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_evictable",
          "args": [
            "page"
          ],
          "line": 4219
        },
        "resolved": true,
        "details": {
          "function_name": "page_evictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4174-4183",
          "snippet": "int page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "pgdat"
          ],
          "line": 4214
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 4210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid check_move_unevictable_pages(struct page **pages, int nr_pages)\n{\n\tstruct lruvec *lruvec;\n\tstruct pglist_data *pgdat = NULL;\n\tint pgscanned = 0;\n\tint pgrescued = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tpgscanned++;\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t}\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tif (!PageLRU(page) || !PageUnevictable(page))\n\t\t\tcontinue;\n\n\t\tif (page_evictable(page)) {\n\t\t\tenum lru_list lru = page_lru_base_type(page);\n\n\t\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\t\tClearPageUnevictable(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, LRU_UNEVICTABLE);\n\t\t\tadd_page_to_lru_list(page, lruvec, lru);\n\t\t\tpgrescued++;\n\t\t}\n\t}\n\n\tif (pgdat) {\n\t\t__count_vm_events(UNEVICTABLE_PGRESCUED, pgrescued);\n\t\t__count_vm_events(UNEVICTABLE_PGSCANNED, pgscanned);\n\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t}\n}"
  },
  {
    "function_name": "page_evictable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "4174-4183",
    "snippet": "int page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_unevictable",
          "args": [
            "page_mapping(page)"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 4180
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "node_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "4116-4159",
    "snippet": "int node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)\n{\n\tint ret;\n\n\t/*\n\t * Node reclaim reclaims unmapped file backed pages and\n\t * slab pages if we are over the defined limits.\n\t *\n\t * A small portion of unmapped file backed pages is needed for\n\t * file I/O otherwise pages read by file I/O will be immediately\n\t * thrown out if the node is overallocated. So we do not reclaim\n\t * if less than a specified percentage of the node is used by\n\t * unmapped file backed pages.\n\t */\n\tif (node_pagecache_reclaimable(pgdat) <= pgdat->min_unmapped_pages &&\n\t    node_page_state(pgdat, NR_SLAB_RECLAIMABLE) <= pgdat->min_slab_pages)\n\t\treturn NODE_RECLAIM_FULL;\n\n\t/*\n\t * Do not scan if the allocation should not be delayed.\n\t */\n\tif (!gfpflags_allow_blocking(gfp_mask) || (current->flags & PF_MEMALLOC))\n\t\treturn NODE_RECLAIM_NOSCAN;\n\n\t/*\n\t * Only run node reclaim on the local node or on nodes that do not\n\t * have associated processors. This will favor the local processor\n\t * over remote processors and spread off node memory allocations\n\t * as wide as possible.\n\t */\n\tif (node_state(pgdat->node_id, N_CPU) && pgdat->node_id != numa_node_id())\n\t\treturn NODE_RECLAIM_NOSCAN;\n\n\tif (test_and_set_bit(PGDAT_RECLAIM_LOCKED, &pgdat->flags))\n\t\treturn NODE_RECLAIM_NOSCAN;\n\n\tret = __node_reclaim(pgdat, gfp_mask, order);\n\tclear_bit(PGDAT_RECLAIM_LOCKED, &pgdat->flags);\n\n\tif (!ret)\n\t\tcount_vm_event(PGSCAN_ZONE_RECLAIM_FAILED);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGSCAN_ZONE_RECLAIM_FAILED"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "PGDAT_RECLAIM_LOCKED",
            "&pgdat->flags"
          ],
          "line": 4153
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__node_reclaim",
          "args": [
            "pgdat",
            "gfp_mask",
            "order"
          ],
          "line": 4152
        },
        "resolved": true,
        "details": {
          "function_name": "__node_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4069-4114",
          "snippet": "static int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)\n{\n\t/* Minimum pages needed in order to stay on node */\n\tconst unsigned long nr_pages = 1 << order;\n\tstruct task_struct *p = current;\n\tstruct reclaim_state reclaim_state;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.order = order,\n\t\t.priority = NODE_RECLAIM_PRIORITY,\n\t\t.may_writepage = !!(node_reclaim_mode & RECLAIM_WRITE),\n\t\t.may_unmap = !!(node_reclaim_mode & RECLAIM_UNMAP),\n\t\t.may_swap = 1,\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t};\n\n\tcond_resched();\n\tfs_reclaim_acquire(sc.gfp_mask);\n\t/*\n\t * We need to be able to allocate from the reserves for RECLAIM_UNMAP\n\t * and we also need to be able to write out pages for RECLAIM_WRITE\n\t * and RECLAIM_UNMAP.\n\t */\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tp->flags |= PF_SWAPWRITE;\n\treclaim_state.reclaimed_slab = 0;\n\tp->reclaim_state = &reclaim_state;\n\n\tif (node_pagecache_reclaimable(pgdat) > pgdat->min_unmapped_pages) {\n\t\t/*\n\t\t * Free memory by calling shrink node with increasing\n\t\t * priorities until we have enough memory freed.\n\t\t */\n\t\tdo {\n\t\t\tshrink_node(pgdat, &sc);\n\t\t} while (sc.nr_reclaimed < nr_pages && --sc.priority >= 0);\n\t}\n\n\tp->reclaim_state = NULL;\n\tcurrent->flags &= ~PF_SWAPWRITE;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(sc.gfp_mask);\n\treturn sc.nr_reclaimed >= nr_pages;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define NODE_RECLAIM_PRIORITY 4",
            "#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */",
            "#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define NODE_RECLAIM_PRIORITY 4\n#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */\n#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */\n\nstatic int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)\n{\n\t/* Minimum pages needed in order to stay on node */\n\tconst unsigned long nr_pages = 1 << order;\n\tstruct task_struct *p = current;\n\tstruct reclaim_state reclaim_state;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.order = order,\n\t\t.priority = NODE_RECLAIM_PRIORITY,\n\t\t.may_writepage = !!(node_reclaim_mode & RECLAIM_WRITE),\n\t\t.may_unmap = !!(node_reclaim_mode & RECLAIM_UNMAP),\n\t\t.may_swap = 1,\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t};\n\n\tcond_resched();\n\tfs_reclaim_acquire(sc.gfp_mask);\n\t/*\n\t * We need to be able to allocate from the reserves for RECLAIM_UNMAP\n\t * and we also need to be able to write out pages for RECLAIM_WRITE\n\t * and RECLAIM_UNMAP.\n\t */\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tp->flags |= PF_SWAPWRITE;\n\treclaim_state.reclaimed_slab = 0;\n\tp->reclaim_state = &reclaim_state;\n\n\tif (node_pagecache_reclaimable(pgdat) > pgdat->min_unmapped_pages) {\n\t\t/*\n\t\t * Free memory by calling shrink node with increasing\n\t\t * priorities until we have enough memory freed.\n\t\t */\n\t\tdo {\n\t\t\tshrink_node(pgdat, &sc);\n\t\t} while (sc.nr_reclaimed < nr_pages && --sc.priority >= 0);\n\t}\n\n\tp->reclaim_state = NULL;\n\tcurrent->flags &= ~PF_SWAPWRITE;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(sc.gfp_mask);\n\treturn sc.nr_reclaimed >= nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "PGDAT_RECLAIM_LOCKED",
            "&pgdat->flags"
          ],
          "line": 4149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_state",
          "args": [
            "pgdat->node_id",
            "N_CPU"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "634-641",
          "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp_mask"
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 4131
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_pagecache_reclaimable",
          "args": [
            "pgdat"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "node_pagecache_reclaimable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4039-4064",
          "snippet": "static unsigned long node_pagecache_reclaimable(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pagecache_reclaimable;\n\tunsigned long delta = 0;\n\n\t/*\n\t * If RECLAIM_UNMAP is set, then all file pages are considered\n\t * potentially reclaimable. Otherwise, we have to worry about\n\t * pages like swapcache and node_unmapped_file_pages() provides\n\t * a better estimate\n\t */\n\tif (node_reclaim_mode & RECLAIM_UNMAP)\n\t\tnr_pagecache_reclaimable = node_page_state(pgdat, NR_FILE_PAGES);\n\telse\n\t\tnr_pagecache_reclaimable = node_unmapped_file_pages(pgdat);\n\n\t/* If we can't clean pages, remove dirty pages from consideration */\n\tif (!(node_reclaim_mode & RECLAIM_WRITE))\n\t\tdelta += node_page_state(pgdat, NR_FILE_DIRTY);\n\n\t/* Watch for any possible underflows due to delta */\n\tif (unlikely(delta > nr_pagecache_reclaimable))\n\t\tdelta = nr_pagecache_reclaimable;\n\n\treturn nr_pagecache_reclaimable - delta;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */",
            "#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */\n#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */\n\nstatic unsigned long node_pagecache_reclaimable(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pagecache_reclaimable;\n\tunsigned long delta = 0;\n\n\t/*\n\t * If RECLAIM_UNMAP is set, then all file pages are considered\n\t * potentially reclaimable. Otherwise, we have to worry about\n\t * pages like swapcache and node_unmapped_file_pages() provides\n\t * a better estimate\n\t */\n\tif (node_reclaim_mode & RECLAIM_UNMAP)\n\t\tnr_pagecache_reclaimable = node_page_state(pgdat, NR_FILE_PAGES);\n\telse\n\t\tnr_pagecache_reclaimable = node_unmapped_file_pages(pgdat);\n\n\t/* If we can't clean pages, remove dirty pages from consideration */\n\tif (!(node_reclaim_mode & RECLAIM_WRITE))\n\t\tdelta += node_page_state(pgdat, NR_FILE_DIRTY);\n\n\t/* Watch for any possible underflows due to delta */\n\tif (unlikely(delta > nr_pagecache_reclaimable))\n\t\tdelta = nr_pagecache_reclaimable;\n\n\treturn nr_pagecache_reclaimable - delta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)\n{\n\tint ret;\n\n\t/*\n\t * Node reclaim reclaims unmapped file backed pages and\n\t * slab pages if we are over the defined limits.\n\t *\n\t * A small portion of unmapped file backed pages is needed for\n\t * file I/O otherwise pages read by file I/O will be immediately\n\t * thrown out if the node is overallocated. So we do not reclaim\n\t * if less than a specified percentage of the node is used by\n\t * unmapped file backed pages.\n\t */\n\tif (node_pagecache_reclaimable(pgdat) <= pgdat->min_unmapped_pages &&\n\t    node_page_state(pgdat, NR_SLAB_RECLAIMABLE) <= pgdat->min_slab_pages)\n\t\treturn NODE_RECLAIM_FULL;\n\n\t/*\n\t * Do not scan if the allocation should not be delayed.\n\t */\n\tif (!gfpflags_allow_blocking(gfp_mask) || (current->flags & PF_MEMALLOC))\n\t\treturn NODE_RECLAIM_NOSCAN;\n\n\t/*\n\t * Only run node reclaim on the local node or on nodes that do not\n\t * have associated processors. This will favor the local processor\n\t * over remote processors and spread off node memory allocations\n\t * as wide as possible.\n\t */\n\tif (node_state(pgdat->node_id, N_CPU) && pgdat->node_id != numa_node_id())\n\t\treturn NODE_RECLAIM_NOSCAN;\n\n\tif (test_and_set_bit(PGDAT_RECLAIM_LOCKED, &pgdat->flags))\n\t\treturn NODE_RECLAIM_NOSCAN;\n\n\tret = __node_reclaim(pgdat, gfp_mask, order);\n\tclear_bit(PGDAT_RECLAIM_LOCKED, &pgdat->flags);\n\n\tif (!ret)\n\t\tcount_vm_event(PGSCAN_ZONE_RECLAIM_FAILED);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__node_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "4069-4114",
    "snippet": "static int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)\n{\n\t/* Minimum pages needed in order to stay on node */\n\tconst unsigned long nr_pages = 1 << order;\n\tstruct task_struct *p = current;\n\tstruct reclaim_state reclaim_state;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.order = order,\n\t\t.priority = NODE_RECLAIM_PRIORITY,\n\t\t.may_writepage = !!(node_reclaim_mode & RECLAIM_WRITE),\n\t\t.may_unmap = !!(node_reclaim_mode & RECLAIM_UNMAP),\n\t\t.may_swap = 1,\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t};\n\n\tcond_resched();\n\tfs_reclaim_acquire(sc.gfp_mask);\n\t/*\n\t * We need to be able to allocate from the reserves for RECLAIM_UNMAP\n\t * and we also need to be able to write out pages for RECLAIM_WRITE\n\t * and RECLAIM_UNMAP.\n\t */\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tp->flags |= PF_SWAPWRITE;\n\treclaim_state.reclaimed_slab = 0;\n\tp->reclaim_state = &reclaim_state;\n\n\tif (node_pagecache_reclaimable(pgdat) > pgdat->min_unmapped_pages) {\n\t\t/*\n\t\t * Free memory by calling shrink node with increasing\n\t\t * priorities until we have enough memory freed.\n\t\t */\n\t\tdo {\n\t\t\tshrink_node(pgdat, &sc);\n\t\t} while (sc.nr_reclaimed < nr_pages && --sc.priority >= 0);\n\t}\n\n\tp->reclaim_state = NULL;\n\tcurrent->flags &= ~PF_SWAPWRITE;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(sc.gfp_mask);\n\treturn sc.nr_reclaimed >= nr_pages;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define NODE_RECLAIM_PRIORITY 4",
      "#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */",
      "#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_reclaim_release",
          "args": [
            "sc.gfp_mask"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3745-3749",
          "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_restore",
          "args": [
            "noreclaim_flag"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_node",
          "args": [
            "pgdat",
            "&sc"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_shrink_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3465-3498",
          "snippet": "static bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_pagecache_reclaimable",
          "args": [
            "pgdat"
          ],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "node_pagecache_reclaimable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4039-4064",
          "snippet": "static unsigned long node_pagecache_reclaimable(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pagecache_reclaimable;\n\tunsigned long delta = 0;\n\n\t/*\n\t * If RECLAIM_UNMAP is set, then all file pages are considered\n\t * potentially reclaimable. Otherwise, we have to worry about\n\t * pages like swapcache and node_unmapped_file_pages() provides\n\t * a better estimate\n\t */\n\tif (node_reclaim_mode & RECLAIM_UNMAP)\n\t\tnr_pagecache_reclaimable = node_page_state(pgdat, NR_FILE_PAGES);\n\telse\n\t\tnr_pagecache_reclaimable = node_unmapped_file_pages(pgdat);\n\n\t/* If we can't clean pages, remove dirty pages from consideration */\n\tif (!(node_reclaim_mode & RECLAIM_WRITE))\n\t\tdelta += node_page_state(pgdat, NR_FILE_DIRTY);\n\n\t/* Watch for any possible underflows due to delta */\n\tif (unlikely(delta > nr_pagecache_reclaimable))\n\t\tdelta = nr_pagecache_reclaimable;\n\n\treturn nr_pagecache_reclaimable - delta;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */",
            "#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */\n#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */\n\nstatic unsigned long node_pagecache_reclaimable(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pagecache_reclaimable;\n\tunsigned long delta = 0;\n\n\t/*\n\t * If RECLAIM_UNMAP is set, then all file pages are considered\n\t * potentially reclaimable. Otherwise, we have to worry about\n\t * pages like swapcache and node_unmapped_file_pages() provides\n\t * a better estimate\n\t */\n\tif (node_reclaim_mode & RECLAIM_UNMAP)\n\t\tnr_pagecache_reclaimable = node_page_state(pgdat, NR_FILE_PAGES);\n\telse\n\t\tnr_pagecache_reclaimable = node_unmapped_file_pages(pgdat);\n\n\t/* If we can't clean pages, remove dirty pages from consideration */\n\tif (!(node_reclaim_mode & RECLAIM_WRITE))\n\t\tdelta += node_page_state(pgdat, NR_FILE_DIRTY);\n\n\t/* Watch for any possible underflows due to delta */\n\tif (unlikely(delta > nr_pagecache_reclaimable))\n\t\tdelta = nr_pagecache_reclaimable;\n\n\treturn nr_pagecache_reclaimable - delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_save",
          "args": [],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_reclaim_acquire",
          "args": [
            "sc.gfp_mask"
          ],
          "line": 4088
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3738-3742",
          "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "gfp_mask"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gfp_context",
          "args": [
            "gfp_mask"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_pages",
            "SWAP_CLUSTER_MAX"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define NODE_RECLAIM_PRIORITY 4\n#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */\n#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */\n\nstatic int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)\n{\n\t/* Minimum pages needed in order to stay on node */\n\tconst unsigned long nr_pages = 1 << order;\n\tstruct task_struct *p = current;\n\tstruct reclaim_state reclaim_state;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.order = order,\n\t\t.priority = NODE_RECLAIM_PRIORITY,\n\t\t.may_writepage = !!(node_reclaim_mode & RECLAIM_WRITE),\n\t\t.may_unmap = !!(node_reclaim_mode & RECLAIM_UNMAP),\n\t\t.may_swap = 1,\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t};\n\n\tcond_resched();\n\tfs_reclaim_acquire(sc.gfp_mask);\n\t/*\n\t * We need to be able to allocate from the reserves for RECLAIM_UNMAP\n\t * and we also need to be able to write out pages for RECLAIM_WRITE\n\t * and RECLAIM_UNMAP.\n\t */\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\tp->flags |= PF_SWAPWRITE;\n\treclaim_state.reclaimed_slab = 0;\n\tp->reclaim_state = &reclaim_state;\n\n\tif (node_pagecache_reclaimable(pgdat) > pgdat->min_unmapped_pages) {\n\t\t/*\n\t\t * Free memory by calling shrink node with increasing\n\t\t * priorities until we have enough memory freed.\n\t\t */\n\t\tdo {\n\t\t\tshrink_node(pgdat, &sc);\n\t\t} while (sc.nr_reclaimed < nr_pages && --sc.priority >= 0);\n\t}\n\n\tp->reclaim_state = NULL;\n\tcurrent->flags &= ~PF_SWAPWRITE;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(sc.gfp_mask);\n\treturn sc.nr_reclaimed >= nr_pages;\n}"
  },
  {
    "function_name": "node_pagecache_reclaimable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "4039-4064",
    "snippet": "static unsigned long node_pagecache_reclaimable(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pagecache_reclaimable;\n\tunsigned long delta = 0;\n\n\t/*\n\t * If RECLAIM_UNMAP is set, then all file pages are considered\n\t * potentially reclaimable. Otherwise, we have to worry about\n\t * pages like swapcache and node_unmapped_file_pages() provides\n\t * a better estimate\n\t */\n\tif (node_reclaim_mode & RECLAIM_UNMAP)\n\t\tnr_pagecache_reclaimable = node_page_state(pgdat, NR_FILE_PAGES);\n\telse\n\t\tnr_pagecache_reclaimable = node_unmapped_file_pages(pgdat);\n\n\t/* If we can't clean pages, remove dirty pages from consideration */\n\tif (!(node_reclaim_mode & RECLAIM_WRITE))\n\t\tdelta += node_page_state(pgdat, NR_FILE_DIRTY);\n\n\t/* Watch for any possible underflows due to delta */\n\tif (unlikely(delta > nr_pagecache_reclaimable))\n\t\tdelta = nr_pagecache_reclaimable;\n\n\treturn nr_pagecache_reclaimable - delta;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */",
      "#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta > nr_pagecache_reclaimable"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_FILE_DIRTY"
          ],
          "line": 4057
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_unmapped_file_pages",
          "args": [
            "pgdat"
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "node_unmapped_file_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4024-4036",
          "snippet": "static inline unsigned long node_unmapped_file_pages(struct pglist_data *pgdat)\n{\n\tunsigned long file_mapped = node_page_state(pgdat, NR_FILE_MAPPED);\n\tunsigned long file_lru = node_page_state(pgdat, NR_INACTIVE_FILE) +\n\t\tnode_page_state(pgdat, NR_ACTIVE_FILE);\n\n\t/*\n\t * It's possible for there to be more file mapped pages than\n\t * accounted for by the pages on the file LRU lists because\n\t * tmpfs pages accounted for as ANON can also be FILE_MAPPED\n\t */\n\treturn (file_lru > file_mapped) ? (file_lru - file_mapped) : 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long node_unmapped_file_pages(struct pglist_data *pgdat)\n{\n\tunsigned long file_mapped = node_page_state(pgdat, NR_FILE_MAPPED);\n\tunsigned long file_lru = node_page_state(pgdat, NR_INACTIVE_FILE) +\n\t\tnode_page_state(pgdat, NR_ACTIVE_FILE);\n\n\t/*\n\t * It's possible for there to be more file mapped pages than\n\t * accounted for by the pages on the file LRU lists because\n\t * tmpfs pages accounted for as ANON can also be FILE_MAPPED\n\t */\n\treturn (file_lru > file_mapped) ? (file_lru - file_mapped) : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define RECLAIM_UNMAP (1<<2)\t/* Unmap pages during reclaim */\n#define RECLAIM_WRITE (1<<1)\t/* Writeout pages during reclaim */\n\nstatic unsigned long node_pagecache_reclaimable(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pagecache_reclaimable;\n\tunsigned long delta = 0;\n\n\t/*\n\t * If RECLAIM_UNMAP is set, then all file pages are considered\n\t * potentially reclaimable. Otherwise, we have to worry about\n\t * pages like swapcache and node_unmapped_file_pages() provides\n\t * a better estimate\n\t */\n\tif (node_reclaim_mode & RECLAIM_UNMAP)\n\t\tnr_pagecache_reclaimable = node_page_state(pgdat, NR_FILE_PAGES);\n\telse\n\t\tnr_pagecache_reclaimable = node_unmapped_file_pages(pgdat);\n\n\t/* If we can't clean pages, remove dirty pages from consideration */\n\tif (!(node_reclaim_mode & RECLAIM_WRITE))\n\t\tdelta += node_page_state(pgdat, NR_FILE_DIRTY);\n\n\t/* Watch for any possible underflows due to delta */\n\tif (unlikely(delta > nr_pagecache_reclaimable))\n\t\tdelta = nr_pagecache_reclaimable;\n\n\treturn nr_pagecache_reclaimable - delta;\n}"
  },
  {
    "function_name": "node_unmapped_file_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "4024-4036",
    "snippet": "static inline unsigned long node_unmapped_file_pages(struct pglist_data *pgdat)\n{\n\tunsigned long file_mapped = node_page_state(pgdat, NR_FILE_MAPPED);\n\tunsigned long file_lru = node_page_state(pgdat, NR_INACTIVE_FILE) +\n\t\tnode_page_state(pgdat, NR_ACTIVE_FILE);\n\n\t/*\n\t * It's possible for there to be more file mapped pages than\n\t * accounted for by the pages on the file LRU lists because\n\t * tmpfs pages accounted for as ANON can also be FILE_MAPPED\n\t */\n\treturn (file_lru > file_mapped) ? (file_lru - file_mapped) : 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_ACTIVE_FILE"
          ],
          "line": 4028
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long node_unmapped_file_pages(struct pglist_data *pgdat)\n{\n\tunsigned long file_mapped = node_page_state(pgdat, NR_FILE_MAPPED);\n\tunsigned long file_lru = node_page_state(pgdat, NR_INACTIVE_FILE) +\n\t\tnode_page_state(pgdat, NR_ACTIVE_FILE);\n\n\t/*\n\t * It's possible for there to be more file mapped pages than\n\t * accounted for by the pages on the file LRU lists because\n\t * tmpfs pages accounted for as ANON can also be FILE_MAPPED\n\t */\n\treturn (file_lru > file_mapped) ? (file_lru - file_mapped) : 0;\n}"
  },
  {
    "function_name": "kswapd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3975-3987",
    "snippet": "static int __init kswapd_init(void)\n{\n\tint nid, ret;\n\n\tswap_setup();\n\tfor_each_node_state(nid, N_MEMORY)\n \t\tkswapd_run(nid);\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"mm/vmscan:online\", kswapd_cpu_online,\n\t\t\t\t\tNULL);\n\tWARN_ON(ret < 0);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"mm/vmscan:online\"",
            "kswapd_cpu_online",
            "NULL"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kswapd_run",
          "args": [
            "nid"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3942-3959",
          "snippet": "int kswapd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kswapd)\n\t\treturn 0;\n\n\tpgdat->kswapd = kthread_run(kswapd, pgdat, \"kswapd%d\", nid);\n\tif (IS_ERR(pgdat->kswapd)) {\n\t\t/* failure at boot is fatal */\n\t\tBUG_ON(system_state < SYSTEM_RUNNING);\n\t\tpr_err(\"Failed to start kswapd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kswapd);\n\t\tpgdat->kswapd = NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint kswapd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kswapd)\n\t\treturn 0;\n\n\tpgdat->kswapd = kthread_run(kswapd, pgdat, \"kswapd%d\", nid);\n\tif (IS_ERR(pgdat->kswapd)) {\n\t\t/* failure at boot is fatal */\n\t\tBUG_ON(system_state < SYSTEM_RUNNING);\n\t\tpr_err(\"Failed to start kswapd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kswapd);\n\t\tpgdat->kswapd = NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_setup",
          "args": [],
          "line": 3979
        },
        "resolved": true,
        "details": {
          "function_name": "swap_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "1024-1037",
          "snippet": "void __init swap_setup(void)\n{\n\tunsigned long megs = totalram_pages >> (20 - PAGE_SHIFT);\n\n\t/* Use a smaller cluster for small-memory machines */\n\tif (megs < 16)\n\t\tpage_cluster = 2;\n\telse\n\t\tpage_cluster = 3;\n\t/*\n\t * Right now other parts of the system means that we\n\t * _really_ don't want to cluster much more\n\t */\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_cluster;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint page_cluster;\n\nvoid __init swap_setup(void)\n{\n\tunsigned long megs = totalram_pages >> (20 - PAGE_SHIFT);\n\n\t/* Use a smaller cluster for small-memory machines */\n\tif (megs < 16)\n\t\tpage_cluster = 2;\n\telse\n\t\tpage_cluster = 3;\n\t/*\n\t * Right now other parts of the system means that we\n\t * _really_ don't want to cluster much more\n\t */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int __init kswapd_init(void)\n{\n\tint nid, ret;\n\n\tswap_setup();\n\tfor_each_node_state(nid, N_MEMORY)\n \t\tkswapd_run(nid);\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"mm/vmscan:online\", kswapd_cpu_online,\n\t\t\t\t\tNULL);\n\tWARN_ON(ret < 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "kswapd_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3965-3973",
    "snippet": "void kswapd_stop(int nid)\n{\n\tstruct task_struct *kswapd = NODE_DATA(nid)->kswapd;\n\n\tif (kswapd) {\n\t\tkthread_stop(kswapd);\n\t\tNODE_DATA(nid)->kswapd = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "kswapd"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 3967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid kswapd_stop(int nid)\n{\n\tstruct task_struct *kswapd = NODE_DATA(nid)->kswapd;\n\n\tif (kswapd) {\n\t\tkthread_stop(kswapd);\n\t\tNODE_DATA(nid)->kswapd = NULL;\n\t}\n}"
  },
  {
    "function_name": "kswapd_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3942-3959",
    "snippet": "int kswapd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kswapd)\n\t\treturn 0;\n\n\tpgdat->kswapd = kthread_run(kswapd, pgdat, \"kswapd%d\", nid);\n\tif (IS_ERR(pgdat->kswapd)) {\n\t\t/* failure at boot is fatal */\n\t\tBUG_ON(system_state < SYSTEM_RUNNING);\n\t\tpr_err(\"Failed to start kswapd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kswapd);\n\t\tpgdat->kswapd = NULL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pgdat->kswapd"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to start kswapd on node %d\\n\"",
            "nid"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "system_state < SYSTEM_RUNNING"
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pgdat->kswapd"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kswapd",
            "pgdat",
            "\"kswapd%d\"",
            "nid"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 3944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint kswapd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kswapd)\n\t\treturn 0;\n\n\tpgdat->kswapd = kthread_run(kswapd, pgdat, \"kswapd%d\", nid);\n\tif (IS_ERR(pgdat->kswapd)) {\n\t\t/* failure at boot is fatal */\n\t\tBUG_ON(system_state < SYSTEM_RUNNING);\n\t\tpr_err(\"Failed to start kswapd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kswapd);\n\t\tpgdat->kswapd = NULL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kswapd_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3921-3936",
    "snippet": "static int kswapd_cpu_online(unsigned int cpu)\n{\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\t\tconst struct cpumask *mask;\n\n\t\tmask = cpumask_of_node(pgdat->node_id);\n\n\t\tif (cpumask_any_and(cpu_online_mask, mask) < nr_cpu_ids)\n\t\t\t/* One of our CPUs online: restore mask */\n\t\t\tset_cpus_allowed_ptr(pgdat->kswapd, mask);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "pgdat->kswapd",
            "mask"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpu_online_mask",
            "mask"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "pgdat->node_id"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int kswapd_cpu_online(unsigned int cpu)\n{\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\t\tconst struct cpumask *mask;\n\n\t\tmask = cpumask_of_node(pgdat->node_id);\n\n\t\tif (cpumask_any_and(cpu_online_mask, mask) < nr_cpu_ids)\n\t\t\t/* One of our CPUs online: restore mask */\n\t\t\tset_cpus_allowed_ptr(pgdat->kswapd, mask);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "shrink_all_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3884-3914",
    "snippet": "unsigned long shrink_all_memory(unsigned long nr_to_reclaim)\n{\n\tstruct reclaim_state reclaim_state;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = nr_to_reclaim,\n\t\t.gfp_mask = GFP_HIGHUSER_MOVABLE,\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = 1,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t\t.hibernation_mode = 1,\n\t};\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);\n\tstruct task_struct *p = current;\n\tunsigned long nr_reclaimed;\n\tunsigned int noreclaim_flag;\n\n\tfs_reclaim_acquire(sc.gfp_mask);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\treclaim_state.reclaimed_slab = 0;\n\tp->reclaim_state = &reclaim_state;\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tp->reclaim_state = NULL;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(sc.gfp_mask);\n\n\treturn nr_reclaimed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_reclaim_release",
          "args": [
            "sc.gfp_mask"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3745-3749",
          "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_restore",
          "args": [
            "noreclaim_flag"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_try_to_free_pages",
          "args": [
            "zonelist",
            "&sc"
          ],
          "line": 3907
        },
        "resolved": true,
        "details": {
          "function_name": "do_try_to_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3032-3093",
          "snippet": "static unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_save",
          "args": [],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_reclaim_acquire",
          "args": [
            "sc.gfp_mask"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3738-3742",
          "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "numa_node_id()",
            "sc.gfp_mask"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long shrink_all_memory(unsigned long nr_to_reclaim)\n{\n\tstruct reclaim_state reclaim_state;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = nr_to_reclaim,\n\t\t.gfp_mask = GFP_HIGHUSER_MOVABLE,\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = 1,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t\t.hibernation_mode = 1,\n\t};\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);\n\tstruct task_struct *p = current;\n\tunsigned long nr_reclaimed;\n\tunsigned int noreclaim_flag;\n\n\tfs_reclaim_acquire(sc.gfp_mask);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\treclaim_state.reclaimed_slab = 0;\n\tp->reclaim_state = &reclaim_state;\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tp->reclaim_state = NULL;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(sc.gfp_mask);\n\n\treturn nr_reclaimed;\n}"
  },
  {
    "function_name": "wakeup_kswapd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3838-3873",
    "snippet": "void wakeup_kswapd(struct zone *zone, gfp_t gfp_flags, int order,\n\t\t   enum zone_type classzone_idx)\n{\n\tpg_data_t *pgdat;\n\n\tif (!managed_zone(zone))\n\t\treturn;\n\n\tif (!cpuset_zone_allowed(zone, gfp_flags))\n\t\treturn;\n\tpgdat = zone->zone_pgdat;\n\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat,\n\t\t\t\t\t\t\t   classzone_idx);\n\tpgdat->kswapd_order = max(pgdat->kswapd_order, order);\n\tif (!waitqueue_active(&pgdat->kswapd_wait))\n\t\treturn;\n\n\t/* Hopeless node, leave it to direct reclaim if possible */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ||\n\t    pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\t/*\n\t\t * There may be plenty of free memory available, but it's too\n\t\t * fragmented for high-order allocations.  Wake up kcompactd\n\t\t * and rely on compaction_suitable() to determine if it's\n\t\t * needed.  If it fails, it will defer subsequent attempts to\n\t\t * ratelimit its work.\n\t\t */\n\t\tif (!(gfp_flags & __GFP_DIRECT_RECLAIM))\n\t\t\twakeup_kcompactd(pgdat, order, classzone_idx);\n\t\treturn;\n\t}\n\n\ttrace_mm_vmscan_wakeup_kswapd(pgdat->node_id, classzone_idx, order,\n\t\t\t\t      gfp_flags);\n\twake_up_interruptible(&pgdat->kswapd_wait);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pgdat->kswapd_wait"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_wakeup_kswapd",
          "args": [
            "pgdat->node_id",
            "classzone_idx",
            "order",
            "gfp_flags"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_kcompactd",
          "args": [
            "pgdat",
            "order",
            "classzone_idx"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_kcompactd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "2026-2050",
          "snippet": "void wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tif (!order)\n\t\treturn;\n\n\tif (pgdat->kcompactd_max_order < order)\n\t\tpgdat->kcompactd_max_order = order;\n\n\tif (pgdat->kcompactd_classzone_idx > classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = classzone_idx;\n\n\t/*\n\t * Pairs with implicit barrier in wait_event_freezable()\n\t * such that wakeups are not missed.\n\t */\n\tif (!wq_has_sleeper(&pgdat->kcompactd_wait))\n\t\treturn;\n\n\tif (!kcompactd_node_suitable(pgdat))\n\t\treturn;\n\n\ttrace_mm_compaction_wakeup_kcompactd(pgdat->node_id, order,\n\t\t\t\t\t\t\tclasszone_idx);\n\twake_up_interruptible(&pgdat->kcompactd_wait);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tif (!order)\n\t\treturn;\n\n\tif (pgdat->kcompactd_max_order < order)\n\t\tpgdat->kcompactd_max_order = order;\n\n\tif (pgdat->kcompactd_classzone_idx > classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = classzone_idx;\n\n\t/*\n\t * Pairs with implicit barrier in wait_event_freezable()\n\t * such that wakeups are not missed.\n\t */\n\tif (!wq_has_sleeper(&pgdat->kcompactd_wait))\n\t\treturn;\n\n\tif (!kcompactd_node_suitable(pgdat))\n\t\treturn;\n\n\ttrace_mm_compaction_wakeup_kcompactd(pgdat->node_id, order,\n\t\t\t\t\t\t\tclasszone_idx);\n\twake_up_interruptible(&pgdat->kcompactd_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_balanced",
          "args": [
            "pgdat",
            "order",
            "classzone_idx"
          ],
          "line": 3857
        },
        "resolved": true,
        "details": {
          "function_name": "pgdat_balanced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3385-3411",
          "snippet": "static bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pgdat->kswapd_wait"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "pgdat->kswapd_order",
            "order"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kswapd_classzone_idx",
          "args": [
            "pgdat",
            "classzone_idx"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_classzone_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3648-3655",
          "snippet": "static enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_zone_allowed",
          "args": [
            "zone",
            "gfp_flags"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid wakeup_kswapd(struct zone *zone, gfp_t gfp_flags, int order,\n\t\t   enum zone_type classzone_idx)\n{\n\tpg_data_t *pgdat;\n\n\tif (!managed_zone(zone))\n\t\treturn;\n\n\tif (!cpuset_zone_allowed(zone, gfp_flags))\n\t\treturn;\n\tpgdat = zone->zone_pgdat;\n\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat,\n\t\t\t\t\t\t\t   classzone_idx);\n\tpgdat->kswapd_order = max(pgdat->kswapd_order, order);\n\tif (!waitqueue_active(&pgdat->kswapd_wait))\n\t\treturn;\n\n\t/* Hopeless node, leave it to direct reclaim if possible */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ||\n\t    pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\t/*\n\t\t * There may be plenty of free memory available, but it's too\n\t\t * fragmented for high-order allocations.  Wake up kcompactd\n\t\t * and rely on compaction_suitable() to determine if it's\n\t\t * needed.  If it fails, it will defer subsequent attempts to\n\t\t * ratelimit its work.\n\t\t */\n\t\tif (!(gfp_flags & __GFP_DIRECT_RECLAIM))\n\t\t\twakeup_kcompactd(pgdat, order, classzone_idx);\n\t\treturn;\n\t}\n\n\ttrace_mm_vmscan_wakeup_kswapd(pgdat->node_id, classzone_idx, order,\n\t\t\t\t      gfp_flags);\n\twake_up_interruptible(&pgdat->kswapd_wait);\n}"
  },
  {
    "function_name": "kswapd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3750-3829",
    "snippet": "static int kswapd(void *p)\n{\n\tunsigned int alloc_order, reclaim_order;\n\tunsigned int classzone_idx = MAX_NR_ZONES - 1;\n\tpg_data_t *pgdat = (pg_data_t*)p;\n\tstruct task_struct *tsk = current;\n\n\tstruct reclaim_state reclaim_state = {\n\t\t.reclaimed_slab = 0,\n\t};\n\tconst struct cpumask *cpumask = cpumask_of_node(pgdat->node_id);\n\n\tif (!cpumask_empty(cpumask))\n\t\tset_cpus_allowed_ptr(tsk, cpumask);\n\tcurrent->reclaim_state = &reclaim_state;\n\n\t/*\n\t * Tell the memory management that we're a \"memory allocator\",\n\t * and that if we need more memory we should get access to it\n\t * regardless (see \"__alloc_pages()\"). \"kswapd\" should\n\t * never get caught in the normal page freeing logic.\n\t *\n\t * (Kswapd normally doesn't need memory anyway, but sometimes\n\t * you need a small amount of memory in order to be able to\n\t * page out something else, and this flag essentially protects\n\t * us from recursively trying to free more memory as we're\n\t * trying to free the first piece of memory in the first place).\n\t */\n\ttsk->flags |= PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD;\n\tset_freezable();\n\n\tpgdat->kswapd_order = 0;\n\tpgdat->kswapd_classzone_idx = MAX_NR_ZONES;\n\tfor ( ; ; ) {\n\t\tbool ret;\n\n\t\talloc_order = reclaim_order = pgdat->kswapd_order;\n\t\tclasszone_idx = kswapd_classzone_idx(pgdat, classzone_idx);\n\nkswapd_try_sleep:\n\t\tkswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,\n\t\t\t\t\tclasszone_idx);\n\n\t\t/* Read the new order and classzone_idx */\n\t\talloc_order = reclaim_order = pgdat->kswapd_order;\n\t\tclasszone_idx = kswapd_classzone_idx(pgdat, 0);\n\t\tpgdat->kswapd_order = 0;\n\t\tpgdat->kswapd_classzone_idx = MAX_NR_ZONES;\n\n\t\tret = try_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We can speed up thawing tasks if we don't call balance_pgdat\n\t\t * after returning from the refrigerator\n\t\t */\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Reclaim begins at the requested order but if a high-order\n\t\t * reclaim fails then kswapd falls back to reclaiming for\n\t\t * order-0. If that happens, kswapd will consider sleeping\n\t\t * for the order it finished reclaiming at (reclaim_order)\n\t\t * but kcompactd is woken to compact for the original\n\t\t * request (alloc_order).\n\t\t */\n\t\ttrace_mm_vmscan_kswapd_wake(pgdat->node_id, classzone_idx,\n\t\t\t\t\t\talloc_order);\n\t\treclaim_order = balance_pgdat(pgdat, alloc_order, classzone_idx);\n\t\tif (reclaim_order < alloc_order)\n\t\t\tgoto kswapd_try_sleep;\n\t}\n\n\ttsk->flags &= ~(PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD);\n\tcurrent->reclaim_state = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_pgdat",
          "args": [
            "pgdat",
            "alloc_order",
            "classzone_idx"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "balance_pgdat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3513-3639",
          "snippet": "static int balance_pgdat(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tunsigned long pflags;\n\tstruct zone *zone;\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.order = order,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\tpsi_memstall_enter(&pflags);\n\t__fs_reclaim_acquire();\n\n\tcount_vm_event(PAGEOUTRUN);\n\n\tdo {\n\t\tunsigned long nr_reclaimed = sc.nr_reclaimed;\n\t\tbool raise_priority = true;\n\t\tbool ret;\n\n\t\tsc.reclaim_idx = classzone_idx;\n\n\t\t/*\n\t\t * If the number of buffer_heads exceeds the maximum allowed\n\t\t * then consider reclaiming from all zones. This has a dual\n\t\t * purpose -- on 64-bit systems it is expected that\n\t\t * buffer_heads are stripped during active rotation. On 32-bit\n\t\t * systems, highmem pages can pin lowmem memory and shrinking\n\t\t * buffers can relieve lowmem pressure. Reclaim may still not\n\t\t * go ahead if all eligible zones for the original allocation\n\t\t * request are balanced to avoid excessive reclaim from kswapd.\n\t\t */\n\t\tif (buffer_heads_over_limit) {\n\t\t\tfor (i = MAX_NR_ZONES - 1; i >= 0; i--) {\n\t\t\t\tzone = pgdat->node_zones + i;\n\t\t\t\tif (!managed_zone(zone))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsc.reclaim_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Only reclaim if there are no eligible zones. Note that\n\t\t * sc.reclaim_idx is not used as buffer_heads_over_limit may\n\t\t * have adjusted it.\n\t\t */\n\t\tif (pgdat_balanced(pgdat, sc.order, classzone_idx))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Do some background aging of the anon list, to give\n\t\t * pages a chance to be referenced before reclaiming. All\n\t\t * pages are rotated regardless of classzone as this is\n\t\t * about consistent aging.\n\t\t */\n\t\tage_active_anon(pgdat, &sc);\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing writepage\n\t\t * even in laptop mode.\n\t\t */\n\t\tif (sc.priority < DEF_PRIORITY - 2)\n\t\t\tsc.may_writepage = 1;\n\n\t\t/* Call soft limit reclaim before calling shrink_node. */\n\t\tsc.nr_scanned = 0;\n\t\tnr_soft_scanned = 0;\n\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(pgdat, sc.order,\n\t\t\t\t\t\tsc.gfp_mask, &nr_soft_scanned);\n\t\tsc.nr_reclaimed += nr_soft_reclaimed;\n\n\t\t/*\n\t\t * There should be no need to raise the scanning priority if\n\t\t * enough pages are already being scanned that that high\n\t\t * watermark would be met at 100% efficiency.\n\t\t */\n\t\tif (kswapd_shrink_node(pgdat, &sc))\n\t\t\traise_priority = false;\n\n\t\t/*\n\t\t * If the low watermark is met there is no need for processes\n\t\t * to be throttled on pfmemalloc_wait as they should not be\n\t\t * able to safely make forward progress. Wake them\n\t\t */\n\t\tif (waitqueue_active(&pgdat->pfmemalloc_wait) &&\n\t\t\t\tallow_direct_reclaim(pgdat))\n\t\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t\t/* Check if kswapd should be suspending */\n\t\t__fs_reclaim_release();\n\t\tret = try_to_freeze();\n\t\t__fs_reclaim_acquire();\n\t\tif (ret || kthread_should_stop())\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Raise priority if scanning rate is too low or there was no\n\t\t * progress in reclaiming pages\n\t\t */\n\t\tnr_reclaimed = sc.nr_reclaimed - nr_reclaimed;\n\t\tif (raise_priority || !nr_reclaimed)\n\t\t\tsc.priority--;\n\t} while (sc.priority >= 1);\n\n\tif (!sc.nr_reclaimed)\n\t\tpgdat->kswapd_failures++;\n\nout:\n\tsnapshot_refaults(NULL, pgdat);\n\t__fs_reclaim_release();\n\tpsi_memstall_leave(&pflags);\n\t/*\n\t * Return the order kswapd stopped reclaiming at as\n\t * prepare_kswapd_sleep() takes it into account. If another caller\n\t * entered the allocator slow path while kswapd was awake, order will\n\t * remain at the higher level.\n\t */\n\treturn sc.order;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int balance_pgdat(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tunsigned long pflags;\n\tstruct zone *zone;\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.order = order,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\tpsi_memstall_enter(&pflags);\n\t__fs_reclaim_acquire();\n\n\tcount_vm_event(PAGEOUTRUN);\n\n\tdo {\n\t\tunsigned long nr_reclaimed = sc.nr_reclaimed;\n\t\tbool raise_priority = true;\n\t\tbool ret;\n\n\t\tsc.reclaim_idx = classzone_idx;\n\n\t\t/*\n\t\t * If the number of buffer_heads exceeds the maximum allowed\n\t\t * then consider reclaiming from all zones. This has a dual\n\t\t * purpose -- on 64-bit systems it is expected that\n\t\t * buffer_heads are stripped during active rotation. On 32-bit\n\t\t * systems, highmem pages can pin lowmem memory and shrinking\n\t\t * buffers can relieve lowmem pressure. Reclaim may still not\n\t\t * go ahead if all eligible zones for the original allocation\n\t\t * request are balanced to avoid excessive reclaim from kswapd.\n\t\t */\n\t\tif (buffer_heads_over_limit) {\n\t\t\tfor (i = MAX_NR_ZONES - 1; i >= 0; i--) {\n\t\t\t\tzone = pgdat->node_zones + i;\n\t\t\t\tif (!managed_zone(zone))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsc.reclaim_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Only reclaim if there are no eligible zones. Note that\n\t\t * sc.reclaim_idx is not used as buffer_heads_over_limit may\n\t\t * have adjusted it.\n\t\t */\n\t\tif (pgdat_balanced(pgdat, sc.order, classzone_idx))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Do some background aging of the anon list, to give\n\t\t * pages a chance to be referenced before reclaiming. All\n\t\t * pages are rotated regardless of classzone as this is\n\t\t * about consistent aging.\n\t\t */\n\t\tage_active_anon(pgdat, &sc);\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing writepage\n\t\t * even in laptop mode.\n\t\t */\n\t\tif (sc.priority < DEF_PRIORITY - 2)\n\t\t\tsc.may_writepage = 1;\n\n\t\t/* Call soft limit reclaim before calling shrink_node. */\n\t\tsc.nr_scanned = 0;\n\t\tnr_soft_scanned = 0;\n\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(pgdat, sc.order,\n\t\t\t\t\t\tsc.gfp_mask, &nr_soft_scanned);\n\t\tsc.nr_reclaimed += nr_soft_reclaimed;\n\n\t\t/*\n\t\t * There should be no need to raise the scanning priority if\n\t\t * enough pages are already being scanned that that high\n\t\t * watermark would be met at 100% efficiency.\n\t\t */\n\t\tif (kswapd_shrink_node(pgdat, &sc))\n\t\t\traise_priority = false;\n\n\t\t/*\n\t\t * If the low watermark is met there is no need for processes\n\t\t * to be throttled on pfmemalloc_wait as they should not be\n\t\t * able to safely make forward progress. Wake them\n\t\t */\n\t\tif (waitqueue_active(&pgdat->pfmemalloc_wait) &&\n\t\t\t\tallow_direct_reclaim(pgdat))\n\t\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t\t/* Check if kswapd should be suspending */\n\t\t__fs_reclaim_release();\n\t\tret = try_to_freeze();\n\t\t__fs_reclaim_acquire();\n\t\tif (ret || kthread_should_stop())\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Raise priority if scanning rate is too low or there was no\n\t\t * progress in reclaiming pages\n\t\t */\n\t\tnr_reclaimed = sc.nr_reclaimed - nr_reclaimed;\n\t\tif (raise_priority || !nr_reclaimed)\n\t\t\tsc.priority--;\n\t} while (sc.priority >= 1);\n\n\tif (!sc.nr_reclaimed)\n\t\tpgdat->kswapd_failures++;\n\nout:\n\tsnapshot_refaults(NULL, pgdat);\n\t__fs_reclaim_release();\n\tpsi_memstall_leave(&pflags);\n\t/*\n\t * Return the order kswapd stopped reclaiming at as\n\t * prepare_kswapd_sleep() takes it into account. If another caller\n\t * entered the allocator slow path while kswapd was awake, order will\n\t * remain at the higher level.\n\t */\n\treturn sc.order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_kswapd_wake",
          "args": [
            "pgdat->node_id",
            "classzone_idx",
            "alloc_order"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kswapd_classzone_idx",
          "args": [
            "pgdat",
            "0"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_classzone_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3648-3655",
          "snippet": "static enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kswapd_try_to_sleep",
          "args": [
            "pgdat",
            "alloc_order",
            "reclaim_order",
            "classzone_idx"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_try_to_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3657-3735",
          "snippet": "static void kswapd_try_to_sleep(pg_data_t *pgdat, int alloc_order, int reclaim_order,\n\t\t\t\tunsigned int classzone_idx)\n{\n\tlong remaining = 0;\n\tDEFINE_WAIT(wait);\n\n\tif (freezing(current) || kthread_should_stop())\n\t\treturn;\n\n\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t/*\n\t * Try to sleep for a short interval. Note that kcompactd will only be\n\t * woken if it is possible to sleep for a short interval. This is\n\t * deliberate on the assumption that if reclaim cannot keep an\n\t * eligible zone balanced that it's also unlikely that compaction will\n\t * succeed.\n\t */\n\tif (prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\t/*\n\t\t * Compaction records what page blocks it recently failed to\n\t\t * isolate pages from and skips them in the future scanning.\n\t\t * When kswapd is going to sleep, it is reasonable to assume\n\t\t * that pages and compaction may succeed so reset the cache.\n\t\t */\n\t\treset_isolation_suitable(pgdat);\n\n\t\t/*\n\t\t * We have freed the memory, now we should compact it to make\n\t\t * allocation of the requested order possible.\n\t\t */\n\t\twakeup_kcompactd(pgdat, alloc_order, classzone_idx);\n\n\t\tremaining = schedule_timeout(HZ/10);\n\n\t\t/*\n\t\t * If woken prematurely then reset kswapd_classzone_idx and\n\t\t * order. The values will either be from a wakeup request or\n\t\t * the previous request that slept prematurely.\n\t\t */\n\t\tif (remaining) {\n\t\t\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat, classzone_idx);\n\t\t\tpgdat->kswapd_order = max(pgdat->kswapd_order, reclaim_order);\n\t\t}\n\n\t\tfinish_wait(&pgdat->kswapd_wait, &wait);\n\t\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\t}\n\n\t/*\n\t * After a short sleep, check if it was a premature sleep. If not, then\n\t * go fully to sleep until explicitly woken up.\n\t */\n\tif (!remaining &&\n\t    prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\ttrace_mm_vmscan_kswapd_sleep(pgdat->node_id);\n\n\t\t/*\n\t\t * vmstat counters are not perfectly accurate and the estimated\n\t\t * value for counters such as NR_FREE_PAGES can deviate from the\n\t\t * true value by nr_online_cpus * threshold. To avoid the zone\n\t\t * watermarks being breached while under pressure, we reduce the\n\t\t * per-cpu vmstat threshold while kswapd is awake and restore\n\t\t * them before going back to sleep.\n\t\t */\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_normal_threshold);\n\n\t\tif (!kthread_should_stop())\n\t\t\tschedule();\n\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_pressure_threshold);\n\t} else {\n\t\tif (remaining)\n\t\t\tcount_vm_event(KSWAPD_LOW_WMARK_HIT_QUICKLY);\n\t\telse\n\t\t\tcount_vm_event(KSWAPD_HIGH_WMARK_HIT_QUICKLY);\n\t}\n\tfinish_wait(&pgdat->kswapd_wait, &wait);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void kswapd_try_to_sleep(pg_data_t *pgdat, int alloc_order, int reclaim_order,\n\t\t\t\tunsigned int classzone_idx)\n{\n\tlong remaining = 0;\n\tDEFINE_WAIT(wait);\n\n\tif (freezing(current) || kthread_should_stop())\n\t\treturn;\n\n\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t/*\n\t * Try to sleep for a short interval. Note that kcompactd will only be\n\t * woken if it is possible to sleep for a short interval. This is\n\t * deliberate on the assumption that if reclaim cannot keep an\n\t * eligible zone balanced that it's also unlikely that compaction will\n\t * succeed.\n\t */\n\tif (prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\t/*\n\t\t * Compaction records what page blocks it recently failed to\n\t\t * isolate pages from and skips them in the future scanning.\n\t\t * When kswapd is going to sleep, it is reasonable to assume\n\t\t * that pages and compaction may succeed so reset the cache.\n\t\t */\n\t\treset_isolation_suitable(pgdat);\n\n\t\t/*\n\t\t * We have freed the memory, now we should compact it to make\n\t\t * allocation of the requested order possible.\n\t\t */\n\t\twakeup_kcompactd(pgdat, alloc_order, classzone_idx);\n\n\t\tremaining = schedule_timeout(HZ/10);\n\n\t\t/*\n\t\t * If woken prematurely then reset kswapd_classzone_idx and\n\t\t * order. The values will either be from a wakeup request or\n\t\t * the previous request that slept prematurely.\n\t\t */\n\t\tif (remaining) {\n\t\t\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat, classzone_idx);\n\t\t\tpgdat->kswapd_order = max(pgdat->kswapd_order, reclaim_order);\n\t\t}\n\n\t\tfinish_wait(&pgdat->kswapd_wait, &wait);\n\t\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\t}\n\n\t/*\n\t * After a short sleep, check if it was a premature sleep. If not, then\n\t * go fully to sleep until explicitly woken up.\n\t */\n\tif (!remaining &&\n\t    prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\ttrace_mm_vmscan_kswapd_sleep(pgdat->node_id);\n\n\t\t/*\n\t\t * vmstat counters are not perfectly accurate and the estimated\n\t\t * value for counters such as NR_FREE_PAGES can deviate from the\n\t\t * true value by nr_online_cpus * threshold. To avoid the zone\n\t\t * watermarks being breached while under pressure, we reduce the\n\t\t * per-cpu vmstat threshold while kswapd is awake and restore\n\t\t * them before going back to sleep.\n\t\t */\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_normal_threshold);\n\n\t\tif (!kthread_should_stop())\n\t\t\tschedule();\n\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_pressure_threshold);\n\t} else {\n\t\tif (remaining)\n\t\t\tcount_vm_event(KSWAPD_LOW_WMARK_HIT_QUICKLY);\n\t\telse\n\t\t\tcount_vm_event(KSWAPD_HIGH_WMARK_HIT_QUICKLY);\n\t}\n\tfinish_wait(&pgdat->kswapd_wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 3779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "tsk",
            "cpumask"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "pgdat->node_id"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int kswapd(void *p)\n{\n\tunsigned int alloc_order, reclaim_order;\n\tunsigned int classzone_idx = MAX_NR_ZONES - 1;\n\tpg_data_t *pgdat = (pg_data_t*)p;\n\tstruct task_struct *tsk = current;\n\n\tstruct reclaim_state reclaim_state = {\n\t\t.reclaimed_slab = 0,\n\t};\n\tconst struct cpumask *cpumask = cpumask_of_node(pgdat->node_id);\n\n\tif (!cpumask_empty(cpumask))\n\t\tset_cpus_allowed_ptr(tsk, cpumask);\n\tcurrent->reclaim_state = &reclaim_state;\n\n\t/*\n\t * Tell the memory management that we're a \"memory allocator\",\n\t * and that if we need more memory we should get access to it\n\t * regardless (see \"__alloc_pages()\"). \"kswapd\" should\n\t * never get caught in the normal page freeing logic.\n\t *\n\t * (Kswapd normally doesn't need memory anyway, but sometimes\n\t * you need a small amount of memory in order to be able to\n\t * page out something else, and this flag essentially protects\n\t * us from recursively trying to free more memory as we're\n\t * trying to free the first piece of memory in the first place).\n\t */\n\ttsk->flags |= PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD;\n\tset_freezable();\n\n\tpgdat->kswapd_order = 0;\n\tpgdat->kswapd_classzone_idx = MAX_NR_ZONES;\n\tfor ( ; ; ) {\n\t\tbool ret;\n\n\t\talloc_order = reclaim_order = pgdat->kswapd_order;\n\t\tclasszone_idx = kswapd_classzone_idx(pgdat, classzone_idx);\n\nkswapd_try_sleep:\n\t\tkswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,\n\t\t\t\t\tclasszone_idx);\n\n\t\t/* Read the new order and classzone_idx */\n\t\talloc_order = reclaim_order = pgdat->kswapd_order;\n\t\tclasszone_idx = kswapd_classzone_idx(pgdat, 0);\n\t\tpgdat->kswapd_order = 0;\n\t\tpgdat->kswapd_classzone_idx = MAX_NR_ZONES;\n\n\t\tret = try_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We can speed up thawing tasks if we don't call balance_pgdat\n\t\t * after returning from the refrigerator\n\t\t */\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Reclaim begins at the requested order but if a high-order\n\t\t * reclaim fails then kswapd falls back to reclaiming for\n\t\t * order-0. If that happens, kswapd will consider sleeping\n\t\t * for the order it finished reclaiming at (reclaim_order)\n\t\t * but kcompactd is woken to compact for the original\n\t\t * request (alloc_order).\n\t\t */\n\t\ttrace_mm_vmscan_kswapd_wake(pgdat->node_id, classzone_idx,\n\t\t\t\t\t\talloc_order);\n\t\treclaim_order = balance_pgdat(pgdat, alloc_order, classzone_idx);\n\t\tif (reclaim_order < alloc_order)\n\t\t\tgoto kswapd_try_sleep;\n\t}\n\n\ttsk->flags &= ~(PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD);\n\tcurrent->reclaim_state = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kswapd_try_to_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3657-3735",
    "snippet": "static void kswapd_try_to_sleep(pg_data_t *pgdat, int alloc_order, int reclaim_order,\n\t\t\t\tunsigned int classzone_idx)\n{\n\tlong remaining = 0;\n\tDEFINE_WAIT(wait);\n\n\tif (freezing(current) || kthread_should_stop())\n\t\treturn;\n\n\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t/*\n\t * Try to sleep for a short interval. Note that kcompactd will only be\n\t * woken if it is possible to sleep for a short interval. This is\n\t * deliberate on the assumption that if reclaim cannot keep an\n\t * eligible zone balanced that it's also unlikely that compaction will\n\t * succeed.\n\t */\n\tif (prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\t/*\n\t\t * Compaction records what page blocks it recently failed to\n\t\t * isolate pages from and skips them in the future scanning.\n\t\t * When kswapd is going to sleep, it is reasonable to assume\n\t\t * that pages and compaction may succeed so reset the cache.\n\t\t */\n\t\treset_isolation_suitable(pgdat);\n\n\t\t/*\n\t\t * We have freed the memory, now we should compact it to make\n\t\t * allocation of the requested order possible.\n\t\t */\n\t\twakeup_kcompactd(pgdat, alloc_order, classzone_idx);\n\n\t\tremaining = schedule_timeout(HZ/10);\n\n\t\t/*\n\t\t * If woken prematurely then reset kswapd_classzone_idx and\n\t\t * order. The values will either be from a wakeup request or\n\t\t * the previous request that slept prematurely.\n\t\t */\n\t\tif (remaining) {\n\t\t\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat, classzone_idx);\n\t\t\tpgdat->kswapd_order = max(pgdat->kswapd_order, reclaim_order);\n\t\t}\n\n\t\tfinish_wait(&pgdat->kswapd_wait, &wait);\n\t\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\t}\n\n\t/*\n\t * After a short sleep, check if it was a premature sleep. If not, then\n\t * go fully to sleep until explicitly woken up.\n\t */\n\tif (!remaining &&\n\t    prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\ttrace_mm_vmscan_kswapd_sleep(pgdat->node_id);\n\n\t\t/*\n\t\t * vmstat counters are not perfectly accurate and the estimated\n\t\t * value for counters such as NR_FREE_PAGES can deviate from the\n\t\t * true value by nr_online_cpus * threshold. To avoid the zone\n\t\t * watermarks being breached while under pressure, we reduce the\n\t\t * per-cpu vmstat threshold while kswapd is awake and restore\n\t\t * them before going back to sleep.\n\t\t */\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_normal_threshold);\n\n\t\tif (!kthread_should_stop())\n\t\t\tschedule();\n\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_pressure_threshold);\n\t} else {\n\t\tif (remaining)\n\t\t\tcount_vm_event(KSWAPD_LOW_WMARK_HIT_QUICKLY);\n\t\telse\n\t\t\tcount_vm_event(KSWAPD_HIGH_WMARK_HIT_QUICKLY);\n\t}\n\tfinish_wait(&pgdat->kswapd_wait, &wait);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&pgdat->kswapd_wait",
            "&wait"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "KSWAPD_HIGH_WMARK_HIT_QUICKLY"
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "KSWAPD_LOW_WMARK_HIT_QUICKLY"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pgdat_percpu_threshold",
          "args": [
            "pgdat",
            "calculate_pressure_threshold"
          ],
          "line": 3727
        },
        "resolved": true,
        "details": {
          "function_name": "set_pgdat_percpu_threshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "290-308",
          "snippet": "void set_pgdat_percpu_threshold(pg_data_t *pgdat,\n\t\t\t\tint (*calculate_pressure)(struct zone *))\n{\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\tint i;\n\n\tfor (i = 0; i < pgdat->nr_zones; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!zone->percpu_drift_mark)\n\t\t\tcontinue;\n\n\t\tthreshold = (*calculate_pressure)(zone);\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid set_pgdat_percpu_threshold(pg_data_t *pgdat,\n\t\t\t\tint (*calculate_pressure)(struct zone *))\n{\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\tint i;\n\n\tfor (i = 0; i < pgdat->nr_zones; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!zone->percpu_drift_mark)\n\t\t\tcontinue;\n\n\t\tthreshold = (*calculate_pressure)(zone);\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3725
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_schedule_balance_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "191-195",
          "snippet": "static void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool pcpu_async_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_kswapd_sleep",
          "args": [
            "pgdat->node_id"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_kswapd_sleep",
          "args": [
            "pgdat",
            "reclaim_order",
            "classzone_idx"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_kswapd_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3427-3455",
          "snippet": "static bool prepare_kswapd_sleep(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\t/*\n\t * The throttled processes are normally woken up in balance_pgdat() as\n\t * soon as allow_direct_reclaim() is true. But there is a potential\n\t * race between when kswapd checks the watermarks and a process gets\n\t * throttled. There is also a potential race if processes get\n\t * throttled, kswapd wakes, a large process exits thereby balancing the\n\t * zones, which causes kswapd to exit balance_pgdat() before reaching\n\t * the wake up checks. If kswapd is going to sleep, no process should\n\t * be sleeping on pfmemalloc_wait, so wake them now if necessary. If\n\t * the wake up is premature, processes will wake kswapd and get\n\t * throttled again. The difference from wake ups in balance_pgdat() is\n\t * that here we are under prepare_to_wait().\n\t */\n\tif (waitqueue_active(&pgdat->pfmemalloc_wait))\n\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t/* Hopeless node, leave it to direct reclaim */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tif (pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\tclear_pgdat_congested(pgdat);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool prepare_kswapd_sleep(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\t/*\n\t * The throttled processes are normally woken up in balance_pgdat() as\n\t * soon as allow_direct_reclaim() is true. But there is a potential\n\t * race between when kswapd checks the watermarks and a process gets\n\t * throttled. There is also a potential race if processes get\n\t * throttled, kswapd wakes, a large process exits thereby balancing the\n\t * zones, which causes kswapd to exit balance_pgdat() before reaching\n\t * the wake up checks. If kswapd is going to sleep, no process should\n\t * be sleeping on pfmemalloc_wait, so wake them now if necessary. If\n\t * the wake up is premature, processes will wake kswapd and get\n\t * throttled again. The difference from wake ups in balance_pgdat() is\n\t * that here we are under prepare_to_wait().\n\t */\n\tif (waitqueue_active(&pgdat->pfmemalloc_wait))\n\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t/* Hopeless node, leave it to direct reclaim */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tif (pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\tclear_pgdat_congested(pgdat);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&pgdat->kswapd_wait",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&pgdat->kswapd_wait",
            "&wait"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "pgdat->kswapd_order",
            "reclaim_order"
          ],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kswapd_classzone_idx",
          "args": [
            "pgdat",
            "classzone_idx"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_classzone_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3648-3655",
          "snippet": "static enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "HZ/10"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_kcompactd",
          "args": [
            "pgdat",
            "alloc_order",
            "classzone_idx"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_kcompactd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "2026-2050",
          "snippet": "void wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tif (!order)\n\t\treturn;\n\n\tif (pgdat->kcompactd_max_order < order)\n\t\tpgdat->kcompactd_max_order = order;\n\n\tif (pgdat->kcompactd_classzone_idx > classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = classzone_idx;\n\n\t/*\n\t * Pairs with implicit barrier in wait_event_freezable()\n\t * such that wakeups are not missed.\n\t */\n\tif (!wq_has_sleeper(&pgdat->kcompactd_wait))\n\t\treturn;\n\n\tif (!kcompactd_node_suitable(pgdat))\n\t\treturn;\n\n\ttrace_mm_compaction_wakeup_kcompactd(pgdat->node_id, order,\n\t\t\t\t\t\t\tclasszone_idx);\n\twake_up_interruptible(&pgdat->kcompactd_wait);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tif (!order)\n\t\treturn;\n\n\tif (pgdat->kcompactd_max_order < order)\n\t\tpgdat->kcompactd_max_order = order;\n\n\tif (pgdat->kcompactd_classzone_idx > classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = classzone_idx;\n\n\t/*\n\t * Pairs with implicit barrier in wait_event_freezable()\n\t * such that wakeups are not missed.\n\t */\n\tif (!wq_has_sleeper(&pgdat->kcompactd_wait))\n\t\treturn;\n\n\tif (!kcompactd_node_suitable(pgdat))\n\t\treturn;\n\n\ttrace_mm_compaction_wakeup_kcompactd(pgdat->node_id, order,\n\t\t\t\t\t\t\tclasszone_idx);\n\twake_up_interruptible(&pgdat->kcompactd_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_isolation_suitable",
          "args": [
            "pgdat"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "reset_isolation_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "273-286",
          "snippet": "void reset_isolation_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Only flush if a full compaction finished recently */\n\t\tif (zone->compact_blockskip_flush)\n\t\t\t__reset_isolation_suitable(zone);\n\t}\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid reset_isolation_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Only flush if a full compaction finished recently */\n\t\tif (zone->compact_blockskip_flush)\n\t\t\t__reset_isolation_suitable(zone);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&pgdat->kswapd_wait",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void kswapd_try_to_sleep(pg_data_t *pgdat, int alloc_order, int reclaim_order,\n\t\t\t\tunsigned int classzone_idx)\n{\n\tlong remaining = 0;\n\tDEFINE_WAIT(wait);\n\n\tif (freezing(current) || kthread_should_stop())\n\t\treturn;\n\n\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\n\t/*\n\t * Try to sleep for a short interval. Note that kcompactd will only be\n\t * woken if it is possible to sleep for a short interval. This is\n\t * deliberate on the assumption that if reclaim cannot keep an\n\t * eligible zone balanced that it's also unlikely that compaction will\n\t * succeed.\n\t */\n\tif (prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\t/*\n\t\t * Compaction records what page blocks it recently failed to\n\t\t * isolate pages from and skips them in the future scanning.\n\t\t * When kswapd is going to sleep, it is reasonable to assume\n\t\t * that pages and compaction may succeed so reset the cache.\n\t\t */\n\t\treset_isolation_suitable(pgdat);\n\n\t\t/*\n\t\t * We have freed the memory, now we should compact it to make\n\t\t * allocation of the requested order possible.\n\t\t */\n\t\twakeup_kcompactd(pgdat, alloc_order, classzone_idx);\n\n\t\tremaining = schedule_timeout(HZ/10);\n\n\t\t/*\n\t\t * If woken prematurely then reset kswapd_classzone_idx and\n\t\t * order. The values will either be from a wakeup request or\n\t\t * the previous request that slept prematurely.\n\t\t */\n\t\tif (remaining) {\n\t\t\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat, classzone_idx);\n\t\t\tpgdat->kswapd_order = max(pgdat->kswapd_order, reclaim_order);\n\t\t}\n\n\t\tfinish_wait(&pgdat->kswapd_wait, &wait);\n\t\tprepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);\n\t}\n\n\t/*\n\t * After a short sleep, check if it was a premature sleep. If not, then\n\t * go fully to sleep until explicitly woken up.\n\t */\n\tif (!remaining &&\n\t    prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx)) {\n\t\ttrace_mm_vmscan_kswapd_sleep(pgdat->node_id);\n\n\t\t/*\n\t\t * vmstat counters are not perfectly accurate and the estimated\n\t\t * value for counters such as NR_FREE_PAGES can deviate from the\n\t\t * true value by nr_online_cpus * threshold. To avoid the zone\n\t\t * watermarks being breached while under pressure, we reduce the\n\t\t * per-cpu vmstat threshold while kswapd is awake and restore\n\t\t * them before going back to sleep.\n\t\t */\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_normal_threshold);\n\n\t\tif (!kthread_should_stop())\n\t\t\tschedule();\n\n\t\tset_pgdat_percpu_threshold(pgdat, calculate_pressure_threshold);\n\t} else {\n\t\tif (remaining)\n\t\t\tcount_vm_event(KSWAPD_LOW_WMARK_HIT_QUICKLY);\n\t\telse\n\t\t\tcount_vm_event(KSWAPD_HIGH_WMARK_HIT_QUICKLY);\n\t}\n\tfinish_wait(&pgdat->kswapd_wait, &wait);\n}"
  },
  {
    "function_name": "kswapd_classzone_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3648-3655",
    "snippet": "static enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "pgdat->kswapd_classzone_idx",
            "classzone_idx"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic enum zone_type kswapd_classzone_idx(pg_data_t *pgdat,\n\t\t\t\t\t   enum zone_type classzone_idx)\n{\n\tif (pgdat->kswapd_classzone_idx == MAX_NR_ZONES)\n\t\treturn classzone_idx;\n\n\treturn max(pgdat->kswapd_classzone_idx, classzone_idx);\n}"
  },
  {
    "function_name": "balance_pgdat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3513-3639",
    "snippet": "static int balance_pgdat(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tunsigned long pflags;\n\tstruct zone *zone;\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.order = order,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\tpsi_memstall_enter(&pflags);\n\t__fs_reclaim_acquire();\n\n\tcount_vm_event(PAGEOUTRUN);\n\n\tdo {\n\t\tunsigned long nr_reclaimed = sc.nr_reclaimed;\n\t\tbool raise_priority = true;\n\t\tbool ret;\n\n\t\tsc.reclaim_idx = classzone_idx;\n\n\t\t/*\n\t\t * If the number of buffer_heads exceeds the maximum allowed\n\t\t * then consider reclaiming from all zones. This has a dual\n\t\t * purpose -- on 64-bit systems it is expected that\n\t\t * buffer_heads are stripped during active rotation. On 32-bit\n\t\t * systems, highmem pages can pin lowmem memory and shrinking\n\t\t * buffers can relieve lowmem pressure. Reclaim may still not\n\t\t * go ahead if all eligible zones for the original allocation\n\t\t * request are balanced to avoid excessive reclaim from kswapd.\n\t\t */\n\t\tif (buffer_heads_over_limit) {\n\t\t\tfor (i = MAX_NR_ZONES - 1; i >= 0; i--) {\n\t\t\t\tzone = pgdat->node_zones + i;\n\t\t\t\tif (!managed_zone(zone))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsc.reclaim_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Only reclaim if there are no eligible zones. Note that\n\t\t * sc.reclaim_idx is not used as buffer_heads_over_limit may\n\t\t * have adjusted it.\n\t\t */\n\t\tif (pgdat_balanced(pgdat, sc.order, classzone_idx))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Do some background aging of the anon list, to give\n\t\t * pages a chance to be referenced before reclaiming. All\n\t\t * pages are rotated regardless of classzone as this is\n\t\t * about consistent aging.\n\t\t */\n\t\tage_active_anon(pgdat, &sc);\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing writepage\n\t\t * even in laptop mode.\n\t\t */\n\t\tif (sc.priority < DEF_PRIORITY - 2)\n\t\t\tsc.may_writepage = 1;\n\n\t\t/* Call soft limit reclaim before calling shrink_node. */\n\t\tsc.nr_scanned = 0;\n\t\tnr_soft_scanned = 0;\n\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(pgdat, sc.order,\n\t\t\t\t\t\tsc.gfp_mask, &nr_soft_scanned);\n\t\tsc.nr_reclaimed += nr_soft_reclaimed;\n\n\t\t/*\n\t\t * There should be no need to raise the scanning priority if\n\t\t * enough pages are already being scanned that that high\n\t\t * watermark would be met at 100% efficiency.\n\t\t */\n\t\tif (kswapd_shrink_node(pgdat, &sc))\n\t\t\traise_priority = false;\n\n\t\t/*\n\t\t * If the low watermark is met there is no need for processes\n\t\t * to be throttled on pfmemalloc_wait as they should not be\n\t\t * able to safely make forward progress. Wake them\n\t\t */\n\t\tif (waitqueue_active(&pgdat->pfmemalloc_wait) &&\n\t\t\t\tallow_direct_reclaim(pgdat))\n\t\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t\t/* Check if kswapd should be suspending */\n\t\t__fs_reclaim_release();\n\t\tret = try_to_freeze();\n\t\t__fs_reclaim_acquire();\n\t\tif (ret || kthread_should_stop())\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Raise priority if scanning rate is too low or there was no\n\t\t * progress in reclaiming pages\n\t\t */\n\t\tnr_reclaimed = sc.nr_reclaimed - nr_reclaimed;\n\t\tif (raise_priority || !nr_reclaimed)\n\t\t\tsc.priority--;\n\t} while (sc.priority >= 1);\n\n\tif (!sc.nr_reclaimed)\n\t\tpgdat->kswapd_failures++;\n\nout:\n\tsnapshot_refaults(NULL, pgdat);\n\t__fs_reclaim_release();\n\tpsi_memstall_leave(&pflags);\n\t/*\n\t * Return the order kswapd stopped reclaiming at as\n\t * prepare_kswapd_sleep() takes it into account. If another caller\n\t * entered the allocator slow path while kswapd was awake, order will\n\t * remain at the higher level.\n\t */\n\treturn sc.order;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_memstall_leave",
          "args": [
            "&pflags"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fs_reclaim_release",
          "args": [],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "__fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3733-3736",
          "snippet": "void __fs_reclaim_release(void)\n{\n\tlock_map_release(&__fs_reclaim_map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __fs_reclaim_release(void)\n{\n\tlock_map_release(&__fs_reclaim_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_refaults",
          "args": [
            "NULL",
            "pgdat"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_refaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2997-3014",
          "snippet": "static void snapshot_refaults(struct mem_cgroup *root_memcg, pg_data_t *pgdat)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = mem_cgroup_iter(root_memcg, NULL, NULL);\n\tdo {\n\t\tunsigned long refaults;\n\t\tstruct lruvec *lruvec;\n\n\t\tif (memcg)\n\t\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\t\telse\n\t\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\t\tlruvec->refaults = refaults;\n\t} while ((memcg = mem_cgroup_iter(root_memcg, memcg, NULL)));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void snapshot_refaults(struct mem_cgroup *root_memcg, pg_data_t *pgdat)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = mem_cgroup_iter(root_memcg, NULL, NULL);\n\tdo {\n\t\tunsigned long refaults;\n\t\tstruct lruvec *lruvec;\n\n\t\tif (memcg)\n\t\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\t\telse\n\t\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\t\tlruvec->refaults = refaults;\n\t} while ((memcg = mem_cgroup_iter(root_memcg, memcg, NULL)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fs_reclaim_acquire",
          "args": [],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "__fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3728-3731",
          "snippet": "void __fs_reclaim_acquire(void)\n{\n\tlock_map_acquire(&__fs_reclaim_map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __fs_reclaim_acquire(void)\n{\n\tlock_map_acquire(&__fs_reclaim_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&pgdat->pfmemalloc_wait"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_direct_reclaim",
          "args": [
            "pgdat"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "allow_direct_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3095-3132",
          "snippet": "static bool allow_direct_reclaim(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tunsigned long pfmemalloc_reserve = 0;\n\tunsigned long free_pages = 0;\n\tint i;\n\tbool wmark_ok;\n\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tfor (i = 0; i <= ZONE_NORMAL; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!zone_reclaimable_pages(zone))\n\t\t\tcontinue;\n\n\t\tpfmemalloc_reserve += min_wmark_pages(zone);\n\t\tfree_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/* If there are no reserves (unexpected config) then do not throttle */\n\tif (!pfmemalloc_reserve)\n\t\treturn true;\n\n\twmark_ok = free_pages > pfmemalloc_reserve / 2;\n\n\t/* kswapd must be awake if processes are being throttled */\n\tif (!wmark_ok && waitqueue_active(&pgdat->kswapd_wait)) {\n\t\tpgdat->kswapd_classzone_idx = min(pgdat->kswapd_classzone_idx,\n\t\t\t\t\t\t(enum zone_type)ZONE_NORMAL);\n\t\twake_up_interruptible(&pgdat->kswapd_wait);\n\t}\n\n\treturn wmark_ok;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool allow_direct_reclaim(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tunsigned long pfmemalloc_reserve = 0;\n\tunsigned long free_pages = 0;\n\tint i;\n\tbool wmark_ok;\n\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tfor (i = 0; i <= ZONE_NORMAL; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!zone_reclaimable_pages(zone))\n\t\t\tcontinue;\n\n\t\tpfmemalloc_reserve += min_wmark_pages(zone);\n\t\tfree_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/* If there are no reserves (unexpected config) then do not throttle */\n\tif (!pfmemalloc_reserve)\n\t\treturn true;\n\n\twmark_ok = free_pages > pfmemalloc_reserve / 2;\n\n\t/* kswapd must be awake if processes are being throttled */\n\tif (!wmark_ok && waitqueue_active(&pgdat->kswapd_wait)) {\n\t\tpgdat->kswapd_classzone_idx = min(pgdat->kswapd_classzone_idx,\n\t\t\t\t\t\t(enum zone_type)ZONE_NORMAL);\n\t\twake_up_interruptible(&pgdat->kswapd_wait);\n\t}\n\n\treturn wmark_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pgdat->pfmemalloc_wait"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kswapd_shrink_node",
          "args": [
            "pgdat",
            "&sc"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_shrink_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3465-3498",
          "snippet": "static bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_soft_limit_reclaim",
          "args": [
            "pgdat",
            "sc.order",
            "sc.gfp_mask",
            "&nr_soft_scanned"
          ],
          "line": 3588
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_soft_limit_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2754-2835",
          "snippet": "unsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node(pgdat->node_id);\n\n\t/*\n\t * Do not even bother to check the largest node if the root\n\t * is empty. Do it lockless to prevent lock bouncing. Races\n\t * are acceptable as soft limit is best effort anyway.\n\t */\n\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))\n\t\treturn 0;\n\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock_irq(&mctz->lock);\n\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed)\n\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);\n\n\t\texcess = soft_limit_excess(mz->memcg);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\tspin_unlock_irq(&mctz->lock);\n\t\tcss_put(&mz->memcg->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->memcg->css);\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t2"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t2\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node(pgdat->node_id);\n\n\t/*\n\t * Do not even bother to check the largest node if the root\n\t * is empty. Do it lockless to prevent lock bouncing. Races\n\t * are acceptable as soft limit is best effort anyway.\n\t */\n\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))\n\t\treturn 0;\n\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock_irq(&mctz->lock);\n\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed)\n\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);\n\n\t\texcess = soft_limit_excess(mz->memcg);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\tspin_unlock_irq(&mctz->lock);\n\t\tcss_put(&mz->memcg->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->memcg->css);\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "age_active_anon",
          "args": [
            "pgdat",
            "&sc"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "age_active_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3361-3379",
          "snippet": "static void age_active_anon(struct pglist_data *pgdat,\n\t\t\t\tstruct scan_control *sc)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!total_swap_pages)\n\t\treturn;\n\n\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\tdo {\n\t\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\n\t\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t\t   sc, LRU_ACTIVE_ANON);\n\n\t\tmemcg = mem_cgroup_iter(NULL, memcg, NULL);\n\t} while (memcg);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void age_active_anon(struct pglist_data *pgdat,\n\t\t\t\tstruct scan_control *sc)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!total_swap_pages)\n\t\treturn;\n\n\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\tdo {\n\t\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\n\t\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t\t   sc, LRU_ACTIVE_ANON);\n\n\t\tmemcg = mem_cgroup_iter(NULL, memcg, NULL);\n\t} while (memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_balanced",
          "args": [
            "pgdat",
            "sc.order",
            "classzone_idx"
          ],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "pgdat_balanced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3385-3411",
          "snippet": "static bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PAGEOUTRUN"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_memstall_enter",
          "args": [
            "&pflags"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int balance_pgdat(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tunsigned long pflags;\n\tstruct zone *zone;\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.order = order,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\tpsi_memstall_enter(&pflags);\n\t__fs_reclaim_acquire();\n\n\tcount_vm_event(PAGEOUTRUN);\n\n\tdo {\n\t\tunsigned long nr_reclaimed = sc.nr_reclaimed;\n\t\tbool raise_priority = true;\n\t\tbool ret;\n\n\t\tsc.reclaim_idx = classzone_idx;\n\n\t\t/*\n\t\t * If the number of buffer_heads exceeds the maximum allowed\n\t\t * then consider reclaiming from all zones. This has a dual\n\t\t * purpose -- on 64-bit systems it is expected that\n\t\t * buffer_heads are stripped during active rotation. On 32-bit\n\t\t * systems, highmem pages can pin lowmem memory and shrinking\n\t\t * buffers can relieve lowmem pressure. Reclaim may still not\n\t\t * go ahead if all eligible zones for the original allocation\n\t\t * request are balanced to avoid excessive reclaim from kswapd.\n\t\t */\n\t\tif (buffer_heads_over_limit) {\n\t\t\tfor (i = MAX_NR_ZONES - 1; i >= 0; i--) {\n\t\t\t\tzone = pgdat->node_zones + i;\n\t\t\t\tif (!managed_zone(zone))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsc.reclaim_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Only reclaim if there are no eligible zones. Note that\n\t\t * sc.reclaim_idx is not used as buffer_heads_over_limit may\n\t\t * have adjusted it.\n\t\t */\n\t\tif (pgdat_balanced(pgdat, sc.order, classzone_idx))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Do some background aging of the anon list, to give\n\t\t * pages a chance to be referenced before reclaiming. All\n\t\t * pages are rotated regardless of classzone as this is\n\t\t * about consistent aging.\n\t\t */\n\t\tage_active_anon(pgdat, &sc);\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing writepage\n\t\t * even in laptop mode.\n\t\t */\n\t\tif (sc.priority < DEF_PRIORITY - 2)\n\t\t\tsc.may_writepage = 1;\n\n\t\t/* Call soft limit reclaim before calling shrink_node. */\n\t\tsc.nr_scanned = 0;\n\t\tnr_soft_scanned = 0;\n\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(pgdat, sc.order,\n\t\t\t\t\t\tsc.gfp_mask, &nr_soft_scanned);\n\t\tsc.nr_reclaimed += nr_soft_reclaimed;\n\n\t\t/*\n\t\t * There should be no need to raise the scanning priority if\n\t\t * enough pages are already being scanned that that high\n\t\t * watermark would be met at 100% efficiency.\n\t\t */\n\t\tif (kswapd_shrink_node(pgdat, &sc))\n\t\t\traise_priority = false;\n\n\t\t/*\n\t\t * If the low watermark is met there is no need for processes\n\t\t * to be throttled on pfmemalloc_wait as they should not be\n\t\t * able to safely make forward progress. Wake them\n\t\t */\n\t\tif (waitqueue_active(&pgdat->pfmemalloc_wait) &&\n\t\t\t\tallow_direct_reclaim(pgdat))\n\t\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t\t/* Check if kswapd should be suspending */\n\t\t__fs_reclaim_release();\n\t\tret = try_to_freeze();\n\t\t__fs_reclaim_acquire();\n\t\tif (ret || kthread_should_stop())\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Raise priority if scanning rate is too low or there was no\n\t\t * progress in reclaiming pages\n\t\t */\n\t\tnr_reclaimed = sc.nr_reclaimed - nr_reclaimed;\n\t\tif (raise_priority || !nr_reclaimed)\n\t\t\tsc.priority--;\n\t} while (sc.priority >= 1);\n\n\tif (!sc.nr_reclaimed)\n\t\tpgdat->kswapd_failures++;\n\nout:\n\tsnapshot_refaults(NULL, pgdat);\n\t__fs_reclaim_release();\n\tpsi_memstall_leave(&pflags);\n\t/*\n\t * Return the order kswapd stopped reclaiming at as\n\t * prepare_kswapd_sleep() takes it into account. If another caller\n\t * entered the allocator slow path while kswapd was awake, order will\n\t * remain at the higher level.\n\t */\n\treturn sc.order;\n}"
  },
  {
    "function_name": "kswapd_shrink_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3465-3498",
    "snippet": "static bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compact_gap",
          "args": [
            "sc->order"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_node",
          "args": [
            "pgdat",
            "sc"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_shrink_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3465-3498",
          "snippet": "static bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "high_wmark_pages(zone)",
            "SWAP_CLUSTER_MAX"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}"
  },
  {
    "function_name": "prepare_kswapd_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3427-3455",
    "snippet": "static bool prepare_kswapd_sleep(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\t/*\n\t * The throttled processes are normally woken up in balance_pgdat() as\n\t * soon as allow_direct_reclaim() is true. But there is a potential\n\t * race between when kswapd checks the watermarks and a process gets\n\t * throttled. There is also a potential race if processes get\n\t * throttled, kswapd wakes, a large process exits thereby balancing the\n\t * zones, which causes kswapd to exit balance_pgdat() before reaching\n\t * the wake up checks. If kswapd is going to sleep, no process should\n\t * be sleeping on pfmemalloc_wait, so wake them now if necessary. If\n\t * the wake up is premature, processes will wake kswapd and get\n\t * throttled again. The difference from wake ups in balance_pgdat() is\n\t * that here we are under prepare_to_wait().\n\t */\n\tif (waitqueue_active(&pgdat->pfmemalloc_wait))\n\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t/* Hopeless node, leave it to direct reclaim */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tif (pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\tclear_pgdat_congested(pgdat);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_pgdat_congested",
          "args": [
            "pgdat"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "clear_pgdat_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3414-3419",
          "snippet": "static void clear_pgdat_congested(pg_data_t *pgdat)\n{\n\tclear_bit(PGDAT_CONGESTED, &pgdat->flags);\n\tclear_bit(PGDAT_DIRTY, &pgdat->flags);\n\tclear_bit(PGDAT_WRITEBACK, &pgdat->flags);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void clear_pgdat_congested(pg_data_t *pgdat)\n{\n\tclear_bit(PGDAT_CONGESTED, &pgdat->flags);\n\tclear_bit(PGDAT_DIRTY, &pgdat->flags);\n\tclear_bit(PGDAT_WRITEBACK, &pgdat->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_balanced",
          "args": [
            "pgdat",
            "order",
            "classzone_idx"
          ],
          "line": 3449
        },
        "resolved": true,
        "details": {
          "function_name": "pgdat_balanced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3385-3411",
          "snippet": "static bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&pgdat->pfmemalloc_wait"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pgdat->pfmemalloc_wait"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool prepare_kswapd_sleep(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\t/*\n\t * The throttled processes are normally woken up in balance_pgdat() as\n\t * soon as allow_direct_reclaim() is true. But there is a potential\n\t * race between when kswapd checks the watermarks and a process gets\n\t * throttled. There is also a potential race if processes get\n\t * throttled, kswapd wakes, a large process exits thereby balancing the\n\t * zones, which causes kswapd to exit balance_pgdat() before reaching\n\t * the wake up checks. If kswapd is going to sleep, no process should\n\t * be sleeping on pfmemalloc_wait, so wake them now if necessary. If\n\t * the wake up is premature, processes will wake kswapd and get\n\t * throttled again. The difference from wake ups in balance_pgdat() is\n\t * that here we are under prepare_to_wait().\n\t */\n\tif (waitqueue_active(&pgdat->pfmemalloc_wait))\n\t\twake_up_all(&pgdat->pfmemalloc_wait);\n\n\t/* Hopeless node, leave it to direct reclaim */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tif (pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\tclear_pgdat_congested(pgdat);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "clear_pgdat_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3414-3419",
    "snippet": "static void clear_pgdat_congested(pg_data_t *pgdat)\n{\n\tclear_bit(PGDAT_CONGESTED, &pgdat->flags);\n\tclear_bit(PGDAT_DIRTY, &pgdat->flags);\n\tclear_bit(PGDAT_WRITEBACK, &pgdat->flags);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "PGDAT_WRITEBACK",
            "&pgdat->flags"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void clear_pgdat_congested(pg_data_t *pgdat)\n{\n\tclear_bit(PGDAT_CONGESTED, &pgdat->flags);\n\tclear_bit(PGDAT_DIRTY, &pgdat->flags);\n\tclear_bit(PGDAT_WRITEBACK, &pgdat->flags);\n}"
  },
  {
    "function_name": "pgdat_balanced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3385-3411",
    "snippet": "static bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_watermark_ok_safe",
          "args": [
            "zone",
            "order",
            "mark",
            "classzone_idx"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_ok_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3231-3241",
          "snippet": "bool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tint i;\n\tunsigned long mark = -1;\n\tstruct zone *zone;\n\n\tfor (i = 0; i <= classzone_idx; i++) {\n\t\tzone = pgdat->node_zones + i;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tmark = high_wmark_pages(zone);\n\t\tif (zone_watermark_ok_safe(zone, order, mark, classzone_idx))\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If a node has no populated zone within classzone_idx, it does not\n\t * need balancing by definition. This can happen if a zone-restricted\n\t * allocation tries to wake a remote kswapd.\n\t */\n\tif (mark == -1)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "age_active_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3361-3379",
    "snippet": "static void age_active_anon(struct pglist_data *pgdat,\n\t\t\t\tstruct scan_control *sc)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!total_swap_pages)\n\t\treturn;\n\n\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\tdo {\n\t\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\n\t\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t\t   sc, LRU_ACTIVE_ANON);\n\n\t\tmemcg = mem_cgroup_iter(NULL, memcg, NULL);\n\t} while (memcg);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_iter",
          "args": [
            "NULL",
            "memcg",
            "NULL"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "910-1018",
          "snippet": "struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_active_list",
          "args": [
            "SWAP_CLUSTER_MAX",
            "lruvec",
            "sc",
            "LRU_ACTIVE_ANON"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_active_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2084-2183",
          "snippet": "static void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inactive_list_is_low",
          "args": [
            "lruvec",
            "false",
            "memcg",
            "sc",
            "true"
          ],
          "line": 3373
        },
        "resolved": true,
        "details": {
          "function_name": "inactive_list_is_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2213-2262",
          "snippet": "static bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "pgdat",
            "memcg"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void age_active_anon(struct pglist_data *pgdat,\n\t\t\t\tstruct scan_control *sc)\n{\n\tstruct mem_cgroup *memcg;\n\n\tif (!total_swap_pages)\n\t\treturn;\n\n\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\tdo {\n\t\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\n\t\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t\t   sc, LRU_ACTIVE_ANON);\n\n\t\tmemcg = mem_cgroup_iter(NULL, memcg, NULL);\n\t} while (memcg);\n}"
  },
  {
    "function_name": "try_to_free_mem_cgroup_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3311-3358",
    "snippet": "unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_vmscan_memcg_reclaim_end",
          "args": [
            "nr_reclaimed"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_memstall_leave",
          "args": [
            "&pflags"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_restore",
          "args": [
            "noreclaim_flag"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_try_to_free_pages",
          "args": [
            "zonelist",
            "&sc"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "do_try_to_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3032-3093",
          "snippet": "static unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_save",
          "args": [],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_memstall_enter",
          "args": [
            "&pflags"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_memcg_reclaim_begin",
          "args": [
            "0",
            "sc.may_writepage",
            "sc.gfp_mask",
            "sc.reclaim_idx"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_select_victim_node",
          "args": [
            "memcg"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_select_victim_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1479-1482",
          "snippet": "int mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_gfp_context",
          "args": [
            "gfp_mask"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_pages",
            "SWAP_CLUSTER_MAX"
          ],
          "line": 3322
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   unsigned long nr_pages,\n\t\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t\t   bool may_swap)\n{\n\tstruct zonelist *zonelist;\n\tunsigned long nr_reclaimed;\n\tunsigned long pflags;\n\tint nid;\n\tunsigned int noreclaim_flag;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = max(nr_pages, SWAP_CLUSTER_MAX),\n\t\t.gfp_mask = (current_gfp_context(gfp_mask) & GFP_RECLAIM_MASK) |\n\t\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK),\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.target_mem_cgroup = memcg,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = may_swap,\n\t};\n\n\t/*\n\t * Unlike direct reclaim via alloc_pages(), memcg's reclaim doesn't\n\t * take care of from where we get pages. So the node where we start the\n\t * scan does not need to be the current node.\n\t */\n\tnid = mem_cgroup_select_victim_node(memcg);\n\n\tzonelist = &NODE_DATA(nid)->node_zonelists[ZONELIST_FALLBACK];\n\n\ttrace_mm_vmscan_memcg_reclaim_begin(0,\n\t\t\t\t\t    sc.may_writepage,\n\t\t\t\t\t    sc.gfp_mask,\n\t\t\t\t\t    sc.reclaim_idx);\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\ttrace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
  },
  {
    "function_name": "mem_cgroup_shrink_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3273-3309",
    "snippet": "unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,\n\t\t\t\t\t\tgfp_t gfp_mask, bool noswap,\n\t\t\t\t\t\tpg_data_t *pgdat,\n\t\t\t\t\t\tunsigned long *nr_scanned)\n{\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.target_mem_cgroup = memcg,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.may_swap = !noswap,\n\t};\n\tunsigned long lru_pages;\n\n\tsc.gfp_mask = (gfp_mask & GFP_RECLAIM_MASK) |\n\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,\n\t\t\t\t\t\t      sc.may_writepage,\n\t\t\t\t\t\t      sc.gfp_mask,\n\t\t\t\t\t\t      sc.reclaim_idx);\n\n\t/*\n\t * NOTE: Although we can get the priority field, using it\n\t * here is not a good idea, since it limits the pages we can scan.\n\t * if we don't reclaim here, the shrink_node from balance_pgdat\n\t * will pick up pages from other mem cgroup's as well. We hack\n\t * the priority and make it zero.\n\t */\n\tshrink_node_memcg(pgdat, memcg, &sc, &lru_pages);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);\n\n\t*nr_scanned = sc.nr_scanned;\n\treturn sc.nr_reclaimed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_vmscan_memcg_softlimit_reclaim_end",
          "args": [
            "sc.nr_reclaimed"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_node_memcg",
          "args": [
            "pgdat",
            "memcg",
            "&sc",
            "&lru_pages"
          ],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_node_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2497-2611",
          "snippet": "static void shrink_node_memcg(struct pglist_data *pgdat, struct mem_cgroup *memcg,\n\t\t\t      struct scan_control *sc, unsigned long *lru_pages)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\tunsigned long nr[NR_LRU_LISTS];\n\tunsigned long targets[NR_LRU_LISTS];\n\tunsigned long nr_to_scan;\n\tenum lru_list lru;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_to_reclaim = sc->nr_to_reclaim;\n\tstruct blk_plug plug;\n\tbool scan_adjusted;\n\n\tget_scan_count(lruvec, memcg, sc, nr, lru_pages);\n\n\t/* Record the original scan target for proportional adjustments later */\n\tmemcpy(targets, nr, sizeof(nr));\n\n\t/*\n\t * Global reclaiming within direct reclaim at DEF_PRIORITY is a normal\n\t * event that can occur when there is little memory pressure e.g.\n\t * multiple streaming readers/writers. Hence, we do not abort scanning\n\t * when the requested number of pages are reclaimed when scanning at\n\t * DEF_PRIORITY on the assumption that the fact we are direct\n\t * reclaiming implies that kswapd is not keeping up and it is best to\n\t * do a batch of work at once. For memcg reclaim one check is made to\n\t * abort proportional reclaim if either the file or anon lru has already\n\t * dropped to zero at the first pass.\n\t */\n\tscan_adjusted = (global_reclaim(sc) && !current_is_kswapd() &&\n\t\t\t sc->priority == DEF_PRIORITY);\n\n\tblk_start_plug(&plug);\n\twhile (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||\n\t\t\t\t\tnr[LRU_INACTIVE_FILE]) {\n\t\tunsigned long nr_anon, nr_file, percentage;\n\t\tunsigned long nr_scanned;\n\n\t\tfor_each_evictable_lru(lru) {\n\t\t\tif (nr[lru]) {\n\t\t\t\tnr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);\n\t\t\t\tnr[lru] -= nr_to_scan;\n\n\t\t\t\tnr_reclaimed += shrink_list(lru, nr_to_scan,\n\t\t\t\t\t\t\t    lruvec, memcg, sc);\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\n\t\tif (nr_reclaimed < nr_to_reclaim || scan_adjusted)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For kswapd and memcg, reclaim at least the number of pages\n\t\t * requested. Ensure that the anon and file LRUs are scanned\n\t\t * proportionally what was requested by get_scan_count(). We\n\t\t * stop reclaiming one LRU and reduce the amount scanning\n\t\t * proportional to the original scan target.\n\t\t */\n\t\tnr_file = nr[LRU_INACTIVE_FILE] + nr[LRU_ACTIVE_FILE];\n\t\tnr_anon = nr[LRU_INACTIVE_ANON] + nr[LRU_ACTIVE_ANON];\n\n\t\t/*\n\t\t * It's just vindictive to attack the larger once the smaller\n\t\t * has gone to zero.  And given the way we stop scanning the\n\t\t * smaller below, this makes sure that we only make one nudge\n\t\t * towards proportionality once we've got nr_to_reclaim.\n\t\t */\n\t\tif (!nr_file || !nr_anon)\n\t\t\tbreak;\n\n\t\tif (nr_file > nr_anon) {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_ANON] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_ANON] + 1;\n\t\t\tlru = LRU_BASE;\n\t\t\tpercentage = nr_anon * 100 / scan_target;\n\t\t} else {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_FILE] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_FILE] + 1;\n\t\t\tlru = LRU_FILE;\n\t\t\tpercentage = nr_file * 100 / scan_target;\n\t\t}\n\n\t\t/* Stop scanning the smaller of the LRU */\n\t\tnr[lru] = 0;\n\t\tnr[lru + LRU_ACTIVE] = 0;\n\n\t\t/*\n\t\t * Recalculate the other LRU scan count based on its original\n\t\t * scan target and the percentage scanning already complete\n\t\t */\n\t\tlru = (lru == LRU_FILE) ? LRU_BASE : LRU_FILE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tlru += LRU_ACTIVE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tscan_adjusted = true;\n\t}\n\tblk_finish_plug(&plug);\n\tsc->nr_reclaimed += nr_reclaimed;\n\n\t/*\n\t * Even if we did not try to evict anon pages at all, we want to\n\t * rebalance the anon lru active/inactive ratio.\n\t */\n\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t   sc, LRU_ACTIVE_ANON);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_node_memcg(struct pglist_data *pgdat, struct mem_cgroup *memcg,\n\t\t\t      struct scan_control *sc, unsigned long *lru_pages)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\tunsigned long nr[NR_LRU_LISTS];\n\tunsigned long targets[NR_LRU_LISTS];\n\tunsigned long nr_to_scan;\n\tenum lru_list lru;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_to_reclaim = sc->nr_to_reclaim;\n\tstruct blk_plug plug;\n\tbool scan_adjusted;\n\n\tget_scan_count(lruvec, memcg, sc, nr, lru_pages);\n\n\t/* Record the original scan target for proportional adjustments later */\n\tmemcpy(targets, nr, sizeof(nr));\n\n\t/*\n\t * Global reclaiming within direct reclaim at DEF_PRIORITY is a normal\n\t * event that can occur when there is little memory pressure e.g.\n\t * multiple streaming readers/writers. Hence, we do not abort scanning\n\t * when the requested number of pages are reclaimed when scanning at\n\t * DEF_PRIORITY on the assumption that the fact we are direct\n\t * reclaiming implies that kswapd is not keeping up and it is best to\n\t * do a batch of work at once. For memcg reclaim one check is made to\n\t * abort proportional reclaim if either the file or anon lru has already\n\t * dropped to zero at the first pass.\n\t */\n\tscan_adjusted = (global_reclaim(sc) && !current_is_kswapd() &&\n\t\t\t sc->priority == DEF_PRIORITY);\n\n\tblk_start_plug(&plug);\n\twhile (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||\n\t\t\t\t\tnr[LRU_INACTIVE_FILE]) {\n\t\tunsigned long nr_anon, nr_file, percentage;\n\t\tunsigned long nr_scanned;\n\n\t\tfor_each_evictable_lru(lru) {\n\t\t\tif (nr[lru]) {\n\t\t\t\tnr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);\n\t\t\t\tnr[lru] -= nr_to_scan;\n\n\t\t\t\tnr_reclaimed += shrink_list(lru, nr_to_scan,\n\t\t\t\t\t\t\t    lruvec, memcg, sc);\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\n\t\tif (nr_reclaimed < nr_to_reclaim || scan_adjusted)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For kswapd and memcg, reclaim at least the number of pages\n\t\t * requested. Ensure that the anon and file LRUs are scanned\n\t\t * proportionally what was requested by get_scan_count(). We\n\t\t * stop reclaiming one LRU and reduce the amount scanning\n\t\t * proportional to the original scan target.\n\t\t */\n\t\tnr_file = nr[LRU_INACTIVE_FILE] + nr[LRU_ACTIVE_FILE];\n\t\tnr_anon = nr[LRU_INACTIVE_ANON] + nr[LRU_ACTIVE_ANON];\n\n\t\t/*\n\t\t * It's just vindictive to attack the larger once the smaller\n\t\t * has gone to zero.  And given the way we stop scanning the\n\t\t * smaller below, this makes sure that we only make one nudge\n\t\t * towards proportionality once we've got nr_to_reclaim.\n\t\t */\n\t\tif (!nr_file || !nr_anon)\n\t\t\tbreak;\n\n\t\tif (nr_file > nr_anon) {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_ANON] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_ANON] + 1;\n\t\t\tlru = LRU_BASE;\n\t\t\tpercentage = nr_anon * 100 / scan_target;\n\t\t} else {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_FILE] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_FILE] + 1;\n\t\t\tlru = LRU_FILE;\n\t\t\tpercentage = nr_file * 100 / scan_target;\n\t\t}\n\n\t\t/* Stop scanning the smaller of the LRU */\n\t\tnr[lru] = 0;\n\t\tnr[lru + LRU_ACTIVE] = 0;\n\n\t\t/*\n\t\t * Recalculate the other LRU scan count based on its original\n\t\t * scan target and the percentage scanning already complete\n\t\t */\n\t\tlru = (lru == LRU_FILE) ? LRU_BASE : LRU_FILE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tlru += LRU_ACTIVE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tscan_adjusted = true;\n\t}\n\tblk_finish_plug(&plug);\n\tsc->nr_reclaimed += nr_reclaimed;\n\n\t/*\n\t * Even if we did not try to evict anon pages at all, we want to\n\t * rebalance the anon lru active/inactive ratio.\n\t */\n\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t   sc, LRU_ACTIVE_ANON);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_memcg_softlimit_reclaim_begin",
          "args": [
            "sc.order",
            "sc.may_writepage",
            "sc.gfp_mask",
            "sc.reclaim_idx"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,\n\t\t\t\t\t\tgfp_t gfp_mask, bool noswap,\n\t\t\t\t\t\tpg_data_t *pgdat,\n\t\t\t\t\t\tunsigned long *nr_scanned)\n{\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.target_mem_cgroup = memcg,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.reclaim_idx = MAX_NR_ZONES - 1,\n\t\t.may_swap = !noswap,\n\t};\n\tunsigned long lru_pages;\n\n\tsc.gfp_mask = (gfp_mask & GFP_RECLAIM_MASK) |\n\t\t\t(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,\n\t\t\t\t\t\t      sc.may_writepage,\n\t\t\t\t\t\t      sc.gfp_mask,\n\t\t\t\t\t\t      sc.reclaim_idx);\n\n\t/*\n\t * NOTE: Although we can get the priority field, using it\n\t * here is not a good idea, since it limits the pages we can scan.\n\t * if we don't reclaim here, the shrink_node from balance_pgdat\n\t * will pick up pages from other mem cgroup's as well. We hack\n\t * the priority and make it zero.\n\t */\n\tshrink_node_memcg(pgdat, memcg, &sc, &lru_pages);\n\n\ttrace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);\n\n\t*nr_scanned = sc.nr_scanned;\n\treturn sc.nr_reclaimed;\n}"
  },
  {
    "function_name": "try_to_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3227-3269",
    "snippet": "unsigned long try_to_free_pages(struct zonelist *zonelist, int order,\n\t\t\t\tgfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned long nr_reclaimed;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t\t.order = order,\n\t\t.nodemask = nodemask,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\t/*\n\t * scan_control uses s8 fields for order, priority, and reclaim_idx.\n\t * Confirm they are large enough for max values.\n\t */\n\tBUILD_BUG_ON(MAX_ORDER > S8_MAX);\n\tBUILD_BUG_ON(DEF_PRIORITY > S8_MAX);\n\tBUILD_BUG_ON(MAX_NR_ZONES > S8_MAX);\n\n\t/*\n\t * Do not enter reclaim if fatal signal was delivered while throttled.\n\t * 1 is returned so that the page allocator does not OOM kill at this\n\t * point.\n\t */\n\tif (throttle_direct_reclaim(sc.gfp_mask, zonelist, nodemask))\n\t\treturn 1;\n\n\ttrace_mm_vmscan_direct_reclaim_begin(order,\n\t\t\t\tsc.may_writepage,\n\t\t\t\tsc.gfp_mask,\n\t\t\t\tsc.reclaim_idx);\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\ttrace_mm_vmscan_direct_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_vmscan_direct_reclaim_end",
          "args": [
            "nr_reclaimed"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_try_to_free_pages",
          "args": [
            "zonelist",
            "&sc"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "do_try_to_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3032-3093",
          "snippet": "static unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_direct_reclaim_begin",
          "args": [
            "order",
            "sc.may_writepage",
            "sc.gfp_mask",
            "sc.reclaim_idx"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "throttle_direct_reclaim",
          "args": [
            "sc.gfp_mask",
            "zonelist",
            "nodemask"
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "throttle_direct_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3143-3225",
          "snippet": "static bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,\n\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *pgdat = NULL;\n\n\t/*\n\t * Kernel threads should not be throttled as they may be indirectly\n\t * responsible for cleaning pages necessary for reclaim to make forward\n\t * progress. kjournald for example may enter direct reclaim while\n\t * committing a transaction where throttling it could forcing other\n\t * processes to block on log_wait_commit().\n\t */\n\tif (current->flags & PF_KTHREAD)\n\t\tgoto out;\n\n\t/*\n\t * If a fatal signal is pending, this process should not throttle.\n\t * It should return quickly so it can exit and free its memory\n\t */\n\tif (fatal_signal_pending(current))\n\t\tgoto out;\n\n\t/*\n\t * Check if the pfmemalloc reserves are ok by finding the first node\n\t * with a usable ZONE_NORMAL or lower zone. The expectation is that\n\t * GFP_KERNEL will be required for allocating network buffers when\n\t * swapping over the network so ZONE_HIGHMEM is unusable.\n\t *\n\t * Throttling is based on the first usable node and throttled processes\n\t * wait on a queue until kswapd makes progress and wakes them. There\n\t * is an affinity then between processes waking up and where reclaim\n\t * progress has been made assuming the process wakes on the same node.\n\t * More importantly, processes running on remote nodes will not compete\n\t * for remote pfmemalloc reserves and processes on different nodes\n\t * should make reasonable progress.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tgfp_zone(gfp_mask), nodemask) {\n\t\tif (zone_idx(zone) > ZONE_NORMAL)\n\t\t\tcontinue;\n\n\t\t/* Throttle based on the first usable node */\n\t\tpgdat = zone->zone_pgdat;\n\t\tif (allow_direct_reclaim(pgdat))\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t/* If no zone was usable by the allocation flags then do not throttle */\n\tif (!pgdat)\n\t\tgoto out;\n\n\t/* Account for the throttling */\n\tcount_vm_event(PGSCAN_DIRECT_THROTTLE);\n\n\t/*\n\t * If the caller cannot enter the filesystem, it's possible that it\n\t * is due to the caller holding an FS lock or performing a journal\n\t * transaction in the case of a filesystem like ext[3|4]. In this case,\n\t * it is not safe to block on pfmemalloc_wait as kswapd could be\n\t * blocked waiting on the same lock. Instead, throttle for up to a\n\t * second before continuing.\n\t */\n\tif (!(gfp_mask & __GFP_FS)) {\n\t\twait_event_interruptible_timeout(pgdat->pfmemalloc_wait,\n\t\t\tallow_direct_reclaim(pgdat), HZ);\n\n\t\tgoto check_pending;\n\t}\n\n\t/* Throttle until kswapd wakes the process */\n\twait_event_killable(zone->zone_pgdat->pfmemalloc_wait,\n\t\tallow_direct_reclaim(pgdat));\n\ncheck_pending:\n\tif (fatal_signal_pending(current))\n\t\treturn true;\n\nout:\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,\n\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *pgdat = NULL;\n\n\t/*\n\t * Kernel threads should not be throttled as they may be indirectly\n\t * responsible for cleaning pages necessary for reclaim to make forward\n\t * progress. kjournald for example may enter direct reclaim while\n\t * committing a transaction where throttling it could forcing other\n\t * processes to block on log_wait_commit().\n\t */\n\tif (current->flags & PF_KTHREAD)\n\t\tgoto out;\n\n\t/*\n\t * If a fatal signal is pending, this process should not throttle.\n\t * It should return quickly so it can exit and free its memory\n\t */\n\tif (fatal_signal_pending(current))\n\t\tgoto out;\n\n\t/*\n\t * Check if the pfmemalloc reserves are ok by finding the first node\n\t * with a usable ZONE_NORMAL or lower zone. The expectation is that\n\t * GFP_KERNEL will be required for allocating network buffers when\n\t * swapping over the network so ZONE_HIGHMEM is unusable.\n\t *\n\t * Throttling is based on the first usable node and throttled processes\n\t * wait on a queue until kswapd makes progress and wakes them. There\n\t * is an affinity then between processes waking up and where reclaim\n\t * progress has been made assuming the process wakes on the same node.\n\t * More importantly, processes running on remote nodes will not compete\n\t * for remote pfmemalloc reserves and processes on different nodes\n\t * should make reasonable progress.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tgfp_zone(gfp_mask), nodemask) {\n\t\tif (zone_idx(zone) > ZONE_NORMAL)\n\t\t\tcontinue;\n\n\t\t/* Throttle based on the first usable node */\n\t\tpgdat = zone->zone_pgdat;\n\t\tif (allow_direct_reclaim(pgdat))\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t/* If no zone was usable by the allocation flags then do not throttle */\n\tif (!pgdat)\n\t\tgoto out;\n\n\t/* Account for the throttling */\n\tcount_vm_event(PGSCAN_DIRECT_THROTTLE);\n\n\t/*\n\t * If the caller cannot enter the filesystem, it's possible that it\n\t * is due to the caller holding an FS lock or performing a journal\n\t * transaction in the case of a filesystem like ext[3|4]. In this case,\n\t * it is not safe to block on pfmemalloc_wait as kswapd could be\n\t * blocked waiting on the same lock. Instead, throttle for up to a\n\t * second before continuing.\n\t */\n\tif (!(gfp_mask & __GFP_FS)) {\n\t\twait_event_interruptible_timeout(pgdat->pfmemalloc_wait,\n\t\t\tallow_direct_reclaim(pgdat), HZ);\n\n\t\tgoto check_pending;\n\t}\n\n\t/* Throttle until kswapd wakes the process */\n\twait_event_killable(zone->zone_pgdat->pfmemalloc_wait,\n\t\tallow_direct_reclaim(pgdat));\n\ncheck_pending:\n\tif (fatal_signal_pending(current))\n\t\treturn true;\n\nout:\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "MAX_NR_ZONES > S8_MAX"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "DEF_PRIORITY > S8_MAX"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "MAX_ORDER > S8_MAX"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "gfp_mask"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gfp_context",
          "args": [
            "gfp_mask"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_pages(struct zonelist *zonelist, int order,\n\t\t\t\tgfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned long nr_reclaimed;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t\t.order = order,\n\t\t.nodemask = nodemask,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\t/*\n\t * scan_control uses s8 fields for order, priority, and reclaim_idx.\n\t * Confirm they are large enough for max values.\n\t */\n\tBUILD_BUG_ON(MAX_ORDER > S8_MAX);\n\tBUILD_BUG_ON(DEF_PRIORITY > S8_MAX);\n\tBUILD_BUG_ON(MAX_NR_ZONES > S8_MAX);\n\n\t/*\n\t * Do not enter reclaim if fatal signal was delivered while throttled.\n\t * 1 is returned so that the page allocator does not OOM kill at this\n\t * point.\n\t */\n\tif (throttle_direct_reclaim(sc.gfp_mask, zonelist, nodemask))\n\t\treturn 1;\n\n\ttrace_mm_vmscan_direct_reclaim_begin(order,\n\t\t\t\tsc.may_writepage,\n\t\t\t\tsc.gfp_mask,\n\t\t\t\tsc.reclaim_idx);\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\ttrace_mm_vmscan_direct_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
  },
  {
    "function_name": "throttle_direct_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3143-3225",
    "snippet": "static bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,\n\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *pgdat = NULL;\n\n\t/*\n\t * Kernel threads should not be throttled as they may be indirectly\n\t * responsible for cleaning pages necessary for reclaim to make forward\n\t * progress. kjournald for example may enter direct reclaim while\n\t * committing a transaction where throttling it could forcing other\n\t * processes to block on log_wait_commit().\n\t */\n\tif (current->flags & PF_KTHREAD)\n\t\tgoto out;\n\n\t/*\n\t * If a fatal signal is pending, this process should not throttle.\n\t * It should return quickly so it can exit and free its memory\n\t */\n\tif (fatal_signal_pending(current))\n\t\tgoto out;\n\n\t/*\n\t * Check if the pfmemalloc reserves are ok by finding the first node\n\t * with a usable ZONE_NORMAL or lower zone. The expectation is that\n\t * GFP_KERNEL will be required for allocating network buffers when\n\t * swapping over the network so ZONE_HIGHMEM is unusable.\n\t *\n\t * Throttling is based on the first usable node and throttled processes\n\t * wait on a queue until kswapd makes progress and wakes them. There\n\t * is an affinity then between processes waking up and where reclaim\n\t * progress has been made assuming the process wakes on the same node.\n\t * More importantly, processes running on remote nodes will not compete\n\t * for remote pfmemalloc reserves and processes on different nodes\n\t * should make reasonable progress.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tgfp_zone(gfp_mask), nodemask) {\n\t\tif (zone_idx(zone) > ZONE_NORMAL)\n\t\t\tcontinue;\n\n\t\t/* Throttle based on the first usable node */\n\t\tpgdat = zone->zone_pgdat;\n\t\tif (allow_direct_reclaim(pgdat))\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t/* If no zone was usable by the allocation flags then do not throttle */\n\tif (!pgdat)\n\t\tgoto out;\n\n\t/* Account for the throttling */\n\tcount_vm_event(PGSCAN_DIRECT_THROTTLE);\n\n\t/*\n\t * If the caller cannot enter the filesystem, it's possible that it\n\t * is due to the caller holding an FS lock or performing a journal\n\t * transaction in the case of a filesystem like ext[3|4]. In this case,\n\t * it is not safe to block on pfmemalloc_wait as kswapd could be\n\t * blocked waiting on the same lock. Instead, throttle for up to a\n\t * second before continuing.\n\t */\n\tif (!(gfp_mask & __GFP_FS)) {\n\t\twait_event_interruptible_timeout(pgdat->pfmemalloc_wait,\n\t\t\tallow_direct_reclaim(pgdat), HZ);\n\n\t\tgoto check_pending;\n\t}\n\n\t/* Throttle until kswapd wakes the process */\n\twait_event_killable(zone->zone_pgdat->pfmemalloc_wait,\n\t\tallow_direct_reclaim(pgdat));\n\ncheck_pending:\n\tif (fatal_signal_pending(current))\n\t\treturn true;\n\nout:\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_killable",
          "args": [
            "zone->zone_pgdat->pfmemalloc_wait",
            "allow_direct_reclaim(pgdat)"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_direct_reclaim",
          "args": [
            "pgdat"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "allow_direct_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3095-3132",
          "snippet": "static bool allow_direct_reclaim(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tunsigned long pfmemalloc_reserve = 0;\n\tunsigned long free_pages = 0;\n\tint i;\n\tbool wmark_ok;\n\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tfor (i = 0; i <= ZONE_NORMAL; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!zone_reclaimable_pages(zone))\n\t\t\tcontinue;\n\n\t\tpfmemalloc_reserve += min_wmark_pages(zone);\n\t\tfree_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/* If there are no reserves (unexpected config) then do not throttle */\n\tif (!pfmemalloc_reserve)\n\t\treturn true;\n\n\twmark_ok = free_pages > pfmemalloc_reserve / 2;\n\n\t/* kswapd must be awake if processes are being throttled */\n\tif (!wmark_ok && waitqueue_active(&pgdat->kswapd_wait)) {\n\t\tpgdat->kswapd_classzone_idx = min(pgdat->kswapd_classzone_idx,\n\t\t\t\t\t\t(enum zone_type)ZONE_NORMAL);\n\t\twake_up_interruptible(&pgdat->kswapd_wait);\n\t}\n\n\treturn wmark_ok;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool allow_direct_reclaim(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tunsigned long pfmemalloc_reserve = 0;\n\tunsigned long free_pages = 0;\n\tint i;\n\tbool wmark_ok;\n\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tfor (i = 0; i <= ZONE_NORMAL; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!zone_reclaimable_pages(zone))\n\t\t\tcontinue;\n\n\t\tpfmemalloc_reserve += min_wmark_pages(zone);\n\t\tfree_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/* If there are no reserves (unexpected config) then do not throttle */\n\tif (!pfmemalloc_reserve)\n\t\treturn true;\n\n\twmark_ok = free_pages > pfmemalloc_reserve / 2;\n\n\t/* kswapd must be awake if processes are being throttled */\n\tif (!wmark_ok && waitqueue_active(&pgdat->kswapd_wait)) {\n\t\tpgdat->kswapd_classzone_idx = min(pgdat->kswapd_classzone_idx,\n\t\t\t\t\t\t(enum zone_type)ZONE_NORMAL);\n\t\twake_up_interruptible(&pgdat->kswapd_wait);\n\t}\n\n\treturn wmark_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "pgdat->pfmemalloc_wait",
            "allow_direct_reclaim(pgdat)",
            "HZ"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGSCAN_DIRECT_THROTTLE"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "zonelist",
            "gfp_zone(gfp_mask)",
            "nodemask"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "gfp_mask"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,\n\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *pgdat = NULL;\n\n\t/*\n\t * Kernel threads should not be throttled as they may be indirectly\n\t * responsible for cleaning pages necessary for reclaim to make forward\n\t * progress. kjournald for example may enter direct reclaim while\n\t * committing a transaction where throttling it could forcing other\n\t * processes to block on log_wait_commit().\n\t */\n\tif (current->flags & PF_KTHREAD)\n\t\tgoto out;\n\n\t/*\n\t * If a fatal signal is pending, this process should not throttle.\n\t * It should return quickly so it can exit and free its memory\n\t */\n\tif (fatal_signal_pending(current))\n\t\tgoto out;\n\n\t/*\n\t * Check if the pfmemalloc reserves are ok by finding the first node\n\t * with a usable ZONE_NORMAL or lower zone. The expectation is that\n\t * GFP_KERNEL will be required for allocating network buffers when\n\t * swapping over the network so ZONE_HIGHMEM is unusable.\n\t *\n\t * Throttling is based on the first usable node and throttled processes\n\t * wait on a queue until kswapd makes progress and wakes them. There\n\t * is an affinity then between processes waking up and where reclaim\n\t * progress has been made assuming the process wakes on the same node.\n\t * More importantly, processes running on remote nodes will not compete\n\t * for remote pfmemalloc reserves and processes on different nodes\n\t * should make reasonable progress.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tgfp_zone(gfp_mask), nodemask) {\n\t\tif (zone_idx(zone) > ZONE_NORMAL)\n\t\t\tcontinue;\n\n\t\t/* Throttle based on the first usable node */\n\t\tpgdat = zone->zone_pgdat;\n\t\tif (allow_direct_reclaim(pgdat))\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t/* If no zone was usable by the allocation flags then do not throttle */\n\tif (!pgdat)\n\t\tgoto out;\n\n\t/* Account for the throttling */\n\tcount_vm_event(PGSCAN_DIRECT_THROTTLE);\n\n\t/*\n\t * If the caller cannot enter the filesystem, it's possible that it\n\t * is due to the caller holding an FS lock or performing a journal\n\t * transaction in the case of a filesystem like ext[3|4]. In this case,\n\t * it is not safe to block on pfmemalloc_wait as kswapd could be\n\t * blocked waiting on the same lock. Instead, throttle for up to a\n\t * second before continuing.\n\t */\n\tif (!(gfp_mask & __GFP_FS)) {\n\t\twait_event_interruptible_timeout(pgdat->pfmemalloc_wait,\n\t\t\tallow_direct_reclaim(pgdat), HZ);\n\n\t\tgoto check_pending;\n\t}\n\n\t/* Throttle until kswapd wakes the process */\n\twait_event_killable(zone->zone_pgdat->pfmemalloc_wait,\n\t\tallow_direct_reclaim(pgdat));\n\ncheck_pending:\n\tif (fatal_signal_pending(current))\n\t\treturn true;\n\nout:\n\treturn false;\n}"
  },
  {
    "function_name": "allow_direct_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3095-3132",
    "snippet": "static bool allow_direct_reclaim(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tunsigned long pfmemalloc_reserve = 0;\n\tunsigned long free_pages = 0;\n\tint i;\n\tbool wmark_ok;\n\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tfor (i = 0; i <= ZONE_NORMAL; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!zone_reclaimable_pages(zone))\n\t\t\tcontinue;\n\n\t\tpfmemalloc_reserve += min_wmark_pages(zone);\n\t\tfree_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/* If there are no reserves (unexpected config) then do not throttle */\n\tif (!pfmemalloc_reserve)\n\t\treturn true;\n\n\twmark_ok = free_pages > pfmemalloc_reserve / 2;\n\n\t/* kswapd must be awake if processes are being throttled */\n\tif (!wmark_ok && waitqueue_active(&pgdat->kswapd_wait)) {\n\t\tpgdat->kswapd_classzone_idx = min(pgdat->kswapd_classzone_idx,\n\t\t\t\t\t\t(enum zone_type)ZONE_NORMAL);\n\t\twake_up_interruptible(&pgdat->kswapd_wait);\n\t}\n\n\treturn wmark_ok;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pgdat->kswapd_wait"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pgdat->kswapd_classzone_idx",
            "(enum zone_type)ZONE_NORMAL"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pgdat->kswapd_wait"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zone",
            "NR_FREE_PAGES"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_reclaimable_pages",
          "args": [
            "zone"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "zone_reclaimable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "320-331",
          "snippet": "unsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool allow_direct_reclaim(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tunsigned long pfmemalloc_reserve = 0;\n\tunsigned long free_pages = 0;\n\tint i;\n\tbool wmark_ok;\n\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES)\n\t\treturn true;\n\n\tfor (i = 0; i <= ZONE_NORMAL; i++) {\n\t\tzone = &pgdat->node_zones[i];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!zone_reclaimable_pages(zone))\n\t\t\tcontinue;\n\n\t\tpfmemalloc_reserve += min_wmark_pages(zone);\n\t\tfree_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/* If there are no reserves (unexpected config) then do not throttle */\n\tif (!pfmemalloc_reserve)\n\t\treturn true;\n\n\twmark_ok = free_pages > pfmemalloc_reserve / 2;\n\n\t/* kswapd must be awake if processes are being throttled */\n\tif (!wmark_ok && waitqueue_active(&pgdat->kswapd_wait)) {\n\t\tpgdat->kswapd_classzone_idx = min(pgdat->kswapd_classzone_idx,\n\t\t\t\t\t\t(enum zone_type)ZONE_NORMAL);\n\t\twake_up_interruptible(&pgdat->kswapd_wait);\n\t}\n\n\treturn wmark_ok;\n}"
  },
  {
    "function_name": "do_try_to_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "3032-3093",
    "snippet": "static unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delayacct_freepages_end",
          "args": [],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memcg_congestion",
          "args": [
            "last_pgdat",
            "sc->target_mem_cgroup",
            "false"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "set_memcg_congestion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "302-305",
          "snippet": "static inline void set_memcg_congestion(struct pglist_data *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg, bool congested)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void set_memcg_congestion(struct pglist_data *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg, bool congested)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_refaults",
          "args": [
            "sc->target_mem_cgroup",
            "zone->zone_pgdat"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_refaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2997-3014",
          "snippet": "static void snapshot_refaults(struct mem_cgroup *root_memcg, pg_data_t *pgdat)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = mem_cgroup_iter(root_memcg, NULL, NULL);\n\tdo {\n\t\tunsigned long refaults;\n\t\tstruct lruvec *lruvec;\n\n\t\tif (memcg)\n\t\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\t\telse\n\t\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\t\tlruvec->refaults = refaults;\n\t} while ((memcg = mem_cgroup_iter(root_memcg, memcg, NULL)));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void snapshot_refaults(struct mem_cgroup *root_memcg, pg_data_t *pgdat)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = mem_cgroup_iter(root_memcg, NULL, NULL);\n\tdo {\n\t\tunsigned long refaults;\n\t\tstruct lruvec *lruvec;\n\n\t\tif (memcg)\n\t\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\t\telse\n\t\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\t\tlruvec->refaults = refaults;\n\t} while ((memcg = mem_cgroup_iter(root_memcg, memcg, NULL)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "zonelist",
            "sc->reclaim_idx",
            "sc->nodemask"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_zones",
          "args": [
            "zonelist",
            "sc"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_zones",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2912-2995",
          "snippet": "static void shrink_zones(struct zonelist *zonelist, struct scan_control *sc)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tgfp_t orig_mask;\n\tpg_data_t *last_pgdat = NULL;\n\n\t/*\n\t * If the number of buffer_heads in the machine exceeds the maximum\n\t * allowed level, force direct reclaim to scan the highmem zone as\n\t * highmem pages could be pinning lowmem pages storing buffer_heads\n\t */\n\torig_mask = sc->gfp_mask;\n\tif (buffer_heads_over_limit) {\n\t\tsc->gfp_mask |= __GFP_HIGHMEM;\n\t\tsc->reclaim_idx = gfp_zone(sc->gfp_mask);\n\t}\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tsc->reclaim_idx, sc->nodemask) {\n\t\t/*\n\t\t * Take care memory controller reclaiming has small influence\n\t\t * to global LRU.\n\t\t */\n\t\tif (global_reclaim(sc)) {\n\t\t\tif (!cpuset_zone_allowed(zone,\n\t\t\t\t\t\t GFP_KERNEL | __GFP_HARDWALL))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If we already have plenty of memory free for\n\t\t\t * compaction in this zone, don't free any more.\n\t\t\t * Even though compaction is invoked for any\n\t\t\t * non-zero order, only frequent costly order\n\t\t\t * reclamation is disruptive enough to become a\n\t\t\t * noticeable problem, like transparent huge\n\t\t\t * page allocations.\n\t\t\t */\n\t\t\tif (IS_ENABLED(CONFIG_COMPACTION) &&\n\t\t\t    sc->order > PAGE_ALLOC_COSTLY_ORDER &&\n\t\t\t    compaction_ready(zone, sc)) {\n\t\t\t\tsc->compaction_ready = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Shrink each node in the zonelist once. If the\n\t\t\t * zonelist is ordered by zone (not the default) then a\n\t\t\t * node may be shrunk multiple times but in that case\n\t\t\t * the user prefers lower zones being preserved.\n\t\t\t */\n\t\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * This steals pages from memory cgroups over softlimit\n\t\t\t * and returns the number of reclaimed pages and\n\t\t\t * scanned pages. This works for global memory pressure\n\t\t\t * and balancing, not for a memcg's limit.\n\t\t\t */\n\t\t\tnr_soft_scanned = 0;\n\t\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(zone->zone_pgdat,\n\t\t\t\t\t\tsc->order, sc->gfp_mask,\n\t\t\t\t\t\t&nr_soft_scanned);\n\t\t\tsc->nr_reclaimed += nr_soft_reclaimed;\n\t\t\tsc->nr_scanned += nr_soft_scanned;\n\t\t\t/* need some check for avoid more shrink_zone() */\n\t\t}\n\n\t\t/* See comment about same check for global reclaim above */\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tshrink_node(zone->zone_pgdat, sc);\n\t}\n\n\t/*\n\t * Restore to original mask to avoid the impact on the caller if we\n\t * promoted it to __GFP_HIGHMEM.\n\t */\n\tsc->gfp_mask = orig_mask;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_zones(struct zonelist *zonelist, struct scan_control *sc)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tgfp_t orig_mask;\n\tpg_data_t *last_pgdat = NULL;\n\n\t/*\n\t * If the number of buffer_heads in the machine exceeds the maximum\n\t * allowed level, force direct reclaim to scan the highmem zone as\n\t * highmem pages could be pinning lowmem pages storing buffer_heads\n\t */\n\torig_mask = sc->gfp_mask;\n\tif (buffer_heads_over_limit) {\n\t\tsc->gfp_mask |= __GFP_HIGHMEM;\n\t\tsc->reclaim_idx = gfp_zone(sc->gfp_mask);\n\t}\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tsc->reclaim_idx, sc->nodemask) {\n\t\t/*\n\t\t * Take care memory controller reclaiming has small influence\n\t\t * to global LRU.\n\t\t */\n\t\tif (global_reclaim(sc)) {\n\t\t\tif (!cpuset_zone_allowed(zone,\n\t\t\t\t\t\t GFP_KERNEL | __GFP_HARDWALL))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If we already have plenty of memory free for\n\t\t\t * compaction in this zone, don't free any more.\n\t\t\t * Even though compaction is invoked for any\n\t\t\t * non-zero order, only frequent costly order\n\t\t\t * reclamation is disruptive enough to become a\n\t\t\t * noticeable problem, like transparent huge\n\t\t\t * page allocations.\n\t\t\t */\n\t\t\tif (IS_ENABLED(CONFIG_COMPACTION) &&\n\t\t\t    sc->order > PAGE_ALLOC_COSTLY_ORDER &&\n\t\t\t    compaction_ready(zone, sc)) {\n\t\t\t\tsc->compaction_ready = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Shrink each node in the zonelist once. If the\n\t\t\t * zonelist is ordered by zone (not the default) then a\n\t\t\t * node may be shrunk multiple times but in that case\n\t\t\t * the user prefers lower zones being preserved.\n\t\t\t */\n\t\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * This steals pages from memory cgroups over softlimit\n\t\t\t * and returns the number of reclaimed pages and\n\t\t\t * scanned pages. This works for global memory pressure\n\t\t\t * and balancing, not for a memcg's limit.\n\t\t\t */\n\t\t\tnr_soft_scanned = 0;\n\t\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(zone->zone_pgdat,\n\t\t\t\t\t\tsc->order, sc->gfp_mask,\n\t\t\t\t\t\t&nr_soft_scanned);\n\t\t\tsc->nr_reclaimed += nr_soft_reclaimed;\n\t\t\tsc->nr_scanned += nr_soft_scanned;\n\t\t\t/* need some check for avoid more shrink_zone() */\n\t\t}\n\n\t\t/* See comment about same check for global reclaim above */\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tshrink_node(zone->zone_pgdat, sc);\n\t}\n\n\t/*\n\t * Restore to original mask to avoid the impact on the caller if we\n\t * promoted it to __GFP_HIGHMEM.\n\t */\n\tsc->gfp_mask = orig_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmpressure_prio",
          "args": [
            "sc->gfp_mask",
            "sc->target_mem_cgroup",
            "sc->priority"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "326-343",
          "snippet": "void vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)\n{\n\t/*\n\t * We only use prio for accounting critical level. For more info\n\t * see comment for vmpressure_level_critical_prio variable above.\n\t */\n\tif (prio > vmpressure_level_critical_prio)\n\t\treturn;\n\n\t/*\n\t * OK, the prio is below the threshold, updating vmpressure\n\t * information before shrinker dives into long shrinking of long\n\t * range vmscan. Passing scanned = vmpressure_win, reclaimed = 0\n\t * to the vmpressure() basically means that we signal 'critical'\n\t * level.\n\t */\n\tvmpressure(gfp, memcg, true, vmpressure_win, 0);\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;",
            "static const unsigned int vmpressure_level_critical_prio = ilog2(100 / 10);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;\nstatic const unsigned int vmpressure_level_critical_prio = ilog2(100 / 10);\n\nvoid vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)\n{\n\t/*\n\t * We only use prio for accounting critical level. For more info\n\t * see comment for vmpressure_level_critical_prio variable above.\n\t */\n\tif (prio > vmpressure_level_critical_prio)\n\t\treturn;\n\n\t/*\n\t * OK, the prio is below the threshold, updating vmpressure\n\t * information before shrinker dives into long shrinking of long\n\t * range vmscan. Passing scanned = vmpressure_win, reclaimed = 0\n\t * to the vmpressure() basically means that we signal 'critical'\n\t * level.\n\t */\n\tvmpressure(gfp, memcg, true, vmpressure_win, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_zid_vm_events",
          "args": [
            "ALLOCSTALL",
            "sc->reclaim_idx",
            "1"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_reclaim",
          "args": [
            "sc"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "global_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "292-295",
          "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayacct_freepages_start",
          "args": [],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long do_try_to_free_pages(struct zonelist *zonelist,\n\t\t\t\t\t  struct scan_control *sc)\n{\n\tint initial_priority = sc->priority;\n\tpg_data_t *last_pgdat;\n\tstruct zoneref *z;\n\tstruct zone *zone;\nretry:\n\tdelayacct_freepages_start();\n\n\tif (global_reclaim(sc))\n\t\t__count_zid_vm_events(ALLOCSTALL, sc->reclaim_idx, 1);\n\n\tdo {\n\t\tvmpressure_prio(sc->gfp_mask, sc->target_mem_cgroup,\n\t\t\t\tsc->priority);\n\t\tsc->nr_scanned = 0;\n\t\tshrink_zones(zonelist, sc);\n\n\t\tif (sc->nr_reclaimed >= sc->nr_to_reclaim)\n\t\t\tbreak;\n\n\t\tif (sc->compaction_ready)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we're getting trouble reclaiming, start doing\n\t\t * writepage even in laptop mode.\n\t\t */\n\t\tif (sc->priority < DEF_PRIORITY - 2)\n\t\t\tsc->may_writepage = 1;\n\t} while (--sc->priority >= 0);\n\n\tlast_pgdat = NULL;\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, sc->reclaim_idx,\n\t\t\t\t\tsc->nodemask) {\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tsnapshot_refaults(sc->target_mem_cgroup, zone->zone_pgdat);\n\t\tset_memcg_congestion(last_pgdat, sc->target_mem_cgroup, false);\n\t}\n\n\tdelayacct_freepages_end();\n\n\tif (sc->nr_reclaimed)\n\t\treturn sc->nr_reclaimed;\n\n\t/* Aborted reclaim to try compaction? don't OOM, then */\n\tif (sc->compaction_ready)\n\t\treturn 1;\n\n\t/* Untapped cgroup reserves?  Don't OOM, retry. */\n\tif (sc->memcg_low_skipped) {\n\t\tsc->priority = initial_priority;\n\t\tsc->memcg_low_reclaim = 1;\n\t\tsc->memcg_low_skipped = 0;\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "snapshot_refaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2997-3014",
    "snippet": "static void snapshot_refaults(struct mem_cgroup *root_memcg, pg_data_t *pgdat)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = mem_cgroup_iter(root_memcg, NULL, NULL);\n\tdo {\n\t\tunsigned long refaults;\n\t\tstruct lruvec *lruvec;\n\n\t\tif (memcg)\n\t\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\t\telse\n\t\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\t\tlruvec->refaults = refaults;\n\t} while ((memcg = mem_cgroup_iter(root_memcg, memcg, NULL)));\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_iter",
          "args": [
            "root_memcg",
            "memcg",
            "NULL"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "910-1018",
          "snippet": "struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "pgdat",
            "memcg"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "WORKINGSET_ACTIVATE"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "memcg",
            "WORKINGSET_ACTIVATE"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void snapshot_refaults(struct mem_cgroup *root_memcg, pg_data_t *pgdat)\n{\n\tstruct mem_cgroup *memcg;\n\n\tmemcg = mem_cgroup_iter(root_memcg, NULL, NULL);\n\tdo {\n\t\tunsigned long refaults;\n\t\tstruct lruvec *lruvec;\n\n\t\tif (memcg)\n\t\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\t\telse\n\t\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\t\tlruvec->refaults = refaults;\n\t} while ((memcg = mem_cgroup_iter(root_memcg, memcg, NULL)));\n}"
  },
  {
    "function_name": "shrink_zones",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2912-2995",
    "snippet": "static void shrink_zones(struct zonelist *zonelist, struct scan_control *sc)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tgfp_t orig_mask;\n\tpg_data_t *last_pgdat = NULL;\n\n\t/*\n\t * If the number of buffer_heads in the machine exceeds the maximum\n\t * allowed level, force direct reclaim to scan the highmem zone as\n\t * highmem pages could be pinning lowmem pages storing buffer_heads\n\t */\n\torig_mask = sc->gfp_mask;\n\tif (buffer_heads_over_limit) {\n\t\tsc->gfp_mask |= __GFP_HIGHMEM;\n\t\tsc->reclaim_idx = gfp_zone(sc->gfp_mask);\n\t}\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tsc->reclaim_idx, sc->nodemask) {\n\t\t/*\n\t\t * Take care memory controller reclaiming has small influence\n\t\t * to global LRU.\n\t\t */\n\t\tif (global_reclaim(sc)) {\n\t\t\tif (!cpuset_zone_allowed(zone,\n\t\t\t\t\t\t GFP_KERNEL | __GFP_HARDWALL))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If we already have plenty of memory free for\n\t\t\t * compaction in this zone, don't free any more.\n\t\t\t * Even though compaction is invoked for any\n\t\t\t * non-zero order, only frequent costly order\n\t\t\t * reclamation is disruptive enough to become a\n\t\t\t * noticeable problem, like transparent huge\n\t\t\t * page allocations.\n\t\t\t */\n\t\t\tif (IS_ENABLED(CONFIG_COMPACTION) &&\n\t\t\t    sc->order > PAGE_ALLOC_COSTLY_ORDER &&\n\t\t\t    compaction_ready(zone, sc)) {\n\t\t\t\tsc->compaction_ready = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Shrink each node in the zonelist once. If the\n\t\t\t * zonelist is ordered by zone (not the default) then a\n\t\t\t * node may be shrunk multiple times but in that case\n\t\t\t * the user prefers lower zones being preserved.\n\t\t\t */\n\t\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * This steals pages from memory cgroups over softlimit\n\t\t\t * and returns the number of reclaimed pages and\n\t\t\t * scanned pages. This works for global memory pressure\n\t\t\t * and balancing, not for a memcg's limit.\n\t\t\t */\n\t\t\tnr_soft_scanned = 0;\n\t\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(zone->zone_pgdat,\n\t\t\t\t\t\tsc->order, sc->gfp_mask,\n\t\t\t\t\t\t&nr_soft_scanned);\n\t\t\tsc->nr_reclaimed += nr_soft_reclaimed;\n\t\t\tsc->nr_scanned += nr_soft_scanned;\n\t\t\t/* need some check for avoid more shrink_zone() */\n\t\t}\n\n\t\t/* See comment about same check for global reclaim above */\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tshrink_node(zone->zone_pgdat, sc);\n\t}\n\n\t/*\n\t * Restore to original mask to avoid the impact on the caller if we\n\t * promoted it to __GFP_HIGHMEM.\n\t */\n\tsc->gfp_mask = orig_mask;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_node",
          "args": [
            "zone->zone_pgdat",
            "sc"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "kswapd_shrink_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3465-3498",
          "snippet": "static bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool kswapd_shrink_node(pg_data_t *pgdat,\n\t\t\t       struct scan_control *sc)\n{\n\tstruct zone *zone;\n\tint z;\n\n\t/* Reclaim a number of pages proportional to the number of zones */\n\tsc->nr_to_reclaim = 0;\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tzone = pgdat->node_zones + z;\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tsc->nr_to_reclaim += max(high_wmark_pages(zone), SWAP_CLUSTER_MAX);\n\t}\n\n\t/*\n\t * Historically care was taken to put equal pressure on all zones but\n\t * now pressure is applied based on node LRU order.\n\t */\n\tshrink_node(pgdat, sc);\n\n\t/*\n\t * Fragmentation may mean that the system cannot be rebalanced for\n\t * high-order allocations. If twice the allocation size has been\n\t * reclaimed then recheck watermarks only at order-0 to prevent\n\t * excessive reclaim. Assume that a process requested a high-order\n\t * can direct reclaim/compact.\n\t */\n\tif (sc->order && sc->nr_reclaimed >= compact_gap(sc->order))\n\t\tsc->order = 0;\n\n\treturn sc->nr_scanned >= sc->nr_to_reclaim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_soft_limit_reclaim",
          "args": [
            "zone->zone_pgdat",
            "sc->order",
            "sc->gfp_mask",
            "&nr_soft_scanned"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_soft_limit_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2754-2835",
          "snippet": "unsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node(pgdat->node_id);\n\n\t/*\n\t * Do not even bother to check the largest node if the root\n\t * is empty. Do it lockless to prevent lock bouncing. Races\n\t * are acceptable as soft limit is best effort anyway.\n\t */\n\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))\n\t\treturn 0;\n\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock_irq(&mctz->lock);\n\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed)\n\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);\n\n\t\texcess = soft_limit_excess(mz->memcg);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\tspin_unlock_irq(&mctz->lock);\n\t\tcss_put(&mz->memcg->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->memcg->css);\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t2"
          ],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define\tMEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS\t2\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,\n\t\t\t\t\t    gfp_t gfp_mask,\n\t\t\t\t\t    unsigned long *total_scanned)\n{\n\tunsigned long nr_reclaimed = 0;\n\tstruct mem_cgroup_per_node *mz, *next_mz = NULL;\n\tunsigned long reclaimed;\n\tint loop = 0;\n\tstruct mem_cgroup_tree_per_node *mctz;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\n\tif (order > 0)\n\t\treturn 0;\n\n\tmctz = soft_limit_tree_node(pgdat->node_id);\n\n\t/*\n\t * Do not even bother to check the largest node if the root\n\t * is empty. Do it lockless to prevent lock bouncing. Races\n\t * are acceptable as soft limit is best effort anyway.\n\t */\n\tif (!mctz || RB_EMPTY_ROOT(&mctz->rb_root))\n\t\treturn 0;\n\n\t/*\n\t * This loop can run a while, specially if mem_cgroup's continuously\n\t * keep exceeding their soft limit and putting the system under\n\t * pressure\n\t */\n\tdo {\n\t\tif (next_mz)\n\t\t\tmz = next_mz;\n\t\telse\n\t\t\tmz = mem_cgroup_largest_soft_limit_node(mctz);\n\t\tif (!mz)\n\t\t\tbreak;\n\n\t\tnr_scanned = 0;\n\t\treclaimed = mem_cgroup_soft_reclaim(mz->memcg, pgdat,\n\t\t\t\t\t\t    gfp_mask, &nr_scanned);\n\t\tnr_reclaimed += reclaimed;\n\t\t*total_scanned += nr_scanned;\n\t\tspin_lock_irq(&mctz->lock);\n\t\t__mem_cgroup_remove_exceeded(mz, mctz);\n\n\t\t/*\n\t\t * If we failed to reclaim anything from this memory cgroup\n\t\t * it is time to move on to the next cgroup\n\t\t */\n\t\tnext_mz = NULL;\n\t\tif (!reclaimed)\n\t\t\tnext_mz = __mem_cgroup_largest_soft_limit_node(mctz);\n\n\t\texcess = soft_limit_excess(mz->memcg);\n\t\t/*\n\t\t * One school of thought says that we should not add\n\t\t * back the node to the tree if reclaim returns 0.\n\t\t * But our reclaim could return 0, simply because due\n\t\t * to priority we are exposing a smaller subset of\n\t\t * memory to reclaim from. Consider this as a longer\n\t\t * term TODO.\n\t\t */\n\t\t/* If excess == 0, no tree ops */\n\t\t__mem_cgroup_insert_exceeded(mz, mctz, excess);\n\t\tspin_unlock_irq(&mctz->lock);\n\t\tcss_put(&mz->memcg->css);\n\t\tloop++;\n\t\t/*\n\t\t * Could not reclaim anything and there are no more\n\t\t * mem cgroups to try or we seem to be looping without\n\t\t * reclaiming anything.\n\t\t */\n\t\tif (!nr_reclaimed &&\n\t\t\t(next_mz == NULL ||\n\t\t\tloop > MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS))\n\t\t\tbreak;\n\t} while (!nr_reclaimed);\n\tif (next_mz)\n\t\tcss_put(&next_mz->memcg->css);\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compaction_ready",
          "args": [
            "zone",
            "sc"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2877-2902",
          "snippet": "static inline bool compaction_ready(struct zone *zone, struct scan_control *sc)\n{\n\tunsigned long watermark;\n\tenum compact_result suitable;\n\n\tsuitable = compaction_suitable(zone, sc->order, 0, sc->reclaim_idx);\n\tif (suitable == COMPACT_SUCCESS)\n\t\t/* Allocation should succeed already. Don't reclaim. */\n\t\treturn true;\n\tif (suitable == COMPACT_SKIPPED)\n\t\t/* Compaction cannot yet proceed. Do reclaim. */\n\t\treturn false;\n\n\t/*\n\t * Compaction is already possible, but it takes time to run and there\n\t * are potentially other callers using the pages just freed. So proceed\n\t * with reclaim to make a buffer of free pages available to give\n\t * compaction a reasonable chance of completing and allocating the page.\n\t * Note that we won't actually reclaim the whole buffer in one attempt\n\t * as the target watermark in should_continue_reclaim() is lower. But if\n\t * we are already above the high+gap watermark, don't reclaim at all.\n\t */\n\twatermark = high_wmark_pages(zone) + compact_gap(sc->order);\n\n\treturn zone_watermark_ok_safe(zone, 0, watermark, sc->reclaim_idx);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool compaction_ready(struct zone *zone, struct scan_control *sc)\n{\n\tunsigned long watermark;\n\tenum compact_result suitable;\n\n\tsuitable = compaction_suitable(zone, sc->order, 0, sc->reclaim_idx);\n\tif (suitable == COMPACT_SUCCESS)\n\t\t/* Allocation should succeed already. Don't reclaim. */\n\t\treturn true;\n\tif (suitable == COMPACT_SKIPPED)\n\t\t/* Compaction cannot yet proceed. Do reclaim. */\n\t\treturn false;\n\n\t/*\n\t * Compaction is already possible, but it takes time to run and there\n\t * are potentially other callers using the pages just freed. So proceed\n\t * with reclaim to make a buffer of free pages available to give\n\t * compaction a reasonable chance of completing and allocating the page.\n\t * Note that we won't actually reclaim the whole buffer in one attempt\n\t * as the target watermark in should_continue_reclaim() is lower. But if\n\t * we are already above the high+gap watermark, don't reclaim at all.\n\t */\n\twatermark = high_wmark_pages(zone) + compact_gap(sc->order);\n\n\treturn zone_watermark_ok_safe(zone, 0, watermark, sc->reclaim_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_COMPACTION"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_zone_allowed",
          "args": [
            "zone",
            "GFP_KERNEL | __GFP_HARDWALL"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_reclaim",
          "args": [
            "sc"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "global_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "292-295",
          "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "zonelist",
            "sc->reclaim_idx",
            "sc->nodemask"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "sc->gfp_mask"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_zones(struct zonelist *zonelist, struct scan_control *sc)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tunsigned long nr_soft_reclaimed;\n\tunsigned long nr_soft_scanned;\n\tgfp_t orig_mask;\n\tpg_data_t *last_pgdat = NULL;\n\n\t/*\n\t * If the number of buffer_heads in the machine exceeds the maximum\n\t * allowed level, force direct reclaim to scan the highmem zone as\n\t * highmem pages could be pinning lowmem pages storing buffer_heads\n\t */\n\torig_mask = sc->gfp_mask;\n\tif (buffer_heads_over_limit) {\n\t\tsc->gfp_mask |= __GFP_HIGHMEM;\n\t\tsc->reclaim_idx = gfp_zone(sc->gfp_mask);\n\t}\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist,\n\t\t\t\t\tsc->reclaim_idx, sc->nodemask) {\n\t\t/*\n\t\t * Take care memory controller reclaiming has small influence\n\t\t * to global LRU.\n\t\t */\n\t\tif (global_reclaim(sc)) {\n\t\t\tif (!cpuset_zone_allowed(zone,\n\t\t\t\t\t\t GFP_KERNEL | __GFP_HARDWALL))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If we already have plenty of memory free for\n\t\t\t * compaction in this zone, don't free any more.\n\t\t\t * Even though compaction is invoked for any\n\t\t\t * non-zero order, only frequent costly order\n\t\t\t * reclamation is disruptive enough to become a\n\t\t\t * noticeable problem, like transparent huge\n\t\t\t * page allocations.\n\t\t\t */\n\t\t\tif (IS_ENABLED(CONFIG_COMPACTION) &&\n\t\t\t    sc->order > PAGE_ALLOC_COSTLY_ORDER &&\n\t\t\t    compaction_ready(zone, sc)) {\n\t\t\t\tsc->compaction_ready = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Shrink each node in the zonelist once. If the\n\t\t\t * zonelist is ordered by zone (not the default) then a\n\t\t\t * node may be shrunk multiple times but in that case\n\t\t\t * the user prefers lower zones being preserved.\n\t\t\t */\n\t\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * This steals pages from memory cgroups over softlimit\n\t\t\t * and returns the number of reclaimed pages and\n\t\t\t * scanned pages. This works for global memory pressure\n\t\t\t * and balancing, not for a memcg's limit.\n\t\t\t */\n\t\t\tnr_soft_scanned = 0;\n\t\t\tnr_soft_reclaimed = mem_cgroup_soft_limit_reclaim(zone->zone_pgdat,\n\t\t\t\t\t\tsc->order, sc->gfp_mask,\n\t\t\t\t\t\t&nr_soft_scanned);\n\t\t\tsc->nr_reclaimed += nr_soft_reclaimed;\n\t\t\tsc->nr_scanned += nr_soft_scanned;\n\t\t\t/* need some check for avoid more shrink_zone() */\n\t\t}\n\n\t\t/* See comment about same check for global reclaim above */\n\t\tif (zone->zone_pgdat == last_pgdat)\n\t\t\tcontinue;\n\t\tlast_pgdat = zone->zone_pgdat;\n\t\tshrink_node(zone->zone_pgdat, sc);\n\t}\n\n\t/*\n\t * Restore to original mask to avoid the impact on the caller if we\n\t * promoted it to __GFP_HIGHMEM.\n\t */\n\tsc->gfp_mask = orig_mask;\n}"
  },
  {
    "function_name": "compaction_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2877-2902",
    "snippet": "static inline bool compaction_ready(struct zone *zone, struct scan_control *sc)\n{\n\tunsigned long watermark;\n\tenum compact_result suitable;\n\n\tsuitable = compaction_suitable(zone, sc->order, 0, sc->reclaim_idx);\n\tif (suitable == COMPACT_SUCCESS)\n\t\t/* Allocation should succeed already. Don't reclaim. */\n\t\treturn true;\n\tif (suitable == COMPACT_SKIPPED)\n\t\t/* Compaction cannot yet proceed. Do reclaim. */\n\t\treturn false;\n\n\t/*\n\t * Compaction is already possible, but it takes time to run and there\n\t * are potentially other callers using the pages just freed. So proceed\n\t * with reclaim to make a buffer of free pages available to give\n\t * compaction a reasonable chance of completing and allocating the page.\n\t * Note that we won't actually reclaim the whole buffer in one attempt\n\t * as the target watermark in should_continue_reclaim() is lower. But if\n\t * we are already above the high+gap watermark, don't reclaim at all.\n\t */\n\twatermark = high_wmark_pages(zone) + compact_gap(sc->order);\n\n\treturn zone_watermark_ok_safe(zone, 0, watermark, sc->reclaim_idx);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_watermark_ok_safe",
          "args": [
            "zone",
            "0",
            "watermark",
            "sc->reclaim_idx"
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_ok_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3231-3241",
          "snippet": "bool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_gap",
          "args": [
            "sc->order"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_suitable",
          "args": [
            "zone",
            "sc->order",
            "0",
            "sc->reclaim_idx"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1467-1503",
          "snippet": "enum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool compaction_ready(struct zone *zone, struct scan_control *sc)\n{\n\tunsigned long watermark;\n\tenum compact_result suitable;\n\n\tsuitable = compaction_suitable(zone, sc->order, 0, sc->reclaim_idx);\n\tif (suitable == COMPACT_SUCCESS)\n\t\t/* Allocation should succeed already. Don't reclaim. */\n\t\treturn true;\n\tif (suitable == COMPACT_SKIPPED)\n\t\t/* Compaction cannot yet proceed. Do reclaim. */\n\t\treturn false;\n\n\t/*\n\t * Compaction is already possible, but it takes time to run and there\n\t * are potentially other callers using the pages just freed. So proceed\n\t * with reclaim to make a buffer of free pages available to give\n\t * compaction a reasonable chance of completing and allocating the page.\n\t * Note that we won't actually reclaim the whole buffer in one attempt\n\t * as the target watermark in should_continue_reclaim() is lower. But if\n\t * we are already above the high+gap watermark, don't reclaim at all.\n\t */\n\twatermark = high_wmark_pages(zone) + compact_gap(sc->order);\n\n\treturn zone_watermark_ok_safe(zone, 0, watermark, sc->reclaim_idx);\n}"
  },
  {
    "function_name": "shrink_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2703-2870",
    "snippet": "static bool shrink_node(pg_data_t *pgdat, struct scan_control *sc)\n{\n\tstruct reclaim_state *reclaim_state = current->reclaim_state;\n\tunsigned long nr_reclaimed, nr_scanned;\n\tbool reclaimable = false;\n\n\tdo {\n\t\tstruct mem_cgroup *root = sc->target_mem_cgroup;\n\t\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t\t.pgdat = pgdat,\n\t\t\t.priority = sc->priority,\n\t\t};\n\t\tunsigned long node_lru_pages = 0;\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemset(&sc->nr, 0, sizeof(sc->nr));\n\n\t\tnr_reclaimed = sc->nr_reclaimed;\n\t\tnr_scanned = sc->nr_scanned;\n\n\t\tmemcg = mem_cgroup_iter(root, NULL, &reclaim);\n\t\tdo {\n\t\t\tunsigned long lru_pages;\n\t\t\tunsigned long reclaimed;\n\t\t\tunsigned long scanned;\n\n\t\t\tswitch (mem_cgroup_protected(root, memcg)) {\n\t\t\tcase MEMCG_PROT_MIN:\n\t\t\t\t/*\n\t\t\t\t * Hard protection.\n\t\t\t\t * If there is no reclaimable memory, OOM.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcase MEMCG_PROT_LOW:\n\t\t\t\t/*\n\t\t\t\t * Soft protection.\n\t\t\t\t * Respect the protection only as long as\n\t\t\t\t * there is an unprotected supply\n\t\t\t\t * of reclaimable memory from other cgroups.\n\t\t\t\t */\n\t\t\t\tif (!sc->memcg_low_reclaim) {\n\t\t\t\t\tsc->memcg_low_skipped = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemcg_memory_event(memcg, MEMCG_LOW);\n\t\t\t\tbreak;\n\t\t\tcase MEMCG_PROT_NONE:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treclaimed = sc->nr_reclaimed;\n\t\t\tscanned = sc->nr_scanned;\n\t\t\tshrink_node_memcg(pgdat, memcg, sc, &lru_pages);\n\t\t\tnode_lru_pages += lru_pages;\n\n\t\t\tshrink_slab(sc->gfp_mask, pgdat->node_id,\n\t\t\t\t    memcg, sc->priority);\n\n\t\t\t/* Record the group's reclaim efficiency */\n\t\t\tvmpressure(sc->gfp_mask, memcg, false,\n\t\t\t\t   sc->nr_scanned - scanned,\n\t\t\t\t   sc->nr_reclaimed - reclaimed);\n\n\t\t\t/*\n\t\t\t * Direct reclaim and kswapd have to scan all memory\n\t\t\t * cgroups to fulfill the overall scan target for the\n\t\t\t * node.\n\t\t\t *\n\t\t\t * Limit reclaim, on the other hand, only cares about\n\t\t\t * nr_to_reclaim pages to be reclaimed and it will\n\t\t\t * retry with decreasing priority if one round over the\n\t\t\t * whole hierarchy is not sufficient.\n\t\t\t */\n\t\t\tif (!global_reclaim(sc) &&\n\t\t\t\t\tsc->nr_reclaimed >= sc->nr_to_reclaim) {\n\t\t\t\tmem_cgroup_iter_break(root, memcg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((memcg = mem_cgroup_iter(root, memcg, &reclaim)));\n\n\t\tif (reclaim_state) {\n\t\t\tsc->nr_reclaimed += reclaim_state->reclaimed_slab;\n\t\t\treclaim_state->reclaimed_slab = 0;\n\t\t}\n\n\t\t/* Record the subtree's reclaim efficiency */\n\t\tvmpressure(sc->gfp_mask, sc->target_mem_cgroup, true,\n\t\t\t   sc->nr_scanned - nr_scanned,\n\t\t\t   sc->nr_reclaimed - nr_reclaimed);\n\n\t\tif (sc->nr_reclaimed - nr_reclaimed)\n\t\t\treclaimable = true;\n\n\t\tif (current_is_kswapd()) {\n\t\t\t/*\n\t\t\t * If reclaim is isolating dirty pages under writeback,\n\t\t\t * it implies that the long-lived page allocation rate\n\t\t\t * is exceeding the page laundering rate. Either the\n\t\t\t * global limits are not being effective at throttling\n\t\t\t * processes due to the page distribution throughout\n\t\t\t * zones or there is heavy usage of a slow backing\n\t\t\t * device. The only option is to throttle from reclaim\n\t\t\t * context which is not ideal as there is no guarantee\n\t\t\t * the dirtying process is throttled in the same way\n\t\t\t * balance_dirty_pages() manages.\n\t\t\t *\n\t\t\t * Once a node is flagged PGDAT_WRITEBACK, kswapd will\n\t\t\t * count the number of pages under pages flagged for\n\t\t\t * immediate reclaim and stall if any are encountered\n\t\t\t * in the nr_immediate check below.\n\t\t\t */\n\t\t\tif (sc->nr.writeback && sc->nr.writeback == sc->nr.taken)\n\t\t\t\tset_bit(PGDAT_WRITEBACK, &pgdat->flags);\n\n\t\t\t/*\n\t\t\t * Tag a node as congested if all the dirty pages\n\t\t\t * scanned were backed by a congested BDI and\n\t\t\t * wait_iff_congested will stall.\n\t\t\t */\n\t\t\tif (sc->nr.dirty && sc->nr.dirty == sc->nr.congested)\n\t\t\t\tset_bit(PGDAT_CONGESTED, &pgdat->flags);\n\n\t\t\t/* Allow kswapd to start writing pages during reclaim.*/\n\t\t\tif (sc->nr.unqueued_dirty == sc->nr.file_taken)\n\t\t\t\tset_bit(PGDAT_DIRTY, &pgdat->flags);\n\n\t\t\t/*\n\t\t\t * If kswapd scans pages marked marked for immediate\n\t\t\t * reclaim and under writeback (nr_immediate), it\n\t\t\t * implies that pages are cycling through the LRU\n\t\t\t * faster than they are written so also forcibly stall.\n\t\t\t */\n\t\t\tif (sc->nr.immediate)\n\t\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t\t/*\n\t\t * Legacy memcg will stall in page writeback so avoid forcibly\n\t\t * stalling in wait_iff_congested().\n\t\t */\n\t\tif (!global_reclaim(sc) && sane_reclaim(sc) &&\n\t\t    sc->nr.dirty && sc->nr.dirty == sc->nr.congested)\n\t\t\tset_memcg_congestion(pgdat, root, true);\n\n\t\t/*\n\t\t * Stall direct reclaim for IO completions if underlying BDIs\n\t\t * and node is congested. Allow kswapd to continue until it\n\t\t * starts encountering unqueued dirty pages or cycling through\n\t\t * the LRU too quickly.\n\t\t */\n\t\tif (!sc->hibernation_mode && !current_is_kswapd() &&\n\t\t   current_may_throttle() && pgdat_memcg_congested(pgdat, root))\n\t\t\twait_iff_congested(BLK_RW_ASYNC, HZ/10);\n\n\t} while (should_continue_reclaim(pgdat, sc->nr_reclaimed - nr_reclaimed,\n\t\t\t\t\t sc->nr_scanned - nr_scanned, sc));\n\n\t/*\n\t * Kswapd gives up on balancing particular nodes after too\n\t * many failures to reclaim anything from them and goes to\n\t * sleep. On reclaim progress, reset the failure counter. A\n\t * successful direct reclaim run will revive a dormant kswapd.\n\t */\n\tif (reclaimable)\n\t\tpgdat->kswapd_failures = 0;\n\n\treturn reclaimable;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_continue_reclaim",
          "args": [
            "pgdat",
            "sc->nr_reclaimed - nr_reclaimed",
            "sc->nr_scanned - nr_scanned",
            "sc"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "should_continue_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2631-2695",
          "snippet": "static inline bool should_continue_reclaim(struct pglist_data *pgdat,\n\t\t\t\t\tunsigned long nr_reclaimed,\n\t\t\t\t\tunsigned long nr_scanned,\n\t\t\t\t\tstruct scan_control *sc)\n{\n\tunsigned long pages_for_compaction;\n\tunsigned long inactive_lru_pages;\n\tint z;\n\n\t/* If not in reclaim/compaction mode, stop */\n\tif (!in_reclaim_compaction(sc))\n\t\treturn false;\n\n\t/* Consider stopping depending on scan and reclaim activity */\n\tif (sc->gfp_mask & __GFP_RETRY_MAYFAIL) {\n\t\t/*\n\t\t * For __GFP_RETRY_MAYFAIL allocations, stop reclaiming if the\n\t\t * full LRU list has been scanned and we are still failing\n\t\t * to reclaim pages. This full LRU scan is potentially\n\t\t * expensive but a __GFP_RETRY_MAYFAIL caller really wants to succeed\n\t\t */\n\t\tif (!nr_reclaimed && !nr_scanned)\n\t\t\treturn false;\n\t} else {\n\t\t/*\n\t\t * For non-__GFP_RETRY_MAYFAIL allocations which can presumably\n\t\t * fail without consequence, stop if we failed to reclaim\n\t\t * any pages from the last SWAP_CLUSTER_MAX number of\n\t\t * pages that were scanned. This will return to the\n\t\t * caller faster at the risk reclaim/compaction and\n\t\t * the resulting allocation attempt fails\n\t\t */\n\t\tif (!nr_reclaimed)\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * If we have not reclaimed enough pages for compaction and the\n\t * inactive lists are large enough, continue reclaiming\n\t */\n\tpages_for_compaction = compact_gap(sc->order);\n\tinactive_lru_pages = node_page_state(pgdat, NR_INACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tinactive_lru_pages += node_page_state(pgdat, NR_INACTIVE_ANON);\n\tif (sc->nr_reclaimed < pages_for_compaction &&\n\t\t\tinactive_lru_pages > pages_for_compaction)\n\t\treturn true;\n\n\t/* If compaction would go ahead or the allocation would succeed, stop */\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tswitch (compaction_suitable(zone, sc->order, 0, sc->reclaim_idx)) {\n\t\tcase COMPACT_SUCCESS:\n\t\tcase COMPACT_CONTINUE:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\t/* check next zone */\n\t\t\t;\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool should_continue_reclaim(struct pglist_data *pgdat,\n\t\t\t\t\tunsigned long nr_reclaimed,\n\t\t\t\t\tunsigned long nr_scanned,\n\t\t\t\t\tstruct scan_control *sc)\n{\n\tunsigned long pages_for_compaction;\n\tunsigned long inactive_lru_pages;\n\tint z;\n\n\t/* If not in reclaim/compaction mode, stop */\n\tif (!in_reclaim_compaction(sc))\n\t\treturn false;\n\n\t/* Consider stopping depending on scan and reclaim activity */\n\tif (sc->gfp_mask & __GFP_RETRY_MAYFAIL) {\n\t\t/*\n\t\t * For __GFP_RETRY_MAYFAIL allocations, stop reclaiming if the\n\t\t * full LRU list has been scanned and we are still failing\n\t\t * to reclaim pages. This full LRU scan is potentially\n\t\t * expensive but a __GFP_RETRY_MAYFAIL caller really wants to succeed\n\t\t */\n\t\tif (!nr_reclaimed && !nr_scanned)\n\t\t\treturn false;\n\t} else {\n\t\t/*\n\t\t * For non-__GFP_RETRY_MAYFAIL allocations which can presumably\n\t\t * fail without consequence, stop if we failed to reclaim\n\t\t * any pages from the last SWAP_CLUSTER_MAX number of\n\t\t * pages that were scanned. This will return to the\n\t\t * caller faster at the risk reclaim/compaction and\n\t\t * the resulting allocation attempt fails\n\t\t */\n\t\tif (!nr_reclaimed)\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * If we have not reclaimed enough pages for compaction and the\n\t * inactive lists are large enough, continue reclaiming\n\t */\n\tpages_for_compaction = compact_gap(sc->order);\n\tinactive_lru_pages = node_page_state(pgdat, NR_INACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tinactive_lru_pages += node_page_state(pgdat, NR_INACTIVE_ANON);\n\tif (sc->nr_reclaimed < pages_for_compaction &&\n\t\t\tinactive_lru_pages > pages_for_compaction)\n\t\treturn true;\n\n\t/* If compaction would go ahead or the allocation would succeed, stop */\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tswitch (compaction_suitable(zone, sc->order, 0, sc->reclaim_idx)) {\n\t\tcase COMPACT_SUCCESS:\n\t\tcase COMPACT_CONTINUE:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\t/* check next zone */\n\t\t\t;\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_iff_congested",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/10"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "wait_iff_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/backing-dev.c",
          "lines": "1047-1079",
          "snippet": "long wait_iff_congested(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\t/*\n\t * If there is no congestion, yield if necessary instead\n\t * of sleeping on the congestion queue\n\t */\n\tif (atomic_read(&nr_wb_congested[sync]) == 0) {\n\t\tcond_resched();\n\n\t\t/* In case we scheduled, work out time remaining */\n\t\tret = timeout - (jiffies - start);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\n\t\tgoto out;\n\t}\n\n\t/* Sleep until uncongested or a write happens */\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\nout:\n\ttrace_writeback_wait_iff_congested(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <trace/events/writeback.h>",
            "#include <linux/device.h>",
            "#include <linux/writeback.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/wait.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};",
            "static atomic_t nr_wb_congested[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <trace/events/writeback.h>\n#include <linux/device.h>\n#include <linux/writeback.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n\nstatic wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};\nstatic atomic_t nr_wb_congested[2];\n\nlong wait_iff_congested(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\t/*\n\t * If there is no congestion, yield if necessary instead\n\t * of sleeping on the congestion queue\n\t */\n\tif (atomic_read(&nr_wb_congested[sync]) == 0) {\n\t\tcond_resched();\n\n\t\t/* In case we scheduled, work out time remaining */\n\t\tret = timeout - (jiffies - start);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\n\t\tgoto out;\n\t}\n\n\t/* Sleep until uncongested or a write happens */\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\nout:\n\ttrace_writeback_wait_iff_congested(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_memcg_congested",
          "args": [
            "pgdat",
            "root"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "pgdat_memcg_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2697-2701",
          "snippet": "static bool pgdat_memcg_congested(pg_data_t *pgdat, struct mem_cgroup *memcg)\n{\n\treturn test_bit(PGDAT_CONGESTED, &pgdat->flags) ||\n\t\t(memcg && memcg_congested(pgdat, memcg));\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool pgdat_memcg_congested(pg_data_t *pgdat, struct mem_cgroup *memcg)\n{\n\treturn test_bit(PGDAT_CONGESTED, &pgdat->flags) ||\n\t\t(memcg && memcg_congested(pgdat, memcg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_may_throttle",
          "args": [],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "current_may_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1895-1900",
          "snippet": "static int current_may_throttle(void)\n{\n\treturn !(current->flags & PF_LESS_THROTTLE) ||\n\t\tcurrent->backing_dev_info == NULL ||\n\t\tbdi_write_congested(current->backing_dev_info);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int current_may_throttle(void)\n{\n\treturn !(current->flags & PF_LESS_THROTTLE) ||\n\t\tcurrent->backing_dev_info == NULL ||\n\t\tbdi_write_congested(current->backing_dev_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memcg_congestion",
          "args": [
            "pgdat",
            "root",
            "true"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "set_memcg_congestion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "302-305",
          "snippet": "static inline void set_memcg_congestion(struct pglist_data *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg, bool congested)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void set_memcg_congestion(struct pglist_data *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg, bool congested)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sane_reclaim",
          "args": [
            "sc"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "sane_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "297-300",
          "snippet": "static bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_reclaim",
          "args": [
            "sc"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "global_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "292-295",
          "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/10"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "congestion_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/backing-dev.c",
          "lines": "1016-1031",
          "snippet": "long congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <trace/events/writeback.h>",
            "#include <linux/device.h>",
            "#include <linux/writeback.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/wait.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <trace/events/writeback.h>\n#include <linux/device.h>\n#include <linux/writeback.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n\nstatic wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};\n\nlong congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PGDAT_DIRTY",
            "&pgdat->flags"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PGDAT_CONGESTED",
            "&pgdat->flags"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PGDAT_WRITEBACK",
            "&pgdat->flags"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmpressure",
          "args": [
            "sc->gfp_mask",
            "sc->target_mem_cgroup",
            "true",
            "sc->nr_scanned - nr_scanned",
            "sc->nr_reclaimed - nr_reclaimed"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "243-313",
          "snippet": "void vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\n\t\tunsigned long scanned, unsigned long reclaimed)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\n\t/*\n\t * Here we only want to account pressure that userland is able to\n\t * help us with. For example, suppose that DMA zone is under\n\t * pressure; if we notify userland about that kind of pressure,\n\t * then it will be mostly a waste as it will trigger unnecessary\n\t * freeing of memory by userland (since userland is more likely to\n\t * have HIGHMEM/MOVABLE pages instead of the DMA fallback). That\n\t * is why we include only movable, highmem and FS/IO pages.\n\t * Indirect reclaim (kswapd) sets sc->gfp_mask to GFP_KERNEL, so\n\t * we account it too.\n\t */\n\tif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\n\t\treturn;\n\n\t/*\n\t * If we got here with no pages scanned, then that is an indicator\n\t * that reclaimer was unable to find any shrinkable LRUs at the\n\t * current scanning depth. But it does not mean that we should\n\t * report the critical pressure, yet. If the scanning priority\n\t * (scanning depth) goes too high (deep), we will be notified\n\t * through vmpressure_prio(). But so far, keep calm.\n\t */\n\tif (!scanned)\n\t\treturn;\n\n\tif (tree) {\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->tree_scanned += scanned;\n\t\tvmpr->tree_reclaimed += reclaimed;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tif (scanned < vmpressure_win)\n\t\t\treturn;\n\t\tschedule_work(&vmpr->work);\n\t} else {\n\t\tenum vmpressure_levels level;\n\n\t\t/* For now, no users for root-level efficiency */\n\t\tif (!memcg || memcg == root_mem_cgroup)\n\t\t\treturn;\n\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->scanned += scanned;\n\t\treclaimed = vmpr->reclaimed += reclaimed;\n\t\tif (scanned < vmpressure_win) {\n\t\t\tspin_unlock(&vmpr->sr_lock);\n\t\t\treturn;\n\t\t}\n\t\tvmpr->scanned = vmpr->reclaimed = 0;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\t\tif (level > VMPRESSURE_LOW) {\n\t\t\t/*\n\t\t\t * Let the socket buffer allocator know that\n\t\t\t * we are having trouble reclaiming LRU pages.\n\t\t\t *\n\t\t\t * For hysteresis keep the pressure state\n\t\t\t * asserted for a second in which subsequent\n\t\t\t * pressure events can occur.\n\t\t\t */\n\t\t\tmemcg->socket_pressure = jiffies + HZ;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;\n\nvoid vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\n\t\tunsigned long scanned, unsigned long reclaimed)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\n\t/*\n\t * Here we only want to account pressure that userland is able to\n\t * help us with. For example, suppose that DMA zone is under\n\t * pressure; if we notify userland about that kind of pressure,\n\t * then it will be mostly a waste as it will trigger unnecessary\n\t * freeing of memory by userland (since userland is more likely to\n\t * have HIGHMEM/MOVABLE pages instead of the DMA fallback). That\n\t * is why we include only movable, highmem and FS/IO pages.\n\t * Indirect reclaim (kswapd) sets sc->gfp_mask to GFP_KERNEL, so\n\t * we account it too.\n\t */\n\tif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\n\t\treturn;\n\n\t/*\n\t * If we got here with no pages scanned, then that is an indicator\n\t * that reclaimer was unable to find any shrinkable LRUs at the\n\t * current scanning depth. But it does not mean that we should\n\t * report the critical pressure, yet. If the scanning priority\n\t * (scanning depth) goes too high (deep), we will be notified\n\t * through vmpressure_prio(). But so far, keep calm.\n\t */\n\tif (!scanned)\n\t\treturn;\n\n\tif (tree) {\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->tree_scanned += scanned;\n\t\tvmpr->tree_reclaimed += reclaimed;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tif (scanned < vmpressure_win)\n\t\t\treturn;\n\t\tschedule_work(&vmpr->work);\n\t} else {\n\t\tenum vmpressure_levels level;\n\n\t\t/* For now, no users for root-level efficiency */\n\t\tif (!memcg || memcg == root_mem_cgroup)\n\t\t\treturn;\n\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->scanned += scanned;\n\t\treclaimed = vmpr->reclaimed += reclaimed;\n\t\tif (scanned < vmpressure_win) {\n\t\t\tspin_unlock(&vmpr->sr_lock);\n\t\t\treturn;\n\t\t}\n\t\tvmpr->scanned = vmpr->reclaimed = 0;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\t\tif (level > VMPRESSURE_LOW) {\n\t\t\t/*\n\t\t\t * Let the socket buffer allocator know that\n\t\t\t * we are having trouble reclaiming LRU pages.\n\t\t\t *\n\t\t\t * For hysteresis keep the pressure state\n\t\t\t * asserted for a second in which subsequent\n\t\t\t * pressure events can occur.\n\t\t\t */\n\t\t\tmemcg->socket_pressure = jiffies + HZ;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_iter",
          "args": [
            "root",
            "memcg",
            "&reclaim"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "910-1018",
          "snippet": "struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_iter_break",
          "args": [
            "root",
            "memcg"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1025-1032",
          "snippet": "void mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic __always_inline struct;\n\nvoid mem_cgroup_iter_break(struct mem_cgroup *root,\n\t\t\t   struct mem_cgroup *prev)\n{\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_slab",
          "args": [
            "sc->gfp_mask",
            "pgdat->node_id",
            "memcg",
            "sc->priority"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "686-725",
          "snippet": "static unsigned long shrink_slab(gfp_t gfp_mask, int nid,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t int priority)\n{\n\tunsigned long ret, freed = 0;\n\tstruct shrinker *shrinker;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\treturn shrink_slab_memcg(gfp_mask, nid, memcg, priority);\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\tgoto out;\n\n\tlist_for_each_entry(shrinker, &shrinker_list, list) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY)\n\t\t\tret = 0;\n\t\tfreed += ret;\n\t\t/*\n\t\t * Bail out if someone want to register a new shrinker to\n\t\t * prevent the regsitration from being stalled for long periods\n\t\t * by parallel ongoing shrinking.\n\t\t */\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&shrinker_rwsem);\nout:\n\tcond_resched();\n\treturn freed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(shrinker_list);",
            "static DECLARE_RWSEM(shrinker_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(shrinker_list);\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nstatic unsigned long shrink_slab(gfp_t gfp_mask, int nid,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t int priority)\n{\n\tunsigned long ret, freed = 0;\n\tstruct shrinker *shrinker;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\treturn shrink_slab_memcg(gfp_mask, nid, memcg, priority);\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\tgoto out;\n\n\tlist_for_each_entry(shrinker, &shrinker_list, list) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY)\n\t\t\tret = 0;\n\t\tfreed += ret;\n\t\t/*\n\t\t * Bail out if someone want to register a new shrinker to\n\t\t * prevent the regsitration from being stalled for long periods\n\t\t * by parallel ongoing shrinking.\n\t\t */\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&shrinker_rwsem);\nout:\n\tcond_resched();\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_node_memcg",
          "args": [
            "pgdat",
            "memcg",
            "sc",
            "&lru_pages"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_node_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2497-2611",
          "snippet": "static void shrink_node_memcg(struct pglist_data *pgdat, struct mem_cgroup *memcg,\n\t\t\t      struct scan_control *sc, unsigned long *lru_pages)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\tunsigned long nr[NR_LRU_LISTS];\n\tunsigned long targets[NR_LRU_LISTS];\n\tunsigned long nr_to_scan;\n\tenum lru_list lru;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_to_reclaim = sc->nr_to_reclaim;\n\tstruct blk_plug plug;\n\tbool scan_adjusted;\n\n\tget_scan_count(lruvec, memcg, sc, nr, lru_pages);\n\n\t/* Record the original scan target for proportional adjustments later */\n\tmemcpy(targets, nr, sizeof(nr));\n\n\t/*\n\t * Global reclaiming within direct reclaim at DEF_PRIORITY is a normal\n\t * event that can occur when there is little memory pressure e.g.\n\t * multiple streaming readers/writers. Hence, we do not abort scanning\n\t * when the requested number of pages are reclaimed when scanning at\n\t * DEF_PRIORITY on the assumption that the fact we are direct\n\t * reclaiming implies that kswapd is not keeping up and it is best to\n\t * do a batch of work at once. For memcg reclaim one check is made to\n\t * abort proportional reclaim if either the file or anon lru has already\n\t * dropped to zero at the first pass.\n\t */\n\tscan_adjusted = (global_reclaim(sc) && !current_is_kswapd() &&\n\t\t\t sc->priority == DEF_PRIORITY);\n\n\tblk_start_plug(&plug);\n\twhile (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||\n\t\t\t\t\tnr[LRU_INACTIVE_FILE]) {\n\t\tunsigned long nr_anon, nr_file, percentage;\n\t\tunsigned long nr_scanned;\n\n\t\tfor_each_evictable_lru(lru) {\n\t\t\tif (nr[lru]) {\n\t\t\t\tnr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);\n\t\t\t\tnr[lru] -= nr_to_scan;\n\n\t\t\t\tnr_reclaimed += shrink_list(lru, nr_to_scan,\n\t\t\t\t\t\t\t    lruvec, memcg, sc);\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\n\t\tif (nr_reclaimed < nr_to_reclaim || scan_adjusted)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For kswapd and memcg, reclaim at least the number of pages\n\t\t * requested. Ensure that the anon and file LRUs are scanned\n\t\t * proportionally what was requested by get_scan_count(). We\n\t\t * stop reclaiming one LRU and reduce the amount scanning\n\t\t * proportional to the original scan target.\n\t\t */\n\t\tnr_file = nr[LRU_INACTIVE_FILE] + nr[LRU_ACTIVE_FILE];\n\t\tnr_anon = nr[LRU_INACTIVE_ANON] + nr[LRU_ACTIVE_ANON];\n\n\t\t/*\n\t\t * It's just vindictive to attack the larger once the smaller\n\t\t * has gone to zero.  And given the way we stop scanning the\n\t\t * smaller below, this makes sure that we only make one nudge\n\t\t * towards proportionality once we've got nr_to_reclaim.\n\t\t */\n\t\tif (!nr_file || !nr_anon)\n\t\t\tbreak;\n\n\t\tif (nr_file > nr_anon) {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_ANON] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_ANON] + 1;\n\t\t\tlru = LRU_BASE;\n\t\t\tpercentage = nr_anon * 100 / scan_target;\n\t\t} else {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_FILE] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_FILE] + 1;\n\t\t\tlru = LRU_FILE;\n\t\t\tpercentage = nr_file * 100 / scan_target;\n\t\t}\n\n\t\t/* Stop scanning the smaller of the LRU */\n\t\tnr[lru] = 0;\n\t\tnr[lru + LRU_ACTIVE] = 0;\n\n\t\t/*\n\t\t * Recalculate the other LRU scan count based on its original\n\t\t * scan target and the percentage scanning already complete\n\t\t */\n\t\tlru = (lru == LRU_FILE) ? LRU_BASE : LRU_FILE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tlru += LRU_ACTIVE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tscan_adjusted = true;\n\t}\n\tblk_finish_plug(&plug);\n\tsc->nr_reclaimed += nr_reclaimed;\n\n\t/*\n\t * Even if we did not try to evict anon pages at all, we want to\n\t * rebalance the anon lru active/inactive ratio.\n\t */\n\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t   sc, LRU_ACTIVE_ANON);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_node_memcg(struct pglist_data *pgdat, struct mem_cgroup *memcg,\n\t\t\t      struct scan_control *sc, unsigned long *lru_pages)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\tunsigned long nr[NR_LRU_LISTS];\n\tunsigned long targets[NR_LRU_LISTS];\n\tunsigned long nr_to_scan;\n\tenum lru_list lru;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_to_reclaim = sc->nr_to_reclaim;\n\tstruct blk_plug plug;\n\tbool scan_adjusted;\n\n\tget_scan_count(lruvec, memcg, sc, nr, lru_pages);\n\n\t/* Record the original scan target for proportional adjustments later */\n\tmemcpy(targets, nr, sizeof(nr));\n\n\t/*\n\t * Global reclaiming within direct reclaim at DEF_PRIORITY is a normal\n\t * event that can occur when there is little memory pressure e.g.\n\t * multiple streaming readers/writers. Hence, we do not abort scanning\n\t * when the requested number of pages are reclaimed when scanning at\n\t * DEF_PRIORITY on the assumption that the fact we are direct\n\t * reclaiming implies that kswapd is not keeping up and it is best to\n\t * do a batch of work at once. For memcg reclaim one check is made to\n\t * abort proportional reclaim if either the file or anon lru has already\n\t * dropped to zero at the first pass.\n\t */\n\tscan_adjusted = (global_reclaim(sc) && !current_is_kswapd() &&\n\t\t\t sc->priority == DEF_PRIORITY);\n\n\tblk_start_plug(&plug);\n\twhile (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||\n\t\t\t\t\tnr[LRU_INACTIVE_FILE]) {\n\t\tunsigned long nr_anon, nr_file, percentage;\n\t\tunsigned long nr_scanned;\n\n\t\tfor_each_evictable_lru(lru) {\n\t\t\tif (nr[lru]) {\n\t\t\t\tnr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);\n\t\t\t\tnr[lru] -= nr_to_scan;\n\n\t\t\t\tnr_reclaimed += shrink_list(lru, nr_to_scan,\n\t\t\t\t\t\t\t    lruvec, memcg, sc);\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\n\t\tif (nr_reclaimed < nr_to_reclaim || scan_adjusted)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For kswapd and memcg, reclaim at least the number of pages\n\t\t * requested. Ensure that the anon and file LRUs are scanned\n\t\t * proportionally what was requested by get_scan_count(). We\n\t\t * stop reclaiming one LRU and reduce the amount scanning\n\t\t * proportional to the original scan target.\n\t\t */\n\t\tnr_file = nr[LRU_INACTIVE_FILE] + nr[LRU_ACTIVE_FILE];\n\t\tnr_anon = nr[LRU_INACTIVE_ANON] + nr[LRU_ACTIVE_ANON];\n\n\t\t/*\n\t\t * It's just vindictive to attack the larger once the smaller\n\t\t * has gone to zero.  And given the way we stop scanning the\n\t\t * smaller below, this makes sure that we only make one nudge\n\t\t * towards proportionality once we've got nr_to_reclaim.\n\t\t */\n\t\tif (!nr_file || !nr_anon)\n\t\t\tbreak;\n\n\t\tif (nr_file > nr_anon) {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_ANON] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_ANON] + 1;\n\t\t\tlru = LRU_BASE;\n\t\t\tpercentage = nr_anon * 100 / scan_target;\n\t\t} else {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_FILE] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_FILE] + 1;\n\t\t\tlru = LRU_FILE;\n\t\t\tpercentage = nr_file * 100 / scan_target;\n\t\t}\n\n\t\t/* Stop scanning the smaller of the LRU */\n\t\tnr[lru] = 0;\n\t\tnr[lru + LRU_ACTIVE] = 0;\n\n\t\t/*\n\t\t * Recalculate the other LRU scan count based on its original\n\t\t * scan target and the percentage scanning already complete\n\t\t */\n\t\tlru = (lru == LRU_FILE) ? LRU_BASE : LRU_FILE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tlru += LRU_ACTIVE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tscan_adjusted = true;\n\t}\n\tblk_finish_plug(&plug);\n\tsc->nr_reclaimed += nr_reclaimed;\n\n\t/*\n\t * Even if we did not try to evict anon pages at all, we want to\n\t * rebalance the anon lru active/inactive ratio.\n\t */\n\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t   sc, LRU_ACTIVE_ANON);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_memory_event",
          "args": [
            "memcg",
            "MEMCG_LOW"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_protected",
          "args": [
            "root",
            "memcg"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5763-5832",
          "snippet": "enum mem_cgroup_protection mem_cgroup_protected(struct mem_cgroup *root,\n\t\t\t\t\t\tstruct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *parent;\n\tunsigned long emin, parent_emin;\n\tunsigned long elow, parent_elow;\n\tunsigned long usage;\n\n\tif (mem_cgroup_disabled())\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (memcg == root)\n\t\treturn MEMCG_PROT_NONE;\n\n\tusage = page_counter_read(&memcg->memory);\n\tif (!usage)\n\t\treturn MEMCG_PROT_NONE;\n\n\temin = memcg->memory.min;\n\telow = memcg->memory.low;\n\n\tparent = parent_mem_cgroup(memcg);\n\t/* No parent means a non-hierarchical mode on v1 memcg */\n\tif (!parent)\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (parent == root)\n\t\tgoto exit;\n\n\tparent_emin = READ_ONCE(parent->memory.emin);\n\temin = min(emin, parent_emin);\n\tif (emin && parent_emin) {\n\t\tunsigned long min_usage, siblings_min_usage;\n\n\t\tmin_usage = min(usage, memcg->memory.min);\n\t\tsiblings_min_usage = atomic_long_read(\n\t\t\t&parent->memory.children_min_usage);\n\n\t\tif (min_usage && siblings_min_usage)\n\t\t\temin = min(emin, parent_emin * min_usage /\n\t\t\t\t   siblings_min_usage);\n\t}\n\n\tparent_elow = READ_ONCE(parent->memory.elow);\n\telow = min(elow, parent_elow);\n\tif (elow && parent_elow) {\n\t\tunsigned long low_usage, siblings_low_usage;\n\n\t\tlow_usage = min(usage, memcg->memory.low);\n\t\tsiblings_low_usage = atomic_long_read(\n\t\t\t&parent->memory.children_low_usage);\n\n\t\tif (low_usage && siblings_low_usage)\n\t\t\telow = min(elow, parent_elow * low_usage /\n\t\t\t\t   siblings_low_usage);\n\t}\n\nexit:\n\tmemcg->memory.emin = emin;\n\tmemcg->memory.elow = elow;\n\n\tif (usage <= emin)\n\t\treturn MEMCG_PROT_MIN;\n\telse if (usage <= elow)\n\t\treturn MEMCG_PROT_LOW;\n\telse\n\t\treturn MEMCG_PROT_NONE;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nenum mem_cgroup_protection mem_cgroup_protected(struct mem_cgroup *root,\n\t\t\t\t\t\tstruct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *parent;\n\tunsigned long emin, parent_emin;\n\tunsigned long elow, parent_elow;\n\tunsigned long usage;\n\n\tif (mem_cgroup_disabled())\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\tif (memcg == root)\n\t\treturn MEMCG_PROT_NONE;\n\n\tusage = page_counter_read(&memcg->memory);\n\tif (!usage)\n\t\treturn MEMCG_PROT_NONE;\n\n\temin = memcg->memory.min;\n\telow = memcg->memory.low;\n\n\tparent = parent_mem_cgroup(memcg);\n\t/* No parent means a non-hierarchical mode on v1 memcg */\n\tif (!parent)\n\t\treturn MEMCG_PROT_NONE;\n\n\tif (parent == root)\n\t\tgoto exit;\n\n\tparent_emin = READ_ONCE(parent->memory.emin);\n\temin = min(emin, parent_emin);\n\tif (emin && parent_emin) {\n\t\tunsigned long min_usage, siblings_min_usage;\n\n\t\tmin_usage = min(usage, memcg->memory.min);\n\t\tsiblings_min_usage = atomic_long_read(\n\t\t\t&parent->memory.children_min_usage);\n\n\t\tif (min_usage && siblings_min_usage)\n\t\t\temin = min(emin, parent_emin * min_usage /\n\t\t\t\t   siblings_min_usage);\n\t}\n\n\tparent_elow = READ_ONCE(parent->memory.elow);\n\telow = min(elow, parent_elow);\n\tif (elow && parent_elow) {\n\t\tunsigned long low_usage, siblings_low_usage;\n\n\t\tlow_usage = min(usage, memcg->memory.low);\n\t\tsiblings_low_usage = atomic_long_read(\n\t\t\t&parent->memory.children_low_usage);\n\n\t\tif (low_usage && siblings_low_usage)\n\t\t\telow = min(elow, parent_elow * low_usage /\n\t\t\t\t   siblings_low_usage);\n\t}\n\nexit:\n\tmemcg->memory.emin = emin;\n\tmemcg->memory.elow = elow;\n\n\tif (usage <= emin)\n\t\treturn MEMCG_PROT_MIN;\n\telse if (usage <= elow)\n\t\treturn MEMCG_PROT_LOW;\n\telse\n\t\treturn MEMCG_PROT_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sc->nr",
            "0",
            "sizeof(sc->nr)"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool shrink_node(pg_data_t *pgdat, struct scan_control *sc)\n{\n\tstruct reclaim_state *reclaim_state = current->reclaim_state;\n\tunsigned long nr_reclaimed, nr_scanned;\n\tbool reclaimable = false;\n\n\tdo {\n\t\tstruct mem_cgroup *root = sc->target_mem_cgroup;\n\t\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t\t.pgdat = pgdat,\n\t\t\t.priority = sc->priority,\n\t\t};\n\t\tunsigned long node_lru_pages = 0;\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemset(&sc->nr, 0, sizeof(sc->nr));\n\n\t\tnr_reclaimed = sc->nr_reclaimed;\n\t\tnr_scanned = sc->nr_scanned;\n\n\t\tmemcg = mem_cgroup_iter(root, NULL, &reclaim);\n\t\tdo {\n\t\t\tunsigned long lru_pages;\n\t\t\tunsigned long reclaimed;\n\t\t\tunsigned long scanned;\n\n\t\t\tswitch (mem_cgroup_protected(root, memcg)) {\n\t\t\tcase MEMCG_PROT_MIN:\n\t\t\t\t/*\n\t\t\t\t * Hard protection.\n\t\t\t\t * If there is no reclaimable memory, OOM.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcase MEMCG_PROT_LOW:\n\t\t\t\t/*\n\t\t\t\t * Soft protection.\n\t\t\t\t * Respect the protection only as long as\n\t\t\t\t * there is an unprotected supply\n\t\t\t\t * of reclaimable memory from other cgroups.\n\t\t\t\t */\n\t\t\t\tif (!sc->memcg_low_reclaim) {\n\t\t\t\t\tsc->memcg_low_skipped = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemcg_memory_event(memcg, MEMCG_LOW);\n\t\t\t\tbreak;\n\t\t\tcase MEMCG_PROT_NONE:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treclaimed = sc->nr_reclaimed;\n\t\t\tscanned = sc->nr_scanned;\n\t\t\tshrink_node_memcg(pgdat, memcg, sc, &lru_pages);\n\t\t\tnode_lru_pages += lru_pages;\n\n\t\t\tshrink_slab(sc->gfp_mask, pgdat->node_id,\n\t\t\t\t    memcg, sc->priority);\n\n\t\t\t/* Record the group's reclaim efficiency */\n\t\t\tvmpressure(sc->gfp_mask, memcg, false,\n\t\t\t\t   sc->nr_scanned - scanned,\n\t\t\t\t   sc->nr_reclaimed - reclaimed);\n\n\t\t\t/*\n\t\t\t * Direct reclaim and kswapd have to scan all memory\n\t\t\t * cgroups to fulfill the overall scan target for the\n\t\t\t * node.\n\t\t\t *\n\t\t\t * Limit reclaim, on the other hand, only cares about\n\t\t\t * nr_to_reclaim pages to be reclaimed and it will\n\t\t\t * retry with decreasing priority if one round over the\n\t\t\t * whole hierarchy is not sufficient.\n\t\t\t */\n\t\t\tif (!global_reclaim(sc) &&\n\t\t\t\t\tsc->nr_reclaimed >= sc->nr_to_reclaim) {\n\t\t\t\tmem_cgroup_iter_break(root, memcg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((memcg = mem_cgroup_iter(root, memcg, &reclaim)));\n\n\t\tif (reclaim_state) {\n\t\t\tsc->nr_reclaimed += reclaim_state->reclaimed_slab;\n\t\t\treclaim_state->reclaimed_slab = 0;\n\t\t}\n\n\t\t/* Record the subtree's reclaim efficiency */\n\t\tvmpressure(sc->gfp_mask, sc->target_mem_cgroup, true,\n\t\t\t   sc->nr_scanned - nr_scanned,\n\t\t\t   sc->nr_reclaimed - nr_reclaimed);\n\n\t\tif (sc->nr_reclaimed - nr_reclaimed)\n\t\t\treclaimable = true;\n\n\t\tif (current_is_kswapd()) {\n\t\t\t/*\n\t\t\t * If reclaim is isolating dirty pages under writeback,\n\t\t\t * it implies that the long-lived page allocation rate\n\t\t\t * is exceeding the page laundering rate. Either the\n\t\t\t * global limits are not being effective at throttling\n\t\t\t * processes due to the page distribution throughout\n\t\t\t * zones or there is heavy usage of a slow backing\n\t\t\t * device. The only option is to throttle from reclaim\n\t\t\t * context which is not ideal as there is no guarantee\n\t\t\t * the dirtying process is throttled in the same way\n\t\t\t * balance_dirty_pages() manages.\n\t\t\t *\n\t\t\t * Once a node is flagged PGDAT_WRITEBACK, kswapd will\n\t\t\t * count the number of pages under pages flagged for\n\t\t\t * immediate reclaim and stall if any are encountered\n\t\t\t * in the nr_immediate check below.\n\t\t\t */\n\t\t\tif (sc->nr.writeback && sc->nr.writeback == sc->nr.taken)\n\t\t\t\tset_bit(PGDAT_WRITEBACK, &pgdat->flags);\n\n\t\t\t/*\n\t\t\t * Tag a node as congested if all the dirty pages\n\t\t\t * scanned were backed by a congested BDI and\n\t\t\t * wait_iff_congested will stall.\n\t\t\t */\n\t\t\tif (sc->nr.dirty && sc->nr.dirty == sc->nr.congested)\n\t\t\t\tset_bit(PGDAT_CONGESTED, &pgdat->flags);\n\n\t\t\t/* Allow kswapd to start writing pages during reclaim.*/\n\t\t\tif (sc->nr.unqueued_dirty == sc->nr.file_taken)\n\t\t\t\tset_bit(PGDAT_DIRTY, &pgdat->flags);\n\n\t\t\t/*\n\t\t\t * If kswapd scans pages marked marked for immediate\n\t\t\t * reclaim and under writeback (nr_immediate), it\n\t\t\t * implies that pages are cycling through the LRU\n\t\t\t * faster than they are written so also forcibly stall.\n\t\t\t */\n\t\t\tif (sc->nr.immediate)\n\t\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t}\n\n\t\t/*\n\t\t * Legacy memcg will stall in page writeback so avoid forcibly\n\t\t * stalling in wait_iff_congested().\n\t\t */\n\t\tif (!global_reclaim(sc) && sane_reclaim(sc) &&\n\t\t    sc->nr.dirty && sc->nr.dirty == sc->nr.congested)\n\t\t\tset_memcg_congestion(pgdat, root, true);\n\n\t\t/*\n\t\t * Stall direct reclaim for IO completions if underlying BDIs\n\t\t * and node is congested. Allow kswapd to continue until it\n\t\t * starts encountering unqueued dirty pages or cycling through\n\t\t * the LRU too quickly.\n\t\t */\n\t\tif (!sc->hibernation_mode && !current_is_kswapd() &&\n\t\t   current_may_throttle() && pgdat_memcg_congested(pgdat, root))\n\t\t\twait_iff_congested(BLK_RW_ASYNC, HZ/10);\n\n\t} while (should_continue_reclaim(pgdat, sc->nr_reclaimed - nr_reclaimed,\n\t\t\t\t\t sc->nr_scanned - nr_scanned, sc));\n\n\t/*\n\t * Kswapd gives up on balancing particular nodes after too\n\t * many failures to reclaim anything from them and goes to\n\t * sleep. On reclaim progress, reset the failure counter. A\n\t * successful direct reclaim run will revive a dormant kswapd.\n\t */\n\tif (reclaimable)\n\t\tpgdat->kswapd_failures = 0;\n\n\treturn reclaimable;\n}"
  },
  {
    "function_name": "pgdat_memcg_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2697-2701",
    "snippet": "static bool pgdat_memcg_congested(pg_data_t *pgdat, struct mem_cgroup *memcg)\n{\n\treturn test_bit(PGDAT_CONGESTED, &pgdat->flags) ||\n\t\t(memcg && memcg_congested(pgdat, memcg));\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_congested",
          "args": [
            "pgdat",
            "memcg"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "pgdat_memcg_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2697-2701",
          "snippet": "static bool pgdat_memcg_congested(pg_data_t *pgdat, struct mem_cgroup *memcg)\n{\n\treturn test_bit(PGDAT_CONGESTED, &pgdat->flags) ||\n\t\t(memcg && memcg_congested(pgdat, memcg));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PGDAT_CONGESTED",
            "&pgdat->flags"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool pgdat_memcg_congested(pg_data_t *pgdat, struct mem_cgroup *memcg)\n{\n\treturn test_bit(PGDAT_CONGESTED, &pgdat->flags) ||\n\t\t(memcg && memcg_congested(pgdat, memcg));\n}"
  },
  {
    "function_name": "should_continue_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2631-2695",
    "snippet": "static inline bool should_continue_reclaim(struct pglist_data *pgdat,\n\t\t\t\t\tunsigned long nr_reclaimed,\n\t\t\t\t\tunsigned long nr_scanned,\n\t\t\t\t\tstruct scan_control *sc)\n{\n\tunsigned long pages_for_compaction;\n\tunsigned long inactive_lru_pages;\n\tint z;\n\n\t/* If not in reclaim/compaction mode, stop */\n\tif (!in_reclaim_compaction(sc))\n\t\treturn false;\n\n\t/* Consider stopping depending on scan and reclaim activity */\n\tif (sc->gfp_mask & __GFP_RETRY_MAYFAIL) {\n\t\t/*\n\t\t * For __GFP_RETRY_MAYFAIL allocations, stop reclaiming if the\n\t\t * full LRU list has been scanned and we are still failing\n\t\t * to reclaim pages. This full LRU scan is potentially\n\t\t * expensive but a __GFP_RETRY_MAYFAIL caller really wants to succeed\n\t\t */\n\t\tif (!nr_reclaimed && !nr_scanned)\n\t\t\treturn false;\n\t} else {\n\t\t/*\n\t\t * For non-__GFP_RETRY_MAYFAIL allocations which can presumably\n\t\t * fail without consequence, stop if we failed to reclaim\n\t\t * any pages from the last SWAP_CLUSTER_MAX number of\n\t\t * pages that were scanned. This will return to the\n\t\t * caller faster at the risk reclaim/compaction and\n\t\t * the resulting allocation attempt fails\n\t\t */\n\t\tif (!nr_reclaimed)\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * If we have not reclaimed enough pages for compaction and the\n\t * inactive lists are large enough, continue reclaiming\n\t */\n\tpages_for_compaction = compact_gap(sc->order);\n\tinactive_lru_pages = node_page_state(pgdat, NR_INACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tinactive_lru_pages += node_page_state(pgdat, NR_INACTIVE_ANON);\n\tif (sc->nr_reclaimed < pages_for_compaction &&\n\t\t\tinactive_lru_pages > pages_for_compaction)\n\t\treturn true;\n\n\t/* If compaction would go ahead or the allocation would succeed, stop */\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tswitch (compaction_suitable(zone, sc->order, 0, sc->reclaim_idx)) {\n\t\tcase COMPACT_SUCCESS:\n\t\tcase COMPACT_CONTINUE:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\t/* check next zone */\n\t\t\t;\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compaction_suitable",
          "args": [
            "zone",
            "sc->order",
            "0",
            "sc->reclaim_idx"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1467-1503",
          "snippet": "enum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_INACTIVE_ANON"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_swap_pages",
          "args": [],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_gap",
          "args": [
            "sc->order"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_reclaim_compaction",
          "args": [
            "sc"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "in_reclaim_compaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2614-2622",
          "snippet": "static bool in_reclaim_compaction(struct scan_control *sc)\n{\n\tif (IS_ENABLED(CONFIG_COMPACTION) && sc->order &&\n\t\t\t(sc->order > PAGE_ALLOC_COSTLY_ORDER ||\n\t\t\t sc->priority < DEF_PRIORITY - 2))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool in_reclaim_compaction(struct scan_control *sc)\n{\n\tif (IS_ENABLED(CONFIG_COMPACTION) && sc->order &&\n\t\t\t(sc->order > PAGE_ALLOC_COSTLY_ORDER ||\n\t\t\t sc->priority < DEF_PRIORITY - 2))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool should_continue_reclaim(struct pglist_data *pgdat,\n\t\t\t\t\tunsigned long nr_reclaimed,\n\t\t\t\t\tunsigned long nr_scanned,\n\t\t\t\t\tstruct scan_control *sc)\n{\n\tunsigned long pages_for_compaction;\n\tunsigned long inactive_lru_pages;\n\tint z;\n\n\t/* If not in reclaim/compaction mode, stop */\n\tif (!in_reclaim_compaction(sc))\n\t\treturn false;\n\n\t/* Consider stopping depending on scan and reclaim activity */\n\tif (sc->gfp_mask & __GFP_RETRY_MAYFAIL) {\n\t\t/*\n\t\t * For __GFP_RETRY_MAYFAIL allocations, stop reclaiming if the\n\t\t * full LRU list has been scanned and we are still failing\n\t\t * to reclaim pages. This full LRU scan is potentially\n\t\t * expensive but a __GFP_RETRY_MAYFAIL caller really wants to succeed\n\t\t */\n\t\tif (!nr_reclaimed && !nr_scanned)\n\t\t\treturn false;\n\t} else {\n\t\t/*\n\t\t * For non-__GFP_RETRY_MAYFAIL allocations which can presumably\n\t\t * fail without consequence, stop if we failed to reclaim\n\t\t * any pages from the last SWAP_CLUSTER_MAX number of\n\t\t * pages that were scanned. This will return to the\n\t\t * caller faster at the risk reclaim/compaction and\n\t\t * the resulting allocation attempt fails\n\t\t */\n\t\tif (!nr_reclaimed)\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * If we have not reclaimed enough pages for compaction and the\n\t * inactive lists are large enough, continue reclaiming\n\t */\n\tpages_for_compaction = compact_gap(sc->order);\n\tinactive_lru_pages = node_page_state(pgdat, NR_INACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tinactive_lru_pages += node_page_state(pgdat, NR_INACTIVE_ANON);\n\tif (sc->nr_reclaimed < pages_for_compaction &&\n\t\t\tinactive_lru_pages > pages_for_compaction)\n\t\treturn true;\n\n\t/* If compaction would go ahead or the allocation would succeed, stop */\n\tfor (z = 0; z <= sc->reclaim_idx; z++) {\n\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tswitch (compaction_suitable(zone, sc->order, 0, sc->reclaim_idx)) {\n\t\tcase COMPACT_SUCCESS:\n\t\tcase COMPACT_CONTINUE:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\t/* check next zone */\n\t\t\t;\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "in_reclaim_compaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2614-2622",
    "snippet": "static bool in_reclaim_compaction(struct scan_control *sc)\n{\n\tif (IS_ENABLED(CONFIG_COMPACTION) && sc->order &&\n\t\t\t(sc->order > PAGE_ALLOC_COSTLY_ORDER ||\n\t\t\t sc->priority < DEF_PRIORITY - 2))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_COMPACTION"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool in_reclaim_compaction(struct scan_control *sc)\n{\n\tif (IS_ENABLED(CONFIG_COMPACTION) && sc->order &&\n\t\t\t(sc->order > PAGE_ALLOC_COSTLY_ORDER ||\n\t\t\t sc->priority < DEF_PRIORITY - 2))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "shrink_node_memcg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2497-2611",
    "snippet": "static void shrink_node_memcg(struct pglist_data *pgdat, struct mem_cgroup *memcg,\n\t\t\t      struct scan_control *sc, unsigned long *lru_pages)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\tunsigned long nr[NR_LRU_LISTS];\n\tunsigned long targets[NR_LRU_LISTS];\n\tunsigned long nr_to_scan;\n\tenum lru_list lru;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_to_reclaim = sc->nr_to_reclaim;\n\tstruct blk_plug plug;\n\tbool scan_adjusted;\n\n\tget_scan_count(lruvec, memcg, sc, nr, lru_pages);\n\n\t/* Record the original scan target for proportional adjustments later */\n\tmemcpy(targets, nr, sizeof(nr));\n\n\t/*\n\t * Global reclaiming within direct reclaim at DEF_PRIORITY is a normal\n\t * event that can occur when there is little memory pressure e.g.\n\t * multiple streaming readers/writers. Hence, we do not abort scanning\n\t * when the requested number of pages are reclaimed when scanning at\n\t * DEF_PRIORITY on the assumption that the fact we are direct\n\t * reclaiming implies that kswapd is not keeping up and it is best to\n\t * do a batch of work at once. For memcg reclaim one check is made to\n\t * abort proportional reclaim if either the file or anon lru has already\n\t * dropped to zero at the first pass.\n\t */\n\tscan_adjusted = (global_reclaim(sc) && !current_is_kswapd() &&\n\t\t\t sc->priority == DEF_PRIORITY);\n\n\tblk_start_plug(&plug);\n\twhile (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||\n\t\t\t\t\tnr[LRU_INACTIVE_FILE]) {\n\t\tunsigned long nr_anon, nr_file, percentage;\n\t\tunsigned long nr_scanned;\n\n\t\tfor_each_evictable_lru(lru) {\n\t\t\tif (nr[lru]) {\n\t\t\t\tnr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);\n\t\t\t\tnr[lru] -= nr_to_scan;\n\n\t\t\t\tnr_reclaimed += shrink_list(lru, nr_to_scan,\n\t\t\t\t\t\t\t    lruvec, memcg, sc);\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\n\t\tif (nr_reclaimed < nr_to_reclaim || scan_adjusted)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For kswapd and memcg, reclaim at least the number of pages\n\t\t * requested. Ensure that the anon and file LRUs are scanned\n\t\t * proportionally what was requested by get_scan_count(). We\n\t\t * stop reclaiming one LRU and reduce the amount scanning\n\t\t * proportional to the original scan target.\n\t\t */\n\t\tnr_file = nr[LRU_INACTIVE_FILE] + nr[LRU_ACTIVE_FILE];\n\t\tnr_anon = nr[LRU_INACTIVE_ANON] + nr[LRU_ACTIVE_ANON];\n\n\t\t/*\n\t\t * It's just vindictive to attack the larger once the smaller\n\t\t * has gone to zero.  And given the way we stop scanning the\n\t\t * smaller below, this makes sure that we only make one nudge\n\t\t * towards proportionality once we've got nr_to_reclaim.\n\t\t */\n\t\tif (!nr_file || !nr_anon)\n\t\t\tbreak;\n\n\t\tif (nr_file > nr_anon) {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_ANON] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_ANON] + 1;\n\t\t\tlru = LRU_BASE;\n\t\t\tpercentage = nr_anon * 100 / scan_target;\n\t\t} else {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_FILE] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_FILE] + 1;\n\t\t\tlru = LRU_FILE;\n\t\t\tpercentage = nr_file * 100 / scan_target;\n\t\t}\n\n\t\t/* Stop scanning the smaller of the LRU */\n\t\tnr[lru] = 0;\n\t\tnr[lru + LRU_ACTIVE] = 0;\n\n\t\t/*\n\t\t * Recalculate the other LRU scan count based on its original\n\t\t * scan target and the percentage scanning already complete\n\t\t */\n\t\tlru = (lru == LRU_FILE) ? LRU_BASE : LRU_FILE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tlru += LRU_ACTIVE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tscan_adjusted = true;\n\t}\n\tblk_finish_plug(&plug);\n\tsc->nr_reclaimed += nr_reclaimed;\n\n\t/*\n\t * Even if we did not try to evict anon pages at all, we want to\n\t * rebalance the anon lru active/inactive ratio.\n\t */\n\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t   sc, LRU_ACTIVE_ANON);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_active_list",
          "args": [
            "SWAP_CLUSTER_MAX",
            "lruvec",
            "sc",
            "LRU_ACTIVE_ANON"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_active_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2084-2183",
          "snippet": "static void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inactive_list_is_low",
          "args": [
            "lruvec",
            "false",
            "memcg",
            "sc",
            "true"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "inactive_list_is_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2213-2262",
          "snippet": "static bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nr[lru]",
            "nr_scanned"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_list",
          "args": [
            "lru",
            "nr_to_scan",
            "lruvec",
            "memcg",
            "sc"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2264-2276",
          "snippet": "static unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,\n\t\t\t\t struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc)\n{\n\tif (is_active_lru(lru)) {\n\t\tif (inactive_list_is_low(lruvec, is_file_lru(lru),\n\t\t\t\t\t memcg, sc, true))\n\t\t\tshrink_active_list(nr_to_scan, lruvec, sc, lru);\n\t\treturn 0;\n\t}\n\n\treturn shrink_inactive_list(nr_to_scan, lruvec, sc, lru);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,\n\t\t\t\t struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc)\n{\n\tif (is_active_lru(lru)) {\n\t\tif (inactive_list_is_low(lruvec, is_file_lru(lru),\n\t\t\t\t\t memcg, sc, true))\n\t\t\tshrink_active_list(nr_to_scan, lruvec, sc, lru);\n\t\treturn 0;\n\t}\n\n\treturn shrink_inactive_list(nr_to_scan, lruvec, sc, lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_reclaim",
          "args": [
            "sc"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "global_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "292-295",
          "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "targets",
            "nr",
            "sizeof(nr)"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_scan_count",
          "args": [
            "lruvec",
            "memcg",
            "sc",
            "nr",
            "lru_pages"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "get_scan_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2294-2492",
          "snippet": "static void get_scan_count(struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t   struct scan_control *sc, unsigned long *nr,\n\t\t\t   unsigned long *lru_pages)\n{\n\tint swappiness = mem_cgroup_swappiness(memcg);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tu64 fraction[2];\n\tu64 denominator = 0;\t/* gcc */\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tunsigned long anon_prio, file_prio;\n\tenum scan_balance scan_balance;\n\tunsigned long anon, file;\n\tunsigned long ap, fp;\n\tenum lru_list lru;\n\n\t/* If we have no swap space, do not bother scanning anon pages. */\n\tif (!sc->may_swap || mem_cgroup_get_nr_swap_pages(memcg) <= 0) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Global reclaim will swap to prevent OOM even with no\n\t * swappiness, but memcg users want to use this knob to\n\t * disable swapping for individual groups completely when\n\t * using the memory controller's swap limit feature would be\n\t * too expensive.\n\t */\n\tif (!global_reclaim(sc) && !swappiness) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not apply any pressure balancing cleverness when the\n\t * system is close to OOM, scan both anon and file equally\n\t * (unless the swappiness setting disagrees with swapping).\n\t */\n\tif (!sc->priority && swappiness) {\n\t\tscan_balance = SCAN_EQUAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prevent the reclaimer from falling into the cache trap: as\n\t * cache pages start out inactive, every cache fault will tip\n\t * the scan balance towards the file LRU.  And as the file LRU\n\t * shrinks, so does the window for rotation from references.\n\t * This means we have a runaway feedback loop where a tiny\n\t * thrashing file LRU becomes infinitely more attractive than\n\t * anon pages.  Try to detect this based on file LRU size.\n\t */\n\tif (global_reclaim(sc)) {\n\t\tunsigned long pgdatfile;\n\t\tunsigned long pgdatfree;\n\t\tint z;\n\t\tunsigned long total_high_wmark = 0;\n\n\t\tpgdatfree = sum_zone_node_page_state(pgdat->node_id, NR_FREE_PAGES);\n\t\tpgdatfile = node_page_state(pgdat, NR_ACTIVE_FILE) +\n\t\t\t   node_page_state(pgdat, NR_INACTIVE_FILE);\n\n\t\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\t\tif (!managed_zone(zone))\n\t\t\t\tcontinue;\n\n\t\t\ttotal_high_wmark += high_wmark_pages(zone);\n\t\t}\n\n\t\tif (unlikely(pgdatfile + pgdatfree <= total_high_wmark)) {\n\t\t\t/*\n\t\t\t * Force SCAN_ANON if there are enough inactive\n\t\t\t * anonymous pages on the LRU in eligible zones.\n\t\t\t * Otherwise, the small LRU gets thrashed.\n\t\t\t */\n\t\t\tif (!inactive_list_is_low(lruvec, false, memcg, sc, false) &&\n\t\t\t    lruvec_lru_size(lruvec, LRU_INACTIVE_ANON, sc->reclaim_idx)\n\t\t\t\t\t>> sc->priority) {\n\t\t\t\tscan_balance = SCAN_ANON;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If there is enough inactive page cache, i.e. if the size of the\n\t * inactive list is greater than that of the active list *and* the\n\t * inactive list actually has some pages to scan on this priority, we\n\t * do not reclaim anything from the anonymous working set right now.\n\t * Without the second condition we could end up never scanning an\n\t * lruvec even if it has plenty of old anonymous pages unless the\n\t * system is under heavy pressure.\n\t */\n\tif (!inactive_list_is_low(lruvec, true, memcg, sc, false) &&\n\t    lruvec_lru_size(lruvec, LRU_INACTIVE_FILE, sc->reclaim_idx) >> sc->priority) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\tscan_balance = SCAN_FRACT;\n\n\t/*\n\t * With swappiness at 100, anonymous and file have the same priority.\n\t * This scanning priority is essentially the inverse of IO cost.\n\t */\n\tanon_prio = swappiness;\n\tfile_prio = 200 - anon_prio;\n\n\t/*\n\t * OK, so we have swap space and a fair amount of page cache\n\t * pages.  We use the recently rotated / recently scanned\n\t * ratios to determine how valuable each cache is.\n\t *\n\t * Because workloads change over time (and to avoid overflow)\n\t * we keep these statistics as a floating average, which ends\n\t * up weighing recent references more than old ones.\n\t *\n\t * anon in [0], file in [1]\n\t */\n\n\tanon  = lruvec_lru_size(lruvec, LRU_ACTIVE_ANON, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_ANON, MAX_NR_ZONES);\n\tfile  = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_FILE, MAX_NR_ZONES);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\tif (unlikely(reclaim_stat->recent_scanned[0] > anon / 4)) {\n\t\treclaim_stat->recent_scanned[0] /= 2;\n\t\treclaim_stat->recent_rotated[0] /= 2;\n\t}\n\n\tif (unlikely(reclaim_stat->recent_scanned[1] > file / 4)) {\n\t\treclaim_stat->recent_scanned[1] /= 2;\n\t\treclaim_stat->recent_rotated[1] /= 2;\n\t}\n\n\t/*\n\t * The amount of pressure on anon vs file pages is inversely\n\t * proportional to the fraction of recently scanned pages on\n\t * each list that were recently referenced and in active use.\n\t */\n\tap = anon_prio * (reclaim_stat->recent_scanned[0] + 1);\n\tap /= reclaim_stat->recent_rotated[0] + 1;\n\n\tfp = file_prio * (reclaim_stat->recent_scanned[1] + 1);\n\tfp /= reclaim_stat->recent_rotated[1] + 1;\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tfraction[0] = ap;\n\tfraction[1] = fp;\n\tdenominator = ap + fp + 1;\nout:\n\t*lru_pages = 0;\n\tfor_each_evictable_lru(lru) {\n\t\tint file = is_file_lru(lru);\n\t\tunsigned long size;\n\t\tunsigned long scan;\n\n\t\tsize = lruvec_lru_size(lruvec, lru, sc->reclaim_idx);\n\t\tscan = size >> sc->priority;\n\t\t/*\n\t\t * If the cgroup's already been deleted, make sure to\n\t\t * scrape out the remaining cache.\n\t\t */\n\t\tif (!scan && !mem_cgroup_online(memcg))\n\t\t\tscan = min(size, SWAP_CLUSTER_MAX);\n\n\t\tswitch (scan_balance) {\n\t\tcase SCAN_EQUAL:\n\t\t\t/* Scan lists relative to size */\n\t\t\tbreak;\n\t\tcase SCAN_FRACT:\n\t\t\t/*\n\t\t\t * Scan types proportional to swappiness and\n\t\t\t * their relative recent reclaim efficiency.\n\t\t\t * Make sure we don't miss the last page\n\t\t\t * because of a round-off error.\n\t\t\t */\n\t\t\tscan = DIV64_U64_ROUND_UP(scan * fraction[file],\n\t\t\t\t\t\t  denominator);\n\t\t\tbreak;\n\t\tcase SCAN_FILE:\n\t\tcase SCAN_ANON:\n\t\t\t/* Scan one type exclusively */\n\t\t\tif ((scan_balance == SCAN_FILE) != file) {\n\t\t\t\tsize = 0;\n\t\t\t\tscan = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Look ma, no brain */\n\t\t\tBUG();\n\t\t}\n\n\t\t*lru_pages += size;\n\t\tnr[lru] = scan;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void get_scan_count(struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t   struct scan_control *sc, unsigned long *nr,\n\t\t\t   unsigned long *lru_pages)\n{\n\tint swappiness = mem_cgroup_swappiness(memcg);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tu64 fraction[2];\n\tu64 denominator = 0;\t/* gcc */\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tunsigned long anon_prio, file_prio;\n\tenum scan_balance scan_balance;\n\tunsigned long anon, file;\n\tunsigned long ap, fp;\n\tenum lru_list lru;\n\n\t/* If we have no swap space, do not bother scanning anon pages. */\n\tif (!sc->may_swap || mem_cgroup_get_nr_swap_pages(memcg) <= 0) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Global reclaim will swap to prevent OOM even with no\n\t * swappiness, but memcg users want to use this knob to\n\t * disable swapping for individual groups completely when\n\t * using the memory controller's swap limit feature would be\n\t * too expensive.\n\t */\n\tif (!global_reclaim(sc) && !swappiness) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not apply any pressure balancing cleverness when the\n\t * system is close to OOM, scan both anon and file equally\n\t * (unless the swappiness setting disagrees with swapping).\n\t */\n\tif (!sc->priority && swappiness) {\n\t\tscan_balance = SCAN_EQUAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prevent the reclaimer from falling into the cache trap: as\n\t * cache pages start out inactive, every cache fault will tip\n\t * the scan balance towards the file LRU.  And as the file LRU\n\t * shrinks, so does the window for rotation from references.\n\t * This means we have a runaway feedback loop where a tiny\n\t * thrashing file LRU becomes infinitely more attractive than\n\t * anon pages.  Try to detect this based on file LRU size.\n\t */\n\tif (global_reclaim(sc)) {\n\t\tunsigned long pgdatfile;\n\t\tunsigned long pgdatfree;\n\t\tint z;\n\t\tunsigned long total_high_wmark = 0;\n\n\t\tpgdatfree = sum_zone_node_page_state(pgdat->node_id, NR_FREE_PAGES);\n\t\tpgdatfile = node_page_state(pgdat, NR_ACTIVE_FILE) +\n\t\t\t   node_page_state(pgdat, NR_INACTIVE_FILE);\n\n\t\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\t\tif (!managed_zone(zone))\n\t\t\t\tcontinue;\n\n\t\t\ttotal_high_wmark += high_wmark_pages(zone);\n\t\t}\n\n\t\tif (unlikely(pgdatfile + pgdatfree <= total_high_wmark)) {\n\t\t\t/*\n\t\t\t * Force SCAN_ANON if there are enough inactive\n\t\t\t * anonymous pages on the LRU in eligible zones.\n\t\t\t * Otherwise, the small LRU gets thrashed.\n\t\t\t */\n\t\t\tif (!inactive_list_is_low(lruvec, false, memcg, sc, false) &&\n\t\t\t    lruvec_lru_size(lruvec, LRU_INACTIVE_ANON, sc->reclaim_idx)\n\t\t\t\t\t>> sc->priority) {\n\t\t\t\tscan_balance = SCAN_ANON;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If there is enough inactive page cache, i.e. if the size of the\n\t * inactive list is greater than that of the active list *and* the\n\t * inactive list actually has some pages to scan on this priority, we\n\t * do not reclaim anything from the anonymous working set right now.\n\t * Without the second condition we could end up never scanning an\n\t * lruvec even if it has plenty of old anonymous pages unless the\n\t * system is under heavy pressure.\n\t */\n\tif (!inactive_list_is_low(lruvec, true, memcg, sc, false) &&\n\t    lruvec_lru_size(lruvec, LRU_INACTIVE_FILE, sc->reclaim_idx) >> sc->priority) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\tscan_balance = SCAN_FRACT;\n\n\t/*\n\t * With swappiness at 100, anonymous and file have the same priority.\n\t * This scanning priority is essentially the inverse of IO cost.\n\t */\n\tanon_prio = swappiness;\n\tfile_prio = 200 - anon_prio;\n\n\t/*\n\t * OK, so we have swap space and a fair amount of page cache\n\t * pages.  We use the recently rotated / recently scanned\n\t * ratios to determine how valuable each cache is.\n\t *\n\t * Because workloads change over time (and to avoid overflow)\n\t * we keep these statistics as a floating average, which ends\n\t * up weighing recent references more than old ones.\n\t *\n\t * anon in [0], file in [1]\n\t */\n\n\tanon  = lruvec_lru_size(lruvec, LRU_ACTIVE_ANON, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_ANON, MAX_NR_ZONES);\n\tfile  = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_FILE, MAX_NR_ZONES);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\tif (unlikely(reclaim_stat->recent_scanned[0] > anon / 4)) {\n\t\treclaim_stat->recent_scanned[0] /= 2;\n\t\treclaim_stat->recent_rotated[0] /= 2;\n\t}\n\n\tif (unlikely(reclaim_stat->recent_scanned[1] > file / 4)) {\n\t\treclaim_stat->recent_scanned[1] /= 2;\n\t\treclaim_stat->recent_rotated[1] /= 2;\n\t}\n\n\t/*\n\t * The amount of pressure on anon vs file pages is inversely\n\t * proportional to the fraction of recently scanned pages on\n\t * each list that were recently referenced and in active use.\n\t */\n\tap = anon_prio * (reclaim_stat->recent_scanned[0] + 1);\n\tap /= reclaim_stat->recent_rotated[0] + 1;\n\n\tfp = file_prio * (reclaim_stat->recent_scanned[1] + 1);\n\tfp /= reclaim_stat->recent_rotated[1] + 1;\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tfraction[0] = ap;\n\tfraction[1] = fp;\n\tdenominator = ap + fp + 1;\nout:\n\t*lru_pages = 0;\n\tfor_each_evictable_lru(lru) {\n\t\tint file = is_file_lru(lru);\n\t\tunsigned long size;\n\t\tunsigned long scan;\n\n\t\tsize = lruvec_lru_size(lruvec, lru, sc->reclaim_idx);\n\t\tscan = size >> sc->priority;\n\t\t/*\n\t\t * If the cgroup's already been deleted, make sure to\n\t\t * scrape out the remaining cache.\n\t\t */\n\t\tif (!scan && !mem_cgroup_online(memcg))\n\t\t\tscan = min(size, SWAP_CLUSTER_MAX);\n\n\t\tswitch (scan_balance) {\n\t\tcase SCAN_EQUAL:\n\t\t\t/* Scan lists relative to size */\n\t\t\tbreak;\n\t\tcase SCAN_FRACT:\n\t\t\t/*\n\t\t\t * Scan types proportional to swappiness and\n\t\t\t * their relative recent reclaim efficiency.\n\t\t\t * Make sure we don't miss the last page\n\t\t\t * because of a round-off error.\n\t\t\t */\n\t\t\tscan = DIV64_U64_ROUND_UP(scan * fraction[file],\n\t\t\t\t\t\t  denominator);\n\t\t\tbreak;\n\t\tcase SCAN_FILE:\n\t\tcase SCAN_ANON:\n\t\t\t/* Scan one type exclusively */\n\t\t\tif ((scan_balance == SCAN_FILE) != file) {\n\t\t\t\tsize = 0;\n\t\t\t\tscan = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Look ma, no brain */\n\t\t\tBUG();\n\t\t}\n\n\t\t*lru_pages += size;\n\t\tnr[lru] = scan;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "pgdat",
            "memcg"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_node_memcg(struct pglist_data *pgdat, struct mem_cgroup *memcg,\n\t\t\t      struct scan_control *sc, unsigned long *lru_pages)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(pgdat, memcg);\n\tunsigned long nr[NR_LRU_LISTS];\n\tunsigned long targets[NR_LRU_LISTS];\n\tunsigned long nr_to_scan;\n\tenum lru_list lru;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_to_reclaim = sc->nr_to_reclaim;\n\tstruct blk_plug plug;\n\tbool scan_adjusted;\n\n\tget_scan_count(lruvec, memcg, sc, nr, lru_pages);\n\n\t/* Record the original scan target for proportional adjustments later */\n\tmemcpy(targets, nr, sizeof(nr));\n\n\t/*\n\t * Global reclaiming within direct reclaim at DEF_PRIORITY is a normal\n\t * event that can occur when there is little memory pressure e.g.\n\t * multiple streaming readers/writers. Hence, we do not abort scanning\n\t * when the requested number of pages are reclaimed when scanning at\n\t * DEF_PRIORITY on the assumption that the fact we are direct\n\t * reclaiming implies that kswapd is not keeping up and it is best to\n\t * do a batch of work at once. For memcg reclaim one check is made to\n\t * abort proportional reclaim if either the file or anon lru has already\n\t * dropped to zero at the first pass.\n\t */\n\tscan_adjusted = (global_reclaim(sc) && !current_is_kswapd() &&\n\t\t\t sc->priority == DEF_PRIORITY);\n\n\tblk_start_plug(&plug);\n\twhile (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||\n\t\t\t\t\tnr[LRU_INACTIVE_FILE]) {\n\t\tunsigned long nr_anon, nr_file, percentage;\n\t\tunsigned long nr_scanned;\n\n\t\tfor_each_evictable_lru(lru) {\n\t\t\tif (nr[lru]) {\n\t\t\t\tnr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);\n\t\t\t\tnr[lru] -= nr_to_scan;\n\n\t\t\t\tnr_reclaimed += shrink_list(lru, nr_to_scan,\n\t\t\t\t\t\t\t    lruvec, memcg, sc);\n\t\t\t}\n\t\t}\n\n\t\tcond_resched();\n\n\t\tif (nr_reclaimed < nr_to_reclaim || scan_adjusted)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For kswapd and memcg, reclaim at least the number of pages\n\t\t * requested. Ensure that the anon and file LRUs are scanned\n\t\t * proportionally what was requested by get_scan_count(). We\n\t\t * stop reclaiming one LRU and reduce the amount scanning\n\t\t * proportional to the original scan target.\n\t\t */\n\t\tnr_file = nr[LRU_INACTIVE_FILE] + nr[LRU_ACTIVE_FILE];\n\t\tnr_anon = nr[LRU_INACTIVE_ANON] + nr[LRU_ACTIVE_ANON];\n\n\t\t/*\n\t\t * It's just vindictive to attack the larger once the smaller\n\t\t * has gone to zero.  And given the way we stop scanning the\n\t\t * smaller below, this makes sure that we only make one nudge\n\t\t * towards proportionality once we've got nr_to_reclaim.\n\t\t */\n\t\tif (!nr_file || !nr_anon)\n\t\t\tbreak;\n\n\t\tif (nr_file > nr_anon) {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_ANON] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_ANON] + 1;\n\t\t\tlru = LRU_BASE;\n\t\t\tpercentage = nr_anon * 100 / scan_target;\n\t\t} else {\n\t\t\tunsigned long scan_target = targets[LRU_INACTIVE_FILE] +\n\t\t\t\t\t\ttargets[LRU_ACTIVE_FILE] + 1;\n\t\t\tlru = LRU_FILE;\n\t\t\tpercentage = nr_file * 100 / scan_target;\n\t\t}\n\n\t\t/* Stop scanning the smaller of the LRU */\n\t\tnr[lru] = 0;\n\t\tnr[lru + LRU_ACTIVE] = 0;\n\n\t\t/*\n\t\t * Recalculate the other LRU scan count based on its original\n\t\t * scan target and the percentage scanning already complete\n\t\t */\n\t\tlru = (lru == LRU_FILE) ? LRU_BASE : LRU_FILE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tlru += LRU_ACTIVE;\n\t\tnr_scanned = targets[lru] - nr[lru];\n\t\tnr[lru] = targets[lru] * (100 - percentage) / 100;\n\t\tnr[lru] -= min(nr[lru], nr_scanned);\n\n\t\tscan_adjusted = true;\n\t}\n\tblk_finish_plug(&plug);\n\tsc->nr_reclaimed += nr_reclaimed;\n\n\t/*\n\t * Even if we did not try to evict anon pages at all, we want to\n\t * rebalance the anon lru active/inactive ratio.\n\t */\n\tif (inactive_list_is_low(lruvec, false, memcg, sc, true))\n\t\tshrink_active_list(SWAP_CLUSTER_MAX, lruvec,\n\t\t\t\t   sc, LRU_ACTIVE_ANON);\n}"
  },
  {
    "function_name": "get_scan_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2294-2492",
    "snippet": "static void get_scan_count(struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t   struct scan_control *sc, unsigned long *nr,\n\t\t\t   unsigned long *lru_pages)\n{\n\tint swappiness = mem_cgroup_swappiness(memcg);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tu64 fraction[2];\n\tu64 denominator = 0;\t/* gcc */\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tunsigned long anon_prio, file_prio;\n\tenum scan_balance scan_balance;\n\tunsigned long anon, file;\n\tunsigned long ap, fp;\n\tenum lru_list lru;\n\n\t/* If we have no swap space, do not bother scanning anon pages. */\n\tif (!sc->may_swap || mem_cgroup_get_nr_swap_pages(memcg) <= 0) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Global reclaim will swap to prevent OOM even with no\n\t * swappiness, but memcg users want to use this knob to\n\t * disable swapping for individual groups completely when\n\t * using the memory controller's swap limit feature would be\n\t * too expensive.\n\t */\n\tif (!global_reclaim(sc) && !swappiness) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not apply any pressure balancing cleverness when the\n\t * system is close to OOM, scan both anon and file equally\n\t * (unless the swappiness setting disagrees with swapping).\n\t */\n\tif (!sc->priority && swappiness) {\n\t\tscan_balance = SCAN_EQUAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prevent the reclaimer from falling into the cache trap: as\n\t * cache pages start out inactive, every cache fault will tip\n\t * the scan balance towards the file LRU.  And as the file LRU\n\t * shrinks, so does the window for rotation from references.\n\t * This means we have a runaway feedback loop where a tiny\n\t * thrashing file LRU becomes infinitely more attractive than\n\t * anon pages.  Try to detect this based on file LRU size.\n\t */\n\tif (global_reclaim(sc)) {\n\t\tunsigned long pgdatfile;\n\t\tunsigned long pgdatfree;\n\t\tint z;\n\t\tunsigned long total_high_wmark = 0;\n\n\t\tpgdatfree = sum_zone_node_page_state(pgdat->node_id, NR_FREE_PAGES);\n\t\tpgdatfile = node_page_state(pgdat, NR_ACTIVE_FILE) +\n\t\t\t   node_page_state(pgdat, NR_INACTIVE_FILE);\n\n\t\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\t\tif (!managed_zone(zone))\n\t\t\t\tcontinue;\n\n\t\t\ttotal_high_wmark += high_wmark_pages(zone);\n\t\t}\n\n\t\tif (unlikely(pgdatfile + pgdatfree <= total_high_wmark)) {\n\t\t\t/*\n\t\t\t * Force SCAN_ANON if there are enough inactive\n\t\t\t * anonymous pages on the LRU in eligible zones.\n\t\t\t * Otherwise, the small LRU gets thrashed.\n\t\t\t */\n\t\t\tif (!inactive_list_is_low(lruvec, false, memcg, sc, false) &&\n\t\t\t    lruvec_lru_size(lruvec, LRU_INACTIVE_ANON, sc->reclaim_idx)\n\t\t\t\t\t>> sc->priority) {\n\t\t\t\tscan_balance = SCAN_ANON;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If there is enough inactive page cache, i.e. if the size of the\n\t * inactive list is greater than that of the active list *and* the\n\t * inactive list actually has some pages to scan on this priority, we\n\t * do not reclaim anything from the anonymous working set right now.\n\t * Without the second condition we could end up never scanning an\n\t * lruvec even if it has plenty of old anonymous pages unless the\n\t * system is under heavy pressure.\n\t */\n\tif (!inactive_list_is_low(lruvec, true, memcg, sc, false) &&\n\t    lruvec_lru_size(lruvec, LRU_INACTIVE_FILE, sc->reclaim_idx) >> sc->priority) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\tscan_balance = SCAN_FRACT;\n\n\t/*\n\t * With swappiness at 100, anonymous and file have the same priority.\n\t * This scanning priority is essentially the inverse of IO cost.\n\t */\n\tanon_prio = swappiness;\n\tfile_prio = 200 - anon_prio;\n\n\t/*\n\t * OK, so we have swap space and a fair amount of page cache\n\t * pages.  We use the recently rotated / recently scanned\n\t * ratios to determine how valuable each cache is.\n\t *\n\t * Because workloads change over time (and to avoid overflow)\n\t * we keep these statistics as a floating average, which ends\n\t * up weighing recent references more than old ones.\n\t *\n\t * anon in [0], file in [1]\n\t */\n\n\tanon  = lruvec_lru_size(lruvec, LRU_ACTIVE_ANON, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_ANON, MAX_NR_ZONES);\n\tfile  = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_FILE, MAX_NR_ZONES);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\tif (unlikely(reclaim_stat->recent_scanned[0] > anon / 4)) {\n\t\treclaim_stat->recent_scanned[0] /= 2;\n\t\treclaim_stat->recent_rotated[0] /= 2;\n\t}\n\n\tif (unlikely(reclaim_stat->recent_scanned[1] > file / 4)) {\n\t\treclaim_stat->recent_scanned[1] /= 2;\n\t\treclaim_stat->recent_rotated[1] /= 2;\n\t}\n\n\t/*\n\t * The amount of pressure on anon vs file pages is inversely\n\t * proportional to the fraction of recently scanned pages on\n\t * each list that were recently referenced and in active use.\n\t */\n\tap = anon_prio * (reclaim_stat->recent_scanned[0] + 1);\n\tap /= reclaim_stat->recent_rotated[0] + 1;\n\n\tfp = file_prio * (reclaim_stat->recent_scanned[1] + 1);\n\tfp /= reclaim_stat->recent_rotated[1] + 1;\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tfraction[0] = ap;\n\tfraction[1] = fp;\n\tdenominator = ap + fp + 1;\nout:\n\t*lru_pages = 0;\n\tfor_each_evictable_lru(lru) {\n\t\tint file = is_file_lru(lru);\n\t\tunsigned long size;\n\t\tunsigned long scan;\n\n\t\tsize = lruvec_lru_size(lruvec, lru, sc->reclaim_idx);\n\t\tscan = size >> sc->priority;\n\t\t/*\n\t\t * If the cgroup's already been deleted, make sure to\n\t\t * scrape out the remaining cache.\n\t\t */\n\t\tif (!scan && !mem_cgroup_online(memcg))\n\t\t\tscan = min(size, SWAP_CLUSTER_MAX);\n\n\t\tswitch (scan_balance) {\n\t\tcase SCAN_EQUAL:\n\t\t\t/* Scan lists relative to size */\n\t\t\tbreak;\n\t\tcase SCAN_FRACT:\n\t\t\t/*\n\t\t\t * Scan types proportional to swappiness and\n\t\t\t * their relative recent reclaim efficiency.\n\t\t\t * Make sure we don't miss the last page\n\t\t\t * because of a round-off error.\n\t\t\t */\n\t\t\tscan = DIV64_U64_ROUND_UP(scan * fraction[file],\n\t\t\t\t\t\t  denominator);\n\t\t\tbreak;\n\t\tcase SCAN_FILE:\n\t\tcase SCAN_ANON:\n\t\t\t/* Scan one type exclusively */\n\t\t\tif ((scan_balance == SCAN_FILE) != file) {\n\t\t\t\tsize = 0;\n\t\t\t\tscan = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Look ma, no brain */\n\t\t\tBUG();\n\t\t}\n\n\t\t*lru_pages += size;\n\t\tnr[lru] = scan;\n\t}\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV64_U64_ROUND_UP",
          "args": [
            "scan * fraction[file]",
            "denominator"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "SWAP_CLUSTER_MAX"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_online",
          "args": [
            "memcg"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_lru_size",
          "args": [
            "lruvec",
            "lru",
            "sc->reclaim_idx"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "lruvec_lru_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "339-366",
          "snippet": "unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_file_lru",
          "args": [
            "lru"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "reclaim_stat->recent_scanned[1] > file / 4"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "reclaim_stat->recent_scanned[0] > anon / 4"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inactive_list_is_low",
          "args": [
            "lruvec",
            "true",
            "memcg",
            "sc",
            "false"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "inactive_list_is_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2213-2262",
          "snippet": "static bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pgdatfile + pgdatfree <= total_high_wmark"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_INACTIVE_FILE"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sum_zone_node_page_state",
          "args": [
            "pgdat->node_id",
            "NR_FREE_PAGES"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "sum_zone_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "958-969",
          "snippet": "unsigned long sum_zone_node_page_state(int node,\n\t\t\t\t enum zone_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_page_state(zones + i, item);\n\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long sum_zone_node_page_state(int node,\n\t\t\t\t enum zone_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_page_state(zones + i, item);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_reclaim",
          "args": [
            "sc"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "global_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "292-295",
          "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_get_nr_swap_pages",
          "args": [
            "memcg"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_get_nr_swap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6519-6530",
          "snippet": "long mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg)\n{\n\tlong nr_swap_pages = get_nr_swap_pages();\n\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn nr_swap_pages;\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tnr_swap_pages = min_t(long, nr_swap_pages,\n\t\t\t\t      READ_ONCE(memcg->swap.max) -\n\t\t\t\t      page_counter_read(&memcg->swap));\n\treturn nr_swap_pages;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nlong mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg)\n{\n\tlong nr_swap_pages = get_nr_swap_pages();\n\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn nr_swap_pages;\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tnr_swap_pages = min_t(long, nr_swap_pages,\n\t\t\t\t      READ_ONCE(memcg->swap.max) -\n\t\t\t\t      page_counter_read(&memcg->swap));\n\treturn nr_swap_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_swappiness",
          "args": [
            "memcg"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void get_scan_count(struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t   struct scan_control *sc, unsigned long *nr,\n\t\t\t   unsigned long *lru_pages)\n{\n\tint swappiness = mem_cgroup_swappiness(memcg);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tu64 fraction[2];\n\tu64 denominator = 0;\t/* gcc */\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tunsigned long anon_prio, file_prio;\n\tenum scan_balance scan_balance;\n\tunsigned long anon, file;\n\tunsigned long ap, fp;\n\tenum lru_list lru;\n\n\t/* If we have no swap space, do not bother scanning anon pages. */\n\tif (!sc->may_swap || mem_cgroup_get_nr_swap_pages(memcg) <= 0) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Global reclaim will swap to prevent OOM even with no\n\t * swappiness, but memcg users want to use this knob to\n\t * disable swapping for individual groups completely when\n\t * using the memory controller's swap limit feature would be\n\t * too expensive.\n\t */\n\tif (!global_reclaim(sc) && !swappiness) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not apply any pressure balancing cleverness when the\n\t * system is close to OOM, scan both anon and file equally\n\t * (unless the swappiness setting disagrees with swapping).\n\t */\n\tif (!sc->priority && swappiness) {\n\t\tscan_balance = SCAN_EQUAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Prevent the reclaimer from falling into the cache trap: as\n\t * cache pages start out inactive, every cache fault will tip\n\t * the scan balance towards the file LRU.  And as the file LRU\n\t * shrinks, so does the window for rotation from references.\n\t * This means we have a runaway feedback loop where a tiny\n\t * thrashing file LRU becomes infinitely more attractive than\n\t * anon pages.  Try to detect this based on file LRU size.\n\t */\n\tif (global_reclaim(sc)) {\n\t\tunsigned long pgdatfile;\n\t\tunsigned long pgdatfree;\n\t\tint z;\n\t\tunsigned long total_high_wmark = 0;\n\n\t\tpgdatfree = sum_zone_node_page_state(pgdat->node_id, NR_FREE_PAGES);\n\t\tpgdatfile = node_page_state(pgdat, NR_ACTIVE_FILE) +\n\t\t\t   node_page_state(pgdat, NR_INACTIVE_FILE);\n\n\t\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\t\tstruct zone *zone = &pgdat->node_zones[z];\n\t\t\tif (!managed_zone(zone))\n\t\t\t\tcontinue;\n\n\t\t\ttotal_high_wmark += high_wmark_pages(zone);\n\t\t}\n\n\t\tif (unlikely(pgdatfile + pgdatfree <= total_high_wmark)) {\n\t\t\t/*\n\t\t\t * Force SCAN_ANON if there are enough inactive\n\t\t\t * anonymous pages on the LRU in eligible zones.\n\t\t\t * Otherwise, the small LRU gets thrashed.\n\t\t\t */\n\t\t\tif (!inactive_list_is_low(lruvec, false, memcg, sc, false) &&\n\t\t\t    lruvec_lru_size(lruvec, LRU_INACTIVE_ANON, sc->reclaim_idx)\n\t\t\t\t\t>> sc->priority) {\n\t\t\t\tscan_balance = SCAN_ANON;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If there is enough inactive page cache, i.e. if the size of the\n\t * inactive list is greater than that of the active list *and* the\n\t * inactive list actually has some pages to scan on this priority, we\n\t * do not reclaim anything from the anonymous working set right now.\n\t * Without the second condition we could end up never scanning an\n\t * lruvec even if it has plenty of old anonymous pages unless the\n\t * system is under heavy pressure.\n\t */\n\tif (!inactive_list_is_low(lruvec, true, memcg, sc, false) &&\n\t    lruvec_lru_size(lruvec, LRU_INACTIVE_FILE, sc->reclaim_idx) >> sc->priority) {\n\t\tscan_balance = SCAN_FILE;\n\t\tgoto out;\n\t}\n\n\tscan_balance = SCAN_FRACT;\n\n\t/*\n\t * With swappiness at 100, anonymous and file have the same priority.\n\t * This scanning priority is essentially the inverse of IO cost.\n\t */\n\tanon_prio = swappiness;\n\tfile_prio = 200 - anon_prio;\n\n\t/*\n\t * OK, so we have swap space and a fair amount of page cache\n\t * pages.  We use the recently rotated / recently scanned\n\t * ratios to determine how valuable each cache is.\n\t *\n\t * Because workloads change over time (and to avoid overflow)\n\t * we keep these statistics as a floating average, which ends\n\t * up weighing recent references more than old ones.\n\t *\n\t * anon in [0], file in [1]\n\t */\n\n\tanon  = lruvec_lru_size(lruvec, LRU_ACTIVE_ANON, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_ANON, MAX_NR_ZONES);\n\tfile  = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES) +\n\t\tlruvec_lru_size(lruvec, LRU_INACTIVE_FILE, MAX_NR_ZONES);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\tif (unlikely(reclaim_stat->recent_scanned[0] > anon / 4)) {\n\t\treclaim_stat->recent_scanned[0] /= 2;\n\t\treclaim_stat->recent_rotated[0] /= 2;\n\t}\n\n\tif (unlikely(reclaim_stat->recent_scanned[1] > file / 4)) {\n\t\treclaim_stat->recent_scanned[1] /= 2;\n\t\treclaim_stat->recent_rotated[1] /= 2;\n\t}\n\n\t/*\n\t * The amount of pressure on anon vs file pages is inversely\n\t * proportional to the fraction of recently scanned pages on\n\t * each list that were recently referenced and in active use.\n\t */\n\tap = anon_prio * (reclaim_stat->recent_scanned[0] + 1);\n\tap /= reclaim_stat->recent_rotated[0] + 1;\n\n\tfp = file_prio * (reclaim_stat->recent_scanned[1] + 1);\n\tfp /= reclaim_stat->recent_rotated[1] + 1;\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tfraction[0] = ap;\n\tfraction[1] = fp;\n\tdenominator = ap + fp + 1;\nout:\n\t*lru_pages = 0;\n\tfor_each_evictable_lru(lru) {\n\t\tint file = is_file_lru(lru);\n\t\tunsigned long size;\n\t\tunsigned long scan;\n\n\t\tsize = lruvec_lru_size(lruvec, lru, sc->reclaim_idx);\n\t\tscan = size >> sc->priority;\n\t\t/*\n\t\t * If the cgroup's already been deleted, make sure to\n\t\t * scrape out the remaining cache.\n\t\t */\n\t\tif (!scan && !mem_cgroup_online(memcg))\n\t\t\tscan = min(size, SWAP_CLUSTER_MAX);\n\n\t\tswitch (scan_balance) {\n\t\tcase SCAN_EQUAL:\n\t\t\t/* Scan lists relative to size */\n\t\t\tbreak;\n\t\tcase SCAN_FRACT:\n\t\t\t/*\n\t\t\t * Scan types proportional to swappiness and\n\t\t\t * their relative recent reclaim efficiency.\n\t\t\t * Make sure we don't miss the last page\n\t\t\t * because of a round-off error.\n\t\t\t */\n\t\t\tscan = DIV64_U64_ROUND_UP(scan * fraction[file],\n\t\t\t\t\t\t  denominator);\n\t\t\tbreak;\n\t\tcase SCAN_FILE:\n\t\tcase SCAN_ANON:\n\t\t\t/* Scan one type exclusively */\n\t\t\tif ((scan_balance == SCAN_FILE) != file) {\n\t\t\t\tsize = 0;\n\t\t\t\tscan = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Look ma, no brain */\n\t\t\tBUG();\n\t\t}\n\n\t\t*lru_pages += size;\n\t\tnr[lru] = scan;\n\t}\n}"
  },
  {
    "function_name": "shrink_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2264-2276",
    "snippet": "static unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,\n\t\t\t\t struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc)\n{\n\tif (is_active_lru(lru)) {\n\t\tif (inactive_list_is_low(lruvec, is_file_lru(lru),\n\t\t\t\t\t memcg, sc, true))\n\t\t\tshrink_active_list(nr_to_scan, lruvec, sc, lru);\n\t\treturn 0;\n\t}\n\n\treturn shrink_inactive_list(nr_to_scan, lruvec, sc, lru);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_inactive_list",
          "args": [
            "nr_to_scan",
            "lruvec",
            "sc",
            "lru"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_inactive_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1906-2015",
          "snippet": "static noinline_for_stack unsigned long\nshrink_inactive_list(unsigned long nr_to_scan, struct lruvec *lruvec,\n\t\t     struct scan_control *sc, enum lru_list lru)\n{\n\tLIST_HEAD(page_list);\n\tunsigned long nr_scanned;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_taken;\n\tstruct reclaim_stat stat = {};\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tbool stalled = false;\n\n\twhile (unlikely(too_many_isolated(pgdat, file, sc))) {\n\t\tif (stalled)\n\t\t\treturn 0;\n\n\t\t/* wait a bit for the reclaimer. */\n\t\tmsleep(100);\n\t\tstalled = true;\n\n\t\t/* We are about to die and free our memory. Return now. */\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn SWAP_CLUSTER_MAX;\n\t}\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &page_list,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_KSWAPD, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_KSWAPD,\n\t\t\t\t   nr_scanned);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_DIRECT, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_DIRECT,\n\t\t\t\t   nr_scanned);\n\t}\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tif (nr_taken == 0)\n\t\treturn 0;\n\n\tnr_reclaimed = shrink_page_list(&page_list, pgdat, sc, 0,\n\t\t\t\t&stat, false);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_KSWAPD, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_KSWAPD,\n\t\t\t\t   nr_reclaimed);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_DIRECT, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_DIRECT,\n\t\t\t\t   nr_reclaimed);\n\t}\n\n\tputback_inactive_pages(lruvec, &page_list);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&page_list);\n\tfree_unref_page_list(&page_list);\n\n\t/*\n\t * If dirty pages are scanned that are not queued for IO, it\n\t * implies that flushers are not doing their job. This can\n\t * happen when memory pressure pushes dirty pages to the end of\n\t * the LRU before the dirty limits are breached and the dirty\n\t * data has expired. It can also happen when the proportion of\n\t * dirty pages grows not through writes but through memory\n\t * pressure reclaiming all the clean cache. And in some cases,\n\t * the flushers simply cannot keep up with the allocation\n\t * rate. Nudge the flusher threads in case they are asleep.\n\t */\n\tif (stat.nr_unqueued_dirty == nr_taken)\n\t\twakeup_flusher_threads(WB_REASON_VMSCAN);\n\n\tsc->nr.dirty += stat.nr_dirty;\n\tsc->nr.congested += stat.nr_congested;\n\tsc->nr.unqueued_dirty += stat.nr_unqueued_dirty;\n\tsc->nr.writeback += stat.nr_writeback;\n\tsc->nr.immediate += stat.nr_immediate;\n\tsc->nr.taken += nr_taken;\n\tif (file)\n\t\tsc->nr.file_taken += nr_taken;\n\n\ttrace_mm_vmscan_lru_shrink_inactive(pgdat->node_id,\n\t\t\tnr_scanned, nr_reclaimed, &stat, sc->priority, file);\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic noinline_for_stack unsigned long\nshrink_inactive_list(unsigned long nr_to_scan, struct lruvec *lruvec,\n\t\t     struct scan_control *sc, enum lru_list lru)\n{\n\tLIST_HEAD(page_list);\n\tunsigned long nr_scanned;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_taken;\n\tstruct reclaim_stat stat = {};\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tbool stalled = false;\n\n\twhile (unlikely(too_many_isolated(pgdat, file, sc))) {\n\t\tif (stalled)\n\t\t\treturn 0;\n\n\t\t/* wait a bit for the reclaimer. */\n\t\tmsleep(100);\n\t\tstalled = true;\n\n\t\t/* We are about to die and free our memory. Return now. */\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn SWAP_CLUSTER_MAX;\n\t}\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &page_list,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_KSWAPD, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_KSWAPD,\n\t\t\t\t   nr_scanned);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_DIRECT, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_DIRECT,\n\t\t\t\t   nr_scanned);\n\t}\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tif (nr_taken == 0)\n\t\treturn 0;\n\n\tnr_reclaimed = shrink_page_list(&page_list, pgdat, sc, 0,\n\t\t\t\t&stat, false);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_KSWAPD, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_KSWAPD,\n\t\t\t\t   nr_reclaimed);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_DIRECT, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_DIRECT,\n\t\t\t\t   nr_reclaimed);\n\t}\n\n\tputback_inactive_pages(lruvec, &page_list);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&page_list);\n\tfree_unref_page_list(&page_list);\n\n\t/*\n\t * If dirty pages are scanned that are not queued for IO, it\n\t * implies that flushers are not doing their job. This can\n\t * happen when memory pressure pushes dirty pages to the end of\n\t * the LRU before the dirty limits are breached and the dirty\n\t * data has expired. It can also happen when the proportion of\n\t * dirty pages grows not through writes but through memory\n\t * pressure reclaiming all the clean cache. And in some cases,\n\t * the flushers simply cannot keep up with the allocation\n\t * rate. Nudge the flusher threads in case they are asleep.\n\t */\n\tif (stat.nr_unqueued_dirty == nr_taken)\n\t\twakeup_flusher_threads(WB_REASON_VMSCAN);\n\n\tsc->nr.dirty += stat.nr_dirty;\n\tsc->nr.congested += stat.nr_congested;\n\tsc->nr.unqueued_dirty += stat.nr_unqueued_dirty;\n\tsc->nr.writeback += stat.nr_writeback;\n\tsc->nr.immediate += stat.nr_immediate;\n\tsc->nr.taken += nr_taken;\n\tif (file)\n\t\tsc->nr.file_taken += nr_taken;\n\n\ttrace_mm_vmscan_lru_shrink_inactive(pgdat->node_id,\n\t\t\tnr_scanned, nr_reclaimed, &stat, sc->priority, file);\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_active_list",
          "args": [
            "nr_to_scan",
            "lruvec",
            "sc",
            "lru"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_active_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2084-2183",
          "snippet": "static void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inactive_list_is_low",
          "args": [
            "lruvec",
            "is_file_lru(lru)",
            "memcg",
            "sc",
            "true"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "inactive_list_is_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2213-2262",
          "snippet": "static bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_file_lru",
          "args": [
            "lru"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_active_lru",
          "args": [
            "lru"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,\n\t\t\t\t struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc)\n{\n\tif (is_active_lru(lru)) {\n\t\tif (inactive_list_is_low(lruvec, is_file_lru(lru),\n\t\t\t\t\t memcg, sc, true))\n\t\t\tshrink_active_list(nr_to_scan, lruvec, sc, lru);\n\t\treturn 0;\n\t}\n\n\treturn shrink_inactive_list(nr_to_scan, lruvec, sc, lru);\n}"
  },
  {
    "function_name": "inactive_list_is_low",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2213-2262",
    "snippet": "static bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_vmscan_inactive_list_is_low",
          "args": [
            "pgdat->node_id",
            "sc->reclaim_idx",
            "lruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES)",
            "inactive",
            "lruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES)",
            "active",
            "inactive_ratio",
            "file"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_lru_size",
          "args": [
            "lruvec",
            "active_lru",
            "MAX_NR_ZONES"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "lruvec_lru_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "339-366",
          "snippet": "unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "int_sqrt",
          "args": [
            "10 * gb"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "WORKINGSET_ACTIVATE"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_page_state",
          "args": [
            "memcg",
            "WORKINGSET_ACTIVATE"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool inactive_list_is_low(struct lruvec *lruvec, bool file,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc, bool actual_reclaim)\n{\n\tenum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tenum lru_list inactive_lru = file * LRU_FILE;\n\tunsigned long inactive, active;\n\tunsigned long inactive_ratio;\n\tunsigned long refaults;\n\tunsigned long gb;\n\n\t/*\n\t * If we don't have swap space, anonymous page deactivation\n\t * is pointless.\n\t */\n\tif (!file && !total_swap_pages)\n\t\treturn false;\n\n\tinactive = lruvec_lru_size(lruvec, inactive_lru, sc->reclaim_idx);\n\tactive = lruvec_lru_size(lruvec, active_lru, sc->reclaim_idx);\n\n\tif (memcg)\n\t\trefaults = memcg_page_state(memcg, WORKINGSET_ACTIVATE);\n\telse\n\t\trefaults = node_page_state(pgdat, WORKINGSET_ACTIVATE);\n\n\t/*\n\t * When refaults are being observed, it means a new workingset\n\t * is being established. Disable active list protection to get\n\t * rid of the stale workingset quickly.\n\t */\n\tif (file && actual_reclaim && lruvec->refaults != refaults) {\n\t\tinactive_ratio = 0;\n\t} else {\n\t\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\t\tif (gb)\n\t\t\tinactive_ratio = int_sqrt(10 * gb);\n\t\telse\n\t\t\tinactive_ratio = 1;\n\t}\n\n\tif (actual_reclaim)\n\t\ttrace_mm_vmscan_inactive_list_is_low(pgdat->node_id, sc->reclaim_idx,\n\t\t\tlruvec_lru_size(lruvec, inactive_lru, MAX_NR_ZONES), inactive,\n\t\t\tlruvec_lru_size(lruvec, active_lru, MAX_NR_ZONES), active,\n\t\t\tinactive_ratio, file);\n\n\treturn inactive * inactive_ratio < active;\n}"
  },
  {
    "function_name": "shrink_active_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2084-2183",
    "snippet": "static void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_vmscan_lru_shrink_active",
          "args": [
            "pgdat->node_id",
            "nr_taken",
            "nr_activate",
            "nr_deactivate",
            "nr_rotated",
            "sc->priority",
            "file"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_unref_page_list",
          "args": [
            "&l_hold"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2803-2836",
          "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge_list",
          "args": [
            "&l_hold"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "pgdat",
            "NR_ISOLATED_ANON + file",
            "-nr_taken"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_active_pages_to_lru",
          "args": [
            "lruvec",
            "&l_inactive",
            "&l_hold",
            "lru - LRU_ACTIVE"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "move_active_pages_to_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "2037-2082",
          "snippet": "static unsigned move_active_pages_to_lru(struct lruvec *lruvec,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     struct list_head *pages_to_free,\n\t\t\t\t     enum lru_list lru)\n{\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct page *page;\n\tint nr_pages;\n\tint nr_moved = 0;\n\n\twhile (!list_empty(list)) {\n\t\tpage = lru_to_page(list);\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\n\t\tnr_pages = hpage_nr_pages(page);\n\t\tupdate_lru_size(lruvec, lru, page_zonenum(page), nr_pages);\n\t\tlist_move(&page->lru, &lruvec->lists[lru]);\n\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, pages_to_free);\n\t\t} else {\n\t\t\tnr_moved += nr_pages;\n\t\t}\n\t}\n\n\tif (!is_active_lru(lru)) {\n\t\t__count_vm_events(PGDEACTIVATE, nr_moved);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGDEACTIVATE,\n\t\t\t\t   nr_moved);\n\t}\n\n\treturn nr_moved;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned move_active_pages_to_lru(struct lruvec *lruvec,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     struct list_head *pages_to_free,\n\t\t\t\t     enum lru_list lru)\n{\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct page *page;\n\tint nr_pages;\n\tint nr_moved = 0;\n\n\twhile (!list_empty(list)) {\n\t\tpage = lru_to_page(list);\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\n\t\tnr_pages = hpage_nr_pages(page);\n\t\tupdate_lru_size(lruvec, lru, page_zonenum(page), nr_pages);\n\t\tlist_move(&page->lru, &lruvec->lists[lru]);\n\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, pages_to_free);\n\t\t} else {\n\t\t\tnr_moved += nr_pages;\n\t\t}\n\t}\n\n\tif (!is_active_lru(lru)) {\n\t\t__count_vm_events(PGDEACTIVATE, nr_moved);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGDEACTIVATE,\n\t\t\t\t   nr_moved);\n\t}\n\n\treturn nr_moved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&l_inactive"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageWorkingset",
          "args": [
            "page"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&l_active"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_referenced",
          "args": [
            "page",
            "0",
            "sc->target_mem_cgroup",
            "&vm_flags"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "page_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "836-881",
          "snippet": "int page_referenced(struct page *page,\n\t\t    int is_locked,\n\t\t    struct mem_cgroup *memcg,\n\t\t    unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct page_referenced_arg pra = {\n\t\t.mapcount = total_mapcount(page),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t*vm_flags = 0;\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tif (!page_rmapping(page))\n\t\treturn 0;\n\n\tif (!is_locked && (!PageAnon(page) || PageKsm(page))) {\n\t\twe_locked = trylock_page(page);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_page_referenced_vma;\n\t}\n\n\trmap_walk(page, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tunlock_page(page);\n\n\treturn pra.referenced;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_referenced(struct page *page,\n\t\t    int is_locked,\n\t\t    struct mem_cgroup *memcg,\n\t\t    unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct page_referenced_arg pra = {\n\t\t.mapcount = total_mapcount(page),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t*vm_flags = 0;\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tif (!page_rmapping(page))\n\t\treturn 0;\n\n\tif (!is_locked && (!PageAnon(page) || PageKsm(page))) {\n\t\twe_locked = trylock_page(page);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_page_referenced_vma;\n\t}\n\n\trmap_walk(page, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tunlock_page(page);\n\n\treturn pra.referenced;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "0"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3319-3330",
          "snippet": "int try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_heads_over_limit"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_evictable(page)"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_evictable",
          "args": [
            "page"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "page_evictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4174-4183",
          "snippet": "int page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "&l_hold"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&l_hold"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_memcg_events",
          "args": [
            "lruvec_memcg(lruvec)",
            "PGREFILL",
            "nr_scanned"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_memcg",
          "args": [
            "lruvec"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGREFILL",
            "nr_scanned"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_lru_pages",
          "args": [
            "nr_to_scan",
            "lruvec",
            "&l_hold",
            "&nr_scanned",
            "sc",
            "isolate_mode",
            "lru"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1665-1744",
          "snippet": "static unsigned long isolate_lru_pages(unsigned long nr_to_scan,\n\t\tstruct lruvec *lruvec, struct list_head *dst,\n\t\tunsigned long *nr_scanned, struct scan_control *sc,\n\t\tisolate_mode_t mode, enum lru_list lru)\n{\n\tstruct list_head *src = &lruvec->lists[lru];\n\tunsigned long nr_taken = 0;\n\tunsigned long nr_zone_taken[MAX_NR_ZONES] = { 0 };\n\tunsigned long nr_skipped[MAX_NR_ZONES] = { 0, };\n\tunsigned long skipped = 0;\n\tunsigned long scan, total_scan, nr_pages;\n\tLIST_HEAD(pages_skipped);\n\n\tscan = 0;\n\tfor (total_scan = 0;\n\t     scan < nr_to_scan && nr_taken < nr_to_scan && !list_empty(src);\n\t     total_scan++) {\n\t\tstruct page *page;\n\n\t\tpage = lru_to_page(src);\n\t\tprefetchw_prev_lru_page(page, src, flags);\n\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\n\t\tif (page_zonenum(page) > sc->reclaim_idx) {\n\t\t\tlist_move(&page->lru, &pages_skipped);\n\t\t\tnr_skipped[page_zonenum(page)]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Do not count skipped pages because that makes the function\n\t\t * return with no isolated pages if the LRU mostly contains\n\t\t * ineligible pages.  This causes the VM to not reclaim any\n\t\t * pages, triggering a premature OOM.\n\t\t */\n\t\tscan++;\n\t\tswitch (__isolate_lru_page(page, mode)) {\n\t\tcase 0:\n\t\t\tnr_pages = hpage_nr_pages(page);\n\t\t\tnr_taken += nr_pages;\n\t\t\tnr_zone_taken[page_zonenum(page)] += nr_pages;\n\t\t\tlist_move(&page->lru, dst);\n\t\t\tbreak;\n\n\t\tcase -EBUSY:\n\t\t\t/* else it is being freed elsewhere */\n\t\t\tlist_move(&page->lru, src);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/*\n\t * Splice any skipped pages to the start of the LRU list. Note that\n\t * this disrupts the LRU order when reclaiming for lower zones but\n\t * we cannot splice to the tail. If we did then the SWAP_CLUSTER_MAX\n\t * scanning would soon rescan the same pages to skip and put the\n\t * system at risk of premature OOM.\n\t */\n\tif (!list_empty(&pages_skipped)) {\n\t\tint zid;\n\n\t\tlist_splice(&pages_skipped, src);\n\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\tif (!nr_skipped[zid])\n\t\t\t\tcontinue;\n\n\t\t\t__count_zid_vm_events(PGSCAN_SKIP, zid, nr_skipped[zid]);\n\t\t\tskipped += nr_skipped[zid];\n\t\t}\n\t}\n\t*nr_scanned = total_scan;\n\ttrace_mm_vmscan_lru_isolate(sc->reclaim_idx, sc->order, nr_to_scan,\n\t\t\t\t    total_scan, skipped, nr_taken, mode, lru);\n\tupdate_lru_sizes(lruvec, lru, nr_zone_taken);\n\treturn nr_taken;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long isolate_lru_pages(unsigned long nr_to_scan,\n\t\tstruct lruvec *lruvec, struct list_head *dst,\n\t\tunsigned long *nr_scanned, struct scan_control *sc,\n\t\tisolate_mode_t mode, enum lru_list lru)\n{\n\tstruct list_head *src = &lruvec->lists[lru];\n\tunsigned long nr_taken = 0;\n\tunsigned long nr_zone_taken[MAX_NR_ZONES] = { 0 };\n\tunsigned long nr_skipped[MAX_NR_ZONES] = { 0, };\n\tunsigned long skipped = 0;\n\tunsigned long scan, total_scan, nr_pages;\n\tLIST_HEAD(pages_skipped);\n\n\tscan = 0;\n\tfor (total_scan = 0;\n\t     scan < nr_to_scan && nr_taken < nr_to_scan && !list_empty(src);\n\t     total_scan++) {\n\t\tstruct page *page;\n\n\t\tpage = lru_to_page(src);\n\t\tprefetchw_prev_lru_page(page, src, flags);\n\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\n\t\tif (page_zonenum(page) > sc->reclaim_idx) {\n\t\t\tlist_move(&page->lru, &pages_skipped);\n\t\t\tnr_skipped[page_zonenum(page)]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Do not count skipped pages because that makes the function\n\t\t * return with no isolated pages if the LRU mostly contains\n\t\t * ineligible pages.  This causes the VM to not reclaim any\n\t\t * pages, triggering a premature OOM.\n\t\t */\n\t\tscan++;\n\t\tswitch (__isolate_lru_page(page, mode)) {\n\t\tcase 0:\n\t\t\tnr_pages = hpage_nr_pages(page);\n\t\t\tnr_taken += nr_pages;\n\t\t\tnr_zone_taken[page_zonenum(page)] += nr_pages;\n\t\t\tlist_move(&page->lru, dst);\n\t\t\tbreak;\n\n\t\tcase -EBUSY:\n\t\t\t/* else it is being freed elsewhere */\n\t\t\tlist_move(&page->lru, src);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/*\n\t * Splice any skipped pages to the start of the LRU list. Note that\n\t * this disrupts the LRU order when reclaiming for lower zones but\n\t * we cannot splice to the tail. If we did then the SWAP_CLUSTER_MAX\n\t * scanning would soon rescan the same pages to skip and put the\n\t * system at risk of premature OOM.\n\t */\n\tif (!list_empty(&pages_skipped)) {\n\t\tint zid;\n\n\t\tlist_splice(&pages_skipped, src);\n\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\tif (!nr_skipped[zid])\n\t\t\t\tcontinue;\n\n\t\t\t__count_zid_vm_events(PGSCAN_SKIP, zid, nr_skipped[zid]);\n\t\t\tskipped += nr_skipped[zid];\n\t\t}\n\t}\n\t*nr_scanned = total_scan;\n\ttrace_mm_vmscan_lru_isolate(sc->reclaim_idx, sc->order, nr_to_scan,\n\t\t\t\t    total_scan, skipped, nr_taken, mode, lru);\n\tupdate_lru_sizes(lruvec, lru, nr_zone_taken);\n\treturn nr_taken;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_lru",
          "args": [
            "lru"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "l_inactive"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "l_active"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "l_hold"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void shrink_active_list(unsigned long nr_to_scan,\n\t\t\t       struct lruvec *lruvec,\n\t\t\t       struct scan_control *sc,\n\t\t\t       enum lru_list lru)\n{\n\tunsigned long nr_taken;\n\tunsigned long nr_scanned;\n\tunsigned long vm_flags;\n\tLIST_HEAD(l_hold);\t/* The pages which were snipped off */\n\tLIST_HEAD(l_active);\n\tLIST_HEAD(l_inactive);\n\tstruct page *page;\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tunsigned nr_deactivate, nr_activate;\n\tunsigned nr_rotated = 0;\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\t__count_vm_events(PGREFILL, nr_scanned);\n\tcount_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\twhile (!list_empty(&l_hold)) {\n\t\tcond_resched();\n\t\tpage = lru_to_page(&l_hold);\n\t\tlist_del(&page->lru);\n\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tputback_lru_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(buffer_heads_over_limit)) {\n\t\t\tif (page_has_private(page) && trylock_page(page)) {\n\t\t\t\tif (page_has_private(page))\n\t\t\t\t\ttry_to_release_page(page, 0);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t}\n\n\t\tif (page_referenced(page, 0, sc->target_mem_cgroup,\n\t\t\t\t    &vm_flags)) {\n\t\t\tnr_rotated += hpage_nr_pages(page);\n\t\t\t/*\n\t\t\t * Identify referenced, file-backed active pages and\n\t\t\t * give them one more trip around the active list. So\n\t\t\t * that executable code get better chances to stay in\n\t\t\t * memory under moderate memory pressure.  Anon pages\n\t\t\t * are not likely to be evicted by use-once streaming\n\t\t\t * IO, plus JVM can create lots of anon VM_EXEC pages,\n\t\t\t * so we ignore them here.\n\t\t\t */\n\t\t\tif ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {\n\t\t\t\tlist_add(&page->lru, &l_active);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tClearPageActive(page);\t/* we are de-activating */\n\t\tSetPageWorkingset(page);\n\t\tlist_add(&page->lru, &l_inactive);\n\t}\n\n\t/*\n\t * Move pages back to the lru list.\n\t */\n\tspin_lock_irq(&pgdat->lru_lock);\n\t/*\n\t * Count referenced pages from currently used mappings as rotated,\n\t * even though only some of them are actually re-activated.  This\n\t * helps balance scan pressure between file and anonymous pages in\n\t * get_scan_count.\n\t */\n\treclaim_stat->recent_rotated[file] += nr_rotated;\n\n\tnr_activate = move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);\n\tnr_deactivate = move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&l_hold);\n\tfree_unref_page_list(&l_hold);\n\ttrace_mm_vmscan_lru_shrink_active(pgdat->node_id, nr_taken, nr_activate,\n\t\t\tnr_deactivate, nr_rotated, sc->priority, file);\n}"
  },
  {
    "function_name": "move_active_pages_to_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "2037-2082",
    "snippet": "static unsigned move_active_pages_to_lru(struct lruvec *lruvec,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     struct list_head *pages_to_free,\n\t\t\t\t     enum lru_list lru)\n{\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct page *page;\n\tint nr_pages;\n\tint nr_moved = 0;\n\n\twhile (!list_empty(list)) {\n\t\tpage = lru_to_page(list);\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\n\t\tnr_pages = hpage_nr_pages(page);\n\t\tupdate_lru_size(lruvec, lru, page_zonenum(page), nr_pages);\n\t\tlist_move(&page->lru, &lruvec->lists[lru]);\n\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, pages_to_free);\n\t\t} else {\n\t\t\tnr_moved += nr_pages;\n\t\t}\n\t}\n\n\tif (!is_active_lru(lru)) {\n\t\t__count_vm_events(PGDEACTIVATE, nr_moved);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGDEACTIVATE,\n\t\t\t\t   nr_moved);\n\t}\n\n\treturn nr_moved;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_memcg_events",
          "args": [
            "lruvec_memcg(lruvec)",
            "PGDEACTIVATE",
            "nr_moved"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_memcg",
          "args": [
            "lruvec"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGDEACTIVATE",
            "nr_moved"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_active_lru",
          "args": [
            "lru"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "pages_to_free"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compound_page_dtor",
          "args": [
            "page"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge",
          "args": [
            "page"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageCompound(page)"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageActive",
          "args": [
            "page"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page_testzero",
          "args": [
            "page"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&lruvec->lists[lru]"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_lru_size",
          "args": [
            "lruvec",
            "lru",
            "page_zonenum(page)",
            "nr_pages"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_update_lru_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1143-1169",
          "snippet": "void mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,\n\t\t\t\tint zid, int nr_pages)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tunsigned long *lru_size;\n\tlong size;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);\n\tlru_size = &mz->lru_zone_size[zid][lru];\n\n\tif (nr_pages < 0)\n\t\t*lru_size += nr_pages;\n\n\tsize = *lru_size;\n\tif (WARN_ONCE(size < 0,\n\t\t\"%s(%p, %d, %d): lru_size %ld\\n\",\n\t\t__func__, lruvec, lru, nr_pages, size)) {\n\t\tVM_BUG_ON(1);\n\t\t*lru_size = 0;\n\t}\n\n\tif (nr_pages > 0)\n\t\t*lru_size += nr_pages;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,\n\t\t\t\tint zid, int nr_pages)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tunsigned long *lru_size;\n\tlong size;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);\n\tlru_size = &mz->lru_zone_size[zid][lru];\n\n\tif (nr_pages < 0)\n\t\t*lru_size += nr_pages;\n\n\tsize = *lru_size;\n\tif (WARN_ONCE(size < 0,\n\t\t\"%s(%p, %d, %d): lru_size %ld\\n\",\n\t\t__func__, lruvec, lru, nr_pages, size)) {\n\t\tVM_BUG_ON(1);\n\t\t*lru_size = 0;\n\t}\n\n\tif (nr_pages > 0)\n\t\t*lru_size += nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zonenum",
          "args": [
            "page"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageLRU",
          "args": [
            "page"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "pgdat"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "list"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned move_active_pages_to_lru(struct lruvec *lruvec,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     struct list_head *pages_to_free,\n\t\t\t\t     enum lru_list lru)\n{\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct page *page;\n\tint nr_pages;\n\tint nr_moved = 0;\n\n\twhile (!list_empty(list)) {\n\t\tpage = lru_to_page(list);\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tSetPageLRU(page);\n\n\t\tnr_pages = hpage_nr_pages(page);\n\t\tupdate_lru_size(lruvec, lru, page_zonenum(page), nr_pages);\n\t\tlist_move(&page->lru, &lruvec->lists[lru]);\n\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, pages_to_free);\n\t\t} else {\n\t\t\tnr_moved += nr_pages;\n\t\t}\n\t}\n\n\tif (!is_active_lru(lru)) {\n\t\t__count_vm_events(PGDEACTIVATE, nr_moved);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGDEACTIVATE,\n\t\t\t\t   nr_moved);\n\t}\n\n\treturn nr_moved;\n}"
  },
  {
    "function_name": "shrink_inactive_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1906-2015",
    "snippet": "static noinline_for_stack unsigned long\nshrink_inactive_list(unsigned long nr_to_scan, struct lruvec *lruvec,\n\t\t     struct scan_control *sc, enum lru_list lru)\n{\n\tLIST_HEAD(page_list);\n\tunsigned long nr_scanned;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_taken;\n\tstruct reclaim_stat stat = {};\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tbool stalled = false;\n\n\twhile (unlikely(too_many_isolated(pgdat, file, sc))) {\n\t\tif (stalled)\n\t\t\treturn 0;\n\n\t\t/* wait a bit for the reclaimer. */\n\t\tmsleep(100);\n\t\tstalled = true;\n\n\t\t/* We are about to die and free our memory. Return now. */\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn SWAP_CLUSTER_MAX;\n\t}\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &page_list,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_KSWAPD, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_KSWAPD,\n\t\t\t\t   nr_scanned);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_DIRECT, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_DIRECT,\n\t\t\t\t   nr_scanned);\n\t}\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tif (nr_taken == 0)\n\t\treturn 0;\n\n\tnr_reclaimed = shrink_page_list(&page_list, pgdat, sc, 0,\n\t\t\t\t&stat, false);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_KSWAPD, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_KSWAPD,\n\t\t\t\t   nr_reclaimed);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_DIRECT, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_DIRECT,\n\t\t\t\t   nr_reclaimed);\n\t}\n\n\tputback_inactive_pages(lruvec, &page_list);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&page_list);\n\tfree_unref_page_list(&page_list);\n\n\t/*\n\t * If dirty pages are scanned that are not queued for IO, it\n\t * implies that flushers are not doing their job. This can\n\t * happen when memory pressure pushes dirty pages to the end of\n\t * the LRU before the dirty limits are breached and the dirty\n\t * data has expired. It can also happen when the proportion of\n\t * dirty pages grows not through writes but through memory\n\t * pressure reclaiming all the clean cache. And in some cases,\n\t * the flushers simply cannot keep up with the allocation\n\t * rate. Nudge the flusher threads in case they are asleep.\n\t */\n\tif (stat.nr_unqueued_dirty == nr_taken)\n\t\twakeup_flusher_threads(WB_REASON_VMSCAN);\n\n\tsc->nr.dirty += stat.nr_dirty;\n\tsc->nr.congested += stat.nr_congested;\n\tsc->nr.unqueued_dirty += stat.nr_unqueued_dirty;\n\tsc->nr.writeback += stat.nr_writeback;\n\tsc->nr.immediate += stat.nr_immediate;\n\tsc->nr.taken += nr_taken;\n\tif (file)\n\t\tsc->nr.file_taken += nr_taken;\n\n\ttrace_mm_vmscan_lru_shrink_inactive(pgdat->node_id,\n\t\t\tnr_scanned, nr_reclaimed, &stat, sc->priority, file);\n\treturn nr_reclaimed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_vmscan_lru_shrink_inactive",
          "args": [
            "pgdat->node_id",
            "nr_scanned",
            "nr_reclaimed",
            "&stat",
            "sc->priority",
            "file"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_flusher_threads",
          "args": [
            "WB_REASON_VMSCAN"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_unref_page_list",
          "args": [
            "&page_list"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2803-2836",
          "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge_list",
          "args": [
            "&page_list"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "pgdat",
            "NR_ISOLATED_ANON + file",
            "-nr_taken"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "putback_inactive_pages",
          "args": [
            "lruvec",
            "&page_list"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "putback_inactive_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1834-1887",
          "snippet": "static noinline_for_stack void\nputback_inactive_pages(struct lruvec *lruvec, struct list_head *page_list)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tLIST_HEAD(pages_to_free);\n\n\t/*\n\t * Put back any unfreeable pages.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tstruct page *page = lru_to_page(page_list);\n\t\tint lru;\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tlist_del(&page->lru);\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\tputback_lru_page(page);\n\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tSetPageLRU(page);\n\t\tlru = page_lru(page);\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\n\t\tif (is_active_lru(lru)) {\n\t\t\tint file = is_file_lru(lru);\n\t\t\tint numpages = hpage_nr_pages(page);\n\t\t\treclaim_stat->recent_rotated[file] += numpages;\n\t\t}\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, &pages_to_free);\n\t\t}\n\t}\n\n\t/*\n\t * To save our caller's stack, now use input list for pages to free.\n\t */\n\tlist_splice(&pages_to_free, page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic noinline_for_stack void\nputback_inactive_pages(struct lruvec *lruvec, struct list_head *page_list)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tLIST_HEAD(pages_to_free);\n\n\t/*\n\t * Put back any unfreeable pages.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tstruct page *page = lru_to_page(page_list);\n\t\tint lru;\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tlist_del(&page->lru);\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\tputback_lru_page(page);\n\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tSetPageLRU(page);\n\t\tlru = page_lru(page);\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\n\t\tif (is_active_lru(lru)) {\n\t\t\tint file = is_file_lru(lru);\n\t\t\tint numpages = hpage_nr_pages(page);\n\t\t\treclaim_stat->recent_rotated[file] += numpages;\n\t\t}\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, &pages_to_free);\n\t\t}\n\t}\n\n\t/*\n\t * To save our caller's stack, now use input list for pages to free.\n\t */\n\tlist_splice(&pages_to_free, page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_memcg_events",
          "args": [
            "lruvec_memcg(lruvec)",
            "PGSTEAL_DIRECT",
            "nr_reclaimed"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_memcg",
          "args": [
            "lruvec"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGSTEAL_DIRECT",
            "nr_reclaimed"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_reclaim",
          "args": [
            "sc"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "global_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "292-295",
          "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_memcg_events",
          "args": [
            "lruvec_memcg(lruvec)",
            "PGSTEAL_KSWAPD",
            "nr_reclaimed"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_memcg",
          "args": [
            "lruvec"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGSTEAL_KSWAPD",
            "nr_reclaimed"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_page_list",
          "args": [
            "&page_list",
            "pgdat",
            "sc",
            "0",
            "&stat",
            "false"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1106-1517",
          "snippet": "static unsigned long shrink_page_list(struct list_head *page_list,\n\t\t\t\t      struct pglist_data *pgdat,\n\t\t\t\t      struct scan_control *sc,\n\t\t\t\t      enum ttu_flags ttu_flags,\n\t\t\t\t      struct reclaim_stat *stat,\n\t\t\t\t      bool force_reclaim)\n{\n\tLIST_HEAD(ret_pages);\n\tLIST_HEAD(free_pages);\n\tint pgactivate = 0;\n\tunsigned nr_unqueued_dirty = 0;\n\tunsigned nr_dirty = 0;\n\tunsigned nr_congested = 0;\n\tunsigned nr_reclaimed = 0;\n\tunsigned nr_writeback = 0;\n\tunsigned nr_immediate = 0;\n\tunsigned nr_ref_keep = 0;\n\tunsigned nr_unmap_fail = 0;\n\n\tcond_resched();\n\n\twhile (!list_empty(page_list)) {\n\t\tstruct address_space *mapping;\n\t\tstruct page *page;\n\t\tint may_enter_fs;\n\t\tenum page_references references = PAGEREF_RECLAIM_CLEAN;\n\t\tbool dirty, writeback;\n\n\t\tcond_resched();\n\n\t\tpage = lru_to_page(page_list);\n\t\tlist_del(&page->lru);\n\n\t\tif (!trylock_page(page))\n\t\t\tgoto keep;\n\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\n\t\tsc->nr_scanned++;\n\n\t\tif (unlikely(!page_evictable(page)))\n\t\t\tgoto activate_locked;\n\n\t\tif (!sc->may_unmap && page_mapped(page))\n\t\t\tgoto keep_locked;\n\n\t\t/* Double the slab pressure for mapped and swapcache pages */\n\t\tif ((page_mapped(page) || PageSwapCache(page)) &&\n\t\t    !(PageAnon(page) && !PageSwapBacked(page)))\n\t\t\tsc->nr_scanned++;\n\n\t\tmay_enter_fs = (sc->gfp_mask & __GFP_FS) ||\n\t\t\t(PageSwapCache(page) && (sc->gfp_mask & __GFP_IO));\n\n\t\t/*\n\t\t * The number of dirty pages determines if a node is marked\n\t\t * reclaim_congested which affects wait_iff_congested. kswapd\n\t\t * will stall and start writing pages if the tail of the LRU\n\t\t * is all dirty unqueued pages.\n\t\t */\n\t\tpage_check_dirty_writeback(page, &dirty, &writeback);\n\t\tif (dirty || writeback)\n\t\t\tnr_dirty++;\n\n\t\tif (dirty && !writeback)\n\t\t\tnr_unqueued_dirty++;\n\n\t\t/*\n\t\t * Treat this page as congested if the underlying BDI is or if\n\t\t * pages are cycling through the LRU so quickly that the\n\t\t * pages marked for immediate reclaim are making it to the\n\t\t * end of the LRU a second time.\n\t\t */\n\t\tmapping = page_mapping(page);\n\t\tif (((dirty || writeback) && mapping &&\n\t\t     inode_write_congested(mapping->host)) ||\n\t\t    (writeback && PageReclaim(page)))\n\t\t\tnr_congested++;\n\n\t\t/*\n\t\t * If a page at the tail of the LRU is under writeback, there\n\t\t * are three cases to consider.\n\t\t *\n\t\t * 1) If reclaim is encountering an excessive number of pages\n\t\t *    under writeback and this page is both under writeback and\n\t\t *    PageReclaim then it indicates that pages are being queued\n\t\t *    for IO but are being recycled through the LRU before the\n\t\t *    IO can complete. Waiting on the page itself risks an\n\t\t *    indefinite stall if it is impossible to writeback the\n\t\t *    page due to IO error or disconnected storage so instead\n\t\t *    note that the LRU is being scanned too quickly and the\n\t\t *    caller can stall after page list has been processed.\n\t\t *\n\t\t * 2) Global or new memcg reclaim encounters a page that is\n\t\t *    not marked for immediate reclaim, or the caller does not\n\t\t *    have __GFP_FS (or __GFP_IO if it's simply going to swap,\n\t\t *    not to fs). In this case mark the page for immediate\n\t\t *    reclaim and continue scanning.\n\t\t *\n\t\t *    Require may_enter_fs because we would wait on fs, which\n\t\t *    may not have submitted IO yet. And the loop driver might\n\t\t *    enter reclaim, and deadlock if it waits on a page for\n\t\t *    which it is needed to do the write (loop masks off\n\t\t *    __GFP_IO|__GFP_FS for this reason); but more thought\n\t\t *    would probably show more reasons.\n\t\t *\n\t\t * 3) Legacy memcg encounters a page that is already marked\n\t\t *    PageReclaim. memcg does not have any dirty pages\n\t\t *    throttling so we could easily OOM just because too many\n\t\t *    pages are in writeback and there is nothing else to\n\t\t *    reclaim. Wait for the writeback to complete.\n\t\t *\n\t\t * In cases 1) and 2) we activate the pages to get them out of\n\t\t * the way while we continue scanning for clean pages on the\n\t\t * inactive list and refilling from the active list. The\n\t\t * observation here is that waiting for disk writes is more\n\t\t * expensive than potentially causing reloads down the line.\n\t\t * Since they're marked for immediate reclaim, they won't put\n\t\t * memory pressure on the cache working set any longer than it\n\t\t * takes to write them to disk.\n\t\t */\n\t\tif (PageWriteback(page)) {\n\t\t\t/* Case 1 above */\n\t\t\tif (current_is_kswapd() &&\n\t\t\t    PageReclaim(page) &&\n\t\t\t    test_bit(PGDAT_WRITEBACK, &pgdat->flags)) {\n\t\t\t\tnr_immediate++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 2 above */\n\t\t\t} else if (sane_reclaim(sc) ||\n\t\t\t    !PageReclaim(page) || !may_enter_fs) {\n\t\t\t\t/*\n\t\t\t\t * This is slightly racy - end_page_writeback()\n\t\t\t\t * might have just cleared PageReclaim, then\n\t\t\t\t * setting PageReclaim here end up interpreted\n\t\t\t\t * as PageReadahead - but that does not matter\n\t\t\t\t * enough to care.  What we do want is for this\n\t\t\t\t * page to have PageReclaim set next time memcg\n\t\t\t\t * reclaim reaches the tests above, so it will\n\t\t\t\t * then wait_on_page_writeback() to avoid OOM;\n\t\t\t\t * and it's also appropriate in global reclaim.\n\t\t\t\t */\n\t\t\t\tSetPageReclaim(page);\n\t\t\t\tnr_writeback++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 3 above */\n\t\t\t} else {\n\t\t\t\tunlock_page(page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t\t/* then go back and try same page again */\n\t\t\t\tlist_add_tail(&page->lru, page_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!force_reclaim)\n\t\t\treferences = page_check_references(page, sc);\n\n\t\tswitch (references) {\n\t\tcase PAGEREF_ACTIVATE:\n\t\t\tgoto activate_locked;\n\t\tcase PAGEREF_KEEP:\n\t\t\tnr_ref_keep++;\n\t\t\tgoto keep_locked;\n\t\tcase PAGEREF_RECLAIM:\n\t\tcase PAGEREF_RECLAIM_CLEAN:\n\t\t\t; /* try to reclaim the page below */\n\t\t}\n\n\t\t/*\n\t\t * Anonymous process memory has backing store?\n\t\t * Try to allocate it some swap space here.\n\t\t * Lazyfree page could be freed directly\n\t\t */\n\t\tif (PageAnon(page) && PageSwapBacked(page)) {\n\t\t\tif (!PageSwapCache(page)) {\n\t\t\t\tif (!(sc->gfp_mask & __GFP_IO))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tif (PageTransHuge(page)) {\n\t\t\t\t\t/* cannot split THP, skip it */\n\t\t\t\t\tif (!can_split_huge_page(page, NULL))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/*\n\t\t\t\t\t * Split pages without a PMD map right\n\t\t\t\t\t * away. Chances are some or all of the\n\t\t\t\t\t * tail pages can be freed without IO.\n\t\t\t\t\t */\n\t\t\t\t\tif (!compound_mapcount(page) &&\n\t\t\t\t\t    split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\t\t\t\tif (!add_to_swap(page)) {\n\t\t\t\t\tif (!PageTransHuge(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/* Fallback to swap normal pages */\n\t\t\t\t\tif (split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\t\tcount_vm_event(THP_SWPOUT_FALLBACK);\n#endif\n\t\t\t\t\tif (!add_to_swap(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\n\t\t\t\tmay_enter_fs = 1;\n\n\t\t\t\t/* Adding to swap updated mapping */\n\t\t\t\tmapping = page_mapping(page);\n\t\t\t}\n\t\t} else if (unlikely(PageTransHuge(page))) {\n\t\t\t/* Split file THP */\n\t\t\tif (split_huge_page_to_list(page, page_list))\n\t\t\t\tgoto keep_locked;\n\t\t}\n\n\t\t/*\n\t\t * The page is mapped into the page tables of one or more\n\t\t * processes. Try to unmap it here.\n\t\t */\n\t\tif (page_mapped(page)) {\n\t\t\tenum ttu_flags flags = ttu_flags | TTU_BATCH_FLUSH;\n\n\t\t\tif (unlikely(PageTransHuge(page)))\n\t\t\t\tflags |= TTU_SPLIT_HUGE_PMD;\n\t\t\tif (!try_to_unmap(page, flags)) {\n\t\t\t\tnr_unmap_fail++;\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\t\t}\n\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * Only kswapd can writeback filesystem pages\n\t\t\t * to avoid risk of stack overflow. But avoid\n\t\t\t * injecting inefficient single-page IO into\n\t\t\t * flusher writeback as much as possible: only\n\t\t\t * write pages when we've encountered many\n\t\t\t * dirty pages, and when we've already scanned\n\t\t\t * the rest of the LRU for clean pages and see\n\t\t\t * the same dirty pages again (PageReclaim).\n\t\t\t */\n\t\t\tif (page_is_file_cache(page) &&\n\t\t\t    (!current_is_kswapd() || !PageReclaim(page) ||\n\t\t\t     !test_bit(PGDAT_DIRTY, &pgdat->flags))) {\n\t\t\t\t/*\n\t\t\t\t * Immediately reclaim when written back.\n\t\t\t\t * Similar in principal to deactivate_page()\n\t\t\t\t * except we already have the page isolated\n\t\t\t\t * and know it's dirty\n\t\t\t\t */\n\t\t\t\tinc_node_page_state(page, NR_VMSCAN_IMMEDIATE);\n\t\t\t\tSetPageReclaim(page);\n\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\n\t\t\tif (references == PAGEREF_RECLAIM_CLEAN)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!may_enter_fs)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!sc->may_writepage)\n\t\t\t\tgoto keep_locked;\n\n\t\t\t/*\n\t\t\t * Page is dirty. Flush the TLB if a writable entry\n\t\t\t * potentially exists to avoid CPU writes after IO\n\t\t\t * starts and then write it out here.\n\t\t\t */\n\t\t\ttry_to_unmap_flush_dirty();\n\t\t\tswitch (pageout(page, mapping, sc)) {\n\t\t\tcase PAGE_KEEP:\n\t\t\t\tgoto keep_locked;\n\t\t\tcase PAGE_ACTIVATE:\n\t\t\t\tgoto activate_locked;\n\t\t\tcase PAGE_SUCCESS:\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tgoto keep;\n\n\t\t\t\t/*\n\t\t\t\t * A synchronous write - probably a ramdisk.  Go\n\t\t\t\t * ahead and try to reclaim the page.\n\t\t\t\t */\n\t\t\t\tif (!trylock_page(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tmapping = page_mapping(page);\n\t\t\tcase PAGE_CLEAN:\n\t\t\t\t; /* try to free the page below */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the page has buffers, try to free the buffer mappings\n\t\t * associated with this page. If we succeed we try to free\n\t\t * the page as well.\n\t\t *\n\t\t * We do this even if the page is PageDirty().\n\t\t * try_to_release_page() does not perform I/O, but it is\n\t\t * possible for a page to have PageDirty set, but it is actually\n\t\t * clean (all its buffers are clean).  This happens if the\n\t\t * buffers were written out directly, with submit_bh(). ext3\n\t\t * will do this, as well as the blockdev mapping.\n\t\t * try_to_release_page() will discover that cleanness and will\n\t\t * drop the buffers and mark the page clean - it can be freed.\n\t\t *\n\t\t * Rarely, pages can have buffers and no ->mapping.  These are\n\t\t * the pages which were not successfully invalidated in\n\t\t * truncate_complete_page().  We try to drop those buffers here\n\t\t * and if that worked, and the page is no longer mapped into\n\t\t * process address space (page_count == 1) it can be freed.\n\t\t * Otherwise, leave the page on the LRU so it is swappable.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (!try_to_release_page(page, sc->gfp_mask))\n\t\t\t\tgoto activate_locked;\n\t\t\tif (!mapping && page_count(page) == 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (put_page_testzero(page))\n\t\t\t\t\tgoto free_it;\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * rare race with speculative reference.\n\t\t\t\t\t * the speculative reference will free\n\t\t\t\t\t * this page shortly, so we may\n\t\t\t\t\t * increment nr_reclaimed here (and\n\t\t\t\t\t * leave it off the LRU).\n\t\t\t\t\t */\n\t\t\t\t\tnr_reclaimed++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PageAnon(page) && !PageSwapBacked(page)) {\n\t\t\t/* follow __remove_mapping for reference */\n\t\t\tif (!page_ref_freeze(page, 1))\n\t\t\t\tgoto keep_locked;\n\t\t\tif (PageDirty(page)) {\n\t\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\t\tgoto keep_locked;\n\t\t\t}\n\n\t\t\tcount_vm_event(PGLAZYFREED);\n\t\t\tcount_memcg_page_event(page, PGLAZYFREED);\n\t\t} else if (!mapping || !__remove_mapping(mapping, page, true))\n\t\t\tgoto keep_locked;\n\t\t/*\n\t\t * At this point, we have no other references and there is\n\t\t * no way to pick any more up (removed from LRU, removed\n\t\t * from pagecache). Can use non-atomic bitops now (and\n\t\t * we obviously don't have to worry about waking up a process\n\t\t * waiting on the page lock, because there are no references.\n\t\t */\n\t\t__ClearPageLocked(page);\nfree_it:\n\t\tnr_reclaimed++;\n\n\t\t/*\n\t\t * Is there need to periodically free_page_list? It would\n\t\t * appear not as the counts should be low\n\t\t */\n\t\tif (unlikely(PageTransHuge(page))) {\n\t\t\tmem_cgroup_uncharge(page);\n\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t} else\n\t\t\tlist_add(&page->lru, &free_pages);\n\t\tcontinue;\n\nactivate_locked:\n\t\t/* Not a candidate for swapping, so reclaim swap space. */\n\t\tif (PageSwapCache(page) && (mem_cgroup_swap_full(page) ||\n\t\t\t\t\t\tPageMlocked(page)))\n\t\t\ttry_to_free_swap(page);\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\tif (!PageMlocked(page)) {\n\t\t\tSetPageActive(page);\n\t\t\tpgactivate++;\n\t\t\tcount_memcg_page_event(page, PGACTIVATE);\n\t\t}\nkeep_locked:\n\t\tunlock_page(page);\nkeep:\n\t\tlist_add(&page->lru, &ret_pages);\n\t\tVM_BUG_ON_PAGE(PageLRU(page) || PageUnevictable(page), page);\n\t}\n\n\tmem_cgroup_uncharge_list(&free_pages);\n\ttry_to_unmap_flush();\n\tfree_unref_page_list(&free_pages);\n\n\tlist_splice(&ret_pages, page_list);\n\tcount_vm_events(PGACTIVATE, pgactivate);\n\n\tif (stat) {\n\t\tstat->nr_dirty = nr_dirty;\n\t\tstat->nr_congested = nr_congested;\n\t\tstat->nr_unqueued_dirty = nr_unqueued_dirty;\n\t\tstat->nr_writeback = nr_writeback;\n\t\tstat->nr_immediate = nr_immediate;\n\t\tstat->nr_activate = pgactivate;\n\t\tstat->nr_ref_keep = nr_ref_keep;\n\t\tstat->nr_unmap_fail = nr_unmap_fail;\n\t}\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long shrink_page_list(struct list_head *page_list,\n\t\t\t\t      struct pglist_data *pgdat,\n\t\t\t\t      struct scan_control *sc,\n\t\t\t\t      enum ttu_flags ttu_flags,\n\t\t\t\t      struct reclaim_stat *stat,\n\t\t\t\t      bool force_reclaim)\n{\n\tLIST_HEAD(ret_pages);\n\tLIST_HEAD(free_pages);\n\tint pgactivate = 0;\n\tunsigned nr_unqueued_dirty = 0;\n\tunsigned nr_dirty = 0;\n\tunsigned nr_congested = 0;\n\tunsigned nr_reclaimed = 0;\n\tunsigned nr_writeback = 0;\n\tunsigned nr_immediate = 0;\n\tunsigned nr_ref_keep = 0;\n\tunsigned nr_unmap_fail = 0;\n\n\tcond_resched();\n\n\twhile (!list_empty(page_list)) {\n\t\tstruct address_space *mapping;\n\t\tstruct page *page;\n\t\tint may_enter_fs;\n\t\tenum page_references references = PAGEREF_RECLAIM_CLEAN;\n\t\tbool dirty, writeback;\n\n\t\tcond_resched();\n\n\t\tpage = lru_to_page(page_list);\n\t\tlist_del(&page->lru);\n\n\t\tif (!trylock_page(page))\n\t\t\tgoto keep;\n\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\n\t\tsc->nr_scanned++;\n\n\t\tif (unlikely(!page_evictable(page)))\n\t\t\tgoto activate_locked;\n\n\t\tif (!sc->may_unmap && page_mapped(page))\n\t\t\tgoto keep_locked;\n\n\t\t/* Double the slab pressure for mapped and swapcache pages */\n\t\tif ((page_mapped(page) || PageSwapCache(page)) &&\n\t\t    !(PageAnon(page) && !PageSwapBacked(page)))\n\t\t\tsc->nr_scanned++;\n\n\t\tmay_enter_fs = (sc->gfp_mask & __GFP_FS) ||\n\t\t\t(PageSwapCache(page) && (sc->gfp_mask & __GFP_IO));\n\n\t\t/*\n\t\t * The number of dirty pages determines if a node is marked\n\t\t * reclaim_congested which affects wait_iff_congested. kswapd\n\t\t * will stall and start writing pages if the tail of the LRU\n\t\t * is all dirty unqueued pages.\n\t\t */\n\t\tpage_check_dirty_writeback(page, &dirty, &writeback);\n\t\tif (dirty || writeback)\n\t\t\tnr_dirty++;\n\n\t\tif (dirty && !writeback)\n\t\t\tnr_unqueued_dirty++;\n\n\t\t/*\n\t\t * Treat this page as congested if the underlying BDI is or if\n\t\t * pages are cycling through the LRU so quickly that the\n\t\t * pages marked for immediate reclaim are making it to the\n\t\t * end of the LRU a second time.\n\t\t */\n\t\tmapping = page_mapping(page);\n\t\tif (((dirty || writeback) && mapping &&\n\t\t     inode_write_congested(mapping->host)) ||\n\t\t    (writeback && PageReclaim(page)))\n\t\t\tnr_congested++;\n\n\t\t/*\n\t\t * If a page at the tail of the LRU is under writeback, there\n\t\t * are three cases to consider.\n\t\t *\n\t\t * 1) If reclaim is encountering an excessive number of pages\n\t\t *    under writeback and this page is both under writeback and\n\t\t *    PageReclaim then it indicates that pages are being queued\n\t\t *    for IO but are being recycled through the LRU before the\n\t\t *    IO can complete. Waiting on the page itself risks an\n\t\t *    indefinite stall if it is impossible to writeback the\n\t\t *    page due to IO error or disconnected storage so instead\n\t\t *    note that the LRU is being scanned too quickly and the\n\t\t *    caller can stall after page list has been processed.\n\t\t *\n\t\t * 2) Global or new memcg reclaim encounters a page that is\n\t\t *    not marked for immediate reclaim, or the caller does not\n\t\t *    have __GFP_FS (or __GFP_IO if it's simply going to swap,\n\t\t *    not to fs). In this case mark the page for immediate\n\t\t *    reclaim and continue scanning.\n\t\t *\n\t\t *    Require may_enter_fs because we would wait on fs, which\n\t\t *    may not have submitted IO yet. And the loop driver might\n\t\t *    enter reclaim, and deadlock if it waits on a page for\n\t\t *    which it is needed to do the write (loop masks off\n\t\t *    __GFP_IO|__GFP_FS for this reason); but more thought\n\t\t *    would probably show more reasons.\n\t\t *\n\t\t * 3) Legacy memcg encounters a page that is already marked\n\t\t *    PageReclaim. memcg does not have any dirty pages\n\t\t *    throttling so we could easily OOM just because too many\n\t\t *    pages are in writeback and there is nothing else to\n\t\t *    reclaim. Wait for the writeback to complete.\n\t\t *\n\t\t * In cases 1) and 2) we activate the pages to get them out of\n\t\t * the way while we continue scanning for clean pages on the\n\t\t * inactive list and refilling from the active list. The\n\t\t * observation here is that waiting for disk writes is more\n\t\t * expensive than potentially causing reloads down the line.\n\t\t * Since they're marked for immediate reclaim, they won't put\n\t\t * memory pressure on the cache working set any longer than it\n\t\t * takes to write them to disk.\n\t\t */\n\t\tif (PageWriteback(page)) {\n\t\t\t/* Case 1 above */\n\t\t\tif (current_is_kswapd() &&\n\t\t\t    PageReclaim(page) &&\n\t\t\t    test_bit(PGDAT_WRITEBACK, &pgdat->flags)) {\n\t\t\t\tnr_immediate++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 2 above */\n\t\t\t} else if (sane_reclaim(sc) ||\n\t\t\t    !PageReclaim(page) || !may_enter_fs) {\n\t\t\t\t/*\n\t\t\t\t * This is slightly racy - end_page_writeback()\n\t\t\t\t * might have just cleared PageReclaim, then\n\t\t\t\t * setting PageReclaim here end up interpreted\n\t\t\t\t * as PageReadahead - but that does not matter\n\t\t\t\t * enough to care.  What we do want is for this\n\t\t\t\t * page to have PageReclaim set next time memcg\n\t\t\t\t * reclaim reaches the tests above, so it will\n\t\t\t\t * then wait_on_page_writeback() to avoid OOM;\n\t\t\t\t * and it's also appropriate in global reclaim.\n\t\t\t\t */\n\t\t\t\tSetPageReclaim(page);\n\t\t\t\tnr_writeback++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 3 above */\n\t\t\t} else {\n\t\t\t\tunlock_page(page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t\t/* then go back and try same page again */\n\t\t\t\tlist_add_tail(&page->lru, page_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!force_reclaim)\n\t\t\treferences = page_check_references(page, sc);\n\n\t\tswitch (references) {\n\t\tcase PAGEREF_ACTIVATE:\n\t\t\tgoto activate_locked;\n\t\tcase PAGEREF_KEEP:\n\t\t\tnr_ref_keep++;\n\t\t\tgoto keep_locked;\n\t\tcase PAGEREF_RECLAIM:\n\t\tcase PAGEREF_RECLAIM_CLEAN:\n\t\t\t; /* try to reclaim the page below */\n\t\t}\n\n\t\t/*\n\t\t * Anonymous process memory has backing store?\n\t\t * Try to allocate it some swap space here.\n\t\t * Lazyfree page could be freed directly\n\t\t */\n\t\tif (PageAnon(page) && PageSwapBacked(page)) {\n\t\t\tif (!PageSwapCache(page)) {\n\t\t\t\tif (!(sc->gfp_mask & __GFP_IO))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tif (PageTransHuge(page)) {\n\t\t\t\t\t/* cannot split THP, skip it */\n\t\t\t\t\tif (!can_split_huge_page(page, NULL))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/*\n\t\t\t\t\t * Split pages without a PMD map right\n\t\t\t\t\t * away. Chances are some or all of the\n\t\t\t\t\t * tail pages can be freed without IO.\n\t\t\t\t\t */\n\t\t\t\t\tif (!compound_mapcount(page) &&\n\t\t\t\t\t    split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\t\t\t\tif (!add_to_swap(page)) {\n\t\t\t\t\tif (!PageTransHuge(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/* Fallback to swap normal pages */\n\t\t\t\t\tif (split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\t\tcount_vm_event(THP_SWPOUT_FALLBACK);\n#endif\n\t\t\t\t\tif (!add_to_swap(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\n\t\t\t\tmay_enter_fs = 1;\n\n\t\t\t\t/* Adding to swap updated mapping */\n\t\t\t\tmapping = page_mapping(page);\n\t\t\t}\n\t\t} else if (unlikely(PageTransHuge(page))) {\n\t\t\t/* Split file THP */\n\t\t\tif (split_huge_page_to_list(page, page_list))\n\t\t\t\tgoto keep_locked;\n\t\t}\n\n\t\t/*\n\t\t * The page is mapped into the page tables of one or more\n\t\t * processes. Try to unmap it here.\n\t\t */\n\t\tif (page_mapped(page)) {\n\t\t\tenum ttu_flags flags = ttu_flags | TTU_BATCH_FLUSH;\n\n\t\t\tif (unlikely(PageTransHuge(page)))\n\t\t\t\tflags |= TTU_SPLIT_HUGE_PMD;\n\t\t\tif (!try_to_unmap(page, flags)) {\n\t\t\t\tnr_unmap_fail++;\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\t\t}\n\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * Only kswapd can writeback filesystem pages\n\t\t\t * to avoid risk of stack overflow. But avoid\n\t\t\t * injecting inefficient single-page IO into\n\t\t\t * flusher writeback as much as possible: only\n\t\t\t * write pages when we've encountered many\n\t\t\t * dirty pages, and when we've already scanned\n\t\t\t * the rest of the LRU for clean pages and see\n\t\t\t * the same dirty pages again (PageReclaim).\n\t\t\t */\n\t\t\tif (page_is_file_cache(page) &&\n\t\t\t    (!current_is_kswapd() || !PageReclaim(page) ||\n\t\t\t     !test_bit(PGDAT_DIRTY, &pgdat->flags))) {\n\t\t\t\t/*\n\t\t\t\t * Immediately reclaim when written back.\n\t\t\t\t * Similar in principal to deactivate_page()\n\t\t\t\t * except we already have the page isolated\n\t\t\t\t * and know it's dirty\n\t\t\t\t */\n\t\t\t\tinc_node_page_state(page, NR_VMSCAN_IMMEDIATE);\n\t\t\t\tSetPageReclaim(page);\n\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\n\t\t\tif (references == PAGEREF_RECLAIM_CLEAN)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!may_enter_fs)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!sc->may_writepage)\n\t\t\t\tgoto keep_locked;\n\n\t\t\t/*\n\t\t\t * Page is dirty. Flush the TLB if a writable entry\n\t\t\t * potentially exists to avoid CPU writes after IO\n\t\t\t * starts and then write it out here.\n\t\t\t */\n\t\t\ttry_to_unmap_flush_dirty();\n\t\t\tswitch (pageout(page, mapping, sc)) {\n\t\t\tcase PAGE_KEEP:\n\t\t\t\tgoto keep_locked;\n\t\t\tcase PAGE_ACTIVATE:\n\t\t\t\tgoto activate_locked;\n\t\t\tcase PAGE_SUCCESS:\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tgoto keep;\n\n\t\t\t\t/*\n\t\t\t\t * A synchronous write - probably a ramdisk.  Go\n\t\t\t\t * ahead and try to reclaim the page.\n\t\t\t\t */\n\t\t\t\tif (!trylock_page(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tmapping = page_mapping(page);\n\t\t\tcase PAGE_CLEAN:\n\t\t\t\t; /* try to free the page below */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the page has buffers, try to free the buffer mappings\n\t\t * associated with this page. If we succeed we try to free\n\t\t * the page as well.\n\t\t *\n\t\t * We do this even if the page is PageDirty().\n\t\t * try_to_release_page() does not perform I/O, but it is\n\t\t * possible for a page to have PageDirty set, but it is actually\n\t\t * clean (all its buffers are clean).  This happens if the\n\t\t * buffers were written out directly, with submit_bh(). ext3\n\t\t * will do this, as well as the blockdev mapping.\n\t\t * try_to_release_page() will discover that cleanness and will\n\t\t * drop the buffers and mark the page clean - it can be freed.\n\t\t *\n\t\t * Rarely, pages can have buffers and no ->mapping.  These are\n\t\t * the pages which were not successfully invalidated in\n\t\t * truncate_complete_page().  We try to drop those buffers here\n\t\t * and if that worked, and the page is no longer mapped into\n\t\t * process address space (page_count == 1) it can be freed.\n\t\t * Otherwise, leave the page on the LRU so it is swappable.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (!try_to_release_page(page, sc->gfp_mask))\n\t\t\t\tgoto activate_locked;\n\t\t\tif (!mapping && page_count(page) == 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (put_page_testzero(page))\n\t\t\t\t\tgoto free_it;\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * rare race with speculative reference.\n\t\t\t\t\t * the speculative reference will free\n\t\t\t\t\t * this page shortly, so we may\n\t\t\t\t\t * increment nr_reclaimed here (and\n\t\t\t\t\t * leave it off the LRU).\n\t\t\t\t\t */\n\t\t\t\t\tnr_reclaimed++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PageAnon(page) && !PageSwapBacked(page)) {\n\t\t\t/* follow __remove_mapping for reference */\n\t\t\tif (!page_ref_freeze(page, 1))\n\t\t\t\tgoto keep_locked;\n\t\t\tif (PageDirty(page)) {\n\t\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\t\tgoto keep_locked;\n\t\t\t}\n\n\t\t\tcount_vm_event(PGLAZYFREED);\n\t\t\tcount_memcg_page_event(page, PGLAZYFREED);\n\t\t} else if (!mapping || !__remove_mapping(mapping, page, true))\n\t\t\tgoto keep_locked;\n\t\t/*\n\t\t * At this point, we have no other references and there is\n\t\t * no way to pick any more up (removed from LRU, removed\n\t\t * from pagecache). Can use non-atomic bitops now (and\n\t\t * we obviously don't have to worry about waking up a process\n\t\t * waiting on the page lock, because there are no references.\n\t\t */\n\t\t__ClearPageLocked(page);\nfree_it:\n\t\tnr_reclaimed++;\n\n\t\t/*\n\t\t * Is there need to periodically free_page_list? It would\n\t\t * appear not as the counts should be low\n\t\t */\n\t\tif (unlikely(PageTransHuge(page))) {\n\t\t\tmem_cgroup_uncharge(page);\n\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t} else\n\t\t\tlist_add(&page->lru, &free_pages);\n\t\tcontinue;\n\nactivate_locked:\n\t\t/* Not a candidate for swapping, so reclaim swap space. */\n\t\tif (PageSwapCache(page) && (mem_cgroup_swap_full(page) ||\n\t\t\t\t\t\tPageMlocked(page)))\n\t\t\ttry_to_free_swap(page);\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\tif (!PageMlocked(page)) {\n\t\t\tSetPageActive(page);\n\t\t\tpgactivate++;\n\t\t\tcount_memcg_page_event(page, PGACTIVATE);\n\t\t}\nkeep_locked:\n\t\tunlock_page(page);\nkeep:\n\t\tlist_add(&page->lru, &ret_pages);\n\t\tVM_BUG_ON_PAGE(PageLRU(page) || PageUnevictable(page), page);\n\t}\n\n\tmem_cgroup_uncharge_list(&free_pages);\n\ttry_to_unmap_flush();\n\tfree_unref_page_list(&free_pages);\n\n\tlist_splice(&ret_pages, page_list);\n\tcount_vm_events(PGACTIVATE, pgactivate);\n\n\tif (stat) {\n\t\tstat->nr_dirty = nr_dirty;\n\t\tstat->nr_congested = nr_congested;\n\t\tstat->nr_unqueued_dirty = nr_unqueued_dirty;\n\t\tstat->nr_writeback = nr_writeback;\n\t\tstat->nr_immediate = nr_immediate;\n\t\tstat->nr_activate = pgactivate;\n\t\tstat->nr_ref_keep = nr_ref_keep;\n\t\tstat->nr_unmap_fail = nr_unmap_fail;\n\t}\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_memcg_events",
          "args": [
            "lruvec_memcg(lruvec)",
            "PGSCAN_DIRECT",
            "nr_scanned"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_memcg",
          "args": [
            "lruvec"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGSCAN_DIRECT",
            "nr_scanned"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_memcg_events",
          "args": [
            "lruvec_memcg(lruvec)",
            "PGSCAN_KSWAPD",
            "nr_scanned"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_memcg",
          "args": [
            "lruvec"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGSCAN_KSWAPD",
            "nr_scanned"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_lru_pages",
          "args": [
            "nr_to_scan",
            "lruvec",
            "&page_list",
            "&nr_scanned",
            "sc",
            "isolate_mode",
            "lru"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1665-1744",
          "snippet": "static unsigned long isolate_lru_pages(unsigned long nr_to_scan,\n\t\tstruct lruvec *lruvec, struct list_head *dst,\n\t\tunsigned long *nr_scanned, struct scan_control *sc,\n\t\tisolate_mode_t mode, enum lru_list lru)\n{\n\tstruct list_head *src = &lruvec->lists[lru];\n\tunsigned long nr_taken = 0;\n\tunsigned long nr_zone_taken[MAX_NR_ZONES] = { 0 };\n\tunsigned long nr_skipped[MAX_NR_ZONES] = { 0, };\n\tunsigned long skipped = 0;\n\tunsigned long scan, total_scan, nr_pages;\n\tLIST_HEAD(pages_skipped);\n\n\tscan = 0;\n\tfor (total_scan = 0;\n\t     scan < nr_to_scan && nr_taken < nr_to_scan && !list_empty(src);\n\t     total_scan++) {\n\t\tstruct page *page;\n\n\t\tpage = lru_to_page(src);\n\t\tprefetchw_prev_lru_page(page, src, flags);\n\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\n\t\tif (page_zonenum(page) > sc->reclaim_idx) {\n\t\t\tlist_move(&page->lru, &pages_skipped);\n\t\t\tnr_skipped[page_zonenum(page)]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Do not count skipped pages because that makes the function\n\t\t * return with no isolated pages if the LRU mostly contains\n\t\t * ineligible pages.  This causes the VM to not reclaim any\n\t\t * pages, triggering a premature OOM.\n\t\t */\n\t\tscan++;\n\t\tswitch (__isolate_lru_page(page, mode)) {\n\t\tcase 0:\n\t\t\tnr_pages = hpage_nr_pages(page);\n\t\t\tnr_taken += nr_pages;\n\t\t\tnr_zone_taken[page_zonenum(page)] += nr_pages;\n\t\t\tlist_move(&page->lru, dst);\n\t\t\tbreak;\n\n\t\tcase -EBUSY:\n\t\t\t/* else it is being freed elsewhere */\n\t\t\tlist_move(&page->lru, src);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/*\n\t * Splice any skipped pages to the start of the LRU list. Note that\n\t * this disrupts the LRU order when reclaiming for lower zones but\n\t * we cannot splice to the tail. If we did then the SWAP_CLUSTER_MAX\n\t * scanning would soon rescan the same pages to skip and put the\n\t * system at risk of premature OOM.\n\t */\n\tif (!list_empty(&pages_skipped)) {\n\t\tint zid;\n\n\t\tlist_splice(&pages_skipped, src);\n\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\tif (!nr_skipped[zid])\n\t\t\t\tcontinue;\n\n\t\t\t__count_zid_vm_events(PGSCAN_SKIP, zid, nr_skipped[zid]);\n\t\t\tskipped += nr_skipped[zid];\n\t\t}\n\t}\n\t*nr_scanned = total_scan;\n\ttrace_mm_vmscan_lru_isolate(sc->reclaim_idx, sc->order, nr_to_scan,\n\t\t\t\t    total_scan, skipped, nr_taken, mode, lru);\n\tupdate_lru_sizes(lruvec, lru, nr_zone_taken);\n\treturn nr_taken;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long isolate_lru_pages(unsigned long nr_to_scan,\n\t\tstruct lruvec *lruvec, struct list_head *dst,\n\t\tunsigned long *nr_scanned, struct scan_control *sc,\n\t\tisolate_mode_t mode, enum lru_list lru)\n{\n\tstruct list_head *src = &lruvec->lists[lru];\n\tunsigned long nr_taken = 0;\n\tunsigned long nr_zone_taken[MAX_NR_ZONES] = { 0 };\n\tunsigned long nr_skipped[MAX_NR_ZONES] = { 0, };\n\tunsigned long skipped = 0;\n\tunsigned long scan, total_scan, nr_pages;\n\tLIST_HEAD(pages_skipped);\n\n\tscan = 0;\n\tfor (total_scan = 0;\n\t     scan < nr_to_scan && nr_taken < nr_to_scan && !list_empty(src);\n\t     total_scan++) {\n\t\tstruct page *page;\n\n\t\tpage = lru_to_page(src);\n\t\tprefetchw_prev_lru_page(page, src, flags);\n\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\n\t\tif (page_zonenum(page) > sc->reclaim_idx) {\n\t\t\tlist_move(&page->lru, &pages_skipped);\n\t\t\tnr_skipped[page_zonenum(page)]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Do not count skipped pages because that makes the function\n\t\t * return with no isolated pages if the LRU mostly contains\n\t\t * ineligible pages.  This causes the VM to not reclaim any\n\t\t * pages, triggering a premature OOM.\n\t\t */\n\t\tscan++;\n\t\tswitch (__isolate_lru_page(page, mode)) {\n\t\tcase 0:\n\t\t\tnr_pages = hpage_nr_pages(page);\n\t\t\tnr_taken += nr_pages;\n\t\t\tnr_zone_taken[page_zonenum(page)] += nr_pages;\n\t\t\tlist_move(&page->lru, dst);\n\t\t\tbreak;\n\n\t\tcase -EBUSY:\n\t\t\t/* else it is being freed elsewhere */\n\t\t\tlist_move(&page->lru, src);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/*\n\t * Splice any skipped pages to the start of the LRU list. Note that\n\t * this disrupts the LRU order when reclaiming for lower zones but\n\t * we cannot splice to the tail. If we did then the SWAP_CLUSTER_MAX\n\t * scanning would soon rescan the same pages to skip and put the\n\t * system at risk of premature OOM.\n\t */\n\tif (!list_empty(&pages_skipped)) {\n\t\tint zid;\n\n\t\tlist_splice(&pages_skipped, src);\n\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\tif (!nr_skipped[zid])\n\t\t\t\tcontinue;\n\n\t\t\t__count_zid_vm_events(PGSCAN_SKIP, zid, nr_skipped[zid]);\n\t\t\tskipped += nr_skipped[zid];\n\t\t}\n\t}\n\t*nr_scanned = total_scan;\n\ttrace_mm_vmscan_lru_isolate(sc->reclaim_idx, sc->order, nr_to_scan,\n\t\t\t\t    total_scan, skipped, nr_taken, mode, lru);\n\tupdate_lru_sizes(lruvec, lru, nr_zone_taken);\n\treturn nr_taken;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "too_many_isolated(pgdat, file, sc)"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_isolated",
          "args": [
            "pgdat",
            "file",
            "sc"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1804-1832",
          "snippet": "static int too_many_isolated(struct pglist_data *pgdat, int file,\n\t\tstruct scan_control *sc)\n{\n\tunsigned long inactive, isolated;\n\n\tif (current_is_kswapd())\n\t\treturn 0;\n\n\tif (!sane_reclaim(sc))\n\t\treturn 0;\n\n\tif (file) {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_FILE);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_FILE);\n\t} else {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_ANON);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_ANON);\n\t}\n\n\t/*\n\t * GFP_NOIO/GFP_NOFS callers are allowed to isolate more pages, so they\n\t * won't get blocked by normal direct-reclaimers, forming a circular\n\t * deadlock.\n\t */\n\tif ((sc->gfp_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\tinactive >>= 3;\n\n\treturn isolated > inactive;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int too_many_isolated(struct pglist_data *pgdat, int file,\n\t\tstruct scan_control *sc)\n{\n\tunsigned long inactive, isolated;\n\n\tif (current_is_kswapd())\n\t\treturn 0;\n\n\tif (!sane_reclaim(sc))\n\t\treturn 0;\n\n\tif (file) {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_FILE);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_FILE);\n\t} else {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_ANON);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_ANON);\n\t}\n\n\t/*\n\t * GFP_NOIO/GFP_NOFS callers are allowed to isolate more pages, so they\n\t * won't get blocked by normal direct-reclaimers, forming a circular\n\t * deadlock.\n\t */\n\tif ((sc->gfp_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\tinactive >>= 3;\n\n\treturn isolated > inactive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_lru",
          "args": [
            "lru"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "page_list"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic noinline_for_stack unsigned long\nshrink_inactive_list(unsigned long nr_to_scan, struct lruvec *lruvec,\n\t\t     struct scan_control *sc, enum lru_list lru)\n{\n\tLIST_HEAD(page_list);\n\tunsigned long nr_scanned;\n\tunsigned long nr_reclaimed = 0;\n\tunsigned long nr_taken;\n\tstruct reclaim_stat stat = {};\n\tisolate_mode_t isolate_mode = 0;\n\tint file = is_file_lru(lru);\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tbool stalled = false;\n\n\twhile (unlikely(too_many_isolated(pgdat, file, sc))) {\n\t\tif (stalled)\n\t\t\treturn 0;\n\n\t\t/* wait a bit for the reclaimer. */\n\t\tmsleep(100);\n\t\tstalled = true;\n\n\t\t/* We are about to die and free our memory. Return now. */\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn SWAP_CLUSTER_MAX;\n\t}\n\n\tlru_add_drain();\n\n\tif (!sc->may_unmap)\n\t\tisolate_mode |= ISOLATE_UNMAPPED;\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tnr_taken = isolate_lru_pages(nr_to_scan, lruvec, &page_list,\n\t\t\t\t     &nr_scanned, sc, isolate_mode, lru);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);\n\treclaim_stat->recent_scanned[file] += nr_taken;\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_KSWAPD, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_KSWAPD,\n\t\t\t\t   nr_scanned);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSCAN_DIRECT, nr_scanned);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSCAN_DIRECT,\n\t\t\t\t   nr_scanned);\n\t}\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tif (nr_taken == 0)\n\t\treturn 0;\n\n\tnr_reclaimed = shrink_page_list(&page_list, pgdat, sc, 0,\n\t\t\t\t&stat, false);\n\n\tspin_lock_irq(&pgdat->lru_lock);\n\n\tif (current_is_kswapd()) {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_KSWAPD, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_KSWAPD,\n\t\t\t\t   nr_reclaimed);\n\t} else {\n\t\tif (global_reclaim(sc))\n\t\t\t__count_vm_events(PGSTEAL_DIRECT, nr_reclaimed);\n\t\tcount_memcg_events(lruvec_memcg(lruvec), PGSTEAL_DIRECT,\n\t\t\t\t   nr_reclaimed);\n\t}\n\n\tputback_inactive_pages(lruvec, &page_list);\n\n\t__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);\n\n\tspin_unlock_irq(&pgdat->lru_lock);\n\n\tmem_cgroup_uncharge_list(&page_list);\n\tfree_unref_page_list(&page_list);\n\n\t/*\n\t * If dirty pages are scanned that are not queued for IO, it\n\t * implies that flushers are not doing their job. This can\n\t * happen when memory pressure pushes dirty pages to the end of\n\t * the LRU before the dirty limits are breached and the dirty\n\t * data has expired. It can also happen when the proportion of\n\t * dirty pages grows not through writes but through memory\n\t * pressure reclaiming all the clean cache. And in some cases,\n\t * the flushers simply cannot keep up with the allocation\n\t * rate. Nudge the flusher threads in case they are asleep.\n\t */\n\tif (stat.nr_unqueued_dirty == nr_taken)\n\t\twakeup_flusher_threads(WB_REASON_VMSCAN);\n\n\tsc->nr.dirty += stat.nr_dirty;\n\tsc->nr.congested += stat.nr_congested;\n\tsc->nr.unqueued_dirty += stat.nr_unqueued_dirty;\n\tsc->nr.writeback += stat.nr_writeback;\n\tsc->nr.immediate += stat.nr_immediate;\n\tsc->nr.taken += nr_taken;\n\tif (file)\n\t\tsc->nr.file_taken += nr_taken;\n\n\ttrace_mm_vmscan_lru_shrink_inactive(pgdat->node_id,\n\t\t\tnr_scanned, nr_reclaimed, &stat, sc->priority, file);\n\treturn nr_reclaimed;\n}"
  },
  {
    "function_name": "current_may_throttle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1895-1900",
    "snippet": "static int current_may_throttle(void)\n{\n\treturn !(current->flags & PF_LESS_THROTTLE) ||\n\t\tcurrent->backing_dev_info == NULL ||\n\t\tbdi_write_congested(current->backing_dev_info);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_write_congested",
          "args": [
            "current->backing_dev_info"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int current_may_throttle(void)\n{\n\treturn !(current->flags & PF_LESS_THROTTLE) ||\n\t\tcurrent->backing_dev_info == NULL ||\n\t\tbdi_write_congested(current->backing_dev_info);\n}"
  },
  {
    "function_name": "putback_inactive_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1834-1887",
    "snippet": "static noinline_for_stack void\nputback_inactive_pages(struct lruvec *lruvec, struct list_head *page_list)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tLIST_HEAD(pages_to_free);\n\n\t/*\n\t * Put back any unfreeable pages.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tstruct page *page = lru_to_page(page_list);\n\t\tint lru;\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tlist_del(&page->lru);\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\tputback_lru_page(page);\n\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tSetPageLRU(page);\n\t\tlru = page_lru(page);\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\n\t\tif (is_active_lru(lru)) {\n\t\t\tint file = is_file_lru(lru);\n\t\t\tint numpages = hpage_nr_pages(page);\n\t\t\treclaim_stat->recent_rotated[file] += numpages;\n\t\t}\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, &pages_to_free);\n\t\t}\n\t}\n\n\t/*\n\t * To save our caller's stack, now use input list for pages to free.\n\t */\n\tlist_splice(&pages_to_free, page_list);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&pages_to_free",
            "page_list"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&pages_to_free"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compound_page_dtor",
          "args": [
            "page"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge",
          "args": [
            "page"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageCompound(page)"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageActive",
          "args": [
            "page"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page_testzero",
          "args": [
            "page"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_lru",
          "args": [
            "lru"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_active_lru",
          "args": [
            "lru"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageLRU",
          "args": [
            "page"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "pgdat"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_evictable(page)"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_evictable",
          "args": [
            "page"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "page_evictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4174-4183",
          "snippet": "int page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "page_list"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_list"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pages_to_free"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic noinline_for_stack void\nputback_inactive_pages(struct lruvec *lruvec, struct list_head *page_list)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\tstruct pglist_data *pgdat = lruvec_pgdat(lruvec);\n\tLIST_HEAD(pages_to_free);\n\n\t/*\n\t * Put back any unfreeable pages.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tstruct page *page = lru_to_page(page_list);\n\t\tint lru;\n\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t\tlist_del(&page->lru);\n\t\tif (unlikely(!page_evictable(page))) {\n\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\tputback_lru_page(page);\n\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\n\t\tSetPageLRU(page);\n\t\tlru = page_lru(page);\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\n\t\tif (is_active_lru(lru)) {\n\t\t\tint file = is_file_lru(lru);\n\t\t\tint numpages = hpage_nr_pages(page);\n\t\t\treclaim_stat->recent_rotated[file] += numpages;\n\t\t}\n\t\tif (put_page_testzero(page)) {\n\t\t\t__ClearPageLRU(page);\n\t\t\t__ClearPageActive(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tspin_unlock_irq(&pgdat->lru_lock);\n\t\t\t\tmem_cgroup_uncharge(page);\n\t\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t\t\tspin_lock_irq(&pgdat->lru_lock);\n\t\t\t} else\n\t\t\t\tlist_add(&page->lru, &pages_to_free);\n\t\t}\n\t}\n\n\t/*\n\t * To save our caller's stack, now use input list for pages to free.\n\t */\n\tlist_splice(&pages_to_free, page_list);\n}"
  },
  {
    "function_name": "too_many_isolated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1804-1832",
    "snippet": "static int too_many_isolated(struct pglist_data *pgdat, int file,\n\t\tstruct scan_control *sc)\n{\n\tunsigned long inactive, isolated;\n\n\tif (current_is_kswapd())\n\t\treturn 0;\n\n\tif (!sane_reclaim(sc))\n\t\treturn 0;\n\n\tif (file) {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_FILE);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_FILE);\n\t} else {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_ANON);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_ANON);\n\t}\n\n\t/*\n\t * GFP_NOIO/GFP_NOFS callers are allowed to isolate more pages, so they\n\t * won't get blocked by normal direct-reclaimers, forming a circular\n\t * deadlock.\n\t */\n\tif ((sc->gfp_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\tinactive >>= 3;\n\n\treturn isolated > inactive;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_ISOLATED_ANON"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sane_reclaim",
          "args": [
            "sc"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "sane_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "297-300",
          "snippet": "static bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int too_many_isolated(struct pglist_data *pgdat, int file,\n\t\tstruct scan_control *sc)\n{\n\tunsigned long inactive, isolated;\n\n\tif (current_is_kswapd())\n\t\treturn 0;\n\n\tif (!sane_reclaim(sc))\n\t\treturn 0;\n\n\tif (file) {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_FILE);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_FILE);\n\t} else {\n\t\tinactive = node_page_state(pgdat, NR_INACTIVE_ANON);\n\t\tisolated = node_page_state(pgdat, NR_ISOLATED_ANON);\n\t}\n\n\t/*\n\t * GFP_NOIO/GFP_NOFS callers are allowed to isolate more pages, so they\n\t * won't get blocked by normal direct-reclaimers, forming a circular\n\t * deadlock.\n\t */\n\tif ((sc->gfp_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\tinactive >>= 3;\n\n\treturn isolated > inactive;\n}"
  },
  {
    "function_name": "isolate_lru_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1772-1795",
    "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "zone->zone_pgdat"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_RATELIMIT",
          "args": [
            "PageTail(page)",
            "\"trying to isolate tail page\""
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!page_count(page)",
            "page"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "isolate_lru_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1665-1744",
    "snippet": "static unsigned long isolate_lru_pages(unsigned long nr_to_scan,\n\t\tstruct lruvec *lruvec, struct list_head *dst,\n\t\tunsigned long *nr_scanned, struct scan_control *sc,\n\t\tisolate_mode_t mode, enum lru_list lru)\n{\n\tstruct list_head *src = &lruvec->lists[lru];\n\tunsigned long nr_taken = 0;\n\tunsigned long nr_zone_taken[MAX_NR_ZONES] = { 0 };\n\tunsigned long nr_skipped[MAX_NR_ZONES] = { 0, };\n\tunsigned long skipped = 0;\n\tunsigned long scan, total_scan, nr_pages;\n\tLIST_HEAD(pages_skipped);\n\n\tscan = 0;\n\tfor (total_scan = 0;\n\t     scan < nr_to_scan && nr_taken < nr_to_scan && !list_empty(src);\n\t     total_scan++) {\n\t\tstruct page *page;\n\n\t\tpage = lru_to_page(src);\n\t\tprefetchw_prev_lru_page(page, src, flags);\n\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\n\t\tif (page_zonenum(page) > sc->reclaim_idx) {\n\t\t\tlist_move(&page->lru, &pages_skipped);\n\t\t\tnr_skipped[page_zonenum(page)]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Do not count skipped pages because that makes the function\n\t\t * return with no isolated pages if the LRU mostly contains\n\t\t * ineligible pages.  This causes the VM to not reclaim any\n\t\t * pages, triggering a premature OOM.\n\t\t */\n\t\tscan++;\n\t\tswitch (__isolate_lru_page(page, mode)) {\n\t\tcase 0:\n\t\t\tnr_pages = hpage_nr_pages(page);\n\t\t\tnr_taken += nr_pages;\n\t\t\tnr_zone_taken[page_zonenum(page)] += nr_pages;\n\t\t\tlist_move(&page->lru, dst);\n\t\t\tbreak;\n\n\t\tcase -EBUSY:\n\t\t\t/* else it is being freed elsewhere */\n\t\t\tlist_move(&page->lru, src);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/*\n\t * Splice any skipped pages to the start of the LRU list. Note that\n\t * this disrupts the LRU order when reclaiming for lower zones but\n\t * we cannot splice to the tail. If we did then the SWAP_CLUSTER_MAX\n\t * scanning would soon rescan the same pages to skip and put the\n\t * system at risk of premature OOM.\n\t */\n\tif (!list_empty(&pages_skipped)) {\n\t\tint zid;\n\n\t\tlist_splice(&pages_skipped, src);\n\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\tif (!nr_skipped[zid])\n\t\t\t\tcontinue;\n\n\t\t\t__count_zid_vm_events(PGSCAN_SKIP, zid, nr_skipped[zid]);\n\t\t\tskipped += nr_skipped[zid];\n\t\t}\n\t}\n\t*nr_scanned = total_scan;\n\ttrace_mm_vmscan_lru_isolate(sc->reclaim_idx, sc->order, nr_to_scan,\n\t\t\t\t    total_scan, skipped, nr_taken, mode, lru);\n\tupdate_lru_sizes(lruvec, lru, nr_zone_taken);\n\treturn nr_taken;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_lru_sizes",
          "args": [
            "lruvec",
            "lru",
            "nr_zone_taken"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "update_lru_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1628-1643",
          "snippet": "static __always_inline void update_lru_sizes(struct lruvec *lruvec,\n\t\t\tenum lru_list lru, unsigned long *nr_zone_taken)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tif (!nr_zone_taken[zid])\n\t\t\tcontinue;\n\n\t\t__update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#ifdef CONFIG_MEMCG\n\t\tmem_cgroup_update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#endif\n\t}\n\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic __always_inline void update_lru_sizes(struct lruvec *lruvec,\n\t\t\tenum lru_list lru, unsigned long *nr_zone_taken)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tif (!nr_zone_taken[zid])\n\t\t\tcontinue;\n\n\t\t__update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#ifdef CONFIG_MEMCG\n\t\tmem_cgroup_update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#endif\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_lru_isolate",
          "args": [
            "sc->reclaim_idx",
            "sc->order",
            "nr_to_scan",
            "total_scan",
            "skipped",
            "nr_taken",
            "mode",
            "lru"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_zid_vm_events",
          "args": [
            "PGSCAN_SKIP",
            "zid",
            "nr_skipped[zid]"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&pages_skipped",
            "src"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pages_skipped"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "src"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zonenum",
          "args": [
            "page"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__isolate_lru_page",
          "args": [
            "page",
            "mode"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "__isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1556-1621",
          "snippet": "int __isolate_lru_page(struct page *page, isolate_mode_t mode)\n{\n\tint ret = -EINVAL;\n\n\t/* Only take pages on the LRU. */\n\tif (!PageLRU(page))\n\t\treturn ret;\n\n\t/* Compaction should not handle unevictable pages but CMA can do so */\n\tif (PageUnevictable(page) && !(mode & ISOLATE_UNEVICTABLE))\n\t\treturn ret;\n\n\tret = -EBUSY;\n\n\t/*\n\t * To minimise LRU disruption, the caller can indicate that it only\n\t * wants to isolate pages it will be able to operate on without\n\t * blocking - clean pages for the most part.\n\t *\n\t * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages\n\t * that it is possible to migrate without blocking\n\t */\n\tif (mode & ISOLATE_ASYNC_MIGRATE) {\n\t\t/* All the caller can do on PageWriteback is block */\n\t\tif (PageWriteback(page))\n\t\t\treturn ret;\n\n\t\tif (PageDirty(page)) {\n\t\t\tstruct address_space *mapping;\n\t\t\tbool migrate_dirty;\n\n\t\t\t/*\n\t\t\t * Only pages without mappings or that have a\n\t\t\t * ->migratepage callback are possible to migrate\n\t\t\t * without blocking. However, we can be racing with\n\t\t\t * truncation so it's necessary to lock the page\n\t\t\t * to stabilise the mapping as truncation holds\n\t\t\t * the page lock until after the page is removed\n\t\t\t * from the page cache.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn ret;\n\n\t\t\tmapping = page_mapping(page);\n\t\t\tmigrate_dirty = !mapping || mapping->a_ops->migratepage;\n\t\t\tunlock_page(page);\n\t\t\tif (!migrate_dirty)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((mode & ISOLATE_UNMAPPED) && page_mapped(page))\n\t\treturn ret;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\t/*\n\t\t * Be careful not to clear PageLRU until after we're\n\t\t * sure the page is not being freed elsewhere -- the\n\t\t * page release code relies on it.\n\t\t */\n\t\tClearPageLRU(page);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __isolate_lru_page(struct page *page, isolate_mode_t mode)\n{\n\tint ret = -EINVAL;\n\n\t/* Only take pages on the LRU. */\n\tif (!PageLRU(page))\n\t\treturn ret;\n\n\t/* Compaction should not handle unevictable pages but CMA can do so */\n\tif (PageUnevictable(page) && !(mode & ISOLATE_UNEVICTABLE))\n\t\treturn ret;\n\n\tret = -EBUSY;\n\n\t/*\n\t * To minimise LRU disruption, the caller can indicate that it only\n\t * wants to isolate pages it will be able to operate on without\n\t * blocking - clean pages for the most part.\n\t *\n\t * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages\n\t * that it is possible to migrate without blocking\n\t */\n\tif (mode & ISOLATE_ASYNC_MIGRATE) {\n\t\t/* All the caller can do on PageWriteback is block */\n\t\tif (PageWriteback(page))\n\t\t\treturn ret;\n\n\t\tif (PageDirty(page)) {\n\t\t\tstruct address_space *mapping;\n\t\t\tbool migrate_dirty;\n\n\t\t\t/*\n\t\t\t * Only pages without mappings or that have a\n\t\t\t * ->migratepage callback are possible to migrate\n\t\t\t * without blocking. However, we can be racing with\n\t\t\t * truncation so it's necessary to lock the page\n\t\t\t * to stabilise the mapping as truncation holds\n\t\t\t * the page lock until after the page is removed\n\t\t\t * from the page cache.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn ret;\n\n\t\t\tmapping = page_mapping(page);\n\t\t\tmigrate_dirty = !mapping || mapping->a_ops->migratepage;\n\t\t\tunlock_page(page);\n\t\t\tif (!migrate_dirty)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((mode & ISOLATE_UNMAPPED) && page_mapped(page))\n\t\treturn ret;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\t/*\n\t\t * Be careful not to clear PageLRU until after we're\n\t\t * sure the page is not being freed elsewhere -- the\n\t\t * page release code relies on it.\n\t\t */\n\t\tClearPageLRU(page);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zonenum",
          "args": [
            "page"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zonenum",
          "args": [
            "page"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLRU(page)",
            "page"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefetchw_prev_lru_page",
          "args": [
            "page",
            "src",
            "flags"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "src"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pages_skipped"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long isolate_lru_pages(unsigned long nr_to_scan,\n\t\tstruct lruvec *lruvec, struct list_head *dst,\n\t\tunsigned long *nr_scanned, struct scan_control *sc,\n\t\tisolate_mode_t mode, enum lru_list lru)\n{\n\tstruct list_head *src = &lruvec->lists[lru];\n\tunsigned long nr_taken = 0;\n\tunsigned long nr_zone_taken[MAX_NR_ZONES] = { 0 };\n\tunsigned long nr_skipped[MAX_NR_ZONES] = { 0, };\n\tunsigned long skipped = 0;\n\tunsigned long scan, total_scan, nr_pages;\n\tLIST_HEAD(pages_skipped);\n\n\tscan = 0;\n\tfor (total_scan = 0;\n\t     scan < nr_to_scan && nr_taken < nr_to_scan && !list_empty(src);\n\t     total_scan++) {\n\t\tstruct page *page;\n\n\t\tpage = lru_to_page(src);\n\t\tprefetchw_prev_lru_page(page, src, flags);\n\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\n\t\tif (page_zonenum(page) > sc->reclaim_idx) {\n\t\t\tlist_move(&page->lru, &pages_skipped);\n\t\t\tnr_skipped[page_zonenum(page)]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Do not count skipped pages because that makes the function\n\t\t * return with no isolated pages if the LRU mostly contains\n\t\t * ineligible pages.  This causes the VM to not reclaim any\n\t\t * pages, triggering a premature OOM.\n\t\t */\n\t\tscan++;\n\t\tswitch (__isolate_lru_page(page, mode)) {\n\t\tcase 0:\n\t\t\tnr_pages = hpage_nr_pages(page);\n\t\t\tnr_taken += nr_pages;\n\t\t\tnr_zone_taken[page_zonenum(page)] += nr_pages;\n\t\t\tlist_move(&page->lru, dst);\n\t\t\tbreak;\n\n\t\tcase -EBUSY:\n\t\t\t/* else it is being freed elsewhere */\n\t\t\tlist_move(&page->lru, src);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/*\n\t * Splice any skipped pages to the start of the LRU list. Note that\n\t * this disrupts the LRU order when reclaiming for lower zones but\n\t * we cannot splice to the tail. If we did then the SWAP_CLUSTER_MAX\n\t * scanning would soon rescan the same pages to skip and put the\n\t * system at risk of premature OOM.\n\t */\n\tif (!list_empty(&pages_skipped)) {\n\t\tint zid;\n\n\t\tlist_splice(&pages_skipped, src);\n\t\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\t\tif (!nr_skipped[zid])\n\t\t\t\tcontinue;\n\n\t\t\t__count_zid_vm_events(PGSCAN_SKIP, zid, nr_skipped[zid]);\n\t\t\tskipped += nr_skipped[zid];\n\t\t}\n\t}\n\t*nr_scanned = total_scan;\n\ttrace_mm_vmscan_lru_isolate(sc->reclaim_idx, sc->order, nr_to_scan,\n\t\t\t\t    total_scan, skipped, nr_taken, mode, lru);\n\tupdate_lru_sizes(lruvec, lru, nr_zone_taken);\n\treturn nr_taken;\n}"
  },
  {
    "function_name": "update_lru_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1628-1643",
    "snippet": "static __always_inline void update_lru_sizes(struct lruvec *lruvec,\n\t\t\tenum lru_list lru, unsigned long *nr_zone_taken)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tif (!nr_zone_taken[zid])\n\t\t\tcontinue;\n\n\t\t__update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#ifdef CONFIG_MEMCG\n\t\tmem_cgroup_update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#endif\n\t}\n\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_update_lru_size",
          "args": [
            "lruvec",
            "lru",
            "zid",
            "-nr_zone_taken[zid]"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_update_lru_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1143-1169",
          "snippet": "void mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,\n\t\t\t\tint zid, int nr_pages)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tunsigned long *lru_size;\n\tlong size;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);\n\tlru_size = &mz->lru_zone_size[zid][lru];\n\n\tif (nr_pages < 0)\n\t\t*lru_size += nr_pages;\n\n\tsize = *lru_size;\n\tif (WARN_ONCE(size < 0,\n\t\t\"%s(%p, %d, %d): lru_size %ld\\n\",\n\t\t__func__, lruvec, lru, nr_pages, size)) {\n\t\tVM_BUG_ON(1);\n\t\t*lru_size = 0;\n\t}\n\n\tif (nr_pages > 0)\n\t\t*lru_size += nr_pages;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,\n\t\t\t\tint zid, int nr_pages)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tunsigned long *lru_size;\n\tlong size;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);\n\tlru_size = &mz->lru_zone_size[zid][lru];\n\n\tif (nr_pages < 0)\n\t\t*lru_size += nr_pages;\n\n\tsize = *lru_size;\n\tif (WARN_ONCE(size < 0,\n\t\t\"%s(%p, %d, %d): lru_size %ld\\n\",\n\t\t__func__, lruvec, lru, nr_pages, size)) {\n\t\tVM_BUG_ON(1);\n\t\t*lru_size = 0;\n\t}\n\n\tif (nr_pages > 0)\n\t\t*lru_size += nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_lru_size",
          "args": [
            "lruvec",
            "lru",
            "zid",
            "-nr_zone_taken[zid]"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic __always_inline void update_lru_sizes(struct lruvec *lruvec,\n\t\t\tenum lru_list lru, unsigned long *nr_zone_taken)\n{\n\tint zid;\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tif (!nr_zone_taken[zid])\n\t\t\tcontinue;\n\n\t\t__update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#ifdef CONFIG_MEMCG\n\t\tmem_cgroup_update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);\n#endif\n\t}\n\n}"
  },
  {
    "function_name": "__isolate_lru_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1556-1621",
    "snippet": "int __isolate_lru_page(struct page *page, isolate_mode_t mode)\n{\n\tint ret = -EINVAL;\n\n\t/* Only take pages on the LRU. */\n\tif (!PageLRU(page))\n\t\treturn ret;\n\n\t/* Compaction should not handle unevictable pages but CMA can do so */\n\tif (PageUnevictable(page) && !(mode & ISOLATE_UNEVICTABLE))\n\t\treturn ret;\n\n\tret = -EBUSY;\n\n\t/*\n\t * To minimise LRU disruption, the caller can indicate that it only\n\t * wants to isolate pages it will be able to operate on without\n\t * blocking - clean pages for the most part.\n\t *\n\t * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages\n\t * that it is possible to migrate without blocking\n\t */\n\tif (mode & ISOLATE_ASYNC_MIGRATE) {\n\t\t/* All the caller can do on PageWriteback is block */\n\t\tif (PageWriteback(page))\n\t\t\treturn ret;\n\n\t\tif (PageDirty(page)) {\n\t\t\tstruct address_space *mapping;\n\t\t\tbool migrate_dirty;\n\n\t\t\t/*\n\t\t\t * Only pages without mappings or that have a\n\t\t\t * ->migratepage callback are possible to migrate\n\t\t\t * without blocking. However, we can be racing with\n\t\t\t * truncation so it's necessary to lock the page\n\t\t\t * to stabilise the mapping as truncation holds\n\t\t\t * the page lock until after the page is removed\n\t\t\t * from the page cache.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn ret;\n\n\t\t\tmapping = page_mapping(page);\n\t\t\tmigrate_dirty = !mapping || mapping->a_ops->migratepage;\n\t\t\tunlock_page(page);\n\t\t\tif (!migrate_dirty)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((mode & ISOLATE_UNMAPPED) && page_mapped(page))\n\t\treturn ret;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\t/*\n\t\t * Be careful not to clear PageLRU until after we're\n\t\t * sure the page is not being freed elsewhere -- the\n\t\t * page release code relies on it.\n\t\t */\n\t\tClearPageLRU(page);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "get_page_unless_zero(page)"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __isolate_lru_page(struct page *page, isolate_mode_t mode)\n{\n\tint ret = -EINVAL;\n\n\t/* Only take pages on the LRU. */\n\tif (!PageLRU(page))\n\t\treturn ret;\n\n\t/* Compaction should not handle unevictable pages but CMA can do so */\n\tif (PageUnevictable(page) && !(mode & ISOLATE_UNEVICTABLE))\n\t\treturn ret;\n\n\tret = -EBUSY;\n\n\t/*\n\t * To minimise LRU disruption, the caller can indicate that it only\n\t * wants to isolate pages it will be able to operate on without\n\t * blocking - clean pages for the most part.\n\t *\n\t * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages\n\t * that it is possible to migrate without blocking\n\t */\n\tif (mode & ISOLATE_ASYNC_MIGRATE) {\n\t\t/* All the caller can do on PageWriteback is block */\n\t\tif (PageWriteback(page))\n\t\t\treturn ret;\n\n\t\tif (PageDirty(page)) {\n\t\t\tstruct address_space *mapping;\n\t\t\tbool migrate_dirty;\n\n\t\t\t/*\n\t\t\t * Only pages without mappings or that have a\n\t\t\t * ->migratepage callback are possible to migrate\n\t\t\t * without blocking. However, we can be racing with\n\t\t\t * truncation so it's necessary to lock the page\n\t\t\t * to stabilise the mapping as truncation holds\n\t\t\t * the page lock until after the page is removed\n\t\t\t * from the page cache.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn ret;\n\n\t\t\tmapping = page_mapping(page);\n\t\t\tmigrate_dirty = !mapping || mapping->a_ops->migratepage;\n\t\t\tunlock_page(page);\n\t\t\tif (!migrate_dirty)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((mode & ISOLATE_UNMAPPED) && page_mapped(page))\n\t\treturn ret;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\t/*\n\t\t * Be careful not to clear PageLRU until after we're\n\t\t * sure the page is not being freed elsewhere -- the\n\t\t * page release code relies on it.\n\t\t */\n\t\tClearPageLRU(page);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "reclaim_clean_pages_from_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1519-1544",
    "snippet": "unsigned long reclaim_clean_pages_from_list(struct zone *zone,\n\t\t\t\t\t    struct list_head *page_list)\n{\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_unmap = 1,\n\t};\n\tunsigned long ret;\n\tstruct page *page, *next;\n\tLIST_HEAD(clean_pages);\n\n\tlist_for_each_entry_safe(page, next, page_list, lru) {\n\t\tif (page_is_file_cache(page) && !PageDirty(page) &&\n\t\t    !__PageMovable(page)) {\n\t\t\tClearPageActive(page);\n\t\t\tlist_move(&page->lru, &clean_pages);\n\t\t}\n\t}\n\n\tret = shrink_page_list(&clean_pages, zone->zone_pgdat, &sc,\n\t\t\tTTU_IGNORE_ACCESS, NULL, true);\n\tlist_splice(&clean_pages, page_list);\n\tmod_node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE, -ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "zone->zone_pgdat",
            "NR_ISOLATED_FILE",
            "-ret"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "644-652",
          "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&clean_pages",
            "page_list"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_page_list",
          "args": [
            "&clean_pages",
            "zone->zone_pgdat",
            "&sc",
            "TTU_IGNORE_ACCESS",
            "NULL",
            "true"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1106-1517",
          "snippet": "static unsigned long shrink_page_list(struct list_head *page_list,\n\t\t\t\t      struct pglist_data *pgdat,\n\t\t\t\t      struct scan_control *sc,\n\t\t\t\t      enum ttu_flags ttu_flags,\n\t\t\t\t      struct reclaim_stat *stat,\n\t\t\t\t      bool force_reclaim)\n{\n\tLIST_HEAD(ret_pages);\n\tLIST_HEAD(free_pages);\n\tint pgactivate = 0;\n\tunsigned nr_unqueued_dirty = 0;\n\tunsigned nr_dirty = 0;\n\tunsigned nr_congested = 0;\n\tunsigned nr_reclaimed = 0;\n\tunsigned nr_writeback = 0;\n\tunsigned nr_immediate = 0;\n\tunsigned nr_ref_keep = 0;\n\tunsigned nr_unmap_fail = 0;\n\n\tcond_resched();\n\n\twhile (!list_empty(page_list)) {\n\t\tstruct address_space *mapping;\n\t\tstruct page *page;\n\t\tint may_enter_fs;\n\t\tenum page_references references = PAGEREF_RECLAIM_CLEAN;\n\t\tbool dirty, writeback;\n\n\t\tcond_resched();\n\n\t\tpage = lru_to_page(page_list);\n\t\tlist_del(&page->lru);\n\n\t\tif (!trylock_page(page))\n\t\t\tgoto keep;\n\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\n\t\tsc->nr_scanned++;\n\n\t\tif (unlikely(!page_evictable(page)))\n\t\t\tgoto activate_locked;\n\n\t\tif (!sc->may_unmap && page_mapped(page))\n\t\t\tgoto keep_locked;\n\n\t\t/* Double the slab pressure for mapped and swapcache pages */\n\t\tif ((page_mapped(page) || PageSwapCache(page)) &&\n\t\t    !(PageAnon(page) && !PageSwapBacked(page)))\n\t\t\tsc->nr_scanned++;\n\n\t\tmay_enter_fs = (sc->gfp_mask & __GFP_FS) ||\n\t\t\t(PageSwapCache(page) && (sc->gfp_mask & __GFP_IO));\n\n\t\t/*\n\t\t * The number of dirty pages determines if a node is marked\n\t\t * reclaim_congested which affects wait_iff_congested. kswapd\n\t\t * will stall and start writing pages if the tail of the LRU\n\t\t * is all dirty unqueued pages.\n\t\t */\n\t\tpage_check_dirty_writeback(page, &dirty, &writeback);\n\t\tif (dirty || writeback)\n\t\t\tnr_dirty++;\n\n\t\tif (dirty && !writeback)\n\t\t\tnr_unqueued_dirty++;\n\n\t\t/*\n\t\t * Treat this page as congested if the underlying BDI is or if\n\t\t * pages are cycling through the LRU so quickly that the\n\t\t * pages marked for immediate reclaim are making it to the\n\t\t * end of the LRU a second time.\n\t\t */\n\t\tmapping = page_mapping(page);\n\t\tif (((dirty || writeback) && mapping &&\n\t\t     inode_write_congested(mapping->host)) ||\n\t\t    (writeback && PageReclaim(page)))\n\t\t\tnr_congested++;\n\n\t\t/*\n\t\t * If a page at the tail of the LRU is under writeback, there\n\t\t * are three cases to consider.\n\t\t *\n\t\t * 1) If reclaim is encountering an excessive number of pages\n\t\t *    under writeback and this page is both under writeback and\n\t\t *    PageReclaim then it indicates that pages are being queued\n\t\t *    for IO but are being recycled through the LRU before the\n\t\t *    IO can complete. Waiting on the page itself risks an\n\t\t *    indefinite stall if it is impossible to writeback the\n\t\t *    page due to IO error or disconnected storage so instead\n\t\t *    note that the LRU is being scanned too quickly and the\n\t\t *    caller can stall after page list has been processed.\n\t\t *\n\t\t * 2) Global or new memcg reclaim encounters a page that is\n\t\t *    not marked for immediate reclaim, or the caller does not\n\t\t *    have __GFP_FS (or __GFP_IO if it's simply going to swap,\n\t\t *    not to fs). In this case mark the page for immediate\n\t\t *    reclaim and continue scanning.\n\t\t *\n\t\t *    Require may_enter_fs because we would wait on fs, which\n\t\t *    may not have submitted IO yet. And the loop driver might\n\t\t *    enter reclaim, and deadlock if it waits on a page for\n\t\t *    which it is needed to do the write (loop masks off\n\t\t *    __GFP_IO|__GFP_FS for this reason); but more thought\n\t\t *    would probably show more reasons.\n\t\t *\n\t\t * 3) Legacy memcg encounters a page that is already marked\n\t\t *    PageReclaim. memcg does not have any dirty pages\n\t\t *    throttling so we could easily OOM just because too many\n\t\t *    pages are in writeback and there is nothing else to\n\t\t *    reclaim. Wait for the writeback to complete.\n\t\t *\n\t\t * In cases 1) and 2) we activate the pages to get them out of\n\t\t * the way while we continue scanning for clean pages on the\n\t\t * inactive list and refilling from the active list. The\n\t\t * observation here is that waiting for disk writes is more\n\t\t * expensive than potentially causing reloads down the line.\n\t\t * Since they're marked for immediate reclaim, they won't put\n\t\t * memory pressure on the cache working set any longer than it\n\t\t * takes to write them to disk.\n\t\t */\n\t\tif (PageWriteback(page)) {\n\t\t\t/* Case 1 above */\n\t\t\tif (current_is_kswapd() &&\n\t\t\t    PageReclaim(page) &&\n\t\t\t    test_bit(PGDAT_WRITEBACK, &pgdat->flags)) {\n\t\t\t\tnr_immediate++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 2 above */\n\t\t\t} else if (sane_reclaim(sc) ||\n\t\t\t    !PageReclaim(page) || !may_enter_fs) {\n\t\t\t\t/*\n\t\t\t\t * This is slightly racy - end_page_writeback()\n\t\t\t\t * might have just cleared PageReclaim, then\n\t\t\t\t * setting PageReclaim here end up interpreted\n\t\t\t\t * as PageReadahead - but that does not matter\n\t\t\t\t * enough to care.  What we do want is for this\n\t\t\t\t * page to have PageReclaim set next time memcg\n\t\t\t\t * reclaim reaches the tests above, so it will\n\t\t\t\t * then wait_on_page_writeback() to avoid OOM;\n\t\t\t\t * and it's also appropriate in global reclaim.\n\t\t\t\t */\n\t\t\t\tSetPageReclaim(page);\n\t\t\t\tnr_writeback++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 3 above */\n\t\t\t} else {\n\t\t\t\tunlock_page(page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t\t/* then go back and try same page again */\n\t\t\t\tlist_add_tail(&page->lru, page_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!force_reclaim)\n\t\t\treferences = page_check_references(page, sc);\n\n\t\tswitch (references) {\n\t\tcase PAGEREF_ACTIVATE:\n\t\t\tgoto activate_locked;\n\t\tcase PAGEREF_KEEP:\n\t\t\tnr_ref_keep++;\n\t\t\tgoto keep_locked;\n\t\tcase PAGEREF_RECLAIM:\n\t\tcase PAGEREF_RECLAIM_CLEAN:\n\t\t\t; /* try to reclaim the page below */\n\t\t}\n\n\t\t/*\n\t\t * Anonymous process memory has backing store?\n\t\t * Try to allocate it some swap space here.\n\t\t * Lazyfree page could be freed directly\n\t\t */\n\t\tif (PageAnon(page) && PageSwapBacked(page)) {\n\t\t\tif (!PageSwapCache(page)) {\n\t\t\t\tif (!(sc->gfp_mask & __GFP_IO))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tif (PageTransHuge(page)) {\n\t\t\t\t\t/* cannot split THP, skip it */\n\t\t\t\t\tif (!can_split_huge_page(page, NULL))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/*\n\t\t\t\t\t * Split pages without a PMD map right\n\t\t\t\t\t * away. Chances are some or all of the\n\t\t\t\t\t * tail pages can be freed without IO.\n\t\t\t\t\t */\n\t\t\t\t\tif (!compound_mapcount(page) &&\n\t\t\t\t\t    split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\t\t\t\tif (!add_to_swap(page)) {\n\t\t\t\t\tif (!PageTransHuge(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/* Fallback to swap normal pages */\n\t\t\t\t\tif (split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\t\tcount_vm_event(THP_SWPOUT_FALLBACK);\n#endif\n\t\t\t\t\tif (!add_to_swap(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\n\t\t\t\tmay_enter_fs = 1;\n\n\t\t\t\t/* Adding to swap updated mapping */\n\t\t\t\tmapping = page_mapping(page);\n\t\t\t}\n\t\t} else if (unlikely(PageTransHuge(page))) {\n\t\t\t/* Split file THP */\n\t\t\tif (split_huge_page_to_list(page, page_list))\n\t\t\t\tgoto keep_locked;\n\t\t}\n\n\t\t/*\n\t\t * The page is mapped into the page tables of one or more\n\t\t * processes. Try to unmap it here.\n\t\t */\n\t\tif (page_mapped(page)) {\n\t\t\tenum ttu_flags flags = ttu_flags | TTU_BATCH_FLUSH;\n\n\t\t\tif (unlikely(PageTransHuge(page)))\n\t\t\t\tflags |= TTU_SPLIT_HUGE_PMD;\n\t\t\tif (!try_to_unmap(page, flags)) {\n\t\t\t\tnr_unmap_fail++;\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\t\t}\n\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * Only kswapd can writeback filesystem pages\n\t\t\t * to avoid risk of stack overflow. But avoid\n\t\t\t * injecting inefficient single-page IO into\n\t\t\t * flusher writeback as much as possible: only\n\t\t\t * write pages when we've encountered many\n\t\t\t * dirty pages, and when we've already scanned\n\t\t\t * the rest of the LRU for clean pages and see\n\t\t\t * the same dirty pages again (PageReclaim).\n\t\t\t */\n\t\t\tif (page_is_file_cache(page) &&\n\t\t\t    (!current_is_kswapd() || !PageReclaim(page) ||\n\t\t\t     !test_bit(PGDAT_DIRTY, &pgdat->flags))) {\n\t\t\t\t/*\n\t\t\t\t * Immediately reclaim when written back.\n\t\t\t\t * Similar in principal to deactivate_page()\n\t\t\t\t * except we already have the page isolated\n\t\t\t\t * and know it's dirty\n\t\t\t\t */\n\t\t\t\tinc_node_page_state(page, NR_VMSCAN_IMMEDIATE);\n\t\t\t\tSetPageReclaim(page);\n\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\n\t\t\tif (references == PAGEREF_RECLAIM_CLEAN)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!may_enter_fs)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!sc->may_writepage)\n\t\t\t\tgoto keep_locked;\n\n\t\t\t/*\n\t\t\t * Page is dirty. Flush the TLB if a writable entry\n\t\t\t * potentially exists to avoid CPU writes after IO\n\t\t\t * starts and then write it out here.\n\t\t\t */\n\t\t\ttry_to_unmap_flush_dirty();\n\t\t\tswitch (pageout(page, mapping, sc)) {\n\t\t\tcase PAGE_KEEP:\n\t\t\t\tgoto keep_locked;\n\t\t\tcase PAGE_ACTIVATE:\n\t\t\t\tgoto activate_locked;\n\t\t\tcase PAGE_SUCCESS:\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tgoto keep;\n\n\t\t\t\t/*\n\t\t\t\t * A synchronous write - probably a ramdisk.  Go\n\t\t\t\t * ahead and try to reclaim the page.\n\t\t\t\t */\n\t\t\t\tif (!trylock_page(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tmapping = page_mapping(page);\n\t\t\tcase PAGE_CLEAN:\n\t\t\t\t; /* try to free the page below */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the page has buffers, try to free the buffer mappings\n\t\t * associated with this page. If we succeed we try to free\n\t\t * the page as well.\n\t\t *\n\t\t * We do this even if the page is PageDirty().\n\t\t * try_to_release_page() does not perform I/O, but it is\n\t\t * possible for a page to have PageDirty set, but it is actually\n\t\t * clean (all its buffers are clean).  This happens if the\n\t\t * buffers were written out directly, with submit_bh(). ext3\n\t\t * will do this, as well as the blockdev mapping.\n\t\t * try_to_release_page() will discover that cleanness and will\n\t\t * drop the buffers and mark the page clean - it can be freed.\n\t\t *\n\t\t * Rarely, pages can have buffers and no ->mapping.  These are\n\t\t * the pages which were not successfully invalidated in\n\t\t * truncate_complete_page().  We try to drop those buffers here\n\t\t * and if that worked, and the page is no longer mapped into\n\t\t * process address space (page_count == 1) it can be freed.\n\t\t * Otherwise, leave the page on the LRU so it is swappable.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (!try_to_release_page(page, sc->gfp_mask))\n\t\t\t\tgoto activate_locked;\n\t\t\tif (!mapping && page_count(page) == 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (put_page_testzero(page))\n\t\t\t\t\tgoto free_it;\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * rare race with speculative reference.\n\t\t\t\t\t * the speculative reference will free\n\t\t\t\t\t * this page shortly, so we may\n\t\t\t\t\t * increment nr_reclaimed here (and\n\t\t\t\t\t * leave it off the LRU).\n\t\t\t\t\t */\n\t\t\t\t\tnr_reclaimed++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PageAnon(page) && !PageSwapBacked(page)) {\n\t\t\t/* follow __remove_mapping for reference */\n\t\t\tif (!page_ref_freeze(page, 1))\n\t\t\t\tgoto keep_locked;\n\t\t\tif (PageDirty(page)) {\n\t\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\t\tgoto keep_locked;\n\t\t\t}\n\n\t\t\tcount_vm_event(PGLAZYFREED);\n\t\t\tcount_memcg_page_event(page, PGLAZYFREED);\n\t\t} else if (!mapping || !__remove_mapping(mapping, page, true))\n\t\t\tgoto keep_locked;\n\t\t/*\n\t\t * At this point, we have no other references and there is\n\t\t * no way to pick any more up (removed from LRU, removed\n\t\t * from pagecache). Can use non-atomic bitops now (and\n\t\t * we obviously don't have to worry about waking up a process\n\t\t * waiting on the page lock, because there are no references.\n\t\t */\n\t\t__ClearPageLocked(page);\nfree_it:\n\t\tnr_reclaimed++;\n\n\t\t/*\n\t\t * Is there need to periodically free_page_list? It would\n\t\t * appear not as the counts should be low\n\t\t */\n\t\tif (unlikely(PageTransHuge(page))) {\n\t\t\tmem_cgroup_uncharge(page);\n\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t} else\n\t\t\tlist_add(&page->lru, &free_pages);\n\t\tcontinue;\n\nactivate_locked:\n\t\t/* Not a candidate for swapping, so reclaim swap space. */\n\t\tif (PageSwapCache(page) && (mem_cgroup_swap_full(page) ||\n\t\t\t\t\t\tPageMlocked(page)))\n\t\t\ttry_to_free_swap(page);\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\tif (!PageMlocked(page)) {\n\t\t\tSetPageActive(page);\n\t\t\tpgactivate++;\n\t\t\tcount_memcg_page_event(page, PGACTIVATE);\n\t\t}\nkeep_locked:\n\t\tunlock_page(page);\nkeep:\n\t\tlist_add(&page->lru, &ret_pages);\n\t\tVM_BUG_ON_PAGE(PageLRU(page) || PageUnevictable(page), page);\n\t}\n\n\tmem_cgroup_uncharge_list(&free_pages);\n\ttry_to_unmap_flush();\n\tfree_unref_page_list(&free_pages);\n\n\tlist_splice(&ret_pages, page_list);\n\tcount_vm_events(PGACTIVATE, pgactivate);\n\n\tif (stat) {\n\t\tstat->nr_dirty = nr_dirty;\n\t\tstat->nr_congested = nr_congested;\n\t\tstat->nr_unqueued_dirty = nr_unqueued_dirty;\n\t\tstat->nr_writeback = nr_writeback;\n\t\tstat->nr_immediate = nr_immediate;\n\t\tstat->nr_activate = pgactivate;\n\t\tstat->nr_ref_keep = nr_ref_keep;\n\t\tstat->nr_unmap_fail = nr_unmap_fail;\n\t}\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long shrink_page_list(struct list_head *page_list,\n\t\t\t\t      struct pglist_data *pgdat,\n\t\t\t\t      struct scan_control *sc,\n\t\t\t\t      enum ttu_flags ttu_flags,\n\t\t\t\t      struct reclaim_stat *stat,\n\t\t\t\t      bool force_reclaim)\n{\n\tLIST_HEAD(ret_pages);\n\tLIST_HEAD(free_pages);\n\tint pgactivate = 0;\n\tunsigned nr_unqueued_dirty = 0;\n\tunsigned nr_dirty = 0;\n\tunsigned nr_congested = 0;\n\tunsigned nr_reclaimed = 0;\n\tunsigned nr_writeback = 0;\n\tunsigned nr_immediate = 0;\n\tunsigned nr_ref_keep = 0;\n\tunsigned nr_unmap_fail = 0;\n\n\tcond_resched();\n\n\twhile (!list_empty(page_list)) {\n\t\tstruct address_space *mapping;\n\t\tstruct page *page;\n\t\tint may_enter_fs;\n\t\tenum page_references references = PAGEREF_RECLAIM_CLEAN;\n\t\tbool dirty, writeback;\n\n\t\tcond_resched();\n\n\t\tpage = lru_to_page(page_list);\n\t\tlist_del(&page->lru);\n\n\t\tif (!trylock_page(page))\n\t\t\tgoto keep;\n\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\n\t\tsc->nr_scanned++;\n\n\t\tif (unlikely(!page_evictable(page)))\n\t\t\tgoto activate_locked;\n\n\t\tif (!sc->may_unmap && page_mapped(page))\n\t\t\tgoto keep_locked;\n\n\t\t/* Double the slab pressure for mapped and swapcache pages */\n\t\tif ((page_mapped(page) || PageSwapCache(page)) &&\n\t\t    !(PageAnon(page) && !PageSwapBacked(page)))\n\t\t\tsc->nr_scanned++;\n\n\t\tmay_enter_fs = (sc->gfp_mask & __GFP_FS) ||\n\t\t\t(PageSwapCache(page) && (sc->gfp_mask & __GFP_IO));\n\n\t\t/*\n\t\t * The number of dirty pages determines if a node is marked\n\t\t * reclaim_congested which affects wait_iff_congested. kswapd\n\t\t * will stall and start writing pages if the tail of the LRU\n\t\t * is all dirty unqueued pages.\n\t\t */\n\t\tpage_check_dirty_writeback(page, &dirty, &writeback);\n\t\tif (dirty || writeback)\n\t\t\tnr_dirty++;\n\n\t\tif (dirty && !writeback)\n\t\t\tnr_unqueued_dirty++;\n\n\t\t/*\n\t\t * Treat this page as congested if the underlying BDI is or if\n\t\t * pages are cycling through the LRU so quickly that the\n\t\t * pages marked for immediate reclaim are making it to the\n\t\t * end of the LRU a second time.\n\t\t */\n\t\tmapping = page_mapping(page);\n\t\tif (((dirty || writeback) && mapping &&\n\t\t     inode_write_congested(mapping->host)) ||\n\t\t    (writeback && PageReclaim(page)))\n\t\t\tnr_congested++;\n\n\t\t/*\n\t\t * If a page at the tail of the LRU is under writeback, there\n\t\t * are three cases to consider.\n\t\t *\n\t\t * 1) If reclaim is encountering an excessive number of pages\n\t\t *    under writeback and this page is both under writeback and\n\t\t *    PageReclaim then it indicates that pages are being queued\n\t\t *    for IO but are being recycled through the LRU before the\n\t\t *    IO can complete. Waiting on the page itself risks an\n\t\t *    indefinite stall if it is impossible to writeback the\n\t\t *    page due to IO error or disconnected storage so instead\n\t\t *    note that the LRU is being scanned too quickly and the\n\t\t *    caller can stall after page list has been processed.\n\t\t *\n\t\t * 2) Global or new memcg reclaim encounters a page that is\n\t\t *    not marked for immediate reclaim, or the caller does not\n\t\t *    have __GFP_FS (or __GFP_IO if it's simply going to swap,\n\t\t *    not to fs). In this case mark the page for immediate\n\t\t *    reclaim and continue scanning.\n\t\t *\n\t\t *    Require may_enter_fs because we would wait on fs, which\n\t\t *    may not have submitted IO yet. And the loop driver might\n\t\t *    enter reclaim, and deadlock if it waits on a page for\n\t\t *    which it is needed to do the write (loop masks off\n\t\t *    __GFP_IO|__GFP_FS for this reason); but more thought\n\t\t *    would probably show more reasons.\n\t\t *\n\t\t * 3) Legacy memcg encounters a page that is already marked\n\t\t *    PageReclaim. memcg does not have any dirty pages\n\t\t *    throttling so we could easily OOM just because too many\n\t\t *    pages are in writeback and there is nothing else to\n\t\t *    reclaim. Wait for the writeback to complete.\n\t\t *\n\t\t * In cases 1) and 2) we activate the pages to get them out of\n\t\t * the way while we continue scanning for clean pages on the\n\t\t * inactive list and refilling from the active list. The\n\t\t * observation here is that waiting for disk writes is more\n\t\t * expensive than potentially causing reloads down the line.\n\t\t * Since they're marked for immediate reclaim, they won't put\n\t\t * memory pressure on the cache working set any longer than it\n\t\t * takes to write them to disk.\n\t\t */\n\t\tif (PageWriteback(page)) {\n\t\t\t/* Case 1 above */\n\t\t\tif (current_is_kswapd() &&\n\t\t\t    PageReclaim(page) &&\n\t\t\t    test_bit(PGDAT_WRITEBACK, &pgdat->flags)) {\n\t\t\t\tnr_immediate++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 2 above */\n\t\t\t} else if (sane_reclaim(sc) ||\n\t\t\t    !PageReclaim(page) || !may_enter_fs) {\n\t\t\t\t/*\n\t\t\t\t * This is slightly racy - end_page_writeback()\n\t\t\t\t * might have just cleared PageReclaim, then\n\t\t\t\t * setting PageReclaim here end up interpreted\n\t\t\t\t * as PageReadahead - but that does not matter\n\t\t\t\t * enough to care.  What we do want is for this\n\t\t\t\t * page to have PageReclaim set next time memcg\n\t\t\t\t * reclaim reaches the tests above, so it will\n\t\t\t\t * then wait_on_page_writeback() to avoid OOM;\n\t\t\t\t * and it's also appropriate in global reclaim.\n\t\t\t\t */\n\t\t\t\tSetPageReclaim(page);\n\t\t\t\tnr_writeback++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 3 above */\n\t\t\t} else {\n\t\t\t\tunlock_page(page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t\t/* then go back and try same page again */\n\t\t\t\tlist_add_tail(&page->lru, page_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!force_reclaim)\n\t\t\treferences = page_check_references(page, sc);\n\n\t\tswitch (references) {\n\t\tcase PAGEREF_ACTIVATE:\n\t\t\tgoto activate_locked;\n\t\tcase PAGEREF_KEEP:\n\t\t\tnr_ref_keep++;\n\t\t\tgoto keep_locked;\n\t\tcase PAGEREF_RECLAIM:\n\t\tcase PAGEREF_RECLAIM_CLEAN:\n\t\t\t; /* try to reclaim the page below */\n\t\t}\n\n\t\t/*\n\t\t * Anonymous process memory has backing store?\n\t\t * Try to allocate it some swap space here.\n\t\t * Lazyfree page could be freed directly\n\t\t */\n\t\tif (PageAnon(page) && PageSwapBacked(page)) {\n\t\t\tif (!PageSwapCache(page)) {\n\t\t\t\tif (!(sc->gfp_mask & __GFP_IO))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tif (PageTransHuge(page)) {\n\t\t\t\t\t/* cannot split THP, skip it */\n\t\t\t\t\tif (!can_split_huge_page(page, NULL))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/*\n\t\t\t\t\t * Split pages without a PMD map right\n\t\t\t\t\t * away. Chances are some or all of the\n\t\t\t\t\t * tail pages can be freed without IO.\n\t\t\t\t\t */\n\t\t\t\t\tif (!compound_mapcount(page) &&\n\t\t\t\t\t    split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\t\t\t\tif (!add_to_swap(page)) {\n\t\t\t\t\tif (!PageTransHuge(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/* Fallback to swap normal pages */\n\t\t\t\t\tif (split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\t\tcount_vm_event(THP_SWPOUT_FALLBACK);\n#endif\n\t\t\t\t\tif (!add_to_swap(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\n\t\t\t\tmay_enter_fs = 1;\n\n\t\t\t\t/* Adding to swap updated mapping */\n\t\t\t\tmapping = page_mapping(page);\n\t\t\t}\n\t\t} else if (unlikely(PageTransHuge(page))) {\n\t\t\t/* Split file THP */\n\t\t\tif (split_huge_page_to_list(page, page_list))\n\t\t\t\tgoto keep_locked;\n\t\t}\n\n\t\t/*\n\t\t * The page is mapped into the page tables of one or more\n\t\t * processes. Try to unmap it here.\n\t\t */\n\t\tif (page_mapped(page)) {\n\t\t\tenum ttu_flags flags = ttu_flags | TTU_BATCH_FLUSH;\n\n\t\t\tif (unlikely(PageTransHuge(page)))\n\t\t\t\tflags |= TTU_SPLIT_HUGE_PMD;\n\t\t\tif (!try_to_unmap(page, flags)) {\n\t\t\t\tnr_unmap_fail++;\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\t\t}\n\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * Only kswapd can writeback filesystem pages\n\t\t\t * to avoid risk of stack overflow. But avoid\n\t\t\t * injecting inefficient single-page IO into\n\t\t\t * flusher writeback as much as possible: only\n\t\t\t * write pages when we've encountered many\n\t\t\t * dirty pages, and when we've already scanned\n\t\t\t * the rest of the LRU for clean pages and see\n\t\t\t * the same dirty pages again (PageReclaim).\n\t\t\t */\n\t\t\tif (page_is_file_cache(page) &&\n\t\t\t    (!current_is_kswapd() || !PageReclaim(page) ||\n\t\t\t     !test_bit(PGDAT_DIRTY, &pgdat->flags))) {\n\t\t\t\t/*\n\t\t\t\t * Immediately reclaim when written back.\n\t\t\t\t * Similar in principal to deactivate_page()\n\t\t\t\t * except we already have the page isolated\n\t\t\t\t * and know it's dirty\n\t\t\t\t */\n\t\t\t\tinc_node_page_state(page, NR_VMSCAN_IMMEDIATE);\n\t\t\t\tSetPageReclaim(page);\n\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\n\t\t\tif (references == PAGEREF_RECLAIM_CLEAN)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!may_enter_fs)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!sc->may_writepage)\n\t\t\t\tgoto keep_locked;\n\n\t\t\t/*\n\t\t\t * Page is dirty. Flush the TLB if a writable entry\n\t\t\t * potentially exists to avoid CPU writes after IO\n\t\t\t * starts and then write it out here.\n\t\t\t */\n\t\t\ttry_to_unmap_flush_dirty();\n\t\t\tswitch (pageout(page, mapping, sc)) {\n\t\t\tcase PAGE_KEEP:\n\t\t\t\tgoto keep_locked;\n\t\t\tcase PAGE_ACTIVATE:\n\t\t\t\tgoto activate_locked;\n\t\t\tcase PAGE_SUCCESS:\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tgoto keep;\n\n\t\t\t\t/*\n\t\t\t\t * A synchronous write - probably a ramdisk.  Go\n\t\t\t\t * ahead and try to reclaim the page.\n\t\t\t\t */\n\t\t\t\tif (!trylock_page(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tmapping = page_mapping(page);\n\t\t\tcase PAGE_CLEAN:\n\t\t\t\t; /* try to free the page below */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the page has buffers, try to free the buffer mappings\n\t\t * associated with this page. If we succeed we try to free\n\t\t * the page as well.\n\t\t *\n\t\t * We do this even if the page is PageDirty().\n\t\t * try_to_release_page() does not perform I/O, but it is\n\t\t * possible for a page to have PageDirty set, but it is actually\n\t\t * clean (all its buffers are clean).  This happens if the\n\t\t * buffers were written out directly, with submit_bh(). ext3\n\t\t * will do this, as well as the blockdev mapping.\n\t\t * try_to_release_page() will discover that cleanness and will\n\t\t * drop the buffers and mark the page clean - it can be freed.\n\t\t *\n\t\t * Rarely, pages can have buffers and no ->mapping.  These are\n\t\t * the pages which were not successfully invalidated in\n\t\t * truncate_complete_page().  We try to drop those buffers here\n\t\t * and if that worked, and the page is no longer mapped into\n\t\t * process address space (page_count == 1) it can be freed.\n\t\t * Otherwise, leave the page on the LRU so it is swappable.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (!try_to_release_page(page, sc->gfp_mask))\n\t\t\t\tgoto activate_locked;\n\t\t\tif (!mapping && page_count(page) == 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (put_page_testzero(page))\n\t\t\t\t\tgoto free_it;\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * rare race with speculative reference.\n\t\t\t\t\t * the speculative reference will free\n\t\t\t\t\t * this page shortly, so we may\n\t\t\t\t\t * increment nr_reclaimed here (and\n\t\t\t\t\t * leave it off the LRU).\n\t\t\t\t\t */\n\t\t\t\t\tnr_reclaimed++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PageAnon(page) && !PageSwapBacked(page)) {\n\t\t\t/* follow __remove_mapping for reference */\n\t\t\tif (!page_ref_freeze(page, 1))\n\t\t\t\tgoto keep_locked;\n\t\t\tif (PageDirty(page)) {\n\t\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\t\tgoto keep_locked;\n\t\t\t}\n\n\t\t\tcount_vm_event(PGLAZYFREED);\n\t\t\tcount_memcg_page_event(page, PGLAZYFREED);\n\t\t} else if (!mapping || !__remove_mapping(mapping, page, true))\n\t\t\tgoto keep_locked;\n\t\t/*\n\t\t * At this point, we have no other references and there is\n\t\t * no way to pick any more up (removed from LRU, removed\n\t\t * from pagecache). Can use non-atomic bitops now (and\n\t\t * we obviously don't have to worry about waking up a process\n\t\t * waiting on the page lock, because there are no references.\n\t\t */\n\t\t__ClearPageLocked(page);\nfree_it:\n\t\tnr_reclaimed++;\n\n\t\t/*\n\t\t * Is there need to periodically free_page_list? It would\n\t\t * appear not as the counts should be low\n\t\t */\n\t\tif (unlikely(PageTransHuge(page))) {\n\t\t\tmem_cgroup_uncharge(page);\n\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t} else\n\t\t\tlist_add(&page->lru, &free_pages);\n\t\tcontinue;\n\nactivate_locked:\n\t\t/* Not a candidate for swapping, so reclaim swap space. */\n\t\tif (PageSwapCache(page) && (mem_cgroup_swap_full(page) ||\n\t\t\t\t\t\tPageMlocked(page)))\n\t\t\ttry_to_free_swap(page);\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\tif (!PageMlocked(page)) {\n\t\t\tSetPageActive(page);\n\t\t\tpgactivate++;\n\t\t\tcount_memcg_page_event(page, PGACTIVATE);\n\t\t}\nkeep_locked:\n\t\tunlock_page(page);\nkeep:\n\t\tlist_add(&page->lru, &ret_pages);\n\t\tVM_BUG_ON_PAGE(PageLRU(page) || PageUnevictable(page), page);\n\t}\n\n\tmem_cgroup_uncharge_list(&free_pages);\n\ttry_to_unmap_flush();\n\tfree_unref_page_list(&free_pages);\n\n\tlist_splice(&ret_pages, page_list);\n\tcount_vm_events(PGACTIVATE, pgactivate);\n\n\tif (stat) {\n\t\tstat->nr_dirty = nr_dirty;\n\t\tstat->nr_congested = nr_congested;\n\t\tstat->nr_unqueued_dirty = nr_unqueued_dirty;\n\t\tstat->nr_writeback = nr_writeback;\n\t\tstat->nr_immediate = nr_immediate;\n\t\tstat->nr_activate = pgactivate;\n\t\tstat->nr_ref_keep = nr_ref_keep;\n\t\tstat->nr_unmap_fail = nr_unmap_fail;\n\t}\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&clean_pages"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "page_list",
            "lru"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "clean_pages"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long reclaim_clean_pages_from_list(struct zone *zone,\n\t\t\t\t\t    struct list_head *page_list)\n{\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_unmap = 1,\n\t};\n\tunsigned long ret;\n\tstruct page *page, *next;\n\tLIST_HEAD(clean_pages);\n\n\tlist_for_each_entry_safe(page, next, page_list, lru) {\n\t\tif (page_is_file_cache(page) && !PageDirty(page) &&\n\t\t    !__PageMovable(page)) {\n\t\t\tClearPageActive(page);\n\t\t\tlist_move(&page->lru, &clean_pages);\n\t\t}\n\t}\n\n\tret = shrink_page_list(&clean_pages, zone->zone_pgdat, &sc,\n\t\t\tTTU_IGNORE_ACCESS, NULL, true);\n\tlist_splice(&clean_pages, page_list);\n\tmod_node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE, -ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "shrink_page_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1106-1517",
    "snippet": "static unsigned long shrink_page_list(struct list_head *page_list,\n\t\t\t\t      struct pglist_data *pgdat,\n\t\t\t\t      struct scan_control *sc,\n\t\t\t\t      enum ttu_flags ttu_flags,\n\t\t\t\t      struct reclaim_stat *stat,\n\t\t\t\t      bool force_reclaim)\n{\n\tLIST_HEAD(ret_pages);\n\tLIST_HEAD(free_pages);\n\tint pgactivate = 0;\n\tunsigned nr_unqueued_dirty = 0;\n\tunsigned nr_dirty = 0;\n\tunsigned nr_congested = 0;\n\tunsigned nr_reclaimed = 0;\n\tunsigned nr_writeback = 0;\n\tunsigned nr_immediate = 0;\n\tunsigned nr_ref_keep = 0;\n\tunsigned nr_unmap_fail = 0;\n\n\tcond_resched();\n\n\twhile (!list_empty(page_list)) {\n\t\tstruct address_space *mapping;\n\t\tstruct page *page;\n\t\tint may_enter_fs;\n\t\tenum page_references references = PAGEREF_RECLAIM_CLEAN;\n\t\tbool dirty, writeback;\n\n\t\tcond_resched();\n\n\t\tpage = lru_to_page(page_list);\n\t\tlist_del(&page->lru);\n\n\t\tif (!trylock_page(page))\n\t\t\tgoto keep;\n\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\n\t\tsc->nr_scanned++;\n\n\t\tif (unlikely(!page_evictable(page)))\n\t\t\tgoto activate_locked;\n\n\t\tif (!sc->may_unmap && page_mapped(page))\n\t\t\tgoto keep_locked;\n\n\t\t/* Double the slab pressure for mapped and swapcache pages */\n\t\tif ((page_mapped(page) || PageSwapCache(page)) &&\n\t\t    !(PageAnon(page) && !PageSwapBacked(page)))\n\t\t\tsc->nr_scanned++;\n\n\t\tmay_enter_fs = (sc->gfp_mask & __GFP_FS) ||\n\t\t\t(PageSwapCache(page) && (sc->gfp_mask & __GFP_IO));\n\n\t\t/*\n\t\t * The number of dirty pages determines if a node is marked\n\t\t * reclaim_congested which affects wait_iff_congested. kswapd\n\t\t * will stall and start writing pages if the tail of the LRU\n\t\t * is all dirty unqueued pages.\n\t\t */\n\t\tpage_check_dirty_writeback(page, &dirty, &writeback);\n\t\tif (dirty || writeback)\n\t\t\tnr_dirty++;\n\n\t\tif (dirty && !writeback)\n\t\t\tnr_unqueued_dirty++;\n\n\t\t/*\n\t\t * Treat this page as congested if the underlying BDI is or if\n\t\t * pages are cycling through the LRU so quickly that the\n\t\t * pages marked for immediate reclaim are making it to the\n\t\t * end of the LRU a second time.\n\t\t */\n\t\tmapping = page_mapping(page);\n\t\tif (((dirty || writeback) && mapping &&\n\t\t     inode_write_congested(mapping->host)) ||\n\t\t    (writeback && PageReclaim(page)))\n\t\t\tnr_congested++;\n\n\t\t/*\n\t\t * If a page at the tail of the LRU is under writeback, there\n\t\t * are three cases to consider.\n\t\t *\n\t\t * 1) If reclaim is encountering an excessive number of pages\n\t\t *    under writeback and this page is both under writeback and\n\t\t *    PageReclaim then it indicates that pages are being queued\n\t\t *    for IO but are being recycled through the LRU before the\n\t\t *    IO can complete. Waiting on the page itself risks an\n\t\t *    indefinite stall if it is impossible to writeback the\n\t\t *    page due to IO error or disconnected storage so instead\n\t\t *    note that the LRU is being scanned too quickly and the\n\t\t *    caller can stall after page list has been processed.\n\t\t *\n\t\t * 2) Global or new memcg reclaim encounters a page that is\n\t\t *    not marked for immediate reclaim, or the caller does not\n\t\t *    have __GFP_FS (or __GFP_IO if it's simply going to swap,\n\t\t *    not to fs). In this case mark the page for immediate\n\t\t *    reclaim and continue scanning.\n\t\t *\n\t\t *    Require may_enter_fs because we would wait on fs, which\n\t\t *    may not have submitted IO yet. And the loop driver might\n\t\t *    enter reclaim, and deadlock if it waits on a page for\n\t\t *    which it is needed to do the write (loop masks off\n\t\t *    __GFP_IO|__GFP_FS for this reason); but more thought\n\t\t *    would probably show more reasons.\n\t\t *\n\t\t * 3) Legacy memcg encounters a page that is already marked\n\t\t *    PageReclaim. memcg does not have any dirty pages\n\t\t *    throttling so we could easily OOM just because too many\n\t\t *    pages are in writeback and there is nothing else to\n\t\t *    reclaim. Wait for the writeback to complete.\n\t\t *\n\t\t * In cases 1) and 2) we activate the pages to get them out of\n\t\t * the way while we continue scanning for clean pages on the\n\t\t * inactive list and refilling from the active list. The\n\t\t * observation here is that waiting for disk writes is more\n\t\t * expensive than potentially causing reloads down the line.\n\t\t * Since they're marked for immediate reclaim, they won't put\n\t\t * memory pressure on the cache working set any longer than it\n\t\t * takes to write them to disk.\n\t\t */\n\t\tif (PageWriteback(page)) {\n\t\t\t/* Case 1 above */\n\t\t\tif (current_is_kswapd() &&\n\t\t\t    PageReclaim(page) &&\n\t\t\t    test_bit(PGDAT_WRITEBACK, &pgdat->flags)) {\n\t\t\t\tnr_immediate++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 2 above */\n\t\t\t} else if (sane_reclaim(sc) ||\n\t\t\t    !PageReclaim(page) || !may_enter_fs) {\n\t\t\t\t/*\n\t\t\t\t * This is slightly racy - end_page_writeback()\n\t\t\t\t * might have just cleared PageReclaim, then\n\t\t\t\t * setting PageReclaim here end up interpreted\n\t\t\t\t * as PageReadahead - but that does not matter\n\t\t\t\t * enough to care.  What we do want is for this\n\t\t\t\t * page to have PageReclaim set next time memcg\n\t\t\t\t * reclaim reaches the tests above, so it will\n\t\t\t\t * then wait_on_page_writeback() to avoid OOM;\n\t\t\t\t * and it's also appropriate in global reclaim.\n\t\t\t\t */\n\t\t\t\tSetPageReclaim(page);\n\t\t\t\tnr_writeback++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 3 above */\n\t\t\t} else {\n\t\t\t\tunlock_page(page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t\t/* then go back and try same page again */\n\t\t\t\tlist_add_tail(&page->lru, page_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!force_reclaim)\n\t\t\treferences = page_check_references(page, sc);\n\n\t\tswitch (references) {\n\t\tcase PAGEREF_ACTIVATE:\n\t\t\tgoto activate_locked;\n\t\tcase PAGEREF_KEEP:\n\t\t\tnr_ref_keep++;\n\t\t\tgoto keep_locked;\n\t\tcase PAGEREF_RECLAIM:\n\t\tcase PAGEREF_RECLAIM_CLEAN:\n\t\t\t; /* try to reclaim the page below */\n\t\t}\n\n\t\t/*\n\t\t * Anonymous process memory has backing store?\n\t\t * Try to allocate it some swap space here.\n\t\t * Lazyfree page could be freed directly\n\t\t */\n\t\tif (PageAnon(page) && PageSwapBacked(page)) {\n\t\t\tif (!PageSwapCache(page)) {\n\t\t\t\tif (!(sc->gfp_mask & __GFP_IO))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tif (PageTransHuge(page)) {\n\t\t\t\t\t/* cannot split THP, skip it */\n\t\t\t\t\tif (!can_split_huge_page(page, NULL))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/*\n\t\t\t\t\t * Split pages without a PMD map right\n\t\t\t\t\t * away. Chances are some or all of the\n\t\t\t\t\t * tail pages can be freed without IO.\n\t\t\t\t\t */\n\t\t\t\t\tif (!compound_mapcount(page) &&\n\t\t\t\t\t    split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\t\t\t\tif (!add_to_swap(page)) {\n\t\t\t\t\tif (!PageTransHuge(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/* Fallback to swap normal pages */\n\t\t\t\t\tif (split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\t\tcount_vm_event(THP_SWPOUT_FALLBACK);\n#endif\n\t\t\t\t\tif (!add_to_swap(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\n\t\t\t\tmay_enter_fs = 1;\n\n\t\t\t\t/* Adding to swap updated mapping */\n\t\t\t\tmapping = page_mapping(page);\n\t\t\t}\n\t\t} else if (unlikely(PageTransHuge(page))) {\n\t\t\t/* Split file THP */\n\t\t\tif (split_huge_page_to_list(page, page_list))\n\t\t\t\tgoto keep_locked;\n\t\t}\n\n\t\t/*\n\t\t * The page is mapped into the page tables of one or more\n\t\t * processes. Try to unmap it here.\n\t\t */\n\t\tif (page_mapped(page)) {\n\t\t\tenum ttu_flags flags = ttu_flags | TTU_BATCH_FLUSH;\n\n\t\t\tif (unlikely(PageTransHuge(page)))\n\t\t\t\tflags |= TTU_SPLIT_HUGE_PMD;\n\t\t\tif (!try_to_unmap(page, flags)) {\n\t\t\t\tnr_unmap_fail++;\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\t\t}\n\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * Only kswapd can writeback filesystem pages\n\t\t\t * to avoid risk of stack overflow. But avoid\n\t\t\t * injecting inefficient single-page IO into\n\t\t\t * flusher writeback as much as possible: only\n\t\t\t * write pages when we've encountered many\n\t\t\t * dirty pages, and when we've already scanned\n\t\t\t * the rest of the LRU for clean pages and see\n\t\t\t * the same dirty pages again (PageReclaim).\n\t\t\t */\n\t\t\tif (page_is_file_cache(page) &&\n\t\t\t    (!current_is_kswapd() || !PageReclaim(page) ||\n\t\t\t     !test_bit(PGDAT_DIRTY, &pgdat->flags))) {\n\t\t\t\t/*\n\t\t\t\t * Immediately reclaim when written back.\n\t\t\t\t * Similar in principal to deactivate_page()\n\t\t\t\t * except we already have the page isolated\n\t\t\t\t * and know it's dirty\n\t\t\t\t */\n\t\t\t\tinc_node_page_state(page, NR_VMSCAN_IMMEDIATE);\n\t\t\t\tSetPageReclaim(page);\n\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\n\t\t\tif (references == PAGEREF_RECLAIM_CLEAN)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!may_enter_fs)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!sc->may_writepage)\n\t\t\t\tgoto keep_locked;\n\n\t\t\t/*\n\t\t\t * Page is dirty. Flush the TLB if a writable entry\n\t\t\t * potentially exists to avoid CPU writes after IO\n\t\t\t * starts and then write it out here.\n\t\t\t */\n\t\t\ttry_to_unmap_flush_dirty();\n\t\t\tswitch (pageout(page, mapping, sc)) {\n\t\t\tcase PAGE_KEEP:\n\t\t\t\tgoto keep_locked;\n\t\t\tcase PAGE_ACTIVATE:\n\t\t\t\tgoto activate_locked;\n\t\t\tcase PAGE_SUCCESS:\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tgoto keep;\n\n\t\t\t\t/*\n\t\t\t\t * A synchronous write - probably a ramdisk.  Go\n\t\t\t\t * ahead and try to reclaim the page.\n\t\t\t\t */\n\t\t\t\tif (!trylock_page(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tmapping = page_mapping(page);\n\t\t\tcase PAGE_CLEAN:\n\t\t\t\t; /* try to free the page below */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the page has buffers, try to free the buffer mappings\n\t\t * associated with this page. If we succeed we try to free\n\t\t * the page as well.\n\t\t *\n\t\t * We do this even if the page is PageDirty().\n\t\t * try_to_release_page() does not perform I/O, but it is\n\t\t * possible for a page to have PageDirty set, but it is actually\n\t\t * clean (all its buffers are clean).  This happens if the\n\t\t * buffers were written out directly, with submit_bh(). ext3\n\t\t * will do this, as well as the blockdev mapping.\n\t\t * try_to_release_page() will discover that cleanness and will\n\t\t * drop the buffers and mark the page clean - it can be freed.\n\t\t *\n\t\t * Rarely, pages can have buffers and no ->mapping.  These are\n\t\t * the pages which were not successfully invalidated in\n\t\t * truncate_complete_page().  We try to drop those buffers here\n\t\t * and if that worked, and the page is no longer mapped into\n\t\t * process address space (page_count == 1) it can be freed.\n\t\t * Otherwise, leave the page on the LRU so it is swappable.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (!try_to_release_page(page, sc->gfp_mask))\n\t\t\t\tgoto activate_locked;\n\t\t\tif (!mapping && page_count(page) == 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (put_page_testzero(page))\n\t\t\t\t\tgoto free_it;\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * rare race with speculative reference.\n\t\t\t\t\t * the speculative reference will free\n\t\t\t\t\t * this page shortly, so we may\n\t\t\t\t\t * increment nr_reclaimed here (and\n\t\t\t\t\t * leave it off the LRU).\n\t\t\t\t\t */\n\t\t\t\t\tnr_reclaimed++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PageAnon(page) && !PageSwapBacked(page)) {\n\t\t\t/* follow __remove_mapping for reference */\n\t\t\tif (!page_ref_freeze(page, 1))\n\t\t\t\tgoto keep_locked;\n\t\t\tif (PageDirty(page)) {\n\t\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\t\tgoto keep_locked;\n\t\t\t}\n\n\t\t\tcount_vm_event(PGLAZYFREED);\n\t\t\tcount_memcg_page_event(page, PGLAZYFREED);\n\t\t} else if (!mapping || !__remove_mapping(mapping, page, true))\n\t\t\tgoto keep_locked;\n\t\t/*\n\t\t * At this point, we have no other references and there is\n\t\t * no way to pick any more up (removed from LRU, removed\n\t\t * from pagecache). Can use non-atomic bitops now (and\n\t\t * we obviously don't have to worry about waking up a process\n\t\t * waiting on the page lock, because there are no references.\n\t\t */\n\t\t__ClearPageLocked(page);\nfree_it:\n\t\tnr_reclaimed++;\n\n\t\t/*\n\t\t * Is there need to periodically free_page_list? It would\n\t\t * appear not as the counts should be low\n\t\t */\n\t\tif (unlikely(PageTransHuge(page))) {\n\t\t\tmem_cgroup_uncharge(page);\n\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t} else\n\t\t\tlist_add(&page->lru, &free_pages);\n\t\tcontinue;\n\nactivate_locked:\n\t\t/* Not a candidate for swapping, so reclaim swap space. */\n\t\tif (PageSwapCache(page) && (mem_cgroup_swap_full(page) ||\n\t\t\t\t\t\tPageMlocked(page)))\n\t\t\ttry_to_free_swap(page);\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\tif (!PageMlocked(page)) {\n\t\t\tSetPageActive(page);\n\t\t\tpgactivate++;\n\t\t\tcount_memcg_page_event(page, PGACTIVATE);\n\t\t}\nkeep_locked:\n\t\tunlock_page(page);\nkeep:\n\t\tlist_add(&page->lru, &ret_pages);\n\t\tVM_BUG_ON_PAGE(PageLRU(page) || PageUnevictable(page), page);\n\t}\n\n\tmem_cgroup_uncharge_list(&free_pages);\n\ttry_to_unmap_flush();\n\tfree_unref_page_list(&free_pages);\n\n\tlist_splice(&ret_pages, page_list);\n\tcount_vm_events(PGACTIVATE, pgactivate);\n\n\tif (stat) {\n\t\tstat->nr_dirty = nr_dirty;\n\t\tstat->nr_congested = nr_congested;\n\t\tstat->nr_unqueued_dirty = nr_unqueued_dirty;\n\t\tstat->nr_writeback = nr_writeback;\n\t\tstat->nr_immediate = nr_immediate;\n\t\tstat->nr_activate = pgactivate;\n\t\tstat->nr_ref_keep = nr_ref_keep;\n\t\tstat->nr_unmap_fail = nr_unmap_fail;\n\t}\n\treturn nr_reclaimed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "PGACTIVATE",
            "pgactivate"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&ret_pages",
            "page_list"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_unref_page_list",
          "args": [
            "&free_pages"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2803-2836",
          "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_unmap_flush",
          "args": [],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap_flush_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "506-508",
          "snippet": "static inline void try_to_unmap_flush_dirty(void)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void try_to_unmap_flush_dirty(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge_list",
          "args": [
            "&free_pages"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page) || PageUnevictable(page)",
            "page"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&ret_pages"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_memcg_page_event",
          "args": [
            "page",
            "PGACTIVATE"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageActive",
          "args": [
            "page"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageActive(page)",
            "page"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "page"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1584-1617",
          "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_swap_full",
          "args": [
            "page"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_swap_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6532-6552",
          "snippet": "bool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nbool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&free_pages"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compound_page_dtor",
          "args": [
            "page"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageTransHuge(page)"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageLocked",
          "args": [
            "page"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_mapping",
          "args": [
            "mapping",
            "page",
            "true"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "885-974",
          "snippet": "static int __remove_mapping(struct address_space *mapping, struct page *page,\n\t\t\t    bool reclaimed)\n{\n\tunsigned long flags;\n\tint refcount;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(mapping != page_mapping(page));\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t/*\n\t * The non racy check for a busy page.\n\t *\n\t * Must be careful with the order of the tests. When someone has\n\t * a ref to the page, it may be possible that they dirty it then\n\t * drop the reference. So if PageDirty is tested before page_count\n\t * here, then the following race may occur:\n\t *\n\t * get_user_pages(&page);\n\t * [user mapping goes away]\n\t * write_to(page);\n\t *\t\t\t\t!PageDirty(page)    [good]\n\t * SetPageDirty(page);\n\t * put_page(page);\n\t *\t\t\t\t!page_count(page)   [good, discard it]\n\t *\n\t * [oops, our write_to data is lost]\n\t *\n\t * Reversing the order of the tests ensures such a situation cannot\n\t * escape unnoticed. The smp_rmb is needed to ensure the page->flags\n\t * load is not satisfied before that of page->_refcount.\n\t *\n\t * Note that if SetPageDirty is always performed via set_page_dirty,\n\t * and thus under the i_pages lock, then this ordering is not required.\n\t */\n\tif (unlikely(PageTransHuge(page)) && PageSwapCache(page))\n\t\trefcount = 1 + HPAGE_PMD_NR;\n\telse\n\t\trefcount = 2;\n\tif (!page_ref_freeze(page, refcount))\n\t\tgoto cannot_free;\n\t/* note: atomic_cmpxchg in page_ref_freeze provides the smp_rmb */\n\tif (unlikely(PageDirty(page))) {\n\t\tpage_ref_unfreeze(page, refcount);\n\t\tgoto cannot_free;\n\t}\n\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t swap = { .val = page_private(page) };\n\t\tmem_cgroup_swapout(page, swap);\n\t\t__delete_from_swap_cache(page, swap);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tput_swap_page(page, swap);\n\t} else {\n\t\tvoid (*freepage)(struct page *);\n\t\tvoid *shadow = NULL;\n\n\t\tfreepage = mapping->a_ops->freepage;\n\t\t/*\n\t\t * Remember a shadow entry for reclaimed file cache in\n\t\t * order to detect refaults, thus thrashing, later on.\n\t\t *\n\t\t * But don't store shadows in an address space that is\n\t\t * already exiting.  This is not just an optizimation,\n\t\t * inode reclaim needs to empty out the radix tree or\n\t\t * the nodes are lost.  Don't plant shadows behind its\n\t\t * back.\n\t\t *\n\t\t * We also don't store shadows for DAX mappings because the\n\t\t * only page cache pages found in these are zero pages\n\t\t * covering holes, and because we don't want to mix DAX\n\t\t * exceptional entries and shadow exceptional entries in the\n\t\t * same address_space.\n\t\t */\n\t\tif (reclaimed && page_is_file_cache(page) &&\n\t\t    !mapping_exiting(mapping) && !dax_mapping(mapping))\n\t\t\tshadow = workingset_eviction(mapping, page);\n\t\t__delete_from_page_cache(page, shadow);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\t\tif (freepage != NULL)\n\t\t\tfreepage(page);\n\t}\n\n\treturn 1;\n\ncannot_free:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int __remove_mapping(struct address_space *mapping, struct page *page,\n\t\t\t    bool reclaimed)\n{\n\tunsigned long flags;\n\tint refcount;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(mapping != page_mapping(page));\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t/*\n\t * The non racy check for a busy page.\n\t *\n\t * Must be careful with the order of the tests. When someone has\n\t * a ref to the page, it may be possible that they dirty it then\n\t * drop the reference. So if PageDirty is tested before page_count\n\t * here, then the following race may occur:\n\t *\n\t * get_user_pages(&page);\n\t * [user mapping goes away]\n\t * write_to(page);\n\t *\t\t\t\t!PageDirty(page)    [good]\n\t * SetPageDirty(page);\n\t * put_page(page);\n\t *\t\t\t\t!page_count(page)   [good, discard it]\n\t *\n\t * [oops, our write_to data is lost]\n\t *\n\t * Reversing the order of the tests ensures such a situation cannot\n\t * escape unnoticed. The smp_rmb is needed to ensure the page->flags\n\t * load is not satisfied before that of page->_refcount.\n\t *\n\t * Note that if SetPageDirty is always performed via set_page_dirty,\n\t * and thus under the i_pages lock, then this ordering is not required.\n\t */\n\tif (unlikely(PageTransHuge(page)) && PageSwapCache(page))\n\t\trefcount = 1 + HPAGE_PMD_NR;\n\telse\n\t\trefcount = 2;\n\tif (!page_ref_freeze(page, refcount))\n\t\tgoto cannot_free;\n\t/* note: atomic_cmpxchg in page_ref_freeze provides the smp_rmb */\n\tif (unlikely(PageDirty(page))) {\n\t\tpage_ref_unfreeze(page, refcount);\n\t\tgoto cannot_free;\n\t}\n\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t swap = { .val = page_private(page) };\n\t\tmem_cgroup_swapout(page, swap);\n\t\t__delete_from_swap_cache(page, swap);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tput_swap_page(page, swap);\n\t} else {\n\t\tvoid (*freepage)(struct page *);\n\t\tvoid *shadow = NULL;\n\n\t\tfreepage = mapping->a_ops->freepage;\n\t\t/*\n\t\t * Remember a shadow entry for reclaimed file cache in\n\t\t * order to detect refaults, thus thrashing, later on.\n\t\t *\n\t\t * But don't store shadows in an address space that is\n\t\t * already exiting.  This is not just an optizimation,\n\t\t * inode reclaim needs to empty out the radix tree or\n\t\t * the nodes are lost.  Don't plant shadows behind its\n\t\t * back.\n\t\t *\n\t\t * We also don't store shadows for DAX mappings because the\n\t\t * only page cache pages found in these are zero pages\n\t\t * covering holes, and because we don't want to mix DAX\n\t\t * exceptional entries and shadow exceptional entries in the\n\t\t * same address_space.\n\t\t */\n\t\tif (reclaimed && page_is_file_cache(page) &&\n\t\t    !mapping_exiting(mapping) && !dax_mapping(mapping))\n\t\t\tshadow = workingset_eviction(mapping, page);\n\t\t__delete_from_page_cache(page, shadow);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\t\tif (freepage != NULL)\n\t\t\tfreepage(page);\n\t}\n\n\treturn 1;\n\ncannot_free:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_memcg_page_event",
          "args": [
            "page",
            "PGLAZYFREED"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGLAZYFREED"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "page",
            "1"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "page",
            "1"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page_testzero",
          "args": [
            "page"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "sc->gfp_mask"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3319-3330",
          "snippet": "int try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageout",
          "args": [
            "page",
            "mapping",
            "sc"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "pageout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "810-879",
          "snippet": "static pageout_t pageout(struct page *page, struct address_space *mapping,\n\t\t\t struct scan_control *sc)\n{\n\t/*\n\t * If the page is dirty, only perform writeback if that write\n\t * will be non-blocking.  To prevent this allocation from being\n\t * stalled by pagecache activity.  But note that there may be\n\t * stalls if we need to run get_block().  We could test\n\t * PagePrivate for that.\n\t *\n\t * If this process is currently in __generic_file_write_iter() against\n\t * this page's queue, we can perform writeback even if that\n\t * will block.\n\t *\n\t * If the page is swapcache, write it back even if that would\n\t * block, for some throttling. This happens by accident, because\n\t * swap_backing_dev_info is bust: it doesn't reflect the\n\t * congestion state of the swapdevs.  Easy to fix, if needed.\n\t */\n\tif (!is_page_cache_freeable(page))\n\t\treturn PAGE_KEEP;\n\tif (!mapping) {\n\t\t/*\n\t\t * Some data journaling orphaned pages can have\n\t\t * page->mapping == NULL while being dirty with clean buffers.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (try_to_free_buffers(page)) {\n\t\t\t\tClearPageDirty(page);\n\t\t\t\tpr_info(\"%s: orphaned page\\n\", __func__);\n\t\t\t\treturn PAGE_CLEAN;\n\t\t\t}\n\t\t}\n\t\treturn PAGE_KEEP;\n\t}\n\tif (mapping->a_ops->writepage == NULL)\n\t\treturn PAGE_ACTIVATE;\n\tif (!may_write_to_inode(mapping->host, sc))\n\t\treturn PAGE_KEEP;\n\n\tif (clear_page_dirty_for_io(page)) {\n\t\tint res;\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t.nr_to_write = SWAP_CLUSTER_MAX,\n\t\t\t.range_start = 0,\n\t\t\t.range_end = LLONG_MAX,\n\t\t\t.for_reclaim = 1,\n\t\t};\n\n\t\tSetPageReclaim(page);\n\t\tres = mapping->a_ops->writepage(page, &wbc);\n\t\tif (res < 0)\n\t\t\thandle_write_error(mapping, page, res);\n\t\tif (res == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\tClearPageReclaim(page);\n\t\t\treturn PAGE_ACTIVATE;\n\t\t}\n\n\t\tif (!PageWriteback(page)) {\n\t\t\t/* synchronous write or broken a_ops? */\n\t\t\tClearPageReclaim(page);\n\t\t}\n\t\ttrace_mm_vmscan_writepage(page);\n\t\tinc_node_page_state(page, NR_VMSCAN_WRITE);\n\t\treturn PAGE_SUCCESS;\n\t}\n\n\treturn PAGE_CLEAN;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic pageout_t pageout(struct page *page, struct address_space *mapping,\n\t\t\t struct scan_control *sc)\n{\n\t/*\n\t * If the page is dirty, only perform writeback if that write\n\t * will be non-blocking.  To prevent this allocation from being\n\t * stalled by pagecache activity.  But note that there may be\n\t * stalls if we need to run get_block().  We could test\n\t * PagePrivate for that.\n\t *\n\t * If this process is currently in __generic_file_write_iter() against\n\t * this page's queue, we can perform writeback even if that\n\t * will block.\n\t *\n\t * If the page is swapcache, write it back even if that would\n\t * block, for some throttling. This happens by accident, because\n\t * swap_backing_dev_info is bust: it doesn't reflect the\n\t * congestion state of the swapdevs.  Easy to fix, if needed.\n\t */\n\tif (!is_page_cache_freeable(page))\n\t\treturn PAGE_KEEP;\n\tif (!mapping) {\n\t\t/*\n\t\t * Some data journaling orphaned pages can have\n\t\t * page->mapping == NULL while being dirty with clean buffers.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (try_to_free_buffers(page)) {\n\t\t\t\tClearPageDirty(page);\n\t\t\t\tpr_info(\"%s: orphaned page\\n\", __func__);\n\t\t\t\treturn PAGE_CLEAN;\n\t\t\t}\n\t\t}\n\t\treturn PAGE_KEEP;\n\t}\n\tif (mapping->a_ops->writepage == NULL)\n\t\treturn PAGE_ACTIVATE;\n\tif (!may_write_to_inode(mapping->host, sc))\n\t\treturn PAGE_KEEP;\n\n\tif (clear_page_dirty_for_io(page)) {\n\t\tint res;\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t.nr_to_write = SWAP_CLUSTER_MAX,\n\t\t\t.range_start = 0,\n\t\t\t.range_end = LLONG_MAX,\n\t\t\t.for_reclaim = 1,\n\t\t};\n\n\t\tSetPageReclaim(page);\n\t\tres = mapping->a_ops->writepage(page, &wbc);\n\t\tif (res < 0)\n\t\t\thandle_write_error(mapping, page, res);\n\t\tif (res == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\tClearPageReclaim(page);\n\t\t\treturn PAGE_ACTIVATE;\n\t\t}\n\n\t\tif (!PageWriteback(page)) {\n\t\t\t/* synchronous write or broken a_ops? */\n\t\t\tClearPageReclaim(page);\n\t\t}\n\t\ttrace_mm_vmscan_writepage(page);\n\t\tinc_node_page_state(page, NR_VMSCAN_WRITE);\n\t\treturn PAGE_SUCCESS;\n\t}\n\n\treturn PAGE_CLEAN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageReclaim",
          "args": [
            "page"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_node_page_state",
          "args": [
            "page",
            "NR_VMSCAN_IMMEDIATE"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "655-664",
          "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PGDAT_DIRTY",
            "&pgdat->flags"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReclaim",
          "args": [
            "page"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_unmap",
          "args": [
            "page",
            "flags"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1699-1726",
          "snippet": "bool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageTransHuge(page)"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page_to_list",
          "args": [
            "page",
            "page_list"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "split_huge_page_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2620-2744",
          "snippet": "int split_huge_page_to_list(struct page *page, struct list_head *list)\n{\n\tstruct page *head = compound_head(page);\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(head));\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct address_space *mapping = NULL;\n\tint count, mapcount, extra_pins, ret;\n\tbool mlocked;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(is_huge_zero_page(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (PageWriteback(page))\n\t\treturn -EBUSY;\n\n\tif (PageAnon(head)) {\n\t\t/*\n\t\t * The caller does not necessarily hold an mmap_sem that would\n\t\t * prevent the anon_vma disappearing so we first we take a\n\t\t * reference to it and then lock the anon_vma for write. This\n\t\t * is similar to page_lock_anon_vma_read except the write lock\n\t\t * is taken to serialise against parallel split or collapse\n\t\t * operations.\n\t\t */\n\t\tanon_vma = page_get_anon_vma(head);\n\t\tif (!anon_vma) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmapping = NULL;\n\t\tanon_vma_lock_write(anon_vma);\n\t} else {\n\t\tmapping = head->mapping;\n\n\t\t/* Truncated ? */\n\t\tif (!mapping) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tanon_vma = NULL;\n\t\ti_mmap_lock_read(mapping);\n\t}\n\n\t/*\n\t * Racy check if we can split the page, before freeze_page() will\n\t * split PMDs\n\t */\n\tif (!can_split_huge_page(head, &extra_pins)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmlocked = PageMlocked(page);\n\tfreeze_page(head);\n\tVM_BUG_ON_PAGE(compound_mapcount(head), head);\n\n\t/* Make sure the page is not on per-CPU pagevec as it takes pin */\n\tif (mlocked)\n\t\tlru_add_drain();\n\n\t/* prevent PageLRU to go away from under us, and freeze lru stats */\n\tspin_lock_irqsave(zone_lru_lock(page_zone(head)), flags);\n\n\tif (mapping) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(head));\n\n\t\t/*\n\t\t * Check if the head page is present in page cache.\n\t\t * We assume all tail are present too, if head is there.\n\t\t */\n\t\txa_lock(&mapping->i_pages);\n\t\tif (xas_load(&xas) != head)\n\t\t\tgoto fail;\n\t}\n\n\t/* Prevent deferred_split_scan() touching ->_refcount */\n\tspin_lock(&pgdata->split_queue_lock);\n\tcount = page_count(head);\n\tmapcount = total_mapcount(head);\n\tif (!mapcount && page_ref_freeze(head, 1 + extra_pins)) {\n\t\tif (!list_empty(page_deferred_list(head))) {\n\t\t\tpgdata->split_queue_len--;\n\t\t\tlist_del(page_deferred_list(head));\n\t\t}\n\t\tif (mapping)\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t\tspin_unlock(&pgdata->split_queue_lock);\n\t\t__split_huge_page(page, list, flags);\n\t\tif (PageSwapCache(head)) {\n\t\t\tswp_entry_t entry = { .val = page_private(head) };\n\n\t\t\tret = split_swap_cluster(entry);\n\t\t} else\n\t\t\tret = 0;\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount) {\n\t\t\tpr_alert(\"total_mapcount: %u, page_count(): %u\\n\",\n\t\t\t\t\tmapcount, count);\n\t\t\tif (PageTail(page))\n\t\t\t\tdump_page(head, NULL);\n\t\t\tdump_page(page, \"total_mapcount(head) > 0\");\n\t\t\tBUG();\n\t\t}\n\t\tspin_unlock(&pgdata->split_queue_lock);\nfail:\t\tif (mapping)\n\t\t\txa_unlock(&mapping->i_pages);\n\t\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\t\tunfreeze_page(head);\n\t\tret = -EBUSY;\n\t}\n\nout_unlock:\n\tif (anon_vma) {\n\t\tanon_vma_unlock_write(anon_vma);\n\t\tput_anon_vma(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_read(mapping);\nout:\n\tcount_vm_event(!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint split_huge_page_to_list(struct page *page, struct list_head *list)\n{\n\tstruct page *head = compound_head(page);\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(head));\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct address_space *mapping = NULL;\n\tint count, mapcount, extra_pins, ret;\n\tbool mlocked;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(is_huge_zero_page(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (PageWriteback(page))\n\t\treturn -EBUSY;\n\n\tif (PageAnon(head)) {\n\t\t/*\n\t\t * The caller does not necessarily hold an mmap_sem that would\n\t\t * prevent the anon_vma disappearing so we first we take a\n\t\t * reference to it and then lock the anon_vma for write. This\n\t\t * is similar to page_lock_anon_vma_read except the write lock\n\t\t * is taken to serialise against parallel split or collapse\n\t\t * operations.\n\t\t */\n\t\tanon_vma = page_get_anon_vma(head);\n\t\tif (!anon_vma) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmapping = NULL;\n\t\tanon_vma_lock_write(anon_vma);\n\t} else {\n\t\tmapping = head->mapping;\n\n\t\t/* Truncated ? */\n\t\tif (!mapping) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tanon_vma = NULL;\n\t\ti_mmap_lock_read(mapping);\n\t}\n\n\t/*\n\t * Racy check if we can split the page, before freeze_page() will\n\t * split PMDs\n\t */\n\tif (!can_split_huge_page(head, &extra_pins)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmlocked = PageMlocked(page);\n\tfreeze_page(head);\n\tVM_BUG_ON_PAGE(compound_mapcount(head), head);\n\n\t/* Make sure the page is not on per-CPU pagevec as it takes pin */\n\tif (mlocked)\n\t\tlru_add_drain();\n\n\t/* prevent PageLRU to go away from under us, and freeze lru stats */\n\tspin_lock_irqsave(zone_lru_lock(page_zone(head)), flags);\n\n\tif (mapping) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(head));\n\n\t\t/*\n\t\t * Check if the head page is present in page cache.\n\t\t * We assume all tail are present too, if head is there.\n\t\t */\n\t\txa_lock(&mapping->i_pages);\n\t\tif (xas_load(&xas) != head)\n\t\t\tgoto fail;\n\t}\n\n\t/* Prevent deferred_split_scan() touching ->_refcount */\n\tspin_lock(&pgdata->split_queue_lock);\n\tcount = page_count(head);\n\tmapcount = total_mapcount(head);\n\tif (!mapcount && page_ref_freeze(head, 1 + extra_pins)) {\n\t\tif (!list_empty(page_deferred_list(head))) {\n\t\t\tpgdata->split_queue_len--;\n\t\t\tlist_del(page_deferred_list(head));\n\t\t}\n\t\tif (mapping)\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t\tspin_unlock(&pgdata->split_queue_lock);\n\t\t__split_huge_page(page, list, flags);\n\t\tif (PageSwapCache(head)) {\n\t\t\tswp_entry_t entry = { .val = page_private(head) };\n\n\t\t\tret = split_swap_cluster(entry);\n\t\t} else\n\t\t\tret = 0;\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount) {\n\t\t\tpr_alert(\"total_mapcount: %u, page_count(): %u\\n\",\n\t\t\t\t\tmapcount, count);\n\t\t\tif (PageTail(page))\n\t\t\t\tdump_page(head, NULL);\n\t\t\tdump_page(page, \"total_mapcount(head) > 0\");\n\t\t\tBUG();\n\t\t}\n\t\tspin_unlock(&pgdata->split_queue_lock);\nfail:\t\tif (mapping)\n\t\t\txa_unlock(&mapping->i_pages);\n\t\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\t\tunfreeze_page(head);\n\t\tret = -EBUSY;\n\t}\n\nout_unlock:\n\tif (anon_vma) {\n\t\tanon_vma_unlock_write(anon_vma);\n\t\tput_anon_vma(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_read(mapping);\nout:\n\tcount_vm_event(!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageTransHuge(page)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_swap",
          "args": [
            "page"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "187-235",
          "snippet": "int add_to_swap(struct page *page)\n{\n\tswp_entry_t entry;\n\tint err;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\n\tentry = get_swap_page(page);\n\tif (!entry.val)\n\t\treturn 0;\n\n\t/*\n\t * XArray node allocations from PF_MEMALLOC contexts could\n\t * completely exhaust the page allocator. __GFP_NOMEMALLOC\n\t * stops emergency reserves from being allocated.\n\t *\n\t * TODO: this could cause a theoretical memory reclaim\n\t * deadlock in the swap out path.\n\t */\n\t/*\n\t * Add it to the swap cache.\n\t */\n\terr = add_to_swap_cache(page, entry,\n\t\t\t__GFP_HIGH|__GFP_NOMEMALLOC|__GFP_NOWARN);\n\tif (err)\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tgoto fail;\n\t/*\n\t * Normally the page will be dirtied in unmap because its pte should be\n\t * dirty. A special case is MADV_FREE page. The page'e pte could have\n\t * dirty bit cleared but the page's SwapBacked bit is still set because\n\t * clearing the dirty bit and SwapBacked bit has no lock protected. For\n\t * such page, unmap will not set dirty bit for it, so page reclaim will\n\t * not write the page out. This can cause data corruption when the page\n\t * is swap in later. Always setting the dirty bit for the page solves\n\t * the problem.\n\t */\n\tset_page_dirty(page);\n\n\treturn 1;\n\nfail:\n\tput_swap_page(page, entry);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nint add_to_swap(struct page *page)\n{\n\tswp_entry_t entry;\n\tint err;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\n\tentry = get_swap_page(page);\n\tif (!entry.val)\n\t\treturn 0;\n\n\t/*\n\t * XArray node allocations from PF_MEMALLOC contexts could\n\t * completely exhaust the page allocator. __GFP_NOMEMALLOC\n\t * stops emergency reserves from being allocated.\n\t *\n\t * TODO: this could cause a theoretical memory reclaim\n\t * deadlock in the swap out path.\n\t */\n\t/*\n\t * Add it to the swap cache.\n\t */\n\terr = add_to_swap_cache(page, entry,\n\t\t\t__GFP_HIGH|__GFP_NOMEMALLOC|__GFP_NOWARN);\n\tif (err)\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tgoto fail;\n\t/*\n\t * Normally the page will be dirtied in unmap because its pte should be\n\t * dirty. A special case is MADV_FREE page. The page'e pte could have\n\t * dirty bit cleared but the page's SwapBacked bit is still set because\n\t * clearing the dirty bit and SwapBacked bit has no lock protected. For\n\t * such page, unmap will not set dirty bit for it, so page reclaim will\n\t * not write the page out. This can cause data corruption when the page\n\t * is swap in later. Always setting the dirty bit for the page solves\n\t * the problem.\n\t */\n\tset_page_dirty(page);\n\n\treturn 1;\n\nfail:\n\tput_swap_page(page, entry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_SWPOUT_FALLBACK"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_split_huge_page",
          "args": [
            "page",
            "NULL"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "can_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2587-2599",
          "snippet": "bool can_split_huge_page(struct page *page, int *pextra_pins)\n{\n\tint extra_pins;\n\n\t/* Additional pins from page cache */\n\tif (PageAnon(page))\n\t\textra_pins = PageSwapCache(page) ? HPAGE_PMD_NR : 0;\n\telse\n\t\textra_pins = HPAGE_PMD_NR;\n\tif (pextra_pins)\n\t\t*pextra_pins = extra_pins;\n\treturn total_mapcount(page) == page_count(page) - extra_pins - 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nbool can_split_huge_page(struct page *page, int *pextra_pins)\n{\n\tint extra_pins;\n\n\t/* Additional pins from page cache */\n\tif (PageAnon(page))\n\t\textra_pins = PageSwapCache(page) ? HPAGE_PMD_NR : 0;\n\telse\n\t\textra_pins = HPAGE_PMD_NR;\n\tif (pextra_pins)\n\t\t*pextra_pins = extra_pins;\n\treturn total_mapcount(page) == page_count(page) - extra_pins - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_check_references",
          "args": [
            "page",
            "sc"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "page_check_references",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1018-1071",
          "snippet": "static enum page_references page_check_references(struct page *page,\n\t\t\t\t\t\t  struct scan_control *sc)\n{\n\tint referenced_ptes, referenced_page;\n\tunsigned long vm_flags;\n\n\treferenced_ptes = page_referenced(page, 1, sc->target_mem_cgroup,\n\t\t\t\t\t  &vm_flags);\n\treferenced_page = TestClearPageReferenced(page);\n\n\t/*\n\t * Mlock lost the isolation race with us.  Let try_to_unmap()\n\t * move the page to the unevictable list.\n\t */\n\tif (vm_flags & VM_LOCKED)\n\t\treturn PAGEREF_RECLAIM;\n\n\tif (referenced_ptes) {\n\t\tif (PageSwapBacked(page))\n\t\t\treturn PAGEREF_ACTIVATE;\n\t\t/*\n\t\t * All mapped pages start out with page table\n\t\t * references from the instantiating fault, so we need\n\t\t * to look twice if a mapped file page is used more\n\t\t * than once.\n\t\t *\n\t\t * Mark it and spare it for another trip around the\n\t\t * inactive list.  Another page table reference will\n\t\t * lead to its activation.\n\t\t *\n\t\t * Note: the mark is set for activated pages as well\n\t\t * so that recently deactivated but used pages are\n\t\t * quickly recovered.\n\t\t */\n\t\tSetPageReferenced(page);\n\n\t\tif (referenced_page || referenced_ptes > 1)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\t/*\n\t\t * Activate file-backed executable pages after first usage.\n\t\t */\n\t\tif (vm_flags & VM_EXEC)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\treturn PAGEREF_KEEP;\n\t}\n\n\t/* Reclaim if clean, defer dirty pages to writeback */\n\tif (referenced_page && !PageSwapBacked(page))\n\t\treturn PAGEREF_RECLAIM_CLEAN;\n\n\treturn PAGEREF_RECLAIM;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic enum page_references page_check_references(struct page *page,\n\t\t\t\t\t\t  struct scan_control *sc)\n{\n\tint referenced_ptes, referenced_page;\n\tunsigned long vm_flags;\n\n\treferenced_ptes = page_referenced(page, 1, sc->target_mem_cgroup,\n\t\t\t\t\t  &vm_flags);\n\treferenced_page = TestClearPageReferenced(page);\n\n\t/*\n\t * Mlock lost the isolation race with us.  Let try_to_unmap()\n\t * move the page to the unevictable list.\n\t */\n\tif (vm_flags & VM_LOCKED)\n\t\treturn PAGEREF_RECLAIM;\n\n\tif (referenced_ptes) {\n\t\tif (PageSwapBacked(page))\n\t\t\treturn PAGEREF_ACTIVATE;\n\t\t/*\n\t\t * All mapped pages start out with page table\n\t\t * references from the instantiating fault, so we need\n\t\t * to look twice if a mapped file page is used more\n\t\t * than once.\n\t\t *\n\t\t * Mark it and spare it for another trip around the\n\t\t * inactive list.  Another page table reference will\n\t\t * lead to its activation.\n\t\t *\n\t\t * Note: the mark is set for activated pages as well\n\t\t * so that recently deactivated but used pages are\n\t\t * quickly recovered.\n\t\t */\n\t\tSetPageReferenced(page);\n\n\t\tif (referenced_page || referenced_ptes > 1)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\t/*\n\t\t * Activate file-backed executable pages after first usage.\n\t\t */\n\t\tif (vm_flags & VM_EXEC)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\treturn PAGEREF_KEEP;\n\t}\n\n\t/* Reclaim if clean, defer dirty pages to writeback */\n\tif (referenced_page && !PageSwapBacked(page))\n\t\treturn PAGEREF_RECLAIM_CLEAN;\n\n\treturn PAGEREF_RECLAIM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "page_list"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReclaim",
          "args": [
            "page"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReclaim",
          "args": [
            "page"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sane_reclaim",
          "args": [
            "sc"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "sane_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "297-300",
          "snippet": "static bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PGDAT_WRITEBACK",
            "&pgdat->flags"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReclaim",
          "args": [
            "page"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReclaim",
          "args": [
            "page"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_write_congested",
          "args": [
            "mapping->host"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_check_dirty_writeback",
          "args": [
            "page",
            "&dirty",
            "&writeback"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "page_check_dirty_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1074-1101",
          "snippet": "static void page_check_dirty_writeback(struct page *page,\n\t\t\t\t       bool *dirty, bool *writeback)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Anonymous pages are not handled by flushers and must be written\n\t * from reclaim context. Do not stall reclaim based on them\n\t */\n\tif (!page_is_file_cache(page) ||\n\t    (PageAnon(page) && !PageSwapBacked(page))) {\n\t\t*dirty = false;\n\t\t*writeback = false;\n\t\treturn;\n\t}\n\n\t/* By default assume that the page flags are accurate */\n\t*dirty = PageDirty(page);\n\t*writeback = PageWriteback(page);\n\n\t/* Verify dirty/writeback state if the filesystem supports it */\n\tif (!page_has_private(page))\n\t\treturn;\n\n\tmapping = page_mapping(page);\n\tif (mapping && mapping->a_ops->is_dirty_writeback)\n\t\tmapping->a_ops->is_dirty_writeback(page, dirty, writeback);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void page_check_dirty_writeback(struct page *page,\n\t\t\t\t       bool *dirty, bool *writeback)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Anonymous pages are not handled by flushers and must be written\n\t * from reclaim context. Do not stall reclaim based on them\n\t */\n\tif (!page_is_file_cache(page) ||\n\t    (PageAnon(page) && !PageSwapBacked(page))) {\n\t\t*dirty = false;\n\t\t*writeback = false;\n\t\treturn;\n\t}\n\n\t/* By default assume that the page flags are accurate */\n\t*dirty = PageDirty(page);\n\t*writeback = PageWriteback(page);\n\n\t/* Verify dirty/writeback state if the filesystem supports it */\n\tif (!page_has_private(page))\n\t\treturn;\n\n\tmapping = page_mapping(page);\n\tif (mapping && mapping->a_ops->is_dirty_writeback)\n\t\tmapping->a_ops->is_dirty_writeback(page, dirty, writeback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_evictable(page)"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_evictable",
          "args": [
            "page"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "page_evictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4174-4183",
          "snippet": "int page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageActive(page)",
            "page"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "page_list"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_list"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "free_pages"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "ret_pages"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long shrink_page_list(struct list_head *page_list,\n\t\t\t\t      struct pglist_data *pgdat,\n\t\t\t\t      struct scan_control *sc,\n\t\t\t\t      enum ttu_flags ttu_flags,\n\t\t\t\t      struct reclaim_stat *stat,\n\t\t\t\t      bool force_reclaim)\n{\n\tLIST_HEAD(ret_pages);\n\tLIST_HEAD(free_pages);\n\tint pgactivate = 0;\n\tunsigned nr_unqueued_dirty = 0;\n\tunsigned nr_dirty = 0;\n\tunsigned nr_congested = 0;\n\tunsigned nr_reclaimed = 0;\n\tunsigned nr_writeback = 0;\n\tunsigned nr_immediate = 0;\n\tunsigned nr_ref_keep = 0;\n\tunsigned nr_unmap_fail = 0;\n\n\tcond_resched();\n\n\twhile (!list_empty(page_list)) {\n\t\tstruct address_space *mapping;\n\t\tstruct page *page;\n\t\tint may_enter_fs;\n\t\tenum page_references references = PAGEREF_RECLAIM_CLEAN;\n\t\tbool dirty, writeback;\n\n\t\tcond_resched();\n\n\t\tpage = lru_to_page(page_list);\n\t\tlist_del(&page->lru);\n\n\t\tif (!trylock_page(page))\n\t\t\tgoto keep;\n\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\n\t\tsc->nr_scanned++;\n\n\t\tif (unlikely(!page_evictable(page)))\n\t\t\tgoto activate_locked;\n\n\t\tif (!sc->may_unmap && page_mapped(page))\n\t\t\tgoto keep_locked;\n\n\t\t/* Double the slab pressure for mapped and swapcache pages */\n\t\tif ((page_mapped(page) || PageSwapCache(page)) &&\n\t\t    !(PageAnon(page) && !PageSwapBacked(page)))\n\t\t\tsc->nr_scanned++;\n\n\t\tmay_enter_fs = (sc->gfp_mask & __GFP_FS) ||\n\t\t\t(PageSwapCache(page) && (sc->gfp_mask & __GFP_IO));\n\n\t\t/*\n\t\t * The number of dirty pages determines if a node is marked\n\t\t * reclaim_congested which affects wait_iff_congested. kswapd\n\t\t * will stall and start writing pages if the tail of the LRU\n\t\t * is all dirty unqueued pages.\n\t\t */\n\t\tpage_check_dirty_writeback(page, &dirty, &writeback);\n\t\tif (dirty || writeback)\n\t\t\tnr_dirty++;\n\n\t\tif (dirty && !writeback)\n\t\t\tnr_unqueued_dirty++;\n\n\t\t/*\n\t\t * Treat this page as congested if the underlying BDI is or if\n\t\t * pages are cycling through the LRU so quickly that the\n\t\t * pages marked for immediate reclaim are making it to the\n\t\t * end of the LRU a second time.\n\t\t */\n\t\tmapping = page_mapping(page);\n\t\tif (((dirty || writeback) && mapping &&\n\t\t     inode_write_congested(mapping->host)) ||\n\t\t    (writeback && PageReclaim(page)))\n\t\t\tnr_congested++;\n\n\t\t/*\n\t\t * If a page at the tail of the LRU is under writeback, there\n\t\t * are three cases to consider.\n\t\t *\n\t\t * 1) If reclaim is encountering an excessive number of pages\n\t\t *    under writeback and this page is both under writeback and\n\t\t *    PageReclaim then it indicates that pages are being queued\n\t\t *    for IO but are being recycled through the LRU before the\n\t\t *    IO can complete. Waiting on the page itself risks an\n\t\t *    indefinite stall if it is impossible to writeback the\n\t\t *    page due to IO error or disconnected storage so instead\n\t\t *    note that the LRU is being scanned too quickly and the\n\t\t *    caller can stall after page list has been processed.\n\t\t *\n\t\t * 2) Global or new memcg reclaim encounters a page that is\n\t\t *    not marked for immediate reclaim, or the caller does not\n\t\t *    have __GFP_FS (or __GFP_IO if it's simply going to swap,\n\t\t *    not to fs). In this case mark the page for immediate\n\t\t *    reclaim and continue scanning.\n\t\t *\n\t\t *    Require may_enter_fs because we would wait on fs, which\n\t\t *    may not have submitted IO yet. And the loop driver might\n\t\t *    enter reclaim, and deadlock if it waits on a page for\n\t\t *    which it is needed to do the write (loop masks off\n\t\t *    __GFP_IO|__GFP_FS for this reason); but more thought\n\t\t *    would probably show more reasons.\n\t\t *\n\t\t * 3) Legacy memcg encounters a page that is already marked\n\t\t *    PageReclaim. memcg does not have any dirty pages\n\t\t *    throttling so we could easily OOM just because too many\n\t\t *    pages are in writeback and there is nothing else to\n\t\t *    reclaim. Wait for the writeback to complete.\n\t\t *\n\t\t * In cases 1) and 2) we activate the pages to get them out of\n\t\t * the way while we continue scanning for clean pages on the\n\t\t * inactive list and refilling from the active list. The\n\t\t * observation here is that waiting for disk writes is more\n\t\t * expensive than potentially causing reloads down the line.\n\t\t * Since they're marked for immediate reclaim, they won't put\n\t\t * memory pressure on the cache working set any longer than it\n\t\t * takes to write them to disk.\n\t\t */\n\t\tif (PageWriteback(page)) {\n\t\t\t/* Case 1 above */\n\t\t\tif (current_is_kswapd() &&\n\t\t\t    PageReclaim(page) &&\n\t\t\t    test_bit(PGDAT_WRITEBACK, &pgdat->flags)) {\n\t\t\t\tnr_immediate++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 2 above */\n\t\t\t} else if (sane_reclaim(sc) ||\n\t\t\t    !PageReclaim(page) || !may_enter_fs) {\n\t\t\t\t/*\n\t\t\t\t * This is slightly racy - end_page_writeback()\n\t\t\t\t * might have just cleared PageReclaim, then\n\t\t\t\t * setting PageReclaim here end up interpreted\n\t\t\t\t * as PageReadahead - but that does not matter\n\t\t\t\t * enough to care.  What we do want is for this\n\t\t\t\t * page to have PageReclaim set next time memcg\n\t\t\t\t * reclaim reaches the tests above, so it will\n\t\t\t\t * then wait_on_page_writeback() to avoid OOM;\n\t\t\t\t * and it's also appropriate in global reclaim.\n\t\t\t\t */\n\t\t\t\tSetPageReclaim(page);\n\t\t\t\tnr_writeback++;\n\t\t\t\tgoto activate_locked;\n\n\t\t\t/* Case 3 above */\n\t\t\t} else {\n\t\t\t\tunlock_page(page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t\t/* then go back and try same page again */\n\t\t\t\tlist_add_tail(&page->lru, page_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!force_reclaim)\n\t\t\treferences = page_check_references(page, sc);\n\n\t\tswitch (references) {\n\t\tcase PAGEREF_ACTIVATE:\n\t\t\tgoto activate_locked;\n\t\tcase PAGEREF_KEEP:\n\t\t\tnr_ref_keep++;\n\t\t\tgoto keep_locked;\n\t\tcase PAGEREF_RECLAIM:\n\t\tcase PAGEREF_RECLAIM_CLEAN:\n\t\t\t; /* try to reclaim the page below */\n\t\t}\n\n\t\t/*\n\t\t * Anonymous process memory has backing store?\n\t\t * Try to allocate it some swap space here.\n\t\t * Lazyfree page could be freed directly\n\t\t */\n\t\tif (PageAnon(page) && PageSwapBacked(page)) {\n\t\t\tif (!PageSwapCache(page)) {\n\t\t\t\tif (!(sc->gfp_mask & __GFP_IO))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tif (PageTransHuge(page)) {\n\t\t\t\t\t/* cannot split THP, skip it */\n\t\t\t\t\tif (!can_split_huge_page(page, NULL))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/*\n\t\t\t\t\t * Split pages without a PMD map right\n\t\t\t\t\t * away. Chances are some or all of the\n\t\t\t\t\t * tail pages can be freed without IO.\n\t\t\t\t\t */\n\t\t\t\t\tif (!compound_mapcount(page) &&\n\t\t\t\t\t    split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\t\t\t\tif (!add_to_swap(page)) {\n\t\t\t\t\tif (!PageTransHuge(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t\t/* Fallback to swap normal pages */\n\t\t\t\t\tif (split_huge_page_to_list(page,\n\t\t\t\t\t\t\t\t    page_list))\n\t\t\t\t\t\tgoto activate_locked;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\t\tcount_vm_event(THP_SWPOUT_FALLBACK);\n#endif\n\t\t\t\t\tif (!add_to_swap(page))\n\t\t\t\t\t\tgoto activate_locked;\n\t\t\t\t}\n\n\t\t\t\tmay_enter_fs = 1;\n\n\t\t\t\t/* Adding to swap updated mapping */\n\t\t\t\tmapping = page_mapping(page);\n\t\t\t}\n\t\t} else if (unlikely(PageTransHuge(page))) {\n\t\t\t/* Split file THP */\n\t\t\tif (split_huge_page_to_list(page, page_list))\n\t\t\t\tgoto keep_locked;\n\t\t}\n\n\t\t/*\n\t\t * The page is mapped into the page tables of one or more\n\t\t * processes. Try to unmap it here.\n\t\t */\n\t\tif (page_mapped(page)) {\n\t\t\tenum ttu_flags flags = ttu_flags | TTU_BATCH_FLUSH;\n\n\t\t\tif (unlikely(PageTransHuge(page)))\n\t\t\t\tflags |= TTU_SPLIT_HUGE_PMD;\n\t\t\tif (!try_to_unmap(page, flags)) {\n\t\t\t\tnr_unmap_fail++;\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\t\t}\n\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * Only kswapd can writeback filesystem pages\n\t\t\t * to avoid risk of stack overflow. But avoid\n\t\t\t * injecting inefficient single-page IO into\n\t\t\t * flusher writeback as much as possible: only\n\t\t\t * write pages when we've encountered many\n\t\t\t * dirty pages, and when we've already scanned\n\t\t\t * the rest of the LRU for clean pages and see\n\t\t\t * the same dirty pages again (PageReclaim).\n\t\t\t */\n\t\t\tif (page_is_file_cache(page) &&\n\t\t\t    (!current_is_kswapd() || !PageReclaim(page) ||\n\t\t\t     !test_bit(PGDAT_DIRTY, &pgdat->flags))) {\n\t\t\t\t/*\n\t\t\t\t * Immediately reclaim when written back.\n\t\t\t\t * Similar in principal to deactivate_page()\n\t\t\t\t * except we already have the page isolated\n\t\t\t\t * and know it's dirty\n\t\t\t\t */\n\t\t\t\tinc_node_page_state(page, NR_VMSCAN_IMMEDIATE);\n\t\t\t\tSetPageReclaim(page);\n\n\t\t\t\tgoto activate_locked;\n\t\t\t}\n\n\t\t\tif (references == PAGEREF_RECLAIM_CLEAN)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!may_enter_fs)\n\t\t\t\tgoto keep_locked;\n\t\t\tif (!sc->may_writepage)\n\t\t\t\tgoto keep_locked;\n\n\t\t\t/*\n\t\t\t * Page is dirty. Flush the TLB if a writable entry\n\t\t\t * potentially exists to avoid CPU writes after IO\n\t\t\t * starts and then write it out here.\n\t\t\t */\n\t\t\ttry_to_unmap_flush_dirty();\n\t\t\tswitch (pageout(page, mapping, sc)) {\n\t\t\tcase PAGE_KEEP:\n\t\t\t\tgoto keep_locked;\n\t\t\tcase PAGE_ACTIVATE:\n\t\t\t\tgoto activate_locked;\n\t\t\tcase PAGE_SUCCESS:\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tgoto keep;\n\n\t\t\t\t/*\n\t\t\t\t * A synchronous write - probably a ramdisk.  Go\n\t\t\t\t * ahead and try to reclaim the page.\n\t\t\t\t */\n\t\t\t\tif (!trylock_page(page))\n\t\t\t\t\tgoto keep;\n\t\t\t\tif (PageDirty(page) || PageWriteback(page))\n\t\t\t\t\tgoto keep_locked;\n\t\t\t\tmapping = page_mapping(page);\n\t\t\tcase PAGE_CLEAN:\n\t\t\t\t; /* try to free the page below */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the page has buffers, try to free the buffer mappings\n\t\t * associated with this page. If we succeed we try to free\n\t\t * the page as well.\n\t\t *\n\t\t * We do this even if the page is PageDirty().\n\t\t * try_to_release_page() does not perform I/O, but it is\n\t\t * possible for a page to have PageDirty set, but it is actually\n\t\t * clean (all its buffers are clean).  This happens if the\n\t\t * buffers were written out directly, with submit_bh(). ext3\n\t\t * will do this, as well as the blockdev mapping.\n\t\t * try_to_release_page() will discover that cleanness and will\n\t\t * drop the buffers and mark the page clean - it can be freed.\n\t\t *\n\t\t * Rarely, pages can have buffers and no ->mapping.  These are\n\t\t * the pages which were not successfully invalidated in\n\t\t * truncate_complete_page().  We try to drop those buffers here\n\t\t * and if that worked, and the page is no longer mapped into\n\t\t * process address space (page_count == 1) it can be freed.\n\t\t * Otherwise, leave the page on the LRU so it is swappable.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (!try_to_release_page(page, sc->gfp_mask))\n\t\t\t\tgoto activate_locked;\n\t\t\tif (!mapping && page_count(page) == 1) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (put_page_testzero(page))\n\t\t\t\t\tgoto free_it;\n\t\t\t\telse {\n\t\t\t\t\t/*\n\t\t\t\t\t * rare race with speculative reference.\n\t\t\t\t\t * the speculative reference will free\n\t\t\t\t\t * this page shortly, so we may\n\t\t\t\t\t * increment nr_reclaimed here (and\n\t\t\t\t\t * leave it off the LRU).\n\t\t\t\t\t */\n\t\t\t\t\tnr_reclaimed++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PageAnon(page) && !PageSwapBacked(page)) {\n\t\t\t/* follow __remove_mapping for reference */\n\t\t\tif (!page_ref_freeze(page, 1))\n\t\t\t\tgoto keep_locked;\n\t\t\tif (PageDirty(page)) {\n\t\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\t\tgoto keep_locked;\n\t\t\t}\n\n\t\t\tcount_vm_event(PGLAZYFREED);\n\t\t\tcount_memcg_page_event(page, PGLAZYFREED);\n\t\t} else if (!mapping || !__remove_mapping(mapping, page, true))\n\t\t\tgoto keep_locked;\n\t\t/*\n\t\t * At this point, we have no other references and there is\n\t\t * no way to pick any more up (removed from LRU, removed\n\t\t * from pagecache). Can use non-atomic bitops now (and\n\t\t * we obviously don't have to worry about waking up a process\n\t\t * waiting on the page lock, because there are no references.\n\t\t */\n\t\t__ClearPageLocked(page);\nfree_it:\n\t\tnr_reclaimed++;\n\n\t\t/*\n\t\t * Is there need to periodically free_page_list? It would\n\t\t * appear not as the counts should be low\n\t\t */\n\t\tif (unlikely(PageTransHuge(page))) {\n\t\t\tmem_cgroup_uncharge(page);\n\t\t\t(*get_compound_page_dtor(page))(page);\n\t\t} else\n\t\t\tlist_add(&page->lru, &free_pages);\n\t\tcontinue;\n\nactivate_locked:\n\t\t/* Not a candidate for swapping, so reclaim swap space. */\n\t\tif (PageSwapCache(page) && (mem_cgroup_swap_full(page) ||\n\t\t\t\t\t\tPageMlocked(page)))\n\t\t\ttry_to_free_swap(page);\n\t\tVM_BUG_ON_PAGE(PageActive(page), page);\n\t\tif (!PageMlocked(page)) {\n\t\t\tSetPageActive(page);\n\t\t\tpgactivate++;\n\t\t\tcount_memcg_page_event(page, PGACTIVATE);\n\t\t}\nkeep_locked:\n\t\tunlock_page(page);\nkeep:\n\t\tlist_add(&page->lru, &ret_pages);\n\t\tVM_BUG_ON_PAGE(PageLRU(page) || PageUnevictable(page), page);\n\t}\n\n\tmem_cgroup_uncharge_list(&free_pages);\n\ttry_to_unmap_flush();\n\tfree_unref_page_list(&free_pages);\n\n\tlist_splice(&ret_pages, page_list);\n\tcount_vm_events(PGACTIVATE, pgactivate);\n\n\tif (stat) {\n\t\tstat->nr_dirty = nr_dirty;\n\t\tstat->nr_congested = nr_congested;\n\t\tstat->nr_unqueued_dirty = nr_unqueued_dirty;\n\t\tstat->nr_writeback = nr_writeback;\n\t\tstat->nr_immediate = nr_immediate;\n\t\tstat->nr_activate = pgactivate;\n\t\tstat->nr_ref_keep = nr_ref_keep;\n\t\tstat->nr_unmap_fail = nr_unmap_fail;\n\t}\n\treturn nr_reclaimed;\n}"
  },
  {
    "function_name": "page_check_dirty_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1074-1101",
    "snippet": "static void page_check_dirty_writeback(struct page *page,\n\t\t\t\t       bool *dirty, bool *writeback)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Anonymous pages are not handled by flushers and must be written\n\t * from reclaim context. Do not stall reclaim based on them\n\t */\n\tif (!page_is_file_cache(page) ||\n\t    (PageAnon(page) && !PageSwapBacked(page))) {\n\t\t*dirty = false;\n\t\t*writeback = false;\n\t\treturn;\n\t}\n\n\t/* By default assume that the page flags are accurate */\n\t*dirty = PageDirty(page);\n\t*writeback = PageWriteback(page);\n\n\t/* Verify dirty/writeback state if the filesystem supports it */\n\tif (!page_has_private(page))\n\t\treturn;\n\n\tmapping = page_mapping(page);\n\tif (mapping && mapping->a_ops->is_dirty_writeback)\n\t\tmapping->a_ops->is_dirty_writeback(page, dirty, writeback);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping->a_ops->is_dirty_writeback",
          "args": [
            "page",
            "dirty",
            "writeback"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void page_check_dirty_writeback(struct page *page,\n\t\t\t\t       bool *dirty, bool *writeback)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Anonymous pages are not handled by flushers and must be written\n\t * from reclaim context. Do not stall reclaim based on them\n\t */\n\tif (!page_is_file_cache(page) ||\n\t    (PageAnon(page) && !PageSwapBacked(page))) {\n\t\t*dirty = false;\n\t\t*writeback = false;\n\t\treturn;\n\t}\n\n\t/* By default assume that the page flags are accurate */\n\t*dirty = PageDirty(page);\n\t*writeback = PageWriteback(page);\n\n\t/* Verify dirty/writeback state if the filesystem supports it */\n\tif (!page_has_private(page))\n\t\treturn;\n\n\tmapping = page_mapping(page);\n\tif (mapping && mapping->a_ops->is_dirty_writeback)\n\t\tmapping->a_ops->is_dirty_writeback(page, dirty, writeback);\n}"
  },
  {
    "function_name": "page_check_references",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1018-1071",
    "snippet": "static enum page_references page_check_references(struct page *page,\n\t\t\t\t\t\t  struct scan_control *sc)\n{\n\tint referenced_ptes, referenced_page;\n\tunsigned long vm_flags;\n\n\treferenced_ptes = page_referenced(page, 1, sc->target_mem_cgroup,\n\t\t\t\t\t  &vm_flags);\n\treferenced_page = TestClearPageReferenced(page);\n\n\t/*\n\t * Mlock lost the isolation race with us.  Let try_to_unmap()\n\t * move the page to the unevictable list.\n\t */\n\tif (vm_flags & VM_LOCKED)\n\t\treturn PAGEREF_RECLAIM;\n\n\tif (referenced_ptes) {\n\t\tif (PageSwapBacked(page))\n\t\t\treturn PAGEREF_ACTIVATE;\n\t\t/*\n\t\t * All mapped pages start out with page table\n\t\t * references from the instantiating fault, so we need\n\t\t * to look twice if a mapped file page is used more\n\t\t * than once.\n\t\t *\n\t\t * Mark it and spare it for another trip around the\n\t\t * inactive list.  Another page table reference will\n\t\t * lead to its activation.\n\t\t *\n\t\t * Note: the mark is set for activated pages as well\n\t\t * so that recently deactivated but used pages are\n\t\t * quickly recovered.\n\t\t */\n\t\tSetPageReferenced(page);\n\n\t\tif (referenced_page || referenced_ptes > 1)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\t/*\n\t\t * Activate file-backed executable pages after first usage.\n\t\t */\n\t\tif (vm_flags & VM_EXEC)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\treturn PAGEREF_KEEP;\n\t}\n\n\t/* Reclaim if clean, defer dirty pages to writeback */\n\tif (referenced_page && !PageSwapBacked(page))\n\t\treturn PAGEREF_RECLAIM_CLEAN;\n\n\treturn PAGEREF_RECLAIM;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "page"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageReferenced",
          "args": [
            "page"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_referenced",
          "args": [
            "page",
            "1",
            "sc->target_mem_cgroup",
            "&vm_flags"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "page_referenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "836-881",
          "snippet": "int page_referenced(struct page *page,\n\t\t    int is_locked,\n\t\t    struct mem_cgroup *memcg,\n\t\t    unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct page_referenced_arg pra = {\n\t\t.mapcount = total_mapcount(page),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t*vm_flags = 0;\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tif (!page_rmapping(page))\n\t\treturn 0;\n\n\tif (!is_locked && (!PageAnon(page) || PageKsm(page))) {\n\t\twe_locked = trylock_page(page);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_page_referenced_vma;\n\t}\n\n\trmap_walk(page, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tunlock_page(page);\n\n\treturn pra.referenced;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_referenced(struct page *page,\n\t\t    int is_locked,\n\t\t    struct mem_cgroup *memcg,\n\t\t    unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct page_referenced_arg pra = {\n\t\t.mapcount = total_mapcount(page),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t*vm_flags = 0;\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tif (!page_rmapping(page))\n\t\treturn 0;\n\n\tif (!is_locked && (!PageAnon(page) || PageKsm(page))) {\n\t\twe_locked = trylock_page(page);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_page_referenced_vma;\n\t}\n\n\trmap_walk(page, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tunlock_page(page);\n\n\treturn pra.referenced;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic enum page_references page_check_references(struct page *page,\n\t\t\t\t\t\t  struct scan_control *sc)\n{\n\tint referenced_ptes, referenced_page;\n\tunsigned long vm_flags;\n\n\treferenced_ptes = page_referenced(page, 1, sc->target_mem_cgroup,\n\t\t\t\t\t  &vm_flags);\n\treferenced_page = TestClearPageReferenced(page);\n\n\t/*\n\t * Mlock lost the isolation race with us.  Let try_to_unmap()\n\t * move the page to the unevictable list.\n\t */\n\tif (vm_flags & VM_LOCKED)\n\t\treturn PAGEREF_RECLAIM;\n\n\tif (referenced_ptes) {\n\t\tif (PageSwapBacked(page))\n\t\t\treturn PAGEREF_ACTIVATE;\n\t\t/*\n\t\t * All mapped pages start out with page table\n\t\t * references from the instantiating fault, so we need\n\t\t * to look twice if a mapped file page is used more\n\t\t * than once.\n\t\t *\n\t\t * Mark it and spare it for another trip around the\n\t\t * inactive list.  Another page table reference will\n\t\t * lead to its activation.\n\t\t *\n\t\t * Note: the mark is set for activated pages as well\n\t\t * so that recently deactivated but used pages are\n\t\t * quickly recovered.\n\t\t */\n\t\tSetPageReferenced(page);\n\n\t\tif (referenced_page || referenced_ptes > 1)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\t/*\n\t\t * Activate file-backed executable pages after first usage.\n\t\t */\n\t\tif (vm_flags & VM_EXEC)\n\t\t\treturn PAGEREF_ACTIVATE;\n\n\t\treturn PAGEREF_KEEP;\n\t}\n\n\t/* Reclaim if clean, defer dirty pages to writeback */\n\tif (referenced_page && !PageSwapBacked(page))\n\t\treturn PAGEREF_RECLAIM_CLEAN;\n\n\treturn PAGEREF_RECLAIM;\n}"
  },
  {
    "function_name": "putback_lru_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "1005-1009",
    "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add",
          "args": [
            "page"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "441-446",
          "snippet": "void lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
  },
  {
    "function_name": "remove_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "982-994",
    "snippet": "int remove_mapping(struct address_space *mapping, struct page *page)\n{\n\tif (__remove_mapping(mapping, page, false)) {\n\t\t/*\n\t\t * Unfreezing the refcount with 1 rather than 2 effectively\n\t\t * drops the pagecache ref for us without requiring another\n\t\t * atomic operation.\n\t\t */\n\t\tpage_ref_unfreeze(page, 1);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "page",
            "1"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_mapping",
          "args": [
            "mapping",
            "page",
            "false"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "885-974",
          "snippet": "static int __remove_mapping(struct address_space *mapping, struct page *page,\n\t\t\t    bool reclaimed)\n{\n\tunsigned long flags;\n\tint refcount;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(mapping != page_mapping(page));\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t/*\n\t * The non racy check for a busy page.\n\t *\n\t * Must be careful with the order of the tests. When someone has\n\t * a ref to the page, it may be possible that they dirty it then\n\t * drop the reference. So if PageDirty is tested before page_count\n\t * here, then the following race may occur:\n\t *\n\t * get_user_pages(&page);\n\t * [user mapping goes away]\n\t * write_to(page);\n\t *\t\t\t\t!PageDirty(page)    [good]\n\t * SetPageDirty(page);\n\t * put_page(page);\n\t *\t\t\t\t!page_count(page)   [good, discard it]\n\t *\n\t * [oops, our write_to data is lost]\n\t *\n\t * Reversing the order of the tests ensures such a situation cannot\n\t * escape unnoticed. The smp_rmb is needed to ensure the page->flags\n\t * load is not satisfied before that of page->_refcount.\n\t *\n\t * Note that if SetPageDirty is always performed via set_page_dirty,\n\t * and thus under the i_pages lock, then this ordering is not required.\n\t */\n\tif (unlikely(PageTransHuge(page)) && PageSwapCache(page))\n\t\trefcount = 1 + HPAGE_PMD_NR;\n\telse\n\t\trefcount = 2;\n\tif (!page_ref_freeze(page, refcount))\n\t\tgoto cannot_free;\n\t/* note: atomic_cmpxchg in page_ref_freeze provides the smp_rmb */\n\tif (unlikely(PageDirty(page))) {\n\t\tpage_ref_unfreeze(page, refcount);\n\t\tgoto cannot_free;\n\t}\n\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t swap = { .val = page_private(page) };\n\t\tmem_cgroup_swapout(page, swap);\n\t\t__delete_from_swap_cache(page, swap);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tput_swap_page(page, swap);\n\t} else {\n\t\tvoid (*freepage)(struct page *);\n\t\tvoid *shadow = NULL;\n\n\t\tfreepage = mapping->a_ops->freepage;\n\t\t/*\n\t\t * Remember a shadow entry for reclaimed file cache in\n\t\t * order to detect refaults, thus thrashing, later on.\n\t\t *\n\t\t * But don't store shadows in an address space that is\n\t\t * already exiting.  This is not just an optizimation,\n\t\t * inode reclaim needs to empty out the radix tree or\n\t\t * the nodes are lost.  Don't plant shadows behind its\n\t\t * back.\n\t\t *\n\t\t * We also don't store shadows for DAX mappings because the\n\t\t * only page cache pages found in these are zero pages\n\t\t * covering holes, and because we don't want to mix DAX\n\t\t * exceptional entries and shadow exceptional entries in the\n\t\t * same address_space.\n\t\t */\n\t\tif (reclaimed && page_is_file_cache(page) &&\n\t\t    !mapping_exiting(mapping) && !dax_mapping(mapping))\n\t\t\tshadow = workingset_eviction(mapping, page);\n\t\t__delete_from_page_cache(page, shadow);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\t\tif (freepage != NULL)\n\t\t\tfreepage(page);\n\t}\n\n\treturn 1;\n\ncannot_free:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int __remove_mapping(struct address_space *mapping, struct page *page,\n\t\t\t    bool reclaimed)\n{\n\tunsigned long flags;\n\tint refcount;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(mapping != page_mapping(page));\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t/*\n\t * The non racy check for a busy page.\n\t *\n\t * Must be careful with the order of the tests. When someone has\n\t * a ref to the page, it may be possible that they dirty it then\n\t * drop the reference. So if PageDirty is tested before page_count\n\t * here, then the following race may occur:\n\t *\n\t * get_user_pages(&page);\n\t * [user mapping goes away]\n\t * write_to(page);\n\t *\t\t\t\t!PageDirty(page)    [good]\n\t * SetPageDirty(page);\n\t * put_page(page);\n\t *\t\t\t\t!page_count(page)   [good, discard it]\n\t *\n\t * [oops, our write_to data is lost]\n\t *\n\t * Reversing the order of the tests ensures such a situation cannot\n\t * escape unnoticed. The smp_rmb is needed to ensure the page->flags\n\t * load is not satisfied before that of page->_refcount.\n\t *\n\t * Note that if SetPageDirty is always performed via set_page_dirty,\n\t * and thus under the i_pages lock, then this ordering is not required.\n\t */\n\tif (unlikely(PageTransHuge(page)) && PageSwapCache(page))\n\t\trefcount = 1 + HPAGE_PMD_NR;\n\telse\n\t\trefcount = 2;\n\tif (!page_ref_freeze(page, refcount))\n\t\tgoto cannot_free;\n\t/* note: atomic_cmpxchg in page_ref_freeze provides the smp_rmb */\n\tif (unlikely(PageDirty(page))) {\n\t\tpage_ref_unfreeze(page, refcount);\n\t\tgoto cannot_free;\n\t}\n\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t swap = { .val = page_private(page) };\n\t\tmem_cgroup_swapout(page, swap);\n\t\t__delete_from_swap_cache(page, swap);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tput_swap_page(page, swap);\n\t} else {\n\t\tvoid (*freepage)(struct page *);\n\t\tvoid *shadow = NULL;\n\n\t\tfreepage = mapping->a_ops->freepage;\n\t\t/*\n\t\t * Remember a shadow entry for reclaimed file cache in\n\t\t * order to detect refaults, thus thrashing, later on.\n\t\t *\n\t\t * But don't store shadows in an address space that is\n\t\t * already exiting.  This is not just an optizimation,\n\t\t * inode reclaim needs to empty out the radix tree or\n\t\t * the nodes are lost.  Don't plant shadows behind its\n\t\t * back.\n\t\t *\n\t\t * We also don't store shadows for DAX mappings because the\n\t\t * only page cache pages found in these are zero pages\n\t\t * covering holes, and because we don't want to mix DAX\n\t\t * exceptional entries and shadow exceptional entries in the\n\t\t * same address_space.\n\t\t */\n\t\tif (reclaimed && page_is_file_cache(page) &&\n\t\t    !mapping_exiting(mapping) && !dax_mapping(mapping))\n\t\t\tshadow = workingset_eviction(mapping, page);\n\t\t__delete_from_page_cache(page, shadow);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\t\tif (freepage != NULL)\n\t\t\tfreepage(page);\n\t}\n\n\treturn 1;\n\ncannot_free:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint remove_mapping(struct address_space *mapping, struct page *page)\n{\n\tif (__remove_mapping(mapping, page, false)) {\n\t\t/*\n\t\t * Unfreezing the refcount with 1 rather than 2 effectively\n\t\t * drops the pagecache ref for us without requiring another\n\t\t * atomic operation.\n\t\t */\n\t\tpage_ref_unfreeze(page, 1);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__remove_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "885-974",
    "snippet": "static int __remove_mapping(struct address_space *mapping, struct page *page,\n\t\t\t    bool reclaimed)\n{\n\tunsigned long flags;\n\tint refcount;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(mapping != page_mapping(page));\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t/*\n\t * The non racy check for a busy page.\n\t *\n\t * Must be careful with the order of the tests. When someone has\n\t * a ref to the page, it may be possible that they dirty it then\n\t * drop the reference. So if PageDirty is tested before page_count\n\t * here, then the following race may occur:\n\t *\n\t * get_user_pages(&page);\n\t * [user mapping goes away]\n\t * write_to(page);\n\t *\t\t\t\t!PageDirty(page)    [good]\n\t * SetPageDirty(page);\n\t * put_page(page);\n\t *\t\t\t\t!page_count(page)   [good, discard it]\n\t *\n\t * [oops, our write_to data is lost]\n\t *\n\t * Reversing the order of the tests ensures such a situation cannot\n\t * escape unnoticed. The smp_rmb is needed to ensure the page->flags\n\t * load is not satisfied before that of page->_refcount.\n\t *\n\t * Note that if SetPageDirty is always performed via set_page_dirty,\n\t * and thus under the i_pages lock, then this ordering is not required.\n\t */\n\tif (unlikely(PageTransHuge(page)) && PageSwapCache(page))\n\t\trefcount = 1 + HPAGE_PMD_NR;\n\telse\n\t\trefcount = 2;\n\tif (!page_ref_freeze(page, refcount))\n\t\tgoto cannot_free;\n\t/* note: atomic_cmpxchg in page_ref_freeze provides the smp_rmb */\n\tif (unlikely(PageDirty(page))) {\n\t\tpage_ref_unfreeze(page, refcount);\n\t\tgoto cannot_free;\n\t}\n\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t swap = { .val = page_private(page) };\n\t\tmem_cgroup_swapout(page, swap);\n\t\t__delete_from_swap_cache(page, swap);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tput_swap_page(page, swap);\n\t} else {\n\t\tvoid (*freepage)(struct page *);\n\t\tvoid *shadow = NULL;\n\n\t\tfreepage = mapping->a_ops->freepage;\n\t\t/*\n\t\t * Remember a shadow entry for reclaimed file cache in\n\t\t * order to detect refaults, thus thrashing, later on.\n\t\t *\n\t\t * But don't store shadows in an address space that is\n\t\t * already exiting.  This is not just an optizimation,\n\t\t * inode reclaim needs to empty out the radix tree or\n\t\t * the nodes are lost.  Don't plant shadows behind its\n\t\t * back.\n\t\t *\n\t\t * We also don't store shadows for DAX mappings because the\n\t\t * only page cache pages found in these are zero pages\n\t\t * covering holes, and because we don't want to mix DAX\n\t\t * exceptional entries and shadow exceptional entries in the\n\t\t * same address_space.\n\t\t */\n\t\tif (reclaimed && page_is_file_cache(page) &&\n\t\t    !mapping_exiting(mapping) && !dax_mapping(mapping))\n\t\t\tshadow = workingset_eviction(mapping, page);\n\t\t__delete_from_page_cache(page, shadow);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\t\tif (freepage != NULL)\n\t\t\tfreepage(page);\n\t}\n\n\treturn 1;\n\ncannot_free:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freepage",
          "args": [
            "page"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1067-1163",
          "snippet": "static void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__delete_from_page_cache",
          "args": [
            "page",
            "shadow"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_from_page_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "227-235",
          "snippet": "void __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}"
        }
      },
      {
        "call_info": {
          "callee": "workingset_eviction",
          "args": [
            "mapping",
            "page"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "workingset_eviction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
          "lines": "224-240",
          "snippet": "void *workingset_eviction(struct address_space *mapping, struct page *page)\n{\n\tstruct pglist_data *pgdat = page_pgdat(page);\n\tstruct mem_cgroup *memcg = page_memcg(page);\n\tint memcgid = mem_cgroup_id(memcg);\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\n\t/* Page is fully exclusive and pins page->mem_cgroup */\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\teviction = atomic_long_inc_return(&lruvec->inactive_age);\n\treturn pack_shadow(memcgid, pgdat, eviction, PageWorkingset(page));\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/memcontrol.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nvoid *workingset_eviction(struct address_space *mapping, struct page *page)\n{\n\tstruct pglist_data *pgdat = page_pgdat(page);\n\tstruct mem_cgroup *memcg = page_memcg(page);\n\tint memcgid = mem_cgroup_id(memcg);\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\n\t/* Page is fully exclusive and pins page->mem_cgroup */\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\teviction = atomic_long_inc_return(&lruvec->inactive_age);\n\treturn pack_shadow(memcgid, pgdat, eviction, PageWorkingset(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_exiting",
          "args": [
            "mapping"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_swap_page",
          "args": [
            "page",
            "swap"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "put_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1225-1270",
          "snippet": "void put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__delete_from_swap_cache",
          "args": [
            "page",
            "swap"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_from_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "157-178",
          "snippet": "void __delete_from_swap_cache(struct page *page, swp_entry_t entry)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tint i, nr = hpage_nr_pages(page);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE(xas, &address_space->i_pages, idx);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(PageWriteback(page), page);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *entry = xas_store(&xas, NULL);\n\t\tVM_BUG_ON_PAGE(entry != page + i, entry);\n\t\tset_page_private(page + i, 0);\n\t\txas_next(&xas);\n\t}\n\tClearPageSwapCache(page);\n\taddress_space->nrpages -= nr;\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tADD_CACHE_INFO(del_total, nr);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid __delete_from_swap_cache(struct page *page, swp_entry_t entry)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tint i, nr = hpage_nr_pages(page);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE(xas, &address_space->i_pages, idx);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(PageWriteback(page), page);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *entry = xas_store(&xas, NULL);\n\t\tVM_BUG_ON_PAGE(entry != page + i, entry);\n\t\tset_page_private(page + i, 0);\n\t\txas_next(&xas);\n\t}\n\tClearPageSwapCache(page);\n\taddress_space->nrpages -= nr;\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tADD_CACHE_INFO(del_total, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_swapout",
          "args": [
            "page",
            "swap"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_swapout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6381-6438",
          "snippet": "void mem_cgroup_swapout(struct page *page, swp_entry_t entry)\n{\n\tstruct mem_cgroup *memcg, *swap_memcg;\n\tunsigned int nr_entries;\n\tunsigned short oldid;\n\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\n\tif (!do_memsw_account())\n\t\treturn;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn;\n\n\t/*\n\t * In case the memcg owning these pages has been offlined and doesn't\n\t * have an ID allocated to it anymore, charge the closest online\n\t * ancestor for the swap instead and transfer the memory+swap charge.\n\t */\n\tswap_memcg = mem_cgroup_id_get_online(memcg);\n\tnr_entries = hpage_nr_pages(page);\n\t/* Get references for the tail pages, too */\n\tif (nr_entries > 1)\n\t\tmem_cgroup_id_get_many(swap_memcg, nr_entries - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(swap_memcg),\n\t\t\t\t   nr_entries);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(swap_memcg, MEMCG_SWAP, nr_entries);\n\n\tpage->mem_cgroup = NULL;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tpage_counter_uncharge(&memcg->memory, nr_entries);\n\n\tif (memcg != swap_memcg) {\n\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\tpage_counter_charge(&swap_memcg->memsw, nr_entries);\n\t\tpage_counter_uncharge(&memcg->memsw, nr_entries);\n\t}\n\n\t/*\n\t * Interrupts should be disabled here because the caller holds the\n\t * i_pages lock which is taken with interrupts-off. It is\n\t * important here to have the interrupts disabled because it is the\n\t * only synchronisation we have for updating the per-CPU variables.\n\t */\n\tVM_BUG_ON(!irqs_disabled());\n\tmem_cgroup_charge_statistics(memcg, page, PageTransHuge(page),\n\t\t\t\t     -nr_entries);\n\tmemcg_check_events(memcg, page);\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tcss_put_many(&memcg->css, nr_entries);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_swapout(struct page *page, swp_entry_t entry)\n{\n\tstruct mem_cgroup *memcg, *swap_memcg;\n\tunsigned int nr_entries;\n\tunsigned short oldid;\n\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\n\tif (!do_memsw_account())\n\t\treturn;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn;\n\n\t/*\n\t * In case the memcg owning these pages has been offlined and doesn't\n\t * have an ID allocated to it anymore, charge the closest online\n\t * ancestor for the swap instead and transfer the memory+swap charge.\n\t */\n\tswap_memcg = mem_cgroup_id_get_online(memcg);\n\tnr_entries = hpage_nr_pages(page);\n\t/* Get references for the tail pages, too */\n\tif (nr_entries > 1)\n\t\tmem_cgroup_id_get_many(swap_memcg, nr_entries - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(swap_memcg),\n\t\t\t\t   nr_entries);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(swap_memcg, MEMCG_SWAP, nr_entries);\n\n\tpage->mem_cgroup = NULL;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tpage_counter_uncharge(&memcg->memory, nr_entries);\n\n\tif (memcg != swap_memcg) {\n\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\tpage_counter_charge(&swap_memcg->memsw, nr_entries);\n\t\tpage_counter_uncharge(&memcg->memsw, nr_entries);\n\t}\n\n\t/*\n\t * Interrupts should be disabled here because the caller holds the\n\t * i_pages lock which is taken with interrupts-off. It is\n\t * important here to have the interrupts disabled because it is the\n\t * only synchronisation we have for updating the per-CPU variables.\n\t */\n\tVM_BUG_ON(!irqs_disabled());\n\tmem_cgroup_charge_statistics(memcg, page, PageTransHuge(page),\n\t\t\t\t     -nr_entries);\n\tmemcg_check_events(memcg, page);\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\tcss_put_many(&memcg->css, nr_entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "page",
            "refcount"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageDirty(page)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "page",
            "refcount"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageTransHuge(page)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irqsave",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mapping != page_mapping(page)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int __remove_mapping(struct address_space *mapping, struct page *page,\n\t\t\t    bool reclaimed)\n{\n\tunsigned long flags;\n\tint refcount;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(mapping != page_mapping(page));\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t/*\n\t * The non racy check for a busy page.\n\t *\n\t * Must be careful with the order of the tests. When someone has\n\t * a ref to the page, it may be possible that they dirty it then\n\t * drop the reference. So if PageDirty is tested before page_count\n\t * here, then the following race may occur:\n\t *\n\t * get_user_pages(&page);\n\t * [user mapping goes away]\n\t * write_to(page);\n\t *\t\t\t\t!PageDirty(page)    [good]\n\t * SetPageDirty(page);\n\t * put_page(page);\n\t *\t\t\t\t!page_count(page)   [good, discard it]\n\t *\n\t * [oops, our write_to data is lost]\n\t *\n\t * Reversing the order of the tests ensures such a situation cannot\n\t * escape unnoticed. The smp_rmb is needed to ensure the page->flags\n\t * load is not satisfied before that of page->_refcount.\n\t *\n\t * Note that if SetPageDirty is always performed via set_page_dirty,\n\t * and thus under the i_pages lock, then this ordering is not required.\n\t */\n\tif (unlikely(PageTransHuge(page)) && PageSwapCache(page))\n\t\trefcount = 1 + HPAGE_PMD_NR;\n\telse\n\t\trefcount = 2;\n\tif (!page_ref_freeze(page, refcount))\n\t\tgoto cannot_free;\n\t/* note: atomic_cmpxchg in page_ref_freeze provides the smp_rmb */\n\tif (unlikely(PageDirty(page))) {\n\t\tpage_ref_unfreeze(page, refcount);\n\t\tgoto cannot_free;\n\t}\n\n\tif (PageSwapCache(page)) {\n\t\tswp_entry_t swap = { .val = page_private(page) };\n\t\tmem_cgroup_swapout(page, swap);\n\t\t__delete_from_swap_cache(page, swap);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tput_swap_page(page, swap);\n\t} else {\n\t\tvoid (*freepage)(struct page *);\n\t\tvoid *shadow = NULL;\n\n\t\tfreepage = mapping->a_ops->freepage;\n\t\t/*\n\t\t * Remember a shadow entry for reclaimed file cache in\n\t\t * order to detect refaults, thus thrashing, later on.\n\t\t *\n\t\t * But don't store shadows in an address space that is\n\t\t * already exiting.  This is not just an optizimation,\n\t\t * inode reclaim needs to empty out the radix tree or\n\t\t * the nodes are lost.  Don't plant shadows behind its\n\t\t * back.\n\t\t *\n\t\t * We also don't store shadows for DAX mappings because the\n\t\t * only page cache pages found in these are zero pages\n\t\t * covering holes, and because we don't want to mix DAX\n\t\t * exceptional entries and shadow exceptional entries in the\n\t\t * same address_space.\n\t\t */\n\t\tif (reclaimed && page_is_file_cache(page) &&\n\t\t    !mapping_exiting(mapping) && !dax_mapping(mapping))\n\t\t\tshadow = workingset_eviction(mapping, page);\n\t\t__delete_from_page_cache(page, shadow);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\t\tif (freepage != NULL)\n\t\t\tfreepage(page);\n\t}\n\n\treturn 1;\n\ncannot_free:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "pageout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "810-879",
    "snippet": "static pageout_t pageout(struct page *page, struct address_space *mapping,\n\t\t\t struct scan_control *sc)\n{\n\t/*\n\t * If the page is dirty, only perform writeback if that write\n\t * will be non-blocking.  To prevent this allocation from being\n\t * stalled by pagecache activity.  But note that there may be\n\t * stalls if we need to run get_block().  We could test\n\t * PagePrivate for that.\n\t *\n\t * If this process is currently in __generic_file_write_iter() against\n\t * this page's queue, we can perform writeback even if that\n\t * will block.\n\t *\n\t * If the page is swapcache, write it back even if that would\n\t * block, for some throttling. This happens by accident, because\n\t * swap_backing_dev_info is bust: it doesn't reflect the\n\t * congestion state of the swapdevs.  Easy to fix, if needed.\n\t */\n\tif (!is_page_cache_freeable(page))\n\t\treturn PAGE_KEEP;\n\tif (!mapping) {\n\t\t/*\n\t\t * Some data journaling orphaned pages can have\n\t\t * page->mapping == NULL while being dirty with clean buffers.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (try_to_free_buffers(page)) {\n\t\t\t\tClearPageDirty(page);\n\t\t\t\tpr_info(\"%s: orphaned page\\n\", __func__);\n\t\t\t\treturn PAGE_CLEAN;\n\t\t\t}\n\t\t}\n\t\treturn PAGE_KEEP;\n\t}\n\tif (mapping->a_ops->writepage == NULL)\n\t\treturn PAGE_ACTIVATE;\n\tif (!may_write_to_inode(mapping->host, sc))\n\t\treturn PAGE_KEEP;\n\n\tif (clear_page_dirty_for_io(page)) {\n\t\tint res;\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t.nr_to_write = SWAP_CLUSTER_MAX,\n\t\t\t.range_start = 0,\n\t\t\t.range_end = LLONG_MAX,\n\t\t\t.for_reclaim = 1,\n\t\t};\n\n\t\tSetPageReclaim(page);\n\t\tres = mapping->a_ops->writepage(page, &wbc);\n\t\tif (res < 0)\n\t\t\thandle_write_error(mapping, page, res);\n\t\tif (res == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\tClearPageReclaim(page);\n\t\t\treturn PAGE_ACTIVATE;\n\t\t}\n\n\t\tif (!PageWriteback(page)) {\n\t\t\t/* synchronous write or broken a_ops? */\n\t\t\tClearPageReclaim(page);\n\t\t}\n\t\ttrace_mm_vmscan_writepage(page);\n\t\tinc_node_page_state(page, NR_VMSCAN_WRITE);\n\t\treturn PAGE_SUCCESS;\n\t}\n\n\treturn PAGE_CLEAN;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_node_page_state",
          "args": [
            "page",
            "NR_VMSCAN_WRITE"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "655-664",
          "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_vmscan_writepage",
          "args": [
            "page"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReclaim",
          "args": [
            "page"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReclaim",
          "args": [
            "page"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_write_error",
          "args": [
            "mapping",
            "page",
            "res"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "handle_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "785-792",
          "snippet": "static void handle_write_error(struct address_space *mapping,\n\t\t\t\tstruct page *page, int error)\n{\n\tlock_page(page);\n\tif (page_mapping(page) == mapping)\n\t\tmapping_set_error(mapping, error);\n\tunlock_page(page);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void handle_write_error(struct address_space *mapping,\n\t\t\t\tstruct page *page, int error)\n{\n\tlock_page(page);\n\tif (page_mapping(page) == mapping)\n\t\tmapping_set_error(mapping, error);\n\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepage",
          "args": [
            "page",
            "&wbc"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReclaim",
          "args": [
            "page"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_dirty_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2634-2692",
          "snippet": "int clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_write_to_inode",
          "args": [
            "mapping->host",
            "sc"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "may_write_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "762-771",
          "snippet": "static int may_write_to_inode(struct inode *inode, struct scan_control *sc)\n{\n\tif (current->flags & PF_SWAPWRITE)\n\t\treturn 1;\n\tif (!inode_write_congested(inode))\n\t\treturn 1;\n\tif (inode_to_bdi(inode) == current->backing_dev_info)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int may_write_to_inode(struct inode *inode, struct scan_control *sc)\n{\n\tif (current->flags & PF_SWAPWRITE)\n\t\treturn 1;\n\tif (!inode_write_congested(inode))\n\t\treturn 1;\n\tif (inode_to_bdi(inode) == current->backing_dev_info)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: orphaned page\\n\"",
            "__func__"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_page_cache_freeable",
          "args": [
            "page"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_cache_freeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "750-760",
          "snippet": "static inline int is_page_cache_freeable(struct page *page)\n{\n\t/*\n\t * A freeable page cache page is referenced only by the caller\n\t * that isolated the page, the page cache and optional buffer\n\t * heads at page->private.\n\t */\n\tint page_cache_pins = PageTransHuge(page) && PageSwapCache(page) ?\n\t\tHPAGE_PMD_NR : 1;\n\treturn page_count(page) - page_has_private(page) == 1 + page_cache_pins;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int is_page_cache_freeable(struct page *page)\n{\n\t/*\n\t * A freeable page cache page is referenced only by the caller\n\t * that isolated the page, the page cache and optional buffer\n\t * heads at page->private.\n\t */\n\tint page_cache_pins = PageTransHuge(page) && PageSwapCache(page) ?\n\t\tHPAGE_PMD_NR : 1;\n\treturn page_count(page) - page_has_private(page) == 1 + page_cache_pins;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic pageout_t pageout(struct page *page, struct address_space *mapping,\n\t\t\t struct scan_control *sc)\n{\n\t/*\n\t * If the page is dirty, only perform writeback if that write\n\t * will be non-blocking.  To prevent this allocation from being\n\t * stalled by pagecache activity.  But note that there may be\n\t * stalls if we need to run get_block().  We could test\n\t * PagePrivate for that.\n\t *\n\t * If this process is currently in __generic_file_write_iter() against\n\t * this page's queue, we can perform writeback even if that\n\t * will block.\n\t *\n\t * If the page is swapcache, write it back even if that would\n\t * block, for some throttling. This happens by accident, because\n\t * swap_backing_dev_info is bust: it doesn't reflect the\n\t * congestion state of the swapdevs.  Easy to fix, if needed.\n\t */\n\tif (!is_page_cache_freeable(page))\n\t\treturn PAGE_KEEP;\n\tif (!mapping) {\n\t\t/*\n\t\t * Some data journaling orphaned pages can have\n\t\t * page->mapping == NULL while being dirty with clean buffers.\n\t\t */\n\t\tif (page_has_private(page)) {\n\t\t\tif (try_to_free_buffers(page)) {\n\t\t\t\tClearPageDirty(page);\n\t\t\t\tpr_info(\"%s: orphaned page\\n\", __func__);\n\t\t\t\treturn PAGE_CLEAN;\n\t\t\t}\n\t\t}\n\t\treturn PAGE_KEEP;\n\t}\n\tif (mapping->a_ops->writepage == NULL)\n\t\treturn PAGE_ACTIVATE;\n\tif (!may_write_to_inode(mapping->host, sc))\n\t\treturn PAGE_KEEP;\n\n\tif (clear_page_dirty_for_io(page)) {\n\t\tint res;\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_NONE,\n\t\t\t.nr_to_write = SWAP_CLUSTER_MAX,\n\t\t\t.range_start = 0,\n\t\t\t.range_end = LLONG_MAX,\n\t\t\t.for_reclaim = 1,\n\t\t};\n\n\t\tSetPageReclaim(page);\n\t\tres = mapping->a_ops->writepage(page, &wbc);\n\t\tif (res < 0)\n\t\t\thandle_write_error(mapping, page, res);\n\t\tif (res == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\tClearPageReclaim(page);\n\t\t\treturn PAGE_ACTIVATE;\n\t\t}\n\n\t\tif (!PageWriteback(page)) {\n\t\t\t/* synchronous write or broken a_ops? */\n\t\t\tClearPageReclaim(page);\n\t\t}\n\t\ttrace_mm_vmscan_writepage(page);\n\t\tinc_node_page_state(page, NR_VMSCAN_WRITE);\n\t\treturn PAGE_SUCCESS;\n\t}\n\n\treturn PAGE_CLEAN;\n}"
  },
  {
    "function_name": "handle_write_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "785-792",
    "snippet": "static void handle_write_error(struct address_space *mapping,\n\t\t\t\tstruct page *page, int error)\n{\n\tlock_page(page);\n\tif (page_mapping(page) == mapping)\n\t\tmapping_set_error(mapping, error);\n\tunlock_page(page);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "error"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void handle_write_error(struct address_space *mapping,\n\t\t\t\tstruct page *page, int error)\n{\n\tlock_page(page);\n\tif (page_mapping(page) == mapping)\n\t\tmapping_set_error(mapping, error);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "may_write_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "762-771",
    "snippet": "static int may_write_to_inode(struct inode *inode, struct scan_control *sc)\n{\n\tif (current->flags & PF_SWAPWRITE)\n\t\treturn 1;\n\tif (!inode_write_congested(inode))\n\t\treturn 1;\n\tif (inode_to_bdi(inode) == current->backing_dev_info)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_write_congested",
          "args": [
            "inode"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int may_write_to_inode(struct inode *inode, struct scan_control *sc)\n{\n\tif (current->flags & PF_SWAPWRITE)\n\t\treturn 1;\n\tif (!inode_write_congested(inode))\n\t\treturn 1;\n\tif (inode_to_bdi(inode) == current->backing_dev_info)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "is_page_cache_freeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "750-760",
    "snippet": "static inline int is_page_cache_freeable(struct page *page)\n{\n\t/*\n\t * A freeable page cache page is referenced only by the caller\n\t * that isolated the page, the page cache and optional buffer\n\t * heads at page->private.\n\t */\n\tint page_cache_pins = PageTransHuge(page) && PageSwapCache(page) ?\n\t\tHPAGE_PMD_NR : 1;\n\treturn page_count(page) - page_has_private(page) == 1 + page_cache_pins;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int is_page_cache_freeable(struct page *page)\n{\n\t/*\n\t * A freeable page cache page is referenced only by the caller\n\t * that isolated the page, the page cache and optional buffer\n\t * heads at page->private.\n\t */\n\tint page_cache_pins = PageTransHuge(page) && PageSwapCache(page) ?\n\t\tHPAGE_PMD_NR : 1;\n\treturn page_count(page) - page_has_private(page) == 1 + page_cache_pins;\n}"
  },
  {
    "function_name": "drop_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "742-748",
    "snippet": "void drop_slab(void)\n{\n\tint nid;\n\n\tfor_each_online_node(nid)\n\t\tdrop_slab_node(nid);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid drop_slab(void)\n{\n\tint nid;\n\n\tfor_each_online_node(nid)\n\t\tdrop_slab_node(nid);\n}"
  },
  {
    "function_name": "drop_slab_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "727-740",
    "snippet": "void drop_slab_node(int nid)\n{\n\tunsigned long freed;\n\n\tdo {\n\t\tstruct mem_cgroup *memcg = NULL;\n\n\t\tfreed = 0;\n\t\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\t\tdo {\n\t\t\tfreed += shrink_slab(GFP_KERNEL, nid, memcg, 0);\n\t\t} while ((memcg = mem_cgroup_iter(NULL, memcg, NULL)) != NULL);\n\t} while (freed > 10);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_iter",
          "args": [
            "NULL",
            "memcg",
            "NULL"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "910-1018",
          "snippet": "struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct mem_cgroup *memcg = NULL;\n\tstruct mem_cgroup *pos = NULL;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tpos = prev;\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\tgoto out;\n\t\treturn root;\n\t}\n\n\trcu_read_lock();\n\n\tif (reclaim) {\n\t\tstruct mem_cgroup_per_node *mz;\n\n\t\tmz = mem_cgroup_nodeinfo(root, reclaim->pgdat->node_id);\n\t\titer = &mz->iter[reclaim->priority];\n\n\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\tgoto out_unlock;\n\n\t\twhile (1) {\n\t\t\tpos = READ_ONCE(iter->position);\n\t\t\tif (!pos || css_tryget(&pos->css))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * css reference reached zero, so iter->position will\n\t\t\t * be cleared by ->css_released. However, we should not\n\t\t\t * rely on this happening soon, because ->css_released\n\t\t\t * is called from a work queue, and by busy-waiting we\n\t\t\t * might block it. So we clear iter->position right\n\t\t\t * away.\n\t\t\t */\n\t\t\t(void)cmpxchg(&iter->position, pos, NULL);\n\t\t}\n\t}\n\n\tif (pos)\n\t\tcss = &pos->css;\n\n\tfor (;;) {\n\t\tcss = css_next_descendant_pre(css, &root->css);\n\t\tif (!css) {\n\t\t\t/*\n\t\t\t * Reclaimers share the hierarchy walk, and a\n\t\t\t * new one might jump in right at the end of\n\t\t\t * the hierarchy - make sure they see at least\n\t\t\t * one group and restart from the beginning.\n\t\t\t */\n\t\t\tif (!prev)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Verify the css and acquire a reference.  The root\n\t\t * is provided by the caller, so we know it's alive\n\t\t * and kicking, and don't take an extra reference.\n\t\t */\n\t\tmemcg = mem_cgroup_from_css(css);\n\n\t\tif (css == &root->css)\n\t\t\tbreak;\n\n\t\tif (css_tryget(css))\n\t\t\tbreak;\n\n\t\tmemcg = NULL;\n\t}\n\n\tif (reclaim) {\n\t\t/*\n\t\t * The position could have already been updated by a competing\n\t\t * thread, so check that the value hasn't changed since we read\n\t\t * it to avoid reclaiming from the same cgroup twice.\n\t\t */\n\t\t(void)cmpxchg(&iter->position, pos, memcg);\n\n\t\tif (pos)\n\t\t\tcss_put(&pos->css);\n\n\t\tif (!memcg)\n\t\t\titer->generation++;\n\t\telse if (!prev)\n\t\t\treclaim->generation = iter->generation;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_slab",
          "args": [
            "GFP_KERNEL",
            "nid",
            "memcg",
            "0"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "686-725",
          "snippet": "static unsigned long shrink_slab(gfp_t gfp_mask, int nid,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t int priority)\n{\n\tunsigned long ret, freed = 0;\n\tstruct shrinker *shrinker;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\treturn shrink_slab_memcg(gfp_mask, nid, memcg, priority);\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\tgoto out;\n\n\tlist_for_each_entry(shrinker, &shrinker_list, list) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY)\n\t\t\tret = 0;\n\t\tfreed += ret;\n\t\t/*\n\t\t * Bail out if someone want to register a new shrinker to\n\t\t * prevent the regsitration from being stalled for long periods\n\t\t * by parallel ongoing shrinking.\n\t\t */\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&shrinker_rwsem);\nout:\n\tcond_resched();\n\treturn freed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(shrinker_list);",
            "static DECLARE_RWSEM(shrinker_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(shrinker_list);\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nstatic unsigned long shrink_slab(gfp_t gfp_mask, int nid,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t int priority)\n{\n\tunsigned long ret, freed = 0;\n\tstruct shrinker *shrinker;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\treturn shrink_slab_memcg(gfp_mask, nid, memcg, priority);\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\tgoto out;\n\n\tlist_for_each_entry(shrinker, &shrinker_list, list) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY)\n\t\t\tret = 0;\n\t\tfreed += ret;\n\t\t/*\n\t\t * Bail out if someone want to register a new shrinker to\n\t\t * prevent the regsitration from being stalled for long periods\n\t\t * by parallel ongoing shrinking.\n\t\t */\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&shrinker_rwsem);\nout:\n\tcond_resched();\n\treturn freed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid drop_slab_node(int nid)\n{\n\tunsigned long freed;\n\n\tdo {\n\t\tstruct mem_cgroup *memcg = NULL;\n\n\t\tfreed = 0;\n\t\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\t\tdo {\n\t\t\tfreed += shrink_slab(GFP_KERNEL, nid, memcg, 0);\n\t\t} while ((memcg = mem_cgroup_iter(NULL, memcg, NULL)) != NULL);\n\t} while (freed > 10);\n}"
  },
  {
    "function_name": "shrink_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "686-725",
    "snippet": "static unsigned long shrink_slab(gfp_t gfp_mask, int nid,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t int priority)\n{\n\tunsigned long ret, freed = 0;\n\tstruct shrinker *shrinker;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\treturn shrink_slab_memcg(gfp_mask, nid, memcg, priority);\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\tgoto out;\n\n\tlist_for_each_entry(shrinker, &shrinker_list, list) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY)\n\t\t\tret = 0;\n\t\tfreed += ret;\n\t\t/*\n\t\t * Bail out if someone want to register a new shrinker to\n\t\t * prevent the regsitration from being stalled for long periods\n\t\t * by parallel ongoing shrinking.\n\t\t */\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&shrinker_rwsem);\nout:\n\tcond_resched();\n\treturn freed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(shrinker_list);",
      "static DECLARE_RWSEM(shrinker_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_contended",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_shrink_slab",
          "args": [
            "&sc",
            "shrinker",
            "priority"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "do_shrink_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "448-586",
          "snippet": "static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,\n\t\t\t\t    struct shrinker *shrinker, int priority)\n{\n\tunsigned long freed = 0;\n\tunsigned long long delta;\n\tlong total_scan;\n\tlong freeable;\n\tlong nr;\n\tlong new_nr;\n\tint nid = shrinkctl->nid;\n\tlong batch_size = shrinker->batch ? shrinker->batch\n\t\t\t\t\t  : SHRINK_BATCH;\n\tlong scanned = 0, next_deferred;\n\n\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))\n\t\tnid = 0;\n\n\tfreeable = shrinker->count_objects(shrinker, shrinkctl);\n\tif (freeable == 0 || freeable == SHRINK_EMPTY)\n\t\treturn freeable;\n\n\t/*\n\t * copy the current shrinker scan count into a local variable\n\t * and zero it so that other concurrent shrinker invocations\n\t * don't also do this scanning work.\n\t */\n\tnr = atomic_long_xchg(&shrinker->nr_deferred[nid], 0);\n\n\ttotal_scan = nr;\n\tif (shrinker->seeks) {\n\t\tdelta = freeable >> priority;\n\t\tdelta *= 4;\n\t\tdo_div(delta, shrinker->seeks);\n\t} else {\n\t\t/*\n\t\t * These objects don't require any IO to create. Trim\n\t\t * them aggressively under memory pressure to keep\n\t\t * them from causing refetches in the IO caches.\n\t\t */\n\t\tdelta = freeable / 2;\n\t}\n\n\t/*\n\t * Make sure we apply some minimal pressure on default priority\n\t * even on small cgroups. Stale objects are not only consuming memory\n\t * by themselves, but can also hold a reference to a dying cgroup,\n\t * preventing it from being reclaimed. A dying cgroup with all\n\t * corresponding structures like per-cpu stats and kmem caches\n\t * can be really big, so it may lead to a significant waste of memory.\n\t */\n\tdelta = max_t(unsigned long long, delta, min(freeable, batch_size));\n\n\ttotal_scan += delta;\n\tif (total_scan < 0) {\n\t\tpr_err(\"shrink_slab: %pF negative objects to delete nr=%ld\\n\",\n\t\t       shrinker->scan_objects, total_scan);\n\t\ttotal_scan = freeable;\n\t\tnext_deferred = nr;\n\t} else\n\t\tnext_deferred = total_scan;\n\n\t/*\n\t * We need to avoid excessive windup on filesystem shrinkers\n\t * due to large numbers of GFP_NOFS allocations causing the\n\t * shrinkers to return -1 all the time. This results in a large\n\t * nr being built up so when a shrink that can do some work\n\t * comes along it empties the entire cache due to nr >>>\n\t * freeable. This is bad for sustaining a working set in\n\t * memory.\n\t *\n\t * Hence only allow the shrinker to scan the entire cache when\n\t * a large delta change is calculated directly.\n\t */\n\tif (delta < freeable / 4)\n\t\ttotal_scan = min(total_scan, freeable / 2);\n\n\t/*\n\t * Avoid risking looping forever due to too large nr value:\n\t * never try to free more than twice the estimate number of\n\t * freeable entries.\n\t */\n\tif (total_scan > freeable * 2)\n\t\ttotal_scan = freeable * 2;\n\n\ttrace_mm_shrink_slab_start(shrinker, shrinkctl, nr,\n\t\t\t\t   freeable, delta, total_scan, priority);\n\n\t/*\n\t * Normally, we should not scan less than batch_size objects in one\n\t * pass to avoid too frequent shrinker calls, but if the slab has less\n\t * than batch_size objects in total and we are really tight on memory,\n\t * we will try to reclaim all available objects, otherwise we can end\n\t * up failing allocations although there are plenty of reclaimable\n\t * objects spread over several slabs with usage less than the\n\t * batch_size.\n\t *\n\t * We detect the \"tight on memory\" situations by looking at the total\n\t * number of objects we want to scan (total_scan). If it is greater\n\t * than the total number of objects on slab (freeable), we must be\n\t * scanning at high prio and therefore should try to reclaim as much as\n\t * possible.\n\t */\n\twhile (total_scan >= batch_size ||\n\t       total_scan >= freeable) {\n\t\tunsigned long ret;\n\t\tunsigned long nr_to_scan = min(batch_size, total_scan);\n\n\t\tshrinkctl->nr_to_scan = nr_to_scan;\n\t\tshrinkctl->nr_scanned = nr_to_scan;\n\t\tret = shrinker->scan_objects(shrinker, shrinkctl);\n\t\tif (ret == SHRINK_STOP)\n\t\t\tbreak;\n\t\tfreed += ret;\n\n\t\tcount_vm_events(SLABS_SCANNED, shrinkctl->nr_scanned);\n\t\ttotal_scan -= shrinkctl->nr_scanned;\n\t\tscanned += shrinkctl->nr_scanned;\n\n\t\tcond_resched();\n\t}\n\n\tif (next_deferred >= scanned)\n\t\tnext_deferred -= scanned;\n\telse\n\t\tnext_deferred = 0;\n\t/*\n\t * move the unused scan count back into the shrinker in a\n\t * manner that handles concurrent updates. If we exhausted the\n\t * scan, there is no need to do an update.\n\t */\n\tif (next_deferred > 0)\n\t\tnew_nr = atomic_long_add_return(next_deferred,\n\t\t\t\t\t\t&shrinker->nr_deferred[nid]);\n\telse\n\t\tnew_nr = atomic_long_read(&shrinker->nr_deferred[nid]);\n\n\ttrace_mm_shrink_slab_end(shrinker, nid, freed, nr, new_nr, total_scan);\n\treturn freed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SHRINK_BATCH 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SHRINK_BATCH 128\n\nstatic unsigned long do_shrink_slab(struct shrink_control *shrinkctl,\n\t\t\t\t    struct shrinker *shrinker, int priority)\n{\n\tunsigned long freed = 0;\n\tunsigned long long delta;\n\tlong total_scan;\n\tlong freeable;\n\tlong nr;\n\tlong new_nr;\n\tint nid = shrinkctl->nid;\n\tlong batch_size = shrinker->batch ? shrinker->batch\n\t\t\t\t\t  : SHRINK_BATCH;\n\tlong scanned = 0, next_deferred;\n\n\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))\n\t\tnid = 0;\n\n\tfreeable = shrinker->count_objects(shrinker, shrinkctl);\n\tif (freeable == 0 || freeable == SHRINK_EMPTY)\n\t\treturn freeable;\n\n\t/*\n\t * copy the current shrinker scan count into a local variable\n\t * and zero it so that other concurrent shrinker invocations\n\t * don't also do this scanning work.\n\t */\n\tnr = atomic_long_xchg(&shrinker->nr_deferred[nid], 0);\n\n\ttotal_scan = nr;\n\tif (shrinker->seeks) {\n\t\tdelta = freeable >> priority;\n\t\tdelta *= 4;\n\t\tdo_div(delta, shrinker->seeks);\n\t} else {\n\t\t/*\n\t\t * These objects don't require any IO to create. Trim\n\t\t * them aggressively under memory pressure to keep\n\t\t * them from causing refetches in the IO caches.\n\t\t */\n\t\tdelta = freeable / 2;\n\t}\n\n\t/*\n\t * Make sure we apply some minimal pressure on default priority\n\t * even on small cgroups. Stale objects are not only consuming memory\n\t * by themselves, but can also hold a reference to a dying cgroup,\n\t * preventing it from being reclaimed. A dying cgroup with all\n\t * corresponding structures like per-cpu stats and kmem caches\n\t * can be really big, so it may lead to a significant waste of memory.\n\t */\n\tdelta = max_t(unsigned long long, delta, min(freeable, batch_size));\n\n\ttotal_scan += delta;\n\tif (total_scan < 0) {\n\t\tpr_err(\"shrink_slab: %pF negative objects to delete nr=%ld\\n\",\n\t\t       shrinker->scan_objects, total_scan);\n\t\ttotal_scan = freeable;\n\t\tnext_deferred = nr;\n\t} else\n\t\tnext_deferred = total_scan;\n\n\t/*\n\t * We need to avoid excessive windup on filesystem shrinkers\n\t * due to large numbers of GFP_NOFS allocations causing the\n\t * shrinkers to return -1 all the time. This results in a large\n\t * nr being built up so when a shrink that can do some work\n\t * comes along it empties the entire cache due to nr >>>\n\t * freeable. This is bad for sustaining a working set in\n\t * memory.\n\t *\n\t * Hence only allow the shrinker to scan the entire cache when\n\t * a large delta change is calculated directly.\n\t */\n\tif (delta < freeable / 4)\n\t\ttotal_scan = min(total_scan, freeable / 2);\n\n\t/*\n\t * Avoid risking looping forever due to too large nr value:\n\t * never try to free more than twice the estimate number of\n\t * freeable entries.\n\t */\n\tif (total_scan > freeable * 2)\n\t\ttotal_scan = freeable * 2;\n\n\ttrace_mm_shrink_slab_start(shrinker, shrinkctl, nr,\n\t\t\t\t   freeable, delta, total_scan, priority);\n\n\t/*\n\t * Normally, we should not scan less than batch_size objects in one\n\t * pass to avoid too frequent shrinker calls, but if the slab has less\n\t * than batch_size objects in total and we are really tight on memory,\n\t * we will try to reclaim all available objects, otherwise we can end\n\t * up failing allocations although there are plenty of reclaimable\n\t * objects spread over several slabs with usage less than the\n\t * batch_size.\n\t *\n\t * We detect the \"tight on memory\" situations by looking at the total\n\t * number of objects we want to scan (total_scan). If it is greater\n\t * than the total number of objects on slab (freeable), we must be\n\t * scanning at high prio and therefore should try to reclaim as much as\n\t * possible.\n\t */\n\twhile (total_scan >= batch_size ||\n\t       total_scan >= freeable) {\n\t\tunsigned long ret;\n\t\tunsigned long nr_to_scan = min(batch_size, total_scan);\n\n\t\tshrinkctl->nr_to_scan = nr_to_scan;\n\t\tshrinkctl->nr_scanned = nr_to_scan;\n\t\tret = shrinker->scan_objects(shrinker, shrinkctl);\n\t\tif (ret == SHRINK_STOP)\n\t\t\tbreak;\n\t\tfreed += ret;\n\n\t\tcount_vm_events(SLABS_SCANNED, shrinkctl->nr_scanned);\n\t\ttotal_scan -= shrinkctl->nr_scanned;\n\t\tscanned += shrinkctl->nr_scanned;\n\n\t\tcond_resched();\n\t}\n\n\tif (next_deferred >= scanned)\n\t\tnext_deferred -= scanned;\n\telse\n\t\tnext_deferred = 0;\n\t/*\n\t * move the unused scan count back into the shrinker in a\n\t * manner that handles concurrent updates. If we exhausted the\n\t * scan, there is no need to do an update.\n\t */\n\tif (next_deferred > 0)\n\t\tnew_nr = atomic_long_add_return(next_deferred,\n\t\t\t\t\t\t&shrinker->nr_deferred[nid]);\n\telse\n\t\tnew_nr = atomic_long_read(&shrinker->nr_deferred[nid]);\n\n\ttrace_mm_shrink_slab_end(shrinker, nid, freed, nr, new_nr, total_scan);\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "shrinker",
            "&shrinker_list",
            "list"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_slab_memcg",
          "args": [
            "gfp_mask",
            "nid",
            "memcg",
            "priority"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_slab_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "659-663",
          "snippet": "static unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,\n\t\t\tstruct mem_cgroup *memcg, int priority)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,\n\t\t\tstruct mem_cgroup *memcg, int priority)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_is_root",
          "args": [
            "memcg"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(shrinker_list);\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nstatic unsigned long shrink_slab(gfp_t gfp_mask, int nid,\n\t\t\t\t struct mem_cgroup *memcg,\n\t\t\t\t int priority)\n{\n\tunsigned long ret, freed = 0;\n\tstruct shrinker *shrinker;\n\n\tif (!mem_cgroup_is_root(memcg))\n\t\treturn shrink_slab_memcg(gfp_mask, nid, memcg, priority);\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\tgoto out;\n\n\tlist_for_each_entry(shrinker, &shrinker_list, list) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY)\n\t\t\tret = 0;\n\t\tfreed += ret;\n\t\t/*\n\t\t * Bail out if someone want to register a new shrinker to\n\t\t * prevent the regsitration from being stalled for long periods\n\t\t * by parallel ongoing shrinking.\n\t\t */\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&shrinker_rwsem);\nout:\n\tcond_resched();\n\treturn freed;\n}"
  },
  {
    "function_name": "shrink_slab_memcg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "659-663",
    "snippet": "static unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,\n\t\t\tstruct mem_cgroup *memcg, int priority)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,\n\t\t\tstruct mem_cgroup *memcg, int priority)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "shrink_slab_memcg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "589-657",
    "snippet": "static unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,\n\t\t\tstruct mem_cgroup *memcg, int priority)\n{\n\tstruct memcg_shrinker_map *map;\n\tunsigned long ret, freed = 0;\n\tint i;\n\n\tif (!memcg_kmem_enabled() || !mem_cgroup_online(memcg))\n\t\treturn 0;\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\treturn 0;\n\n\tmap = rcu_dereference_protected(memcg->nodeinfo[nid]->shrinker_map,\n\t\t\t\t\ttrue);\n\tif (unlikely(!map))\n\t\tgoto unlock;\n\n\tfor_each_set_bit(i, map->map, shrinker_nr_max) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\t\tstruct shrinker *shrinker;\n\n\t\tshrinker = idr_find(&shrinker_idr, i);\n\t\tif (unlikely(!shrinker || shrinker == SHRINKER_REGISTERING)) {\n\t\t\tif (!shrinker)\n\t\t\t\tclear_bit(i, map->map);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY) {\n\t\t\tclear_bit(i, map->map);\n\t\t\t/*\n\t\t\t * After the shrinker reported that it had no objects to\n\t\t\t * free, but before we cleared the corresponding bit in\n\t\t\t * the memcg shrinker map, a new object might have been\n\t\t\t * added. To make sure, we have the bit set in this\n\t\t\t * case, we invoke the shrinker one more time and reset\n\t\t\t * the bit if it reports that it is not empty anymore.\n\t\t\t * The memory barrier here pairs with the barrier in\n\t\t\t * memcg_set_shrinker_bit():\n\t\t\t *\n\t\t\t * list_lru_add()     shrink_slab_memcg()\n\t\t\t *   list_add_tail()    clear_bit()\n\t\t\t *   <MB>               <MB>\n\t\t\t *   set_bit()          do_shrink_slab()\n\t\t\t */\n\t\t\tsmp_mb__after_atomic();\n\t\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\t\tif (ret == SHRINK_EMPTY)\n\t\t\t\tret = 0;\n\t\t\telse\n\t\t\t\tmemcg_set_shrinker_bit(memcg, nid, i);\n\t\t}\n\t\tfreed += ret;\n\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock:\n\tup_read(&shrinker_rwsem);\n\treturn freed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SHRINKER_REGISTERING ((struct shrinker *)~0UL)"
    ],
    "globals_used": [
      "static DECLARE_RWSEM(shrinker_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_contended",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_set_shrinker_bit",
          "args": [
            "memcg",
            "nid",
            "i"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_set_shrinker_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "426-438",
          "snippet": "void memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid memcg_set_shrinker_bit(struct mem_cgroup *memcg, int nid, int shrinker_id)\n{\n\tif (shrinker_id >= 0 && memcg && !mem_cgroup_is_root(memcg)) {\n\t\tstruct memcg_shrinker_map *map;\n\n\t\trcu_read_lock();\n\t\tmap = rcu_dereference(memcg->nodeinfo[nid]->shrinker_map);\n\t\t/* Pairs with smp mb in shrink_slab() */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(shrinker_id, map->map);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_shrink_slab",
          "args": [
            "&sc",
            "shrinker",
            "priority"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "do_shrink_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "448-586",
          "snippet": "static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,\n\t\t\t\t    struct shrinker *shrinker, int priority)\n{\n\tunsigned long freed = 0;\n\tunsigned long long delta;\n\tlong total_scan;\n\tlong freeable;\n\tlong nr;\n\tlong new_nr;\n\tint nid = shrinkctl->nid;\n\tlong batch_size = shrinker->batch ? shrinker->batch\n\t\t\t\t\t  : SHRINK_BATCH;\n\tlong scanned = 0, next_deferred;\n\n\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))\n\t\tnid = 0;\n\n\tfreeable = shrinker->count_objects(shrinker, shrinkctl);\n\tif (freeable == 0 || freeable == SHRINK_EMPTY)\n\t\treturn freeable;\n\n\t/*\n\t * copy the current shrinker scan count into a local variable\n\t * and zero it so that other concurrent shrinker invocations\n\t * don't also do this scanning work.\n\t */\n\tnr = atomic_long_xchg(&shrinker->nr_deferred[nid], 0);\n\n\ttotal_scan = nr;\n\tif (shrinker->seeks) {\n\t\tdelta = freeable >> priority;\n\t\tdelta *= 4;\n\t\tdo_div(delta, shrinker->seeks);\n\t} else {\n\t\t/*\n\t\t * These objects don't require any IO to create. Trim\n\t\t * them aggressively under memory pressure to keep\n\t\t * them from causing refetches in the IO caches.\n\t\t */\n\t\tdelta = freeable / 2;\n\t}\n\n\t/*\n\t * Make sure we apply some minimal pressure on default priority\n\t * even on small cgroups. Stale objects are not only consuming memory\n\t * by themselves, but can also hold a reference to a dying cgroup,\n\t * preventing it from being reclaimed. A dying cgroup with all\n\t * corresponding structures like per-cpu stats and kmem caches\n\t * can be really big, so it may lead to a significant waste of memory.\n\t */\n\tdelta = max_t(unsigned long long, delta, min(freeable, batch_size));\n\n\ttotal_scan += delta;\n\tif (total_scan < 0) {\n\t\tpr_err(\"shrink_slab: %pF negative objects to delete nr=%ld\\n\",\n\t\t       shrinker->scan_objects, total_scan);\n\t\ttotal_scan = freeable;\n\t\tnext_deferred = nr;\n\t} else\n\t\tnext_deferred = total_scan;\n\n\t/*\n\t * We need to avoid excessive windup on filesystem shrinkers\n\t * due to large numbers of GFP_NOFS allocations causing the\n\t * shrinkers to return -1 all the time. This results in a large\n\t * nr being built up so when a shrink that can do some work\n\t * comes along it empties the entire cache due to nr >>>\n\t * freeable. This is bad for sustaining a working set in\n\t * memory.\n\t *\n\t * Hence only allow the shrinker to scan the entire cache when\n\t * a large delta change is calculated directly.\n\t */\n\tif (delta < freeable / 4)\n\t\ttotal_scan = min(total_scan, freeable / 2);\n\n\t/*\n\t * Avoid risking looping forever due to too large nr value:\n\t * never try to free more than twice the estimate number of\n\t * freeable entries.\n\t */\n\tif (total_scan > freeable * 2)\n\t\ttotal_scan = freeable * 2;\n\n\ttrace_mm_shrink_slab_start(shrinker, shrinkctl, nr,\n\t\t\t\t   freeable, delta, total_scan, priority);\n\n\t/*\n\t * Normally, we should not scan less than batch_size objects in one\n\t * pass to avoid too frequent shrinker calls, but if the slab has less\n\t * than batch_size objects in total and we are really tight on memory,\n\t * we will try to reclaim all available objects, otherwise we can end\n\t * up failing allocations although there are plenty of reclaimable\n\t * objects spread over several slabs with usage less than the\n\t * batch_size.\n\t *\n\t * We detect the \"tight on memory\" situations by looking at the total\n\t * number of objects we want to scan (total_scan). If it is greater\n\t * than the total number of objects on slab (freeable), we must be\n\t * scanning at high prio and therefore should try to reclaim as much as\n\t * possible.\n\t */\n\twhile (total_scan >= batch_size ||\n\t       total_scan >= freeable) {\n\t\tunsigned long ret;\n\t\tunsigned long nr_to_scan = min(batch_size, total_scan);\n\n\t\tshrinkctl->nr_to_scan = nr_to_scan;\n\t\tshrinkctl->nr_scanned = nr_to_scan;\n\t\tret = shrinker->scan_objects(shrinker, shrinkctl);\n\t\tif (ret == SHRINK_STOP)\n\t\t\tbreak;\n\t\tfreed += ret;\n\n\t\tcount_vm_events(SLABS_SCANNED, shrinkctl->nr_scanned);\n\t\ttotal_scan -= shrinkctl->nr_scanned;\n\t\tscanned += shrinkctl->nr_scanned;\n\n\t\tcond_resched();\n\t}\n\n\tif (next_deferred >= scanned)\n\t\tnext_deferred -= scanned;\n\telse\n\t\tnext_deferred = 0;\n\t/*\n\t * move the unused scan count back into the shrinker in a\n\t * manner that handles concurrent updates. If we exhausted the\n\t * scan, there is no need to do an update.\n\t */\n\tif (next_deferred > 0)\n\t\tnew_nr = atomic_long_add_return(next_deferred,\n\t\t\t\t\t\t&shrinker->nr_deferred[nid]);\n\telse\n\t\tnew_nr = atomic_long_read(&shrinker->nr_deferred[nid]);\n\n\ttrace_mm_shrink_slab_end(shrinker, nid, freed, nr, new_nr, total_scan);\n\treturn freed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SHRINK_BATCH 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SHRINK_BATCH 128\n\nstatic unsigned long do_shrink_slab(struct shrink_control *shrinkctl,\n\t\t\t\t    struct shrinker *shrinker, int priority)\n{\n\tunsigned long freed = 0;\n\tunsigned long long delta;\n\tlong total_scan;\n\tlong freeable;\n\tlong nr;\n\tlong new_nr;\n\tint nid = shrinkctl->nid;\n\tlong batch_size = shrinker->batch ? shrinker->batch\n\t\t\t\t\t  : SHRINK_BATCH;\n\tlong scanned = 0, next_deferred;\n\n\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))\n\t\tnid = 0;\n\n\tfreeable = shrinker->count_objects(shrinker, shrinkctl);\n\tif (freeable == 0 || freeable == SHRINK_EMPTY)\n\t\treturn freeable;\n\n\t/*\n\t * copy the current shrinker scan count into a local variable\n\t * and zero it so that other concurrent shrinker invocations\n\t * don't also do this scanning work.\n\t */\n\tnr = atomic_long_xchg(&shrinker->nr_deferred[nid], 0);\n\n\ttotal_scan = nr;\n\tif (shrinker->seeks) {\n\t\tdelta = freeable >> priority;\n\t\tdelta *= 4;\n\t\tdo_div(delta, shrinker->seeks);\n\t} else {\n\t\t/*\n\t\t * These objects don't require any IO to create. Trim\n\t\t * them aggressively under memory pressure to keep\n\t\t * them from causing refetches in the IO caches.\n\t\t */\n\t\tdelta = freeable / 2;\n\t}\n\n\t/*\n\t * Make sure we apply some minimal pressure on default priority\n\t * even on small cgroups. Stale objects are not only consuming memory\n\t * by themselves, but can also hold a reference to a dying cgroup,\n\t * preventing it from being reclaimed. A dying cgroup with all\n\t * corresponding structures like per-cpu stats and kmem caches\n\t * can be really big, so it may lead to a significant waste of memory.\n\t */\n\tdelta = max_t(unsigned long long, delta, min(freeable, batch_size));\n\n\ttotal_scan += delta;\n\tif (total_scan < 0) {\n\t\tpr_err(\"shrink_slab: %pF negative objects to delete nr=%ld\\n\",\n\t\t       shrinker->scan_objects, total_scan);\n\t\ttotal_scan = freeable;\n\t\tnext_deferred = nr;\n\t} else\n\t\tnext_deferred = total_scan;\n\n\t/*\n\t * We need to avoid excessive windup on filesystem shrinkers\n\t * due to large numbers of GFP_NOFS allocations causing the\n\t * shrinkers to return -1 all the time. This results in a large\n\t * nr being built up so when a shrink that can do some work\n\t * comes along it empties the entire cache due to nr >>>\n\t * freeable. This is bad for sustaining a working set in\n\t * memory.\n\t *\n\t * Hence only allow the shrinker to scan the entire cache when\n\t * a large delta change is calculated directly.\n\t */\n\tif (delta < freeable / 4)\n\t\ttotal_scan = min(total_scan, freeable / 2);\n\n\t/*\n\t * Avoid risking looping forever due to too large nr value:\n\t * never try to free more than twice the estimate number of\n\t * freeable entries.\n\t */\n\tif (total_scan > freeable * 2)\n\t\ttotal_scan = freeable * 2;\n\n\ttrace_mm_shrink_slab_start(shrinker, shrinkctl, nr,\n\t\t\t\t   freeable, delta, total_scan, priority);\n\n\t/*\n\t * Normally, we should not scan less than batch_size objects in one\n\t * pass to avoid too frequent shrinker calls, but if the slab has less\n\t * than batch_size objects in total and we are really tight on memory,\n\t * we will try to reclaim all available objects, otherwise we can end\n\t * up failing allocations although there are plenty of reclaimable\n\t * objects spread over several slabs with usage less than the\n\t * batch_size.\n\t *\n\t * We detect the \"tight on memory\" situations by looking at the total\n\t * number of objects we want to scan (total_scan). If it is greater\n\t * than the total number of objects on slab (freeable), we must be\n\t * scanning at high prio and therefore should try to reclaim as much as\n\t * possible.\n\t */\n\twhile (total_scan >= batch_size ||\n\t       total_scan >= freeable) {\n\t\tunsigned long ret;\n\t\tunsigned long nr_to_scan = min(batch_size, total_scan);\n\n\t\tshrinkctl->nr_to_scan = nr_to_scan;\n\t\tshrinkctl->nr_scanned = nr_to_scan;\n\t\tret = shrinker->scan_objects(shrinker, shrinkctl);\n\t\tif (ret == SHRINK_STOP)\n\t\t\tbreak;\n\t\tfreed += ret;\n\n\t\tcount_vm_events(SLABS_SCANNED, shrinkctl->nr_scanned);\n\t\ttotal_scan -= shrinkctl->nr_scanned;\n\t\tscanned += shrinkctl->nr_scanned;\n\n\t\tcond_resched();\n\t}\n\n\tif (next_deferred >= scanned)\n\t\tnext_deferred -= scanned;\n\telse\n\t\tnext_deferred = 0;\n\t/*\n\t * move the unused scan count back into the shrinker in a\n\t * manner that handles concurrent updates. If we exhausted the\n\t * scan, there is no need to do an update.\n\t */\n\tif (next_deferred > 0)\n\t\tnew_nr = atomic_long_add_return(next_deferred,\n\t\t\t\t\t\t&shrinker->nr_deferred[nid]);\n\telse\n\t\tnew_nr = atomic_long_read(&shrinker->nr_deferred[nid]);\n\n\ttrace_mm_shrink_slab_end(shrinker, nid, freed, nr, new_nr, total_scan);\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "i",
            "map->map"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!shrinker || shrinker == SHRINKER_REGISTERING"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&shrinker_idr",
            "i"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "map->map",
            "shrinker_nr_max"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!map"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "memcg->nodeinfo[nid]->shrinker_map",
            "true"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_online",
          "args": [
            "memcg"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SHRINKER_REGISTERING ((struct shrinker *)~0UL)\n\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nstatic unsigned long shrink_slab_memcg(gfp_t gfp_mask, int nid,\n\t\t\tstruct mem_cgroup *memcg, int priority)\n{\n\tstruct memcg_shrinker_map *map;\n\tunsigned long ret, freed = 0;\n\tint i;\n\n\tif (!memcg_kmem_enabled() || !mem_cgroup_online(memcg))\n\t\treturn 0;\n\n\tif (!down_read_trylock(&shrinker_rwsem))\n\t\treturn 0;\n\n\tmap = rcu_dereference_protected(memcg->nodeinfo[nid]->shrinker_map,\n\t\t\t\t\ttrue);\n\tif (unlikely(!map))\n\t\tgoto unlock;\n\n\tfor_each_set_bit(i, map->map, shrinker_nr_max) {\n\t\tstruct shrink_control sc = {\n\t\t\t.gfp_mask = gfp_mask,\n\t\t\t.nid = nid,\n\t\t\t.memcg = memcg,\n\t\t};\n\t\tstruct shrinker *shrinker;\n\n\t\tshrinker = idr_find(&shrinker_idr, i);\n\t\tif (unlikely(!shrinker || shrinker == SHRINKER_REGISTERING)) {\n\t\t\tif (!shrinker)\n\t\t\t\tclear_bit(i, map->map);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\tif (ret == SHRINK_EMPTY) {\n\t\t\tclear_bit(i, map->map);\n\t\t\t/*\n\t\t\t * After the shrinker reported that it had no objects to\n\t\t\t * free, but before we cleared the corresponding bit in\n\t\t\t * the memcg shrinker map, a new object might have been\n\t\t\t * added. To make sure, we have the bit set in this\n\t\t\t * case, we invoke the shrinker one more time and reset\n\t\t\t * the bit if it reports that it is not empty anymore.\n\t\t\t * The memory barrier here pairs with the barrier in\n\t\t\t * memcg_set_shrinker_bit():\n\t\t\t *\n\t\t\t * list_lru_add()     shrink_slab_memcg()\n\t\t\t *   list_add_tail()    clear_bit()\n\t\t\t *   <MB>               <MB>\n\t\t\t *   set_bit()          do_shrink_slab()\n\t\t\t */\n\t\t\tsmp_mb__after_atomic();\n\t\t\tret = do_shrink_slab(&sc, shrinker, priority);\n\t\t\tif (ret == SHRINK_EMPTY)\n\t\t\t\tret = 0;\n\t\t\telse\n\t\t\t\tmemcg_set_shrinker_bit(memcg, nid, i);\n\t\t}\n\t\tfreed += ret;\n\n\t\tif (rwsem_is_contended(&shrinker_rwsem)) {\n\t\t\tfreed = freed ? : 1;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock:\n\tup_read(&shrinker_rwsem);\n\treturn freed;\n}"
  },
  {
    "function_name": "do_shrink_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "448-586",
    "snippet": "static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,\n\t\t\t\t    struct shrinker *shrinker, int priority)\n{\n\tunsigned long freed = 0;\n\tunsigned long long delta;\n\tlong total_scan;\n\tlong freeable;\n\tlong nr;\n\tlong new_nr;\n\tint nid = shrinkctl->nid;\n\tlong batch_size = shrinker->batch ? shrinker->batch\n\t\t\t\t\t  : SHRINK_BATCH;\n\tlong scanned = 0, next_deferred;\n\n\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))\n\t\tnid = 0;\n\n\tfreeable = shrinker->count_objects(shrinker, shrinkctl);\n\tif (freeable == 0 || freeable == SHRINK_EMPTY)\n\t\treturn freeable;\n\n\t/*\n\t * copy the current shrinker scan count into a local variable\n\t * and zero it so that other concurrent shrinker invocations\n\t * don't also do this scanning work.\n\t */\n\tnr = atomic_long_xchg(&shrinker->nr_deferred[nid], 0);\n\n\ttotal_scan = nr;\n\tif (shrinker->seeks) {\n\t\tdelta = freeable >> priority;\n\t\tdelta *= 4;\n\t\tdo_div(delta, shrinker->seeks);\n\t} else {\n\t\t/*\n\t\t * These objects don't require any IO to create. Trim\n\t\t * them aggressively under memory pressure to keep\n\t\t * them from causing refetches in the IO caches.\n\t\t */\n\t\tdelta = freeable / 2;\n\t}\n\n\t/*\n\t * Make sure we apply some minimal pressure on default priority\n\t * even on small cgroups. Stale objects are not only consuming memory\n\t * by themselves, but can also hold a reference to a dying cgroup,\n\t * preventing it from being reclaimed. A dying cgroup with all\n\t * corresponding structures like per-cpu stats and kmem caches\n\t * can be really big, so it may lead to a significant waste of memory.\n\t */\n\tdelta = max_t(unsigned long long, delta, min(freeable, batch_size));\n\n\ttotal_scan += delta;\n\tif (total_scan < 0) {\n\t\tpr_err(\"shrink_slab: %pF negative objects to delete nr=%ld\\n\",\n\t\t       shrinker->scan_objects, total_scan);\n\t\ttotal_scan = freeable;\n\t\tnext_deferred = nr;\n\t} else\n\t\tnext_deferred = total_scan;\n\n\t/*\n\t * We need to avoid excessive windup on filesystem shrinkers\n\t * due to large numbers of GFP_NOFS allocations causing the\n\t * shrinkers to return -1 all the time. This results in a large\n\t * nr being built up so when a shrink that can do some work\n\t * comes along it empties the entire cache due to nr >>>\n\t * freeable. This is bad for sustaining a working set in\n\t * memory.\n\t *\n\t * Hence only allow the shrinker to scan the entire cache when\n\t * a large delta change is calculated directly.\n\t */\n\tif (delta < freeable / 4)\n\t\ttotal_scan = min(total_scan, freeable / 2);\n\n\t/*\n\t * Avoid risking looping forever due to too large nr value:\n\t * never try to free more than twice the estimate number of\n\t * freeable entries.\n\t */\n\tif (total_scan > freeable * 2)\n\t\ttotal_scan = freeable * 2;\n\n\ttrace_mm_shrink_slab_start(shrinker, shrinkctl, nr,\n\t\t\t\t   freeable, delta, total_scan, priority);\n\n\t/*\n\t * Normally, we should not scan less than batch_size objects in one\n\t * pass to avoid too frequent shrinker calls, but if the slab has less\n\t * than batch_size objects in total and we are really tight on memory,\n\t * we will try to reclaim all available objects, otherwise we can end\n\t * up failing allocations although there are plenty of reclaimable\n\t * objects spread over several slabs with usage less than the\n\t * batch_size.\n\t *\n\t * We detect the \"tight on memory\" situations by looking at the total\n\t * number of objects we want to scan (total_scan). If it is greater\n\t * than the total number of objects on slab (freeable), we must be\n\t * scanning at high prio and therefore should try to reclaim as much as\n\t * possible.\n\t */\n\twhile (total_scan >= batch_size ||\n\t       total_scan >= freeable) {\n\t\tunsigned long ret;\n\t\tunsigned long nr_to_scan = min(batch_size, total_scan);\n\n\t\tshrinkctl->nr_to_scan = nr_to_scan;\n\t\tshrinkctl->nr_scanned = nr_to_scan;\n\t\tret = shrinker->scan_objects(shrinker, shrinkctl);\n\t\tif (ret == SHRINK_STOP)\n\t\t\tbreak;\n\t\tfreed += ret;\n\n\t\tcount_vm_events(SLABS_SCANNED, shrinkctl->nr_scanned);\n\t\ttotal_scan -= shrinkctl->nr_scanned;\n\t\tscanned += shrinkctl->nr_scanned;\n\n\t\tcond_resched();\n\t}\n\n\tif (next_deferred >= scanned)\n\t\tnext_deferred -= scanned;\n\telse\n\t\tnext_deferred = 0;\n\t/*\n\t * move the unused scan count back into the shrinker in a\n\t * manner that handles concurrent updates. If we exhausted the\n\t * scan, there is no need to do an update.\n\t */\n\tif (next_deferred > 0)\n\t\tnew_nr = atomic_long_add_return(next_deferred,\n\t\t\t\t\t\t&shrinker->nr_deferred[nid]);\n\telse\n\t\tnew_nr = atomic_long_read(&shrinker->nr_deferred[nid]);\n\n\ttrace_mm_shrink_slab_end(shrinker, nid, freed, nr, new_nr, total_scan);\n\treturn freed;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SHRINK_BATCH 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_shrink_slab_end",
          "args": [
            "shrinker",
            "nid",
            "freed",
            "nr",
            "new_nr",
            "total_scan"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&shrinker->nr_deferred[nid]"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "next_deferred",
            "&shrinker->nr_deferred[nid]"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "SLABS_SCANNED",
            "shrinkctl->nr_scanned"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrinker->scan_objects",
          "args": [
            "shrinker",
            "shrinkctl"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "batch_size",
            "total_scan"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_shrink_slab_start",
          "args": [
            "shrinker",
            "shrinkctl",
            "nr",
            "freeable",
            "delta",
            "total_scan",
            "priority"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"shrink_slab: %pF negative objects to delete nr=%ld\\n\"",
            "shrinker->scan_objects",
            "total_scan"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong long",
            "delta",
            "min(freeable, batch_size)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "delta",
            "shrinker->seeks"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_xchg",
          "args": [
            "&shrinker->nr_deferred[nid]",
            "0"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrinker->count_objects",
          "args": [
            "shrinker",
            "shrinkctl"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SHRINK_BATCH 128\n\nstatic unsigned long do_shrink_slab(struct shrink_control *shrinkctl,\n\t\t\t\t    struct shrinker *shrinker, int priority)\n{\n\tunsigned long freed = 0;\n\tunsigned long long delta;\n\tlong total_scan;\n\tlong freeable;\n\tlong nr;\n\tlong new_nr;\n\tint nid = shrinkctl->nid;\n\tlong batch_size = shrinker->batch ? shrinker->batch\n\t\t\t\t\t  : SHRINK_BATCH;\n\tlong scanned = 0, next_deferred;\n\n\tif (!(shrinker->flags & SHRINKER_NUMA_AWARE))\n\t\tnid = 0;\n\n\tfreeable = shrinker->count_objects(shrinker, shrinkctl);\n\tif (freeable == 0 || freeable == SHRINK_EMPTY)\n\t\treturn freeable;\n\n\t/*\n\t * copy the current shrinker scan count into a local variable\n\t * and zero it so that other concurrent shrinker invocations\n\t * don't also do this scanning work.\n\t */\n\tnr = atomic_long_xchg(&shrinker->nr_deferred[nid], 0);\n\n\ttotal_scan = nr;\n\tif (shrinker->seeks) {\n\t\tdelta = freeable >> priority;\n\t\tdelta *= 4;\n\t\tdo_div(delta, shrinker->seeks);\n\t} else {\n\t\t/*\n\t\t * These objects don't require any IO to create. Trim\n\t\t * them aggressively under memory pressure to keep\n\t\t * them from causing refetches in the IO caches.\n\t\t */\n\t\tdelta = freeable / 2;\n\t}\n\n\t/*\n\t * Make sure we apply some minimal pressure on default priority\n\t * even on small cgroups. Stale objects are not only consuming memory\n\t * by themselves, but can also hold a reference to a dying cgroup,\n\t * preventing it from being reclaimed. A dying cgroup with all\n\t * corresponding structures like per-cpu stats and kmem caches\n\t * can be really big, so it may lead to a significant waste of memory.\n\t */\n\tdelta = max_t(unsigned long long, delta, min(freeable, batch_size));\n\n\ttotal_scan += delta;\n\tif (total_scan < 0) {\n\t\tpr_err(\"shrink_slab: %pF negative objects to delete nr=%ld\\n\",\n\t\t       shrinker->scan_objects, total_scan);\n\t\ttotal_scan = freeable;\n\t\tnext_deferred = nr;\n\t} else\n\t\tnext_deferred = total_scan;\n\n\t/*\n\t * We need to avoid excessive windup on filesystem shrinkers\n\t * due to large numbers of GFP_NOFS allocations causing the\n\t * shrinkers to return -1 all the time. This results in a large\n\t * nr being built up so when a shrink that can do some work\n\t * comes along it empties the entire cache due to nr >>>\n\t * freeable. This is bad for sustaining a working set in\n\t * memory.\n\t *\n\t * Hence only allow the shrinker to scan the entire cache when\n\t * a large delta change is calculated directly.\n\t */\n\tif (delta < freeable / 4)\n\t\ttotal_scan = min(total_scan, freeable / 2);\n\n\t/*\n\t * Avoid risking looping forever due to too large nr value:\n\t * never try to free more than twice the estimate number of\n\t * freeable entries.\n\t */\n\tif (total_scan > freeable * 2)\n\t\ttotal_scan = freeable * 2;\n\n\ttrace_mm_shrink_slab_start(shrinker, shrinkctl, nr,\n\t\t\t\t   freeable, delta, total_scan, priority);\n\n\t/*\n\t * Normally, we should not scan less than batch_size objects in one\n\t * pass to avoid too frequent shrinker calls, but if the slab has less\n\t * than batch_size objects in total and we are really tight on memory,\n\t * we will try to reclaim all available objects, otherwise we can end\n\t * up failing allocations although there are plenty of reclaimable\n\t * objects spread over several slabs with usage less than the\n\t * batch_size.\n\t *\n\t * We detect the \"tight on memory\" situations by looking at the total\n\t * number of objects we want to scan (total_scan). If it is greater\n\t * than the total number of objects on slab (freeable), we must be\n\t * scanning at high prio and therefore should try to reclaim as much as\n\t * possible.\n\t */\n\twhile (total_scan >= batch_size ||\n\t       total_scan >= freeable) {\n\t\tunsigned long ret;\n\t\tunsigned long nr_to_scan = min(batch_size, total_scan);\n\n\t\tshrinkctl->nr_to_scan = nr_to_scan;\n\t\tshrinkctl->nr_scanned = nr_to_scan;\n\t\tret = shrinker->scan_objects(shrinker, shrinkctl);\n\t\tif (ret == SHRINK_STOP)\n\t\t\tbreak;\n\t\tfreed += ret;\n\n\t\tcount_vm_events(SLABS_SCANNED, shrinkctl->nr_scanned);\n\t\ttotal_scan -= shrinkctl->nr_scanned;\n\t\tscanned += shrinkctl->nr_scanned;\n\n\t\tcond_resched();\n\t}\n\n\tif (next_deferred >= scanned)\n\t\tnext_deferred -= scanned;\n\telse\n\t\tnext_deferred = 0;\n\t/*\n\t * move the unused scan count back into the shrinker in a\n\t * manner that handles concurrent updates. If we exhausted the\n\t * scan, there is no need to do an update.\n\t */\n\tif (next_deferred > 0)\n\t\tnew_nr = atomic_long_add_return(next_deferred,\n\t\t\t\t\t\t&shrinker->nr_deferred[nid]);\n\telse\n\t\tnew_nr = atomic_long_read(&shrinker->nr_deferred[nid]);\n\n\ttrace_mm_shrink_slab_end(shrinker, nid, freed, nr, new_nr, total_scan);\n\treturn freed;\n}"
  },
  {
    "function_name": "unregister_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "432-443",
    "snippet": "void unregister_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\tdown_write(&shrinker_rwsem);\n\tlist_del(&shrinker->list);\n\tup_write(&shrinker_rwsem);\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(shrinker_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "shrinker->nr_deferred"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&shrinker->list"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_memcg_shrinker",
          "args": [
            "shrinker"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_memcg_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "232-234",
          "snippet": "static void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nvoid unregister_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\tdown_write(&shrinker_rwsem);\n\tlist_del(&shrinker->list);\n\tup_write(&shrinker_rwsem);\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}"
  },
  {
    "function_name": "register_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "418-426",
    "snippet": "int register_shrinker(struct shrinker *shrinker)\n{\n\tint err = prealloc_shrinker(shrinker);\n\n\tif (err)\n\t\treturn err;\n\tregister_shrinker_prepared(shrinker);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_shrinker_prepared",
          "args": [
            "shrinker"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "register_shrinker_prepared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "407-416",
          "snippet": "void register_shrinker_prepared(struct shrinker *shrinker)\n{\n\tdown_write(&shrinker_rwsem);\n\tlist_add_tail(&shrinker->list, &shrinker_list);\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tidr_replace(&shrinker_idr, shrinker, shrinker->id);\n#endif\n\tup_write(&shrinker_rwsem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(shrinker_list);",
            "static DECLARE_RWSEM(shrinker_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(shrinker_list);\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nvoid register_shrinker_prepared(struct shrinker *shrinker)\n{\n\tdown_write(&shrinker_rwsem);\n\tlist_add_tail(&shrinker->list, &shrinker_list);\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tidr_replace(&shrinker_idr, shrinker, shrinker->id);\n#endif\n\tup_write(&shrinker_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_shrinker",
          "args": [
            "shrinker"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "371-393",
          "snippet": "int prealloc_shrinker(struct shrinker *shrinker)\n{\n\tsize_t size = sizeof(*shrinker->nr_deferred);\n\n\tif (shrinker->flags & SHRINKER_NUMA_AWARE)\n\t\tsize *= nr_node_ids;\n\n\tshrinker->nr_deferred = kzalloc(size, GFP_KERNEL);\n\tif (!shrinker->nr_deferred)\n\t\treturn -ENOMEM;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE) {\n\t\tif (prealloc_memcg_shrinker(shrinker))\n\t\t\tgoto free_deferred;\n\t}\n\n\treturn 0;\n\nfree_deferred:\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint prealloc_shrinker(struct shrinker *shrinker)\n{\n\tsize_t size = sizeof(*shrinker->nr_deferred);\n\n\tif (shrinker->flags & SHRINKER_NUMA_AWARE)\n\t\tsize *= nr_node_ids;\n\n\tshrinker->nr_deferred = kzalloc(size, GFP_KERNEL);\n\tif (!shrinker->nr_deferred)\n\t\treturn -ENOMEM;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE) {\n\t\tif (prealloc_memcg_shrinker(shrinker))\n\t\t\tgoto free_deferred;\n\t}\n\n\treturn 0;\n\nfree_deferred:\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint register_shrinker(struct shrinker *shrinker)\n{\n\tint err = prealloc_shrinker(shrinker);\n\n\tif (err)\n\t\treturn err;\n\tregister_shrinker_prepared(shrinker);\n\treturn 0;\n}"
  },
  {
    "function_name": "register_shrinker_prepared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "407-416",
    "snippet": "void register_shrinker_prepared(struct shrinker *shrinker)\n{\n\tdown_write(&shrinker_rwsem);\n\tlist_add_tail(&shrinker->list, &shrinker_list);\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tidr_replace(&shrinker_idr, shrinker, shrinker->id);\n#endif\n\tup_write(&shrinker_rwsem);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(shrinker_list);",
      "static DECLARE_RWSEM(shrinker_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_replace",
          "args": [
            "&shrinker_idr",
            "shrinker",
            "shrinker->id"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&shrinker->list",
            "&shrinker_list"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(shrinker_list);\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nvoid register_shrinker_prepared(struct shrinker *shrinker)\n{\n\tdown_write(&shrinker_rwsem);\n\tlist_add_tail(&shrinker->list, &shrinker_list);\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tidr_replace(&shrinker_idr, shrinker, shrinker->id);\n#endif\n\tup_write(&shrinker_rwsem);\n}"
  },
  {
    "function_name": "free_prealloced_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "395-405",
    "snippet": "void free_prealloced_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "shrinker->nr_deferred"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_memcg_shrinker",
          "args": [
            "shrinker"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_memcg_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "232-234",
          "snippet": "static void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid free_prealloced_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}"
  },
  {
    "function_name": "prealloc_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "371-393",
    "snippet": "int prealloc_shrinker(struct shrinker *shrinker)\n{\n\tsize_t size = sizeof(*shrinker->nr_deferred);\n\n\tif (shrinker->flags & SHRINKER_NUMA_AWARE)\n\t\tsize *= nr_node_ids;\n\n\tshrinker->nr_deferred = kzalloc(size, GFP_KERNEL);\n\tif (!shrinker->nr_deferred)\n\t\treturn -ENOMEM;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE) {\n\t\tif (prealloc_memcg_shrinker(shrinker))\n\t\t\tgoto free_deferred;\n\t}\n\n\treturn 0;\n\nfree_deferred:\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "shrinker->nr_deferred"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_memcg_shrinker",
          "args": [
            "shrinker"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_memcg_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "227-230",
          "snippet": "static int prealloc_memcg_shrinker(struct shrinker *shrinker)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int prealloc_memcg_shrinker(struct shrinker *shrinker)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint prealloc_shrinker(struct shrinker *shrinker)\n{\n\tsize_t size = sizeof(*shrinker->nr_deferred);\n\n\tif (shrinker->flags & SHRINKER_NUMA_AWARE)\n\t\tsize *= nr_node_ids;\n\n\tshrinker->nr_deferred = kzalloc(size, GFP_KERNEL);\n\tif (!shrinker->nr_deferred)\n\t\treturn -ENOMEM;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE) {\n\t\tif (prealloc_memcg_shrinker(shrinker))\n\t\t\tgoto free_deferred;\n\t}\n\n\treturn 0;\n\nfree_deferred:\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "lruvec_lru_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "339-366",
    "snippet": "unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "lru_size"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "&lruvec_pgdat(lruvec)->node_zones[zid]",
            "NR_ZONE_LRU_BASE + lru"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_get_zone_lru_size",
          "args": [
            "lruvec",
            "lru",
            "zid"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "lruvec_pgdat(lruvec)",
            "NR_LRU_BASE + lru"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_get_lru_size",
          "args": [
            "lruvec",
            "lru"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}"
  },
  {
    "function_name": "zone_reclaimable_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "320-331",
    "snippet": "unsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "zone",
            "NR_ZONE_ACTIVE_ANON"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "zone",
            "NR_ZONE_INACTIVE_ANON"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_swap_pages",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "zone",
            "NR_ZONE_ACTIVE_FILE"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "zone",
            "NR_ZONE_INACTIVE_FILE"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}"
  },
  {
    "function_name": "memcg_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "307-312",
    "snippet": "static inline bool memcg_congested(struct pglist_data *pgdat,\n\t\t\tstruct mem_cgroup *memcg)\n{\n\treturn false;\n\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool memcg_congested(struct pglist_data *pgdat,\n\t\t\tstruct mem_cgroup *memcg)\n{\n\treturn false;\n\n}"
  },
  {
    "function_name": "set_memcg_congestion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "302-305",
    "snippet": "static inline void set_memcg_congestion(struct pglist_data *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg, bool congested)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void set_memcg_congestion(struct pglist_data *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg, bool congested)\n{\n}"
  },
  {
    "function_name": "sane_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "297-300",
    "snippet": "static bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool sane_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "global_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "292-295",
    "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "memcg_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "282-290",
    "snippet": "static bool memcg_congested(pg_data_t *pgdat,\n\t\t\tstruct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_per_node *mn;\n\n\tmn = mem_cgroup_nodeinfo(memcg, pgdat->node_id);\n\treturn READ_ONCE(mn->congested);\n\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mn->congested"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "pgdat->node_id"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool memcg_congested(pg_data_t *pgdat,\n\t\t\tstruct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup_per_node *mn;\n\n\tmn = mem_cgroup_nodeinfo(memcg, pgdat->node_id);\n\treturn READ_ONCE(mn->congested);\n\n}"
  },
  {
    "function_name": "set_memcg_congestion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "269-280",
    "snippet": "static void set_memcg_congestion(pg_data_t *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg,\n\t\t\t\tbool congested)\n{\n\tstruct mem_cgroup_per_node *mn;\n\n\tif (!memcg)\n\t\treturn;\n\n\tmn = mem_cgroup_nodeinfo(memcg, pgdat->node_id);\n\tWRITE_ONCE(mn->congested, congested);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "mn->congested",
            "congested"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_nodeinfo",
          "args": [
            "memcg",
            "pgdat->node_id"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void set_memcg_congestion(pg_data_t *pgdat,\n\t\t\t\tstruct mem_cgroup *memcg,\n\t\t\t\tbool congested)\n{\n\tstruct mem_cgroup_per_node *mn;\n\n\tif (!memcg)\n\t\treturn;\n\n\tmn = mem_cgroup_nodeinfo(memcg, pgdat->node_id);\n\tWRITE_ONCE(mn->congested, congested);\n}"
  },
  {
    "function_name": "sane_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "256-267",
    "snippet": "static bool sane_reclaim(struct scan_control *sc)\n{\n\tstruct mem_cgroup *memcg = sc->target_mem_cgroup;\n\n\tif (!memcg)\n\t\treturn true;\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn true;\n#endif\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "memory_cgrp_subsys"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool sane_reclaim(struct scan_control *sc)\n{\n\tstruct mem_cgroup *memcg = sc->target_mem_cgroup;\n\n\tif (!memcg)\n\t\treturn true;\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tif (cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn true;\n#endif\n\treturn false;\n}"
  },
  {
    "function_name": "global_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "238-241",
    "snippet": "static bool global_reclaim(struct scan_control *sc)\n{\n\treturn !sc->target_mem_cgroup;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool global_reclaim(struct scan_control *sc)\n{\n\treturn !sc->target_mem_cgroup;\n}"
  },
  {
    "function_name": "unregister_memcg_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "232-234",
    "snippet": "static void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n}"
  },
  {
    "function_name": "prealloc_memcg_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "227-230",
    "snippet": "static int prealloc_memcg_shrinker(struct shrinker *shrinker)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int prealloc_memcg_shrinker(struct shrinker *shrinker)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_memcg_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "216-225",
    "snippet": "static void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n\tint id = shrinker->id;\n\n\tBUG_ON(id < 0);\n\n\tdown_write(&shrinker_rwsem);\n\tidr_remove(&shrinker_idr, id);\n\tup_write(&shrinker_rwsem);\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(shrinker_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&shrinker_idr",
            "id"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "id < 0"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nstatic void unregister_memcg_shrinker(struct shrinker *shrinker)\n{\n\tint id = shrinker->id;\n\n\tBUG_ON(id < 0);\n\n\tdown_write(&shrinker_rwsem);\n\tidr_remove(&shrinker_idr, id);\n\tup_write(&shrinker_rwsem);\n}"
  },
  {
    "function_name": "prealloc_memcg_shrinker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
    "lines": "191-214",
    "snippet": "static int prealloc_memcg_shrinker(struct shrinker *shrinker)\n{\n\tint id, ret = -ENOMEM;\n\n\tdown_write(&shrinker_rwsem);\n\t/* This may call shrinker, so it must use down_read_trylock() */\n\tid = idr_alloc(&shrinker_idr, SHRINKER_REGISTERING, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\tgoto unlock;\n\n\tif (id >= shrinker_nr_max) {\n\t\tif (memcg_expand_shrinker_maps(id)) {\n\t\t\tidr_remove(&shrinker_idr, id);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tshrinker_nr_max = id + 1;\n\t}\n\tshrinker->id = id;\n\tret = 0;\nunlock:\n\tup_write(&shrinker_rwsem);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/vmscan.h>",
      "#include \"internal.h\"",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/swapops.h>",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/psi.h>",
      "#include <linux/dax.h>",
      "#include <linux/printk.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/oom.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/notifier.h>",
      "#include <linux/compaction.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmpressure.h>",
      "#include <linux/highmem.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SHRINKER_REGISTERING ((struct shrinker *)~0UL)"
    ],
    "globals_used": [
      "static DECLARE_RWSEM(shrinker_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&shrinker_idr",
            "id"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_expand_shrinker_maps",
          "args": [
            "id"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_expand_shrinker_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "398-424",
          "snippet": "int memcg_expand_shrinker_maps(int new_id)\n{\n\tint size, old_size, ret = 0;\n\tstruct mem_cgroup *memcg;\n\n\tsize = DIV_ROUND_UP(new_id + 1, BITS_PER_LONG) * sizeof(unsigned long);\n\told_size = memcg_shrinker_map_size;\n\tif (size <= old_size)\n\t\treturn 0;\n\n\tmutex_lock(&memcg_shrinker_map_mutex);\n\tif (!root_mem_cgroup)\n\t\tgoto unlock;\n\n\tfor_each_mem_cgroup(memcg) {\n\t\tif (mem_cgroup_is_root(memcg))\n\t\t\tcontinue;\n\t\tret = memcg_expand_one_shrinker_map(memcg, size, old_size);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\nunlock:\n\tif (!ret)\n\t\tmemcg_shrinker_map_size = size;\n\tmutex_unlock(&memcg_shrinker_map_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint memcg_expand_shrinker_maps(int new_id)\n{\n\tint size, old_size, ret = 0;\n\tstruct mem_cgroup *memcg;\n\n\tsize = DIV_ROUND_UP(new_id + 1, BITS_PER_LONG) * sizeof(unsigned long);\n\told_size = memcg_shrinker_map_size;\n\tif (size <= old_size)\n\t\treturn 0;\n\n\tmutex_lock(&memcg_shrinker_map_mutex);\n\tif (!root_mem_cgroup)\n\t\tgoto unlock;\n\n\tfor_each_mem_cgroup(memcg) {\n\t\tif (mem_cgroup_is_root(memcg))\n\t\t\tcontinue;\n\t\tret = memcg_expand_one_shrinker_map(memcg, size, old_size);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\nunlock:\n\tif (!ret)\n\t\tmemcg_shrinker_map_size = size;\n\tmutex_unlock(&memcg_shrinker_map_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&shrinker_idr",
            "SHRINKER_REGISTERING",
            "0",
            "0",
            "GFP_KERNEL"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&shrinker_rwsem"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SHRINKER_REGISTERING ((struct shrinker *)~0UL)\n\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nstatic int prealloc_memcg_shrinker(struct shrinker *shrinker)\n{\n\tint id, ret = -ENOMEM;\n\n\tdown_write(&shrinker_rwsem);\n\t/* This may call shrinker, so it must use down_read_trylock() */\n\tid = idr_alloc(&shrinker_idr, SHRINKER_REGISTERING, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\tgoto unlock;\n\n\tif (id >= shrinker_nr_max) {\n\t\tif (memcg_expand_shrinker_maps(id)) {\n\t\t\tidr_remove(&shrinker_idr, id);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tshrinker_nr_max = id + 1;\n\t}\n\tshrinker->id = id;\n\tret = 0;\nunlock:\n\tup_write(&shrinker_rwsem);\n\treturn ret;\n}"
  }
]