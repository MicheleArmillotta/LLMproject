[
  {
    "function_name": "get_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "735-782",
    "snippet": "int get_cmdline(struct task_struct *task, char *buffer, int buflen)\n{\n\tint res = 0;\n\tunsigned int len;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tif (!mm)\n\t\tgoto out;\n\tif (!mm->arg_end)\n\t\tgoto out_mm;\t/* Shh! No looking before we're done */\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tlen = arg_end - arg_start;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\n\tres = access_process_vm(task, arg_start, buffer, len, FOLL_FORCE);\n\n\t/*\n\t * If the nul at the end of args has been overwritten, then\n\t * assume application is using setproctitle(3).\n\t */\n\tif (res > 0 && buffer[res-1] != '\\0' && len < buflen) {\n\t\tlen = strnlen(buffer, res);\n\t\tif (len < res) {\n\t\t\tres = len;\n\t\t} else {\n\t\t\tlen = env_end - env_start;\n\t\t\tif (len > buflen - res)\n\t\t\t\tlen = buflen - res;\n\t\t\tres += access_process_vm(task, env_start,\n\t\t\t\t\t\t buffer+res, len,\n\t\t\t\t\t\t FOLL_FORCE);\n\t\t\tres = strnlen(buffer, res);\n\t\t}\n\t}\nout_mm:\n\tmmput(mm);\nout:\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "buffer",
            "res"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_process_vm",
          "args": [
            "task",
            "env_start",
            "buffer+res",
            "len",
            "FOLL_FORCE"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "access_process_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1827-1843",
          "snippet": "int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len,\n\t\tunsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\n\tif (addr + len < addr)\n\t\treturn 0;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tlen = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\n\tmmput(mm);\n\treturn len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len,\n\t\tunsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\n\tif (addr + len < addr)\n\t\treturn 0;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tlen = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\n\tmmput(mm);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "buffer",
            "res"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint get_cmdline(struct task_struct *task, char *buffer, int buflen)\n{\n\tint res = 0;\n\tunsigned int len;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tif (!mm)\n\t\tgoto out;\n\tif (!mm->arg_end)\n\t\tgoto out_mm;\t/* Shh! No looking before we're done */\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tlen = arg_end - arg_start;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\n\tres = access_process_vm(task, arg_start, buffer, len, FOLL_FORCE);\n\n\t/*\n\t * If the nul at the end of args has been overwritten, then\n\t * assume application is using setproctitle(3).\n\t */\n\tif (res > 0 && buffer[res-1] != '\\0' && len < buflen) {\n\t\tlen = strnlen(buffer, res);\n\t\tif (len < res) {\n\t\t\tres = len;\n\t\t} else {\n\t\t\tlen = env_end - env_start;\n\t\t\tif (len > buflen - res)\n\t\t\t\tlen = buflen - res;\n\t\t\tres += access_process_vm(task, env_start,\n\t\t\t\t\t\t buffer+res, len,\n\t\t\t\t\t\t FOLL_FORCE);\n\t\t\tres = strnlen(buffer, res);\n\t\t}\n\t}\nout_mm:\n\tmmput(mm);\nout:\n\treturn res;\n}"
  },
  {
    "function_name": "__vm_enough_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "639-724",
    "snippet": "int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)\n{\n\tlong free, allowed, reserve;\n\n\tVM_WARN_ONCE(percpu_counter_read(&vm_committed_as) <\n\t\t\t-(s64)vm_committed_as_batch * num_online_cpus(),\n\t\t\t\"memory commitment underflow\");\n\n\tvm_acct_memory(pages);\n\n\t/*\n\t * Sometimes we want to use more memory than we have\n\t */\n\tif (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)\n\t\treturn 0;\n\n\tif (sysctl_overcommit_memory == OVERCOMMIT_GUESS) {\n\t\tfree = global_zone_page_state(NR_FREE_PAGES);\n\t\tfree += global_node_page_state(NR_FILE_PAGES);\n\n\t\t/*\n\t\t * shmem pages shouldn't be counted as free in this\n\t\t * case, they can't be purged, only swapped out, and\n\t\t * that won't affect the overall amount of available\n\t\t * memory in the system.\n\t\t */\n\t\tfree -= global_node_page_state(NR_SHMEM);\n\n\t\tfree += get_nr_swap_pages();\n\n\t\t/*\n\t\t * Any slabs which are created with the\n\t\t * SLAB_RECLAIM_ACCOUNT flag claim to have contents\n\t\t * which are reclaimable, under pressure.  The dentry\n\t\t * cache and most inode caches should fall into this\n\t\t */\n\t\tfree += global_node_page_state(NR_SLAB_RECLAIMABLE);\n\n\t\t/*\n\t\t * Part of the kernel memory, which can be released\n\t\t * under memory pressure.\n\t\t */\n\t\tfree += global_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);\n\n\t\t/*\n\t\t * Leave reserved pages. The pages are not for anonymous pages.\n\t\t */\n\t\tif (free <= totalreserve_pages)\n\t\t\tgoto error;\n\t\telse\n\t\t\tfree -= totalreserve_pages;\n\n\t\t/*\n\t\t * Reserve some for root\n\t\t */\n\t\tif (!cap_sys_admin)\n\t\t\tfree -= sysctl_admin_reserve_kbytes >> (PAGE_SHIFT - 10);\n\n\t\tif (free > pages)\n\t\t\treturn 0;\n\n\t\tgoto error;\n\t}\n\n\tallowed = vm_commit_limit();\n\t/*\n\t * Reserve some for root\n\t */\n\tif (!cap_sys_admin)\n\t\tallowed -= sysctl_admin_reserve_kbytes >> (PAGE_SHIFT - 10);\n\n\t/*\n\t * Don't let a single process grow so big a user can't recover\n\t */\n\tif (mm) {\n\t\treserve = sysctl_user_reserve_kbytes >> (PAGE_SHIFT - 10);\n\t\tallowed -= min_t(long, mm->total_vm / 32, reserve);\n\t}\n\n\tif (percpu_counter_read_positive(&vm_committed_as) < allowed)\n\t\treturn 0;\nerror:\n\tvm_unacct_memory(pages);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_overcommit_memory",
      "struct percpu_counter vm_committed_as"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "pages"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&vm_committed_as"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "mm->total_vm / 32",
            "reserve"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_commit_limit",
          "args": [],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "vm_commit_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "589-601",
          "snippet": "unsigned long vm_commit_limit(void)\n{\n\tunsigned long allowed;\n\n\tif (sysctl_overcommit_kbytes)\n\t\tallowed = sysctl_overcommit_kbytes >> (PAGE_SHIFT - 10);\n\telse\n\t\tallowed = ((totalram_pages - hugetlb_total_pages())\n\t\t\t   * sysctl_overcommit_ratio / 100);\n\tallowed += total_swap_pages;\n\n\treturn allowed;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_overcommit_ratio"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint sysctl_overcommit_ratio;\n\nunsigned long vm_commit_limit(void)\n{\n\tunsigned long allowed;\n\n\tif (sysctl_overcommit_kbytes)\n\t\tallowed = sysctl_overcommit_kbytes >> (PAGE_SHIFT - 10);\n\telse\n\t\tallowed = ((totalram_pages - hugetlb_total_pages())\n\t\t\t   * sysctl_overcommit_ratio / 100);\n\tallowed += total_swap_pages;\n\n\treturn allowed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_KERNEL_MISC_RECLAIMABLE"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_swap_pages",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SHMEM"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_FILE_PAGES"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_acct_memory",
          "args": [
            "pages"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ONCE",
          "args": [
            "percpu_counter_read(&vm_committed_as) <\n\t\t\t-(s64)vm_committed_as_batch * num_online_cpus()",
            "\"memory commitment underflow\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read",
          "args": [
            "&vm_committed_as"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint sysctl_overcommit_memory;\nstruct percpu_counter vm_committed_as;\n\nint __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)\n{\n\tlong free, allowed, reserve;\n\n\tVM_WARN_ONCE(percpu_counter_read(&vm_committed_as) <\n\t\t\t-(s64)vm_committed_as_batch * num_online_cpus(),\n\t\t\t\"memory commitment underflow\");\n\n\tvm_acct_memory(pages);\n\n\t/*\n\t * Sometimes we want to use more memory than we have\n\t */\n\tif (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)\n\t\treturn 0;\n\n\tif (sysctl_overcommit_memory == OVERCOMMIT_GUESS) {\n\t\tfree = global_zone_page_state(NR_FREE_PAGES);\n\t\tfree += global_node_page_state(NR_FILE_PAGES);\n\n\t\t/*\n\t\t * shmem pages shouldn't be counted as free in this\n\t\t * case, they can't be purged, only swapped out, and\n\t\t * that won't affect the overall amount of available\n\t\t * memory in the system.\n\t\t */\n\t\tfree -= global_node_page_state(NR_SHMEM);\n\n\t\tfree += get_nr_swap_pages();\n\n\t\t/*\n\t\t * Any slabs which are created with the\n\t\t * SLAB_RECLAIM_ACCOUNT flag claim to have contents\n\t\t * which are reclaimable, under pressure.  The dentry\n\t\t * cache and most inode caches should fall into this\n\t\t */\n\t\tfree += global_node_page_state(NR_SLAB_RECLAIMABLE);\n\n\t\t/*\n\t\t * Part of the kernel memory, which can be released\n\t\t * under memory pressure.\n\t\t */\n\t\tfree += global_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);\n\n\t\t/*\n\t\t * Leave reserved pages. The pages are not for anonymous pages.\n\t\t */\n\t\tif (free <= totalreserve_pages)\n\t\t\tgoto error;\n\t\telse\n\t\t\tfree -= totalreserve_pages;\n\n\t\t/*\n\t\t * Reserve some for root\n\t\t */\n\t\tif (!cap_sys_admin)\n\t\t\tfree -= sysctl_admin_reserve_kbytes >> (PAGE_SHIFT - 10);\n\n\t\tif (free > pages)\n\t\t\treturn 0;\n\n\t\tgoto error;\n\t}\n\n\tallowed = vm_commit_limit();\n\t/*\n\t * Reserve some for root\n\t */\n\tif (!cap_sys_admin)\n\t\tallowed -= sysctl_admin_reserve_kbytes >> (PAGE_SHIFT - 10);\n\n\t/*\n\t * Don't let a single process grow so big a user can't recover\n\t */\n\tif (mm) {\n\t\treserve = sysctl_user_reserve_kbytes >> (PAGE_SHIFT - 10);\n\t\tallowed -= min_t(long, mm->total_vm / 32, reserve);\n\t}\n\n\tif (percpu_counter_read_positive(&vm_committed_as) < allowed)\n\t\treturn 0;\nerror:\n\tvm_unacct_memory(pages);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "vm_memory_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "617-620",
    "snippet": "unsigned long vm_memory_committed(void)\n{\n\treturn percpu_counter_read_positive(&vm_committed_as);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct percpu_counter vm_committed_as"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&vm_committed_as"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct percpu_counter vm_committed_as;\n\nunsigned long vm_memory_committed(void)\n{\n\treturn percpu_counter_read_positive(&vm_committed_as);\n}"
  },
  {
    "function_name": "vm_commit_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "589-601",
    "snippet": "unsigned long vm_commit_limit(void)\n{\n\tunsigned long allowed;\n\n\tif (sysctl_overcommit_kbytes)\n\t\tallowed = sysctl_overcommit_kbytes >> (PAGE_SHIFT - 10);\n\telse\n\t\tallowed = ((totalram_pages - hugetlb_total_pages())\n\t\t\t   * sysctl_overcommit_ratio / 100);\n\tallowed += total_swap_pages;\n\n\treturn allowed;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_overcommit_ratio"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_total_pages",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_total_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3042-3050",
          "snippet": "unsigned long hugetlb_total_pages(void)\n{\n\tstruct hstate *h;\n\tunsigned long nr_total_pages = 0;\n\n\tfor_each_hstate(h)\n\t\tnr_total_pages += h->nr_huge_pages * pages_per_huge_page(h);\n\treturn nr_total_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nunsigned long hugetlb_total_pages(void)\n{\n\tstruct hstate *h;\n\tunsigned long nr_total_pages = 0;\n\n\tfor_each_hstate(h)\n\t\tnr_total_pages += h->nr_huge_pages * pages_per_huge_page(h);\n\treturn nr_total_pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint sysctl_overcommit_ratio;\n\nunsigned long vm_commit_limit(void)\n{\n\tunsigned long allowed;\n\n\tif (sysctl_overcommit_kbytes)\n\t\tallowed = sysctl_overcommit_kbytes >> (PAGE_SHIFT - 10);\n\telse\n\t\tallowed = ((totalram_pages - hugetlb_total_pages())\n\t\t\t   * sysctl_overcommit_ratio / 100);\n\tallowed += total_swap_pages;\n\n\treturn allowed;\n}"
  },
  {
    "function_name": "overcommit_kbytes_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "574-584",
    "snippet": "int overcommit_kbytes_handler(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp,\n\t\t\t     loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tsysctl_overcommit_ratio = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_overcommit_ratio"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint sysctl_overcommit_ratio;\n\nint overcommit_kbytes_handler(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp,\n\t\t\t     loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tsysctl_overcommit_ratio = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "overcommit_ratio_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "562-572",
    "snippet": "int overcommit_ratio_handler(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp,\n\t\t\t     loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tsysctl_overcommit_kbytes = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint overcommit_ratio_handler(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp,\n\t\t\t     loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tsysctl_overcommit_kbytes = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "__page_mapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "536-552",
    "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "compound_mapcount_ptr(page)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_mapcount"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
  },
  {
    "function_name": "page_mapping_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "528-533",
    "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageSwapCache(page)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
  },
  {
    "function_name": "page_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "500-522",
    "snippet": "struct address_space *page_mapping(struct page *page)\n{\n\tstruct address_space *mapping;\n\n\tpage = compound_head(page);\n\n\t/* This happens if someone calls flush_dcache_page on slab page */\n\tif (unlikely(PageSlab(page)))\n\t\treturn NULL;\n\n\tif (unlikely(PageSwapCache(page))) {\n\t\tswp_entry_t entry;\n\n\t\tentry.val = page_private(page);\n\t\treturn swap_address_space(entry);\n\t}\n\n\tmapping = page->mapping;\n\tif ((unsigned long)mapping & PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\n\treturn (void *)((unsigned long)mapping & ~PAGE_MAPPING_FLAGS);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageSwapCache(page)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageSlab(page)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping(struct page *page)\n{\n\tstruct address_space *mapping;\n\n\tpage = compound_head(page);\n\n\t/* This happens if someone calls flush_dcache_page on slab page */\n\tif (unlikely(PageSlab(page)))\n\t\treturn NULL;\n\n\tif (unlikely(PageSwapCache(page))) {\n\t\tswp_entry_t entry;\n\n\t\tentry.val = page_private(page);\n\t\treturn swap_address_space(entry);\n\t}\n\n\tmapping = page->mapping;\n\tif ((unsigned long)mapping & PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\n\treturn (void *)((unsigned long)mapping & ~PAGE_MAPPING_FLAGS);\n}"
  },
  {
    "function_name": "page_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "489-498",
    "snippet": "struct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__page_rmapping",
          "args": [
            "page"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__page_rmapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "449-457",
          "snippet": "static inline void *__page_rmapping(struct page *page)\n{\n\tunsigned long mapping;\n\n\tmapping = (unsigned long)page->mapping;\n\tmapping &= ~PAGE_MAPPING_FLAGS;\n\n\treturn (void *)mapping;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void *__page_rmapping(struct page *page)\n{\n\tunsigned long mapping;\n\n\tmapping = (unsigned long)page->mapping;\n\tmapping &= ~PAGE_MAPPING_FLAGS;\n\n\treturn (void *)mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}"
  },
  {
    "function_name": "page_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "470-486",
    "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "compound_mapcount_ptr(page)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_mapcount"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageCompound(page)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "page_rmapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "460-464",
    "snippet": "void *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__page_rmapping",
          "args": [
            "page"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "__page_rmapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "449-457",
          "snippet": "static inline void *__page_rmapping(struct page *page)\n{\n\tunsigned long mapping;\n\n\tmapping = (unsigned long)page->mapping;\n\tmapping &= ~PAGE_MAPPING_FLAGS;\n\n\treturn (void *)mapping;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void *__page_rmapping(struct page *page)\n{\n\tunsigned long mapping;\n\n\tmapping = (unsigned long)page->mapping;\n\tmapping &= ~PAGE_MAPPING_FLAGS;\n\n\treturn (void *)mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}"
  },
  {
    "function_name": "__page_rmapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "449-457",
    "snippet": "static inline void *__page_rmapping(struct page *page)\n{\n\tunsigned long mapping;\n\n\tmapping = (unsigned long)page->mapping;\n\tmapping &= ~PAGE_MAPPING_FLAGS;\n\n\treturn (void *)mapping;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void *__page_rmapping(struct page *page)\n{\n\tunsigned long mapping;\n\n\tmapping = (unsigned long)page->mapping;\n\tmapping &= ~PAGE_MAPPING_FLAGS;\n\n\treturn (void *)mapping;\n}"
  },
  {
    "function_name": "kvfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "440-446",
    "snippet": "void kvfree(const void *addr)\n{\n\tif (is_vmalloc_addr(addr))\n\t\tvfree(addr);\n\telse\n\t\tkfree(addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "addr"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "28-32",
          "snippet": "void kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "addr"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "440-446",
          "snippet": "void kvfree(const void *addr)\n{\n\tif (is_vmalloc_addr(addr))\n\t\tvfree(addr);\n\telse\n\t\tkfree(addr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "addr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvfree(const void *addr)\n{\n\tif (is_vmalloc_addr(addr))\n\t\tvfree(addr);\n\telse\n\t\tkfree(addr);\n}"
  },
  {
    "function_name": "kvmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "390-427",
    "snippet": "void *kvmalloc_node(size_t size, gfp_t flags, int node)\n{\n\tgfp_t kmalloc_flags = flags;\n\tvoid *ret;\n\n\t/*\n\t * vmalloc uses GFP_KERNEL for some internal allocations (e.g page tables)\n\t * so the given set of flags has to be compatible.\n\t */\n\tif ((flags & GFP_KERNEL) != GFP_KERNEL)\n\t\treturn kmalloc_node(size, flags, node);\n\n\t/*\n\t * We want to attempt a large physically contiguous block first because\n\t * it is less likely to fragment multiple larger blocks and therefore\n\t * contribute to a long term fragmentation less than vmalloc fallback.\n\t * However make sure that larger requests are not too disruptive - no\n\t * OOM killer and no allocation failure warnings as we have a fallback.\n\t */\n\tif (size > PAGE_SIZE) {\n\t\tkmalloc_flags |= __GFP_NOWARN;\n\n\t\tif (!(kmalloc_flags & __GFP_RETRY_MAYFAIL))\n\t\t\tkmalloc_flags |= __GFP_NORETRY;\n\t}\n\n\tret = kmalloc_node(size, kmalloc_flags, node);\n\n\t/*\n\t * It doesn't really make sense to fallback to vmalloc for sub page\n\t * requests\n\t */\n\tif (ret || size <= PAGE_SIZE)\n\t\treturn ret;\n\n\treturn __vmalloc_node_flags_caller(size, node, flags,\n\t\t\t__builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_flags_caller",
          "args": [
            "size",
            "node",
            "flags",
            "__builtin_return_address(0)"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node_flags_caller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1814-1818",
          "snippet": "void *__vmalloc_node_flags_caller(unsigned long size, int node, gfp_t flags,\n\t\t\t\t  void *caller)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nvoid *__vmalloc_node_flags_caller(unsigned long size, int node, gfp_t flags,\n\t\t\t\t  void *caller)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "size",
            "kmalloc_flags",
            "node"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *kvmalloc_node(size_t size, gfp_t flags, int node)\n{\n\tgfp_t kmalloc_flags = flags;\n\tvoid *ret;\n\n\t/*\n\t * vmalloc uses GFP_KERNEL for some internal allocations (e.g page tables)\n\t * so the given set of flags has to be compatible.\n\t */\n\tif ((flags & GFP_KERNEL) != GFP_KERNEL)\n\t\treturn kmalloc_node(size, flags, node);\n\n\t/*\n\t * We want to attempt a large physically contiguous block first because\n\t * it is less likely to fragment multiple larger blocks and therefore\n\t * contribute to a long term fragmentation less than vmalloc fallback.\n\t * However make sure that larger requests are not too disruptive - no\n\t * OOM killer and no allocation failure warnings as we have a fallback.\n\t */\n\tif (size > PAGE_SIZE) {\n\t\tkmalloc_flags |= __GFP_NOWARN;\n\n\t\tif (!(kmalloc_flags & __GFP_RETRY_MAYFAIL))\n\t\t\tkmalloc_flags |= __GFP_NORETRY;\n\t}\n\n\tret = kmalloc_node(size, kmalloc_flags, node);\n\n\t/*\n\t * It doesn't really make sense to fallback to vmalloc for sub page\n\t * requests\n\t */\n\tif (ret || size <= PAGE_SIZE)\n\t\treturn ret;\n\n\treturn __vmalloc_node_flags_caller(size, node, flags,\n\t\t\t__builtin_return_address(0));\n}"
  },
  {
    "function_name": "vm_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "360-370",
    "snippet": "unsigned long vm_mmap(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long offset)\n{\n\tif (unlikely(offset + PAGE_ALIGN(len) < offset))\n\t\treturn -EINVAL;\n\tif (unlikely(offset_in_page(offset)))\n\t\treturn -EINVAL;\n\n\treturn vm_mmap_pgoff(file, addr, len, prot, flag, offset >> PAGE_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_mmap_pgoff",
          "args": [
            "file",
            "addr",
            "len",
            "prot",
            "flag",
            "offset >> PAGE_SHIFT"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "vm_mmap_pgoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "337-358",
          "snippet": "unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long pgoff)\n{\n\tunsigned long ret;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long populate;\n\tLIST_HEAD(uf);\n\n\tret = security_mmap_file(file, prot, flag);\n\tif (!ret) {\n\t\tif (down_write_killable(&mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t\tret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,\n\t\t\t\t    &populate, &uf);\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_unmap_complete(mm, &uf);\n\t\tif (populate)\n\t\t\tmm_populate(ret, populate);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long pgoff)\n{\n\tunsigned long ret;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long populate;\n\tLIST_HEAD(uf);\n\n\tret = security_mmap_file(file, prot, flag);\n\tif (!ret) {\n\t\tif (down_write_killable(&mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t\tret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,\n\t\t\t\t    &populate, &uf);\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_unmap_complete(mm, &uf);\n\t\tif (populate)\n\t\t\tmm_populate(ret, populate);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset_in_page(offset)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "offset"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset + PAGE_ALIGN(len) < offset"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long vm_mmap(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long offset)\n{\n\tif (unlikely(offset + PAGE_ALIGN(len) < offset))\n\t\treturn -EINVAL;\n\tif (unlikely(offset_in_page(offset)))\n\t\treturn -EINVAL;\n\n\treturn vm_mmap_pgoff(file, addr, len, prot, flag, offset >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "vm_mmap_pgoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "337-358",
    "snippet": "unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long pgoff)\n{\n\tunsigned long ret;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long populate;\n\tLIST_HEAD(uf);\n\n\tret = security_mmap_file(file, prot, flag);\n\tif (!ret) {\n\t\tif (down_write_killable(&mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t\tret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,\n\t\t\t\t    &populate, &uf);\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_unmap_complete(mm, &uf);\n\t\tif (populate)\n\t\t\tmm_populate(ret, populate);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_populate",
          "args": [
            "ret",
            "populate"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_unmap_complete",
          "args": [
            "mm",
            "&uf"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mmap_pgoff",
          "args": [
            "file",
            "addr",
            "len",
            "prot",
            "flag",
            "pgoff",
            "&populate",
            "&uf"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_mmap_file",
          "args": [
            "file",
            "prot",
            "flag"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "uf"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long pgoff)\n{\n\tunsigned long ret;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long populate;\n\tLIST_HEAD(uf);\n\n\tret = security_mmap_file(file, prot, flag);\n\tif (!ret) {\n\t\tif (down_write_killable(&mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t\tret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,\n\t\t\t\t    &populate, &uf);\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_unmap_complete(mm, &uf);\n\t\tif (populate)\n\t\t\tmm_populate(ret, populate);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "get_user_pages_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "329-334",
    "snippet": "int __weak get_user_pages_fast(unsigned long start,\n\t\t\t\tint nr_pages, int write, struct page **pages)\n{\n\treturn get_user_pages_unlocked(start, nr_pages, pages,\n\t\t\t\t       write ? FOLL_WRITE : 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_pages_unlocked",
          "args": [
            "start",
            "nr_pages",
            "pages",
            "write ? FOLL_WRITE : 0"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "193-198",
          "snippet": "long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,\n\t\t\t     struct page **pages, unsigned int gup_flags)\n{\n\treturn __get_user_pages_unlocked(current, current->mm, start, nr_pages,\n\t\t\t\t\t pages, gup_flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nlong get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,\n\t\t\t     struct page **pages, unsigned int gup_flags)\n{\n\treturn __get_user_pages_unlocked(current, current->mm, start, nr_pages,\n\t\t\t\t\t pages, gup_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __weak get_user_pages_fast(unsigned long start,\n\t\t\t\tint nr_pages, int write, struct page **pages)\n{\n\treturn get_user_pages_unlocked(start, nr_pages, pages,\n\t\t\t\t       write ? FOLL_WRITE : 0);\n}"
  },
  {
    "function_name": "__get_user_pages_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "298-302",
    "snippet": "int __weak __get_user_pages_fast(unsigned long start,\n\t\t\t\t int nr_pages, int write, struct page **pages)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __weak __get_user_pages_fast(unsigned long start,\n\t\t\t\t int nr_pages, int write, struct page **pages)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_pick_mmap_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "283-287",
    "snippet": "void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)\n{\n\tmm->mmap_base = TASK_UNMAPPED_BASE;\n\tmm->get_unmapped_area = arch_get_unmapped_area;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)\n{\n\tmm->mmap_base = TASK_UNMAPPED_BASE;\n\tmm->get_unmapped_area = arch_get_unmapped_area;\n}"
  },
  {
    "function_name": "vma_is_stack_for_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "275-280",
    "snippet": "int vma_is_stack_for_current(struct vm_area_struct *vma)\n{\n\tstruct task_struct * __maybe_unused t = current;\n\n\treturn (vma->vm_start <= KSTK_ESP(t) && vma->vm_end >= KSTK_ESP(t));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KSTK_ESP",
          "args": [
            "t"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KSTK_ESP",
          "args": [
            "t"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint vma_is_stack_for_current(struct vm_area_struct *vma)\n{\n\tstruct task_struct * __maybe_unused t = current;\n\n\treturn (vma->vm_start <= KSTK_ESP(t) && vma->vm_end >= KSTK_ESP(t));\n}"
  },
  {
    "function_name": "__vma_link_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "252-272",
    "snippet": "void __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct vm_area_struct *prev, struct rb_node *rb_parent)\n{\n\tstruct vm_area_struct *next;\n\n\tvma->vm_prev = prev;\n\tif (prev) {\n\t\tnext = prev->vm_next;\n\t\tprev->vm_next = vma;\n\t} else {\n\t\tmm->mmap = vma;\n\t\tif (rb_parent)\n\t\t\tnext = rb_entry(rb_parent,\n\t\t\t\t\tstruct vm_area_struct, vm_rb);\n\t\telse\n\t\t\tnext = NULL;\n\t}\n\tvma->vm_next = next;\n\tif (next)\n\t\tnext->vm_prev = vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_parent",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct vm_area_struct *prev, struct rb_node *rb_parent)\n{\n\tstruct vm_area_struct *next;\n\n\tvma->vm_prev = prev;\n\tif (prev) {\n\t\tnext = prev->vm_next;\n\t\tprev->vm_next = vma;\n\t} else {\n\t\tmm->mmap = vma;\n\t\tif (rb_parent)\n\t\t\tnext = rb_entry(rb_parent,\n\t\t\t\t\tstruct vm_area_struct, vm_rb);\n\t\telse\n\t\t\tnext = NULL;\n\t}\n\tvma->vm_next = next;\n\tif (next)\n\t\tnext->vm_prev = vma;\n}"
  },
  {
    "function_name": "memdup_user_nul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "229-249",
    "snippet": "void *memdup_user_nul(const void __user *src, size_t len)\n{\n\tchar *p;\n\n\t/*\n\t * Always use GFP_KERNEL, since copy_from_user() can sleep and\n\t * cause pagefault, which makes it pointless to use GFP_NOFS\n\t * or GFP_ATOMIC.\n\t */\n\tp = kmalloc_track_caller(len + 1, GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\tp[len] = '\\0';\n\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "28-32",
          "snippet": "void kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "p",
            "src",
            "len"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *memdup_user_nul(const void __user *src, size_t len)\n{\n\tchar *p;\n\n\t/*\n\t * Always use GFP_KERNEL, since copy_from_user() can sleep and\n\t * cause pagefault, which makes it pointless to use GFP_NOFS\n\t * or GFP_ATOMIC.\n\t */\n\tp = kmalloc_track_caller(len + 1, GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\tp[len] = '\\0';\n\n\treturn p;\n}"
  },
  {
    "function_name": "strndup_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "197-218",
    "snippet": "char *strndup_user(const char __user *s, long n)\n{\n\tchar *p;\n\tlong length;\n\n\tlength = strnlen_user(s, n);\n\n\tif (!length)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (length > n)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tp = memdup_user(s, length);\n\n\tif (IS_ERR(p))\n\t\treturn p;\n\n\tp[length - 1] = '\\0';\n\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "s",
            "length"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "memdup_user_nul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "229-249",
          "snippet": "void *memdup_user_nul(const void __user *src, size_t len)\n{\n\tchar *p;\n\n\t/*\n\t * Always use GFP_KERNEL, since copy_from_user() can sleep and\n\t * cause pagefault, which makes it pointless to use GFP_NOFS\n\t * or GFP_ATOMIC.\n\t */\n\tp = kmalloc_track_caller(len + 1, GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\tp[len] = '\\0';\n\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *memdup_user_nul(const void __user *src, size_t len)\n{\n\tchar *p;\n\n\t/*\n\t * Always use GFP_KERNEL, since copy_from_user() can sleep and\n\t * cause pagefault, which makes it pointless to use GFP_NOFS\n\t * or GFP_ATOMIC.\n\t */\n\tp = kmalloc_track_caller(len + 1, GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\tp[len] = '\\0';\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "s",
            "n"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nchar *strndup_user(const char __user *s, long n)\n{\n\tchar *p;\n\tlong length;\n\n\tlength = strnlen_user(s, n);\n\n\tif (!length)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (length > n)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tp = memdup_user(s, length);\n\n\tif (IS_ERR(p))\n\t\treturn p;\n\n\tp[length - 1] = '\\0';\n\n\treturn p;\n}"
  },
  {
    "function_name": "vmemdup_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "175-189",
    "snippet": "void *vmemdup_user(const void __user *src, size_t len)\n{\n\tvoid *p;\n\n\tp = kvmalloc(len, GFP_USER);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkvfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "p"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "440-446",
          "snippet": "void kvfree(const void *addr)\n{\n\tif (is_vmalloc_addr(addr))\n\t\tvfree(addr);\n\telse\n\t\tkfree(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvfree(const void *addr)\n{\n\tif (is_vmalloc_addr(addr))\n\t\tvfree(addr);\n\telse\n\t\tkfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "p",
            "src",
            "len"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "len",
            "GFP_USER"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *vmemdup_user(const void __user *src, size_t len)\n{\n\tvoid *p;\n\n\tp = kvmalloc(len, GFP_USER);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkvfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "memdup_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "149-163",
    "snippet": "void *memdup_user(const void __user *src, size_t len)\n{\n\tvoid *p;\n\n\tp = kmalloc_track_caller(len, GFP_USER);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "28-32",
          "snippet": "void kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "p",
            "src",
            "len"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "len",
            "GFP_USER"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *memdup_user(const void __user *src, size_t len)\n{\n\tvoid *p;\n\n\tp = kmalloc_track_caller(len, GFP_USER);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "kmemdup_nul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "124-137",
    "snippet": "char *kmemdup_nul(const char *s, size_t len, gfp_t gfp)\n{\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tbuf = kmalloc_track_caller(len + 1, gfp);\n\tif (buf) {\n\t\tmemcpy(buf, s, len);\n\t\tbuf[len] = '\\0';\n\t}\n\treturn buf;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "s",
            "len"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "len + 1",
            "gfp"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nchar *kmemdup_nul(const char *s, size_t len, gfp_t gfp)\n{\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tbuf = kmalloc_track_caller(len + 1, gfp);\n\tif (buf) {\n\t\tmemcpy(buf, s, len);\n\t\tbuf[len] = '\\0';\n\t}\n\treturn buf;\n}"
  },
  {
    "function_name": "kmemdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "107-115",
    "snippet": "void *kmemdup(const void *src, size_t len, gfp_t gfp)\n{\n\tvoid *p;\n\n\tp = kmalloc_track_caller(len, gfp);\n\tif (p)\n\t\tmemcpy(p, src, len);\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "src",
            "len"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "len",
            "gfp"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *kmemdup(const void *src, size_t len, gfp_t gfp)\n{\n\tvoid *p;\n\n\tp = kmalloc_track_caller(len, gfp);\n\tif (p)\n\t\tmemcpy(p, src, len);\n\treturn p;\n}"
  },
  {
    "function_name": "kstrndup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "82-97",
    "snippet": "char *kstrndup(const char *s, size_t max, gfp_t gfp)\n{\n\tsize_t len;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tlen = strnlen(s, max);\n\tbuf = kmalloc_track_caller(len+1, gfp);\n\tif (buf) {\n\t\tmemcpy(buf, s, len);\n\t\tbuf[len] = '\\0';\n\t}\n\treturn buf;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "s",
            "len"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "len+1",
            "gfp"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "s",
            "max"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nchar *kstrndup(const char *s, size_t max, gfp_t gfp)\n{\n\tsize_t len;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tlen = strnlen(s, max);\n\tbuf = kmalloc_track_caller(len+1, gfp);\n\tif (buf) {\n\t\tmemcpy(buf, s, len);\n\t\tbuf[len] = '\\0';\n\t}\n\treturn buf;\n}"
  },
  {
    "function_name": "kstrdup_const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "65-71",
    "snippet": "const char *kstrdup_const(const char *s, gfp_t gfp)\n{\n\tif (is_kernel_rodata((unsigned long)s))\n\t\treturn s;\n\n\treturn kstrdup(s, gfp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "s",
            "gfp"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "kstrdup_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "65-71",
          "snippet": "const char *kstrdup_const(const char *s, gfp_t gfp)\n{\n\tif (is_kernel_rodata((unsigned long)s))\n\t\treturn s;\n\n\treturn kstrdup(s, gfp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_rodata",
          "args": [
            "(unsigned long)s"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nconst char *kstrdup_const(const char *s, gfp_t gfp)\n{\n\tif (is_kernel_rodata((unsigned long)s))\n\t\treturn s;\n\n\treturn kstrdup(s, gfp);\n}"
  },
  {
    "function_name": "kstrdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "40-53",
    "snippet": "char *kstrdup(const char *s, gfp_t gfp)\n{\n\tsize_t len;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tlen = strlen(s) + 1;\n\tbuf = kmalloc_track_caller(len, gfp);\n\tif (buf)\n\t\tmemcpy(buf, s, len);\n\treturn buf;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "s",
            "len"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "len",
            "gfp"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nchar *kstrdup(const char *s, gfp_t gfp)\n{\n\tsize_t len;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tlen = strlen(s) + 1;\n\tbuf = kmalloc_track_caller(len, gfp);\n\tif (buf)\n\t\tmemcpy(buf, s, len);\n\treturn buf;\n}"
  },
  {
    "function_name": "kfree_const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
    "lines": "28-32",
    "snippet": "void kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mman.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/security.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/export.h>",
      "#include <linux/compiler.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "x"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "28-32",
          "snippet": "void kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_rodata",
          "args": [
            "(unsigned long)x"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}"
  }
]