[
  {
    "function_name": "__kernel_map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "126-129",
    "snippet": "void __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}"
  },
  {
    "function_name": "kernel_poison_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "114-123",
    "snippet": "void kernel_poison_pages(struct page *page, int numpages, int enable)\n{\n\tif (!page_poisoning_enabled())\n\t\treturn;\n\n\tif (enable)\n\t\tunpoison_pages(page, numpages);\n\telse\n\t\tpoison_pages(page, numpages);\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poison_pages",
          "args": [
            "page",
            "numpages"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "unpoison_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "106-112",
          "snippet": "static void unpoison_pages(struct page *page, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tunpoison_page(page + i);\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void unpoison_pages(struct page *page, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tunpoison_page(page + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_poisoning_enabled",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "page_poisoning_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "25-36",
          "snippet": "bool page_poisoning_enabled(void)\n{\n\t/*\n\t * Assumes that debug_pagealloc_enabled is set before\n\t * memblock_free_all.\n\t * Page poisoning is debug page alloc for some arches. If\n\t * either of those options are enabled, enable poisoning.\n\t */\n\treturn (want_page_poisoning ||\n\t\t(!IS_ENABLED(CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC) &&\n\t\tdebug_pagealloc_enabled()));\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool want_page_poisoning"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic bool want_page_poisoning;\n\nbool page_poisoning_enabled(void)\n{\n\t/*\n\t * Assumes that debug_pagealloc_enabled is set before\n\t * memblock_free_all.\n\t * Page poisoning is debug page alloc for some arches. If\n\t * either of those options are enabled, enable poisoning.\n\t */\n\treturn (want_page_poisoning ||\n\t\t(!IS_ENABLED(CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC) &&\n\t\tdebug_pagealloc_enabled()));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_poison_pages(struct page *page, int numpages, int enable)\n{\n\tif (!page_poisoning_enabled())\n\t\treturn;\n\n\tif (enable)\n\t\tunpoison_pages(page, numpages);\n\telse\n\t\tpoison_pages(page, numpages);\n}"
  },
  {
    "function_name": "unpoison_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "106-112",
    "snippet": "static void unpoison_pages(struct page *page, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tunpoison_page(page + i);\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpoison_page",
          "args": [
            "page + i"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "unpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "92-104",
          "snippet": "static void unpoison_page(struct page *page)\n{\n\tvoid *addr;\n\n\taddr = kmap_atomic(page);\n\t/*\n\t * Page poisoning when enabled poisons each and every page\n\t * that is freed to buddy. Thus no extra check is done to\n\t * see if a page was posioned.\n\t */\n\tcheck_poison_mem(addr, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void unpoison_page(struct page *page)\n{\n\tvoid *addr;\n\n\taddr = kmap_atomic(page);\n\t/*\n\t * Page poisoning when enabled poisons each and every page\n\t * that is freed to buddy. Thus no extra check is done to\n\t * see if a page was posioned.\n\t */\n\tcheck_poison_mem(addr, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void unpoison_pages(struct page *page, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tunpoison_page(page + i);\n}"
  },
  {
    "function_name": "unpoison_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "92-104",
    "snippet": "static void unpoison_page(struct page *page)\n{\n\tvoid *addr;\n\n\taddr = kmap_atomic(page);\n\t/*\n\t * Page poisoning when enabled poisons each and every page\n\t * that is freed to buddy. Thus no extra check is done to\n\t * see if a page was posioned.\n\t */\n\tcheck_poison_mem(addr, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_poison_mem",
          "args": [
            "addr",
            "PAGE_SIZE"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "check_poison_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "62-90",
          "snippet": "static void check_poison_mem(unsigned char *mem, size_t bytes)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit, 5 * HZ, 10);\n\tunsigned char *start;\n\tunsigned char *end;\n\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING_NO_SANITY))\n\t\treturn;\n\n\tstart = memchr_inv(mem, PAGE_POISON, bytes);\n\tif (!start)\n\t\treturn;\n\n\tfor (end = mem + bytes - 1; end > start; end--) {\n\t\tif (*end != PAGE_POISON)\n\t\t\tbreak;\n\t}\n\n\tif (!__ratelimit(&ratelimit))\n\t\treturn;\n\telse if (start == end && single_bit_flip(*start, PAGE_POISON))\n\t\tpr_err(\"pagealloc: single bit error\\n\");\n\telse\n\t\tpr_err(\"pagealloc: memory corruption\\n\");\n\n\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1, start,\n\t\t\tend - start + 1, 1);\n\tdump_stack();\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void check_poison_mem(unsigned char *mem, size_t bytes)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit, 5 * HZ, 10);\n\tunsigned char *start;\n\tunsigned char *end;\n\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING_NO_SANITY))\n\t\treturn;\n\n\tstart = memchr_inv(mem, PAGE_POISON, bytes);\n\tif (!start)\n\t\treturn;\n\n\tfor (end = mem + bytes - 1; end > start; end--) {\n\t\tif (*end != PAGE_POISON)\n\t\t\tbreak;\n\t}\n\n\tif (!__ratelimit(&ratelimit))\n\t\treturn;\n\telse if (start == end && single_bit_flip(*start, PAGE_POISON))\n\t\tpr_err(\"pagealloc: single bit error\\n\");\n\telse\n\t\tpr_err(\"pagealloc: memory corruption\\n\");\n\n\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1, start,\n\t\t\tend - start + 1, 1);\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void unpoison_page(struct page *page)\n{\n\tvoid *addr;\n\n\taddr = kmap_atomic(page);\n\t/*\n\t * Page poisoning when enabled poisons each and every page\n\t * that is freed to buddy. Thus no extra check is done to\n\t * see if a page was posioned.\n\t */\n\tcheck_poison_mem(addr, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}"
  },
  {
    "function_name": "check_poison_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "62-90",
    "snippet": "static void check_poison_mem(unsigned char *mem, size_t bytes)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit, 5 * HZ, 10);\n\tunsigned char *start;\n\tunsigned char *end;\n\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING_NO_SANITY))\n\t\treturn;\n\n\tstart = memchr_inv(mem, PAGE_POISON, bytes);\n\tif (!start)\n\t\treturn;\n\n\tfor (end = mem + bytes - 1; end > start; end--) {\n\t\tif (*end != PAGE_POISON)\n\t\t\tbreak;\n\t}\n\n\tif (!__ratelimit(&ratelimit))\n\t\treturn;\n\telse if (start == end && single_bit_flip(*start, PAGE_POISON))\n\t\tpr_err(\"pagealloc: single bit error\\n\");\n\telse\n\t\tpr_err(\"pagealloc: memory corruption\\n\");\n\n\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1, start,\n\t\t\tend - start + 1, 1);\n\tdump_stack();\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"\"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "1",
            "start",
            "end - start + 1",
            "1"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pagealloc: memory corruption\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pagealloc: single bit error\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "single_bit_flip",
          "args": [
            "*start",
            "PAGE_POISON"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "single_bit_flip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "55-60",
          "snippet": "static bool single_bit_flip(unsigned char a, unsigned char b)\n{\n\tunsigned char error = a ^ b;\n\n\treturn error && !(error & (error - 1));\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic bool single_bit_flip(unsigned char a, unsigned char b)\n{\n\tunsigned char error = a ^ b;\n\n\treturn error && !(error & (error - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "mem",
            "PAGE_POISON",
            "bytes"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PAGE_POISONING_NO_SANITY"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void check_poison_mem(unsigned char *mem, size_t bytes)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit, 5 * HZ, 10);\n\tunsigned char *start;\n\tunsigned char *end;\n\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING_NO_SANITY))\n\t\treturn;\n\n\tstart = memchr_inv(mem, PAGE_POISON, bytes);\n\tif (!start)\n\t\treturn;\n\n\tfor (end = mem + bytes - 1; end > start; end--) {\n\t\tif (*end != PAGE_POISON)\n\t\t\tbreak;\n\t}\n\n\tif (!__ratelimit(&ratelimit))\n\t\treturn;\n\telse if (start == end && single_bit_flip(*start, PAGE_POISON))\n\t\tpr_err(\"pagealloc: single bit error\\n\");\n\telse\n\t\tpr_err(\"pagealloc: memory corruption\\n\");\n\n\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_ADDRESS, 16, 1, start,\n\t\t\tend - start + 1, 1);\n\tdump_stack();\n}"
  },
  {
    "function_name": "single_bit_flip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "55-60",
    "snippet": "static bool single_bit_flip(unsigned char a, unsigned char b)\n{\n\tunsigned char error = a ^ b;\n\n\treturn error && !(error & (error - 1));\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic bool single_bit_flip(unsigned char a, unsigned char b)\n{\n\tunsigned char error = a ^ b;\n\n\treturn error && !(error & (error - 1));\n}"
  },
  {
    "function_name": "poison_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "47-53",
    "snippet": "static void poison_pages(struct page *page, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tpoison_page(page + i);\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poison_page",
          "args": [
            "page + i"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "unpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "92-104",
          "snippet": "static void unpoison_page(struct page *page)\n{\n\tvoid *addr;\n\n\taddr = kmap_atomic(page);\n\t/*\n\t * Page poisoning when enabled poisons each and every page\n\t * that is freed to buddy. Thus no extra check is done to\n\t * see if a page was posioned.\n\t */\n\tcheck_poison_mem(addr, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void unpoison_page(struct page *page)\n{\n\tvoid *addr;\n\n\taddr = kmap_atomic(page);\n\t/*\n\t * Page poisoning when enabled poisons each and every page\n\t * that is freed to buddy. Thus no extra check is done to\n\t * see if a page was posioned.\n\t */\n\tcheck_poison_mem(addr, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void poison_pages(struct page *page, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tpoison_page(page + i);\n}"
  },
  {
    "function_name": "poison_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "39-45",
    "snippet": "static void poison_page(struct page *page)\n{\n\tvoid *addr = kmap_atomic(page);\n\n\tmemset(addr, PAGE_POISON, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr",
            "PAGE_POISON",
            "PAGE_SIZE"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void poison_page(struct page *page)\n{\n\tvoid *addr = kmap_atomic(page);\n\n\tmemset(addr, PAGE_POISON, PAGE_SIZE);\n\tkunmap_atomic(addr);\n}"
  },
  {
    "function_name": "page_poisoning_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "25-36",
    "snippet": "bool page_poisoning_enabled(void)\n{\n\t/*\n\t * Assumes that debug_pagealloc_enabled is set before\n\t * memblock_free_all.\n\t * Page poisoning is debug page alloc for some arches. If\n\t * either of those options are enabled, enable poisoning.\n\t */\n\treturn (want_page_poisoning ||\n\t\t(!IS_ENABLED(CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC) &&\n\t\tdebug_pagealloc_enabled()));\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool want_page_poisoning"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic bool want_page_poisoning;\n\nbool page_poisoning_enabled(void)\n{\n\t/*\n\t * Assumes that debug_pagealloc_enabled is set before\n\t * memblock_free_all.\n\t * Page poisoning is debug page alloc for some arches. If\n\t * either of those options are enabled, enable poisoning.\n\t */\n\treturn (want_page_poisoning ||\n\t\t(!IS_ENABLED(CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC) &&\n\t\tdebug_pagealloc_enabled()));\n}"
  },
  {
    "function_name": "early_page_poison_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
    "lines": "12-17",
    "snippet": "static int __init early_page_poison_param(char *buf)\n{\n\tif (!buf)\n\t\treturn -EINVAL;\n\treturn strtobool(buf, &want_page_poisoning);\n}",
    "includes": [
      "#include <linux/ratelimit.h>",
      "#include <linux/poison.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool want_page_poisoning"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtobool",
          "args": [
            "buf",
            "&want_page_poisoning"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic bool want_page_poisoning;\n\nstatic int __init early_page_poison_param(char *buf)\n{\n\tif (!buf)\n\t\treturn -EINVAL;\n\treturn strtobool(buf, &want_page_poisoning);\n}"
  }
]