[
  {
    "function_name": "early_memtest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
    "lines": "100-113",
    "snippet": "void __init early_memtest(phys_addr_t start, phys_addr_t end)\n{\n\tunsigned int i;\n\tunsigned int idx = 0;\n\n\tif (!memtest_pattern)\n\t\treturn;\n\n\tpr_info(\"early_memtest: # of tests: %u\\n\", memtest_pattern);\n\tfor (i = memtest_pattern-1; i < UINT_MAX; --i) {\n\t\tidx = i % ARRAY_SIZE(patterns);\n\t\tdo_one_pass(patterns[idx], start, end);\n\t}\n}",
    "includes": [
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 patterns[] __initdata = {\n\t/* The first entry has to be 0 to leave memtest with zeroed memory */\n\t0,\n\t0xffffffffffffffffULL,\n\t0x5555555555555555ULL,\n\t0xaaaaaaaaaaaaaaaaULL,\n\t0x1111111111111111ULL,\n\t0x2222222222222222ULL,\n\t0x4444444444444444ULL,\n\t0x8888888888888888ULL,\n\t0x3333333333333333ULL,\n\t0x6666666666666666ULL,\n\t0x9999999999999999ULL,\n\t0xccccccccccccccccULL,\n\t0x7777777777777777ULL,\n\t0xbbbbbbbbbbbbbbbbULL,\n\t0xddddddddddddddddULL,\n\t0xeeeeeeeeeeeeeeeeULL,\n\t0x7a6c7258554e494cULL, /* yeah ;-) */\n};",
      "static unsigned int memtest_pattern"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_one_pass",
          "args": [
            "patterns[idx]",
            "start",
            "end"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "do_one_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
          "lines": "66-81",
          "snippet": "static void __init do_one_pass(u64 pattern, phys_addr_t start, phys_addr_t end)\n{\n\tu64 i;\n\tphys_addr_t this_start, this_end;\n\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &this_start,\n\t\t\t\t&this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\t\tif (this_start < this_end) {\n\t\t\tpr_info(\"  %pa - %pa pattern %016llx\\n\",\n\t\t\t\t&this_start, &this_end, cpu_to_be64(pattern));\n\t\t\tmemtest(pattern, this_start, this_end - this_start);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __init do_one_pass(u64 pattern, phys_addr_t start, phys_addr_t end)\n{\n\tu64 i;\n\tphys_addr_t this_start, this_end;\n\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &this_start,\n\t\t\t\t&this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\t\tif (this_start < this_end) {\n\t\t\tpr_info(\"  %pa - %pa pattern %016llx\\n\",\n\t\t\t\t&this_start, &this_end, cpu_to_be64(pattern));\n\t\t\tmemtest(pattern, this_start, this_end - this_start);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "patterns"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"early_memtest: # of tests: %u\\n\"",
            "memtest_pattern"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic u64 patterns[] __initdata = {\n\t/* The first entry has to be 0 to leave memtest with zeroed memory */\n\t0,\n\t0xffffffffffffffffULL,\n\t0x5555555555555555ULL,\n\t0xaaaaaaaaaaaaaaaaULL,\n\t0x1111111111111111ULL,\n\t0x2222222222222222ULL,\n\t0x4444444444444444ULL,\n\t0x8888888888888888ULL,\n\t0x3333333333333333ULL,\n\t0x6666666666666666ULL,\n\t0x9999999999999999ULL,\n\t0xccccccccccccccccULL,\n\t0x7777777777777777ULL,\n\t0xbbbbbbbbbbbbbbbbULL,\n\t0xddddddddddddddddULL,\n\t0xeeeeeeeeeeeeeeeeULL,\n\t0x7a6c7258554e494cULL, /* yeah ;-) */\n};\nstatic unsigned int memtest_pattern;\n\nvoid __init early_memtest(phys_addr_t start, phys_addr_t end)\n{\n\tunsigned int i;\n\tunsigned int idx = 0;\n\n\tif (!memtest_pattern)\n\t\treturn;\n\n\tpr_info(\"early_memtest: # of tests: %u\\n\", memtest_pattern);\n\tfor (i = memtest_pattern-1; i < UINT_MAX; --i) {\n\t\tidx = i % ARRAY_SIZE(patterns);\n\t\tdo_one_pass(patterns[idx], start, end);\n\t}\n}"
  },
  {
    "function_name": "parse_memtest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
    "lines": "86-96",
    "snippet": "static int __init parse_memtest(char *arg)\n{\n\tint ret = 0;\n\n\tif (arg)\n\t\tret = kstrtouint(arg, 0, &memtest_pattern);\n\telse\n\t\tmemtest_pattern = ARRAY_SIZE(patterns);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 patterns[] __initdata = {\n\t/* The first entry has to be 0 to leave memtest with zeroed memory */\n\t0,\n\t0xffffffffffffffffULL,\n\t0x5555555555555555ULL,\n\t0xaaaaaaaaaaaaaaaaULL,\n\t0x1111111111111111ULL,\n\t0x2222222222222222ULL,\n\t0x4444444444444444ULL,\n\t0x8888888888888888ULL,\n\t0x3333333333333333ULL,\n\t0x6666666666666666ULL,\n\t0x9999999999999999ULL,\n\t0xccccccccccccccccULL,\n\t0x7777777777777777ULL,\n\t0xbbbbbbbbbbbbbbbbULL,\n\t0xddddddddddddddddULL,\n\t0xeeeeeeeeeeeeeeeeULL,\n\t0x7a6c7258554e494cULL, /* yeah ;-) */\n};",
      "static unsigned int memtest_pattern"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "patterns"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "arg",
            "0",
            "&memtest_pattern"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic u64 patterns[] __initdata = {\n\t/* The first entry has to be 0 to leave memtest with zeroed memory */\n\t0,\n\t0xffffffffffffffffULL,\n\t0x5555555555555555ULL,\n\t0xaaaaaaaaaaaaaaaaULL,\n\t0x1111111111111111ULL,\n\t0x2222222222222222ULL,\n\t0x4444444444444444ULL,\n\t0x8888888888888888ULL,\n\t0x3333333333333333ULL,\n\t0x6666666666666666ULL,\n\t0x9999999999999999ULL,\n\t0xccccccccccccccccULL,\n\t0x7777777777777777ULL,\n\t0xbbbbbbbbbbbbbbbbULL,\n\t0xddddddddddddddddULL,\n\t0xeeeeeeeeeeeeeeeeULL,\n\t0x7a6c7258554e494cULL, /* yeah ;-) */\n};\nstatic unsigned int memtest_pattern;\n\nstatic int __init parse_memtest(char *arg)\n{\n\tint ret = 0;\n\n\tif (arg)\n\t\tret = kstrtouint(arg, 0, &memtest_pattern);\n\telse\n\t\tmemtest_pattern = ARRAY_SIZE(patterns);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_one_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
    "lines": "66-81",
    "snippet": "static void __init do_one_pass(u64 pattern, phys_addr_t start, phys_addr_t end)\n{\n\tu64 i;\n\tphys_addr_t this_start, this_end;\n\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &this_start,\n\t\t\t\t&this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\t\tif (this_start < this_end) {\n\t\t\tpr_info(\"  %pa - %pa pattern %016llx\\n\",\n\t\t\t\t&this_start, &this_end, cpu_to_be64(pattern));\n\t\t\tmemtest(pattern, this_start, this_end - this_start);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memtest",
          "args": [
            "pattern",
            "this_start",
            "this_end - this_start"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "memtest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
          "lines": "35-64",
          "snippet": "static void __init memtest(u64 pattern, phys_addr_t start_phys, phys_addr_t size)\n{\n\tu64 *p, *start, *end;\n\tphys_addr_t start_bad, last_bad;\n\tphys_addr_t start_phys_aligned;\n\tconst size_t incr = sizeof(pattern);\n\n\tstart_phys_aligned = ALIGN(start_phys, incr);\n\tstart = __va(start_phys_aligned);\n\tend = start + (size - (start_phys_aligned - start_phys)) / incr;\n\tstart_bad = 0;\n\tlast_bad = 0;\n\n\tfor (p = start; p < end; p++)\n\t\t*p = pattern;\n\n\tfor (p = start; p < end; p++, start_phys_aligned += incr) {\n\t\tif (*p == pattern)\n\t\t\tcontinue;\n\t\tif (start_phys_aligned == last_bad + incr) {\n\t\t\tlast_bad += incr;\n\t\t\tcontinue;\n\t\t}\n\t\tif (start_bad)\n\t\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n\t\tstart_bad = last_bad = start_phys_aligned;\n\t}\n\tif (start_bad)\n\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n}",
          "includes": [
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __init memtest(u64 pattern, phys_addr_t start_phys, phys_addr_t size)\n{\n\tu64 *p, *start, *end;\n\tphys_addr_t start_bad, last_bad;\n\tphys_addr_t start_phys_aligned;\n\tconst size_t incr = sizeof(pattern);\n\n\tstart_phys_aligned = ALIGN(start_phys, incr);\n\tstart = __va(start_phys_aligned);\n\tend = start + (size - (start_phys_aligned - start_phys)) / incr;\n\tstart_bad = 0;\n\tlast_bad = 0;\n\n\tfor (p = start; p < end; p++)\n\t\t*p = pattern;\n\n\tfor (p = start; p < end; p++, start_phys_aligned += incr) {\n\t\tif (*p == pattern)\n\t\t\tcontinue;\n\t\tif (start_phys_aligned == last_bad + incr) {\n\t\t\tlast_bad += incr;\n\t\t\tcontinue;\n\t\t}\n\t\tif (start_bad)\n\t\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n\t\tstart_bad = last_bad = start_phys_aligned;\n\t}\n\tif (start_bad)\n\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  %pa - %pa pattern %016llx\\n\"",
            "&this_start",
            "&this_end",
            "cpu_to_be64(pattern)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "pattern"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "this_end",
            "start",
            "end"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "this_start",
            "start",
            "end"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "NUMA_NO_NODE",
            "MEMBLOCK_NONE",
            "&this_start",
            "&this_end",
            "NULL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __init do_one_pass(u64 pattern, phys_addr_t start, phys_addr_t end)\n{\n\tu64 i;\n\tphys_addr_t this_start, this_end;\n\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &this_start,\n\t\t\t\t&this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\t\tif (this_start < this_end) {\n\t\t\tpr_info(\"  %pa - %pa pattern %016llx\\n\",\n\t\t\t\t&this_start, &this_end, cpu_to_be64(pattern));\n\t\t\tmemtest(pattern, this_start, this_end - this_start);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "memtest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
    "lines": "35-64",
    "snippet": "static void __init memtest(u64 pattern, phys_addr_t start_phys, phys_addr_t size)\n{\n\tu64 *p, *start, *end;\n\tphys_addr_t start_bad, last_bad;\n\tphys_addr_t start_phys_aligned;\n\tconst size_t incr = sizeof(pattern);\n\n\tstart_phys_aligned = ALIGN(start_phys, incr);\n\tstart = __va(start_phys_aligned);\n\tend = start + (size - (start_phys_aligned - start_phys)) / incr;\n\tstart_bad = 0;\n\tlast_bad = 0;\n\n\tfor (p = start; p < end; p++)\n\t\t*p = pattern;\n\n\tfor (p = start; p < end; p++, start_phys_aligned += incr) {\n\t\tif (*p == pattern)\n\t\t\tcontinue;\n\t\tif (start_phys_aligned == last_bad + incr) {\n\t\t\tlast_bad += incr;\n\t\t\tcontinue;\n\t\t}\n\t\tif (start_bad)\n\t\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n\t\tstart_bad = last_bad = start_phys_aligned;\n\t}\n\tif (start_bad)\n\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n}",
    "includes": [
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reserve_bad_mem",
          "args": [
            "pattern",
            "start_bad",
            "last_bad + incr"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_bad_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
          "lines": "28-33",
          "snippet": "static void __init reserve_bad_mem(u64 pattern, phys_addr_t start_bad, phys_addr_t end_bad)\n{\n\tpr_info(\"  %016llx bad mem addr %pa - %pa reserved\\n\",\n\t\tcpu_to_be64(pattern), &start_bad, &end_bad);\n\tmemblock_reserve(start_bad, end_bad - start_bad);\n}",
          "includes": [
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __init reserve_bad_mem(u64 pattern, phys_addr_t start_bad, phys_addr_t end_bad)\n{\n\tpr_info(\"  %016llx bad mem addr %pa - %pa reserved\\n\",\n\t\tcpu_to_be64(pattern), &start_bad, &end_bad);\n\tmemblock_reserve(start_bad, end_bad - start_bad);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "start_phys_aligned"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "start_phys",
            "incr"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __init memtest(u64 pattern, phys_addr_t start_phys, phys_addr_t size)\n{\n\tu64 *p, *start, *end;\n\tphys_addr_t start_bad, last_bad;\n\tphys_addr_t start_phys_aligned;\n\tconst size_t incr = sizeof(pattern);\n\n\tstart_phys_aligned = ALIGN(start_phys, incr);\n\tstart = __va(start_phys_aligned);\n\tend = start + (size - (start_phys_aligned - start_phys)) / incr;\n\tstart_bad = 0;\n\tlast_bad = 0;\n\n\tfor (p = start; p < end; p++)\n\t\t*p = pattern;\n\n\tfor (p = start; p < end; p++, start_phys_aligned += incr) {\n\t\tif (*p == pattern)\n\t\t\tcontinue;\n\t\tif (start_phys_aligned == last_bad + incr) {\n\t\t\tlast_bad += incr;\n\t\t\tcontinue;\n\t\t}\n\t\tif (start_bad)\n\t\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n\t\tstart_bad = last_bad = start_phys_aligned;\n\t}\n\tif (start_bad)\n\t\treserve_bad_mem(pattern, start_bad, last_bad + incr);\n}"
  },
  {
    "function_name": "reserve_bad_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memtest.c",
    "lines": "28-33",
    "snippet": "static void __init reserve_bad_mem(u64 pattern, phys_addr_t start_bad, phys_addr_t end_bad)\n{\n\tpr_info(\"  %016llx bad mem addr %pa - %pa reserved\\n\",\n\t\tcpu_to_be64(pattern), &start_bad, &end_bad);\n\tmemblock_reserve(start_bad, end_bad - start_bad);\n}",
    "includes": [
      "#include <linux/memblock.h>",
      "#include <linux/init.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "start_bad",
            "end_bad - start_bad"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "815-823",
          "snippet": "int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  %016llx bad mem addr %pa - %pa reserved\\n\"",
            "cpu_to_be64(pattern)",
            "&start_bad",
            "&end_bad"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "pattern"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __init reserve_bad_mem(u64 pattern, phys_addr_t start_bad, phys_addr_t end_bad)\n{\n\tpr_info(\"  %016llx bad mem addr %pa - %pa reserved\\n\",\n\t\tcpu_to_be64(pattern), &start_bad, &end_bad);\n\tmemblock_reserve(start_bad, end_bad - start_bad);\n}"
  }
]