[
  {
    "function_name": "memblock_init_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "2006-2021",
    "snippet": "static int __init memblock_init_debugfs(void)\n{\n\tstruct dentry *root = debugfs_create_dir(\"memblock\", NULL);\n\tif (!root)\n\t\treturn -ENXIO;\n\tdebugfs_create_file(\"memory\", 0444, root,\n\t\t\t    &memblock.memory, &memblock_debug_fops);\n\tdebugfs_create_file(\"reserved\", 0444, root,\n\t\t\t    &memblock.reserved, &memblock_debug_fops);\n#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP\n\tdebugfs_create_file(\"physmem\", 0444, root,\n\t\t\t    &memblock.physmem, &memblock_debug_fops);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"physmem\"",
            "0444",
            "root",
            "&memblock.physmem",
            "&memblock_debug_fops"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"reserved\"",
            "0444",
            "root",
            "&memblock.reserved",
            "&memblock_debug_fops"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"memory\"",
            "0444",
            "root",
            "&memblock.memory",
            "&memblock_debug_fops"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"memblock\"",
            "NULL"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int __init memblock_init_debugfs(void)\n{\n\tstruct dentry *root = debugfs_create_dir(\"memblock\", NULL);\n\tif (!root)\n\t\treturn -ENXIO;\n\tdebugfs_create_file(\"memory\", 0444, root,\n\t\t\t    &memblock.memory, &memblock_debug_fops);\n\tdebugfs_create_file(\"reserved\", 0444, root,\n\t\t\t    &memblock.reserved, &memblock_debug_fops);\n#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP\n\tdebugfs_create_file(\"physmem\", 0444, root,\n\t\t\t    &memblock.physmem, &memblock_debug_fops);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_debug_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1988-2003",
    "snippet": "static int memblock_debug_show(struct seq_file *m, void *private)\n{\n\tstruct memblock_type *type = m->private;\n\tstruct memblock_region *reg;\n\tint i;\n\tphys_addr_t end;\n\n\tfor (i = 0; i < type->cnt; i++) {\n\t\treg = &type->regions[i];\n\t\tend = reg->base + reg->size - 1;\n\n\t\tseq_printf(m, \"%4d: \", i);\n\t\tseq_printf(m, \"%pa..%pa\\n\", &reg->base, &end);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%pa..%pa\\n\"",
            "&reg->base",
            "&end"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%4d: \"",
            "i"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int memblock_debug_show(struct seq_file *m, void *private)\n{\n\tstruct memblock_type *type = m->private;\n\tstruct memblock_region *reg;\n\tint i;\n\tphys_addr_t end;\n\n\tfor (i = 0; i < type->cnt; i++) {\n\t\treg = &type->regions[i];\n\t\tend = reg->base + reg->size - 1;\n\n\t\tseq_printf(m, \"%4d: \", i);\n\t\tseq_printf(m, \"%pa..%pa\\n\", &reg->base, &end);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_free_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1974-1984",
    "snippet": "unsigned long __init memblock_free_all(void)\n{\n\tunsigned long pages;\n\n\treset_all_zones_managed_pages();\n\n\tpages = free_low_memory_core_early();\n\ttotalram_pages += pages;\n\n\treturn pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_low_memory_core_early",
          "args": [],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "free_low_memory_core_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1923-1944",
          "snippet": "static unsigned long __init free_low_memory_core_early(void)\n{\n\tunsigned long count = 0;\n\tphys_addr_t start, end;\n\tu64 i;\n\n\tmemblock_clear_hotplug(0, -1);\n\n\tfor_each_reserved_mem_region(i, &start, &end)\n\t\treserve_bootmem_region(start, end);\n\n\t/*\n\t * We need to use NUMA_NO_NODE instead of NODE_DATA(0)->node_id\n\t *  because in some case like Node0 doesn't have RAM installed\n\t *  low ram will be on Node1\n\t */\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,\n\t\t\t\tNULL)\n\t\tcount += __free_memory_core(start, end);\n\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __init free_low_memory_core_early(void)\n{\n\tunsigned long count = 0;\n\tphys_addr_t start, end;\n\tu64 i;\n\n\tmemblock_clear_hotplug(0, -1);\n\n\tfor_each_reserved_mem_region(i, &start, &end)\n\t\treserve_bootmem_region(start, end);\n\n\t/*\n\t * We need to use NUMA_NO_NODE instead of NODE_DATA(0)->node_id\n\t *  because in some case like Node0 doesn't have RAM installed\n\t *  low ram will be on Node1\n\t */\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,\n\t\t\t\tNULL)\n\t\tcount += __free_memory_core(start, end);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_all_zones_managed_pages",
          "args": [],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "reset_all_zones_managed_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1956-1967",
          "snippet": "void __init reset_all_zones_managed_pages(void)\n{\n\tstruct pglist_data *pgdat;\n\n\tif (reset_managed_pages_done)\n\t\treturn;\n\n\tfor_each_online_pgdat(pgdat)\n\t\treset_node_managed_pages(pgdat);\n\n\treset_managed_pages_done = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int reset_managed_pages_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int reset_managed_pages_done;\n\nvoid __init reset_all_zones_managed_pages(void)\n{\n\tstruct pglist_data *pgdat;\n\n\tif (reset_managed_pages_done)\n\t\treturn;\n\n\tfor_each_online_pgdat(pgdat)\n\t\treset_node_managed_pages(pgdat);\n\n\treset_managed_pages_done = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long __init memblock_free_all(void)\n{\n\tunsigned long pages;\n\n\treset_all_zones_managed_pages();\n\n\tpages = free_low_memory_core_early();\n\ttotalram_pages += pages;\n\n\treturn pages;\n}"
  },
  {
    "function_name": "reset_all_zones_managed_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1956-1967",
    "snippet": "void __init reset_all_zones_managed_pages(void)\n{\n\tstruct pglist_data *pgdat;\n\n\tif (reset_managed_pages_done)\n\t\treturn;\n\n\tfor_each_online_pgdat(pgdat)\n\t\treset_node_managed_pages(pgdat);\n\n\treset_managed_pages_done = 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int reset_managed_pages_done"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int reset_managed_pages_done;\n\nvoid __init reset_all_zones_managed_pages(void)\n{\n\tstruct pglist_data *pgdat;\n\n\tif (reset_managed_pages_done)\n\t\treturn;\n\n\tfor_each_online_pgdat(pgdat)\n\t\treset_node_managed_pages(pgdat);\n\n\treset_managed_pages_done = 1;\n}"
  },
  {
    "function_name": "reset_node_managed_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1948-1954",
    "snippet": "void reset_node_managed_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->managed_pages = 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid reset_node_managed_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->managed_pages = 0;\n}"
  },
  {
    "function_name": "free_low_memory_core_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1923-1944",
    "snippet": "static unsigned long __init free_low_memory_core_early(void)\n{\n\tunsigned long count = 0;\n\tphys_addr_t start, end;\n\tu64 i;\n\n\tmemblock_clear_hotplug(0, -1);\n\n\tfor_each_reserved_mem_region(i, &start, &end)\n\t\treserve_bootmem_region(start, end);\n\n\t/*\n\t * We need to use NUMA_NO_NODE instead of NODE_DATA(0)->node_id\n\t *  because in some case like Node0 doesn't have RAM installed\n\t *  low ram will be on Node1\n\t */\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,\n\t\t\t\tNULL)\n\t\tcount += __free_memory_core(start, end);\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_memory_core",
          "args": [
            "start",
            "end"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "__free_memory_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1908-1921",
          "snippet": "static unsigned long __init __free_memory_core(phys_addr_t start,\n\t\t\t\t phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_UP(start);\n\tunsigned long end_pfn = min_t(unsigned long,\n\t\t\t\t      PFN_DOWN(end), max_low_pfn);\n\n\tif (start_pfn >= end_pfn)\n\t\treturn 0;\n\n\t__free_pages_memory(start_pfn, end_pfn);\n\n\treturn end_pfn - start_pfn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long max_low_pfn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long max_low_pfn;\n\nstatic unsigned long __init __free_memory_core(phys_addr_t start,\n\t\t\t\t phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_UP(start);\n\tunsigned long end_pfn = min_t(unsigned long,\n\t\t\t\t      PFN_DOWN(end), max_low_pfn);\n\n\tif (start_pfn >= end_pfn)\n\t\treturn 0;\n\n\t__free_pages_memory(start_pfn, end_pfn);\n\n\treturn end_pfn - start_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "NUMA_NO_NODE",
            "MEMBLOCK_NONE",
            "&start",
            "&end",
            "NULL"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reserve_bootmem_region",
          "args": [
            "start",
            "end"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_bootmem_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1227-1249",
          "snippet": "void __meminit reserve_bootmem_region(phys_addr_t start, phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_DOWN(start);\n\tunsigned long end_pfn = PFN_UP(end);\n\n\tfor (; start_pfn < end_pfn; start_pfn++) {\n\t\tif (pfn_valid(start_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(start_pfn);\n\n\t\t\tinit_reserved_page(start_pfn);\n\n\t\t\t/* Avoid false-positive PageTail() */\n\t\t\tINIT_LIST_HEAD(&page->lru);\n\n\t\t\t/*\n\t\t\t * no need for atomic set_bit because the struct\n\t\t\t * page is not visible yet so nobody should\n\t\t\t * access it yet.\n\t\t\t */\n\t\t\t__SetPageReserved(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __meminit reserve_bootmem_region(phys_addr_t start, phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_DOWN(start);\n\tunsigned long end_pfn = PFN_UP(end);\n\n\tfor (; start_pfn < end_pfn; start_pfn++) {\n\t\tif (pfn_valid(start_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(start_pfn);\n\n\t\t\tinit_reserved_page(start_pfn);\n\n\t\t\t/* Avoid false-positive PageTail() */\n\t\t\tINIT_LIST_HEAD(&page->lru);\n\n\t\t\t/*\n\t\t\t * no need for atomic set_bit because the struct\n\t\t\t * page is not visible yet so nobody should\n\t\t\t * access it yet.\n\t\t\t */\n\t\t\t__SetPageReserved(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_reserved_mem_region",
          "args": [
            "i",
            "&start",
            "&end"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_clear_hotplug",
          "args": [
            "0",
            "-1"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_clear_hotplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "875-878",
          "snippet": "int __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 0, MEMBLOCK_HOTPLUG);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 0, MEMBLOCK_HOTPLUG);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __init free_low_memory_core_early(void)\n{\n\tunsigned long count = 0;\n\tphys_addr_t start, end;\n\tu64 i;\n\n\tmemblock_clear_hotplug(0, -1);\n\n\tfor_each_reserved_mem_region(i, &start, &end)\n\t\treserve_bootmem_region(start, end);\n\n\t/*\n\t * We need to use NUMA_NO_NODE instead of NODE_DATA(0)->node_id\n\t *  because in some case like Node0 doesn't have RAM installed\n\t *  low ram will be on Node1\n\t */\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,\n\t\t\t\tNULL)\n\t\tcount += __free_memory_core(start, end);\n\n\treturn count;\n}"
  },
  {
    "function_name": "__free_memory_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1908-1921",
    "snippet": "static unsigned long __init __free_memory_core(phys_addr_t start,\n\t\t\t\t phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_UP(start);\n\tunsigned long end_pfn = min_t(unsigned long,\n\t\t\t\t      PFN_DOWN(end), max_low_pfn);\n\n\tif (start_pfn >= end_pfn)\n\t\treturn 0;\n\n\t__free_pages_memory(start_pfn, end_pfn);\n\n\treturn end_pfn - start_pfn;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long max_low_pfn;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages_memory",
          "args": [
            "start_pfn",
            "end_pfn"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1892-1906",
          "snippet": "static void __init __free_pages_memory(unsigned long start, unsigned long end)\n{\n\tint order;\n\n\twhile (start < end) {\n\t\torder = min(MAX_ORDER - 1UL, __ffs(start));\n\n\t\twhile (start + (1UL << order) > end)\n\t\t\torder--;\n\n\t\tmemblock_free_pages(pfn_to_page(start), start, order);\n\n\t\tstart += (1UL << order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __init __free_pages_memory(unsigned long start, unsigned long end)\n{\n\tint order;\n\n\twhile (start < end) {\n\t\torder = min(MAX_ORDER - 1UL, __ffs(start));\n\n\t\twhile (start + (1UL << order) > end)\n\t\t\torder--;\n\n\t\tmemblock_free_pages(pfn_to_page(start), start, order);\n\n\t\tstart += (1UL << order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "PFN_DOWN(end)",
            "max_low_pfn"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "end"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "start"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long max_low_pfn;\n\nstatic unsigned long __init __free_memory_core(phys_addr_t start,\n\t\t\t\t phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_UP(start);\n\tunsigned long end_pfn = min_t(unsigned long,\n\t\t\t\t      PFN_DOWN(end), max_low_pfn);\n\n\tif (start_pfn >= end_pfn)\n\t\treturn 0;\n\n\t__free_pages_memory(start_pfn, end_pfn);\n\n\treturn end_pfn - start_pfn;\n}"
  },
  {
    "function_name": "__free_pages_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1892-1906",
    "snippet": "static void __init __free_pages_memory(unsigned long start, unsigned long end)\n{\n\tint order;\n\n\twhile (start < end) {\n\t\torder = min(MAX_ORDER - 1UL, __ffs(start));\n\n\t\twhile (start + (1UL << order) > end)\n\t\t\torder--;\n\n\t\tmemblock_free_pages(pfn_to_page(start), start, order);\n\n\t\tstart += (1UL << order);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free_pages",
          "args": [
            "pfn_to_page(start)",
            "start",
            "order"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1341-1347",
          "snippet": "void __init memblock_free_pages(struct page *page, unsigned long pfn,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (early_page_uninitialised(pfn))\n\t\treturn;\n\treturn __free_pages_boot_core(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __init memblock_free_pages(struct page *page, unsigned long pfn,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (early_page_uninitialised(pfn))\n\t\treturn;\n\treturn __free_pages_boot_core(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "MAX_ORDER - 1UL",
            "__ffs(start)"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "start"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __init __free_pages_memory(unsigned long start, unsigned long end)\n{\n\tint order;\n\n\twhile (start < end) {\n\t\torder = min(MAX_ORDER - 1UL, __ffs(start));\n\n\t\twhile (start + (1UL << order) > end)\n\t\t\torder--;\n\n\t\tmemblock_free_pages(pfn_to_page(start), start, order);\n\n\t\tstart += (1UL << order);\n\t}\n}"
  },
  {
    "function_name": "early_memblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1884-1889",
    "snippet": "static int __init early_memblock(char *p)\n{\n\tif (p && strstr(p, \"debug\"))\n\t\tmemblock_debug = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int memblock_debug"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"debug\""
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint memblock_debug;\n\nstatic int __init early_memblock(char *p)\n{\n\tif (p && strstr(p, \"debug\"))\n\t\tmemblock_debug = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_allow_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1879-1882",
    "snippet": "void __init memblock_allow_resize(void)\n{\n\tmemblock_can_resize = 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int memblock_can_resize"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int memblock_can_resize;\n\nvoid __init memblock_allow_resize(void)\n{\n\tmemblock_can_resize = 1;\n}"
  },
  {
    "function_name": "memblock_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1839-1863",
    "snippet": "static void __init_memblock memblock_dump(struct memblock_type *type)\n{\n\tphys_addr_t base, end, size;\n\tenum memblock_flags flags;\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\tpr_info(\" %s.cnt  = 0x%lx\\n\", type->name, type->cnt);\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tchar nid_buf[32] = \"\";\n\n\t\tbase = rgn->base;\n\t\tsize = rgn->size;\n\t\tend = base + size - 1;\n\t\tflags = rgn->flags;\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\tif (memblock_get_region_node(rgn) != MAX_NUMNODES)\n\t\t\tsnprintf(nid_buf, sizeof(nid_buf), \" on node %d\",\n\t\t\t\t memblock_get_region_node(rgn));\n#endif\n\t\tpr_info(\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\",\n\t\t\ttype->name, idx, &base, &end, &size, nid_buf, flags);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\"",
            "type->name",
            "idx",
            "&base",
            "&end",
            "&size",
            "nid_buf",
            "flags"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nid_buf",
            "sizeof(nid_buf)",
            "\" on node %d\"",
            "memblock_get_region_node(rgn)"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "rgn"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "rgn"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock_type",
          "args": [
            "idx",
            "type",
            "rgn"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" %s.cnt  = 0x%lx\\n\"",
            "type->name",
            "type->cnt"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_dump(struct memblock_type *type)\n{\n\tphys_addr_t base, end, size;\n\tenum memblock_flags flags;\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\tpr_info(\" %s.cnt  = 0x%lx\\n\", type->name, type->cnt);\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tchar nid_buf[32] = \"\";\n\n\t\tbase = rgn->base;\n\t\tsize = rgn->size;\n\t\tend = base + size - 1;\n\t\tflags = rgn->flags;\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\tif (memblock_get_region_node(rgn) != MAX_NUMNODES)\n\t\t\tsnprintf(nid_buf, sizeof(nid_buf), \" on node %d\",\n\t\t\t\t memblock_get_region_node(rgn));\n#endif\n\t\tpr_info(\" %s[%#x]\\t[%pa-%pa], %pa bytes%s flags: %#x\\n\",\n\t\t\ttype->name, idx, &base, &end, &size, nid_buf, flags);\n\t}\n}"
  },
  {
    "function_name": "memblock_set_current_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1829-1832",
    "snippet": "void __init_memblock memblock_set_current_limit(phys_addr_t limit)\n{\n\tmemblock.current_limit = limit;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nvoid __init_memblock memblock_set_current_limit(phys_addr_t limit)\n{\n\tmemblock.current_limit = limit;\n}"
  },
  {
    "function_name": "memblock_trim_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1804-1827",
    "snippet": "void __init_memblock memblock_trim_memory(phys_addr_t align)\n{\n\tphys_addr_t start, end, orig_start, orig_end;\n\tstruct memblock_region *r;\n\n\tfor_each_memblock(memory, r) {\n\t\torig_start = r->base;\n\t\torig_end = r->base + r->size;\n\t\tstart = round_up(orig_start, align);\n\t\tend = round_down(orig_end, align);\n\n\t\tif (start == orig_start && end == orig_end)\n\t\t\tcontinue;\n\n\t\tif (start < end) {\n\t\t\tr->base = start;\n\t\t\tr->size = end - start;\n\t\t} else {\n\t\t\tmemblock_remove_region(&memblock.memory,\n\t\t\t\t\t       r - memblock.memory.regions);\n\t\t\tr--;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_remove_region",
          "args": [
            "&memblock.memory",
            "r - memblock.memory.regions"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "341-357",
          "snippet": "static void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "orig_end",
            "align"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "orig_start",
            "align"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "r"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nvoid __init_memblock memblock_trim_memory(phys_addr_t align)\n{\n\tphys_addr_t start, end, orig_start, orig_end;\n\tstruct memblock_region *r;\n\n\tfor_each_memblock(memory, r) {\n\t\torig_start = r->base;\n\t\torig_end = r->base + r->size;\n\t\tstart = round_up(orig_start, align);\n\t\tend = round_down(orig_end, align);\n\n\t\tif (start == orig_start && end == orig_end)\n\t\t\tcontinue;\n\n\t\tif (start < end) {\n\t\t\tr->base = start;\n\t\t\tr->size = end - start;\n\t\t} else {\n\t\t\tmemblock_remove_region(&memblock.memory,\n\t\t\t\t\t       r - memblock.memory.regions);\n\t\t\tr--;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "memblock_is_region_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1798-1802",
    "snippet": "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)\n{\n\tmemblock_cap_size(base, &size);\n\treturn memblock_overlaps_region(&memblock.reserved, base, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_overlaps_region",
          "args": [
            "&memblock.reserved",
            "base",
            "size"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_overlaps_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "148-158",
          "snippet": "bool __init_memblock memblock_overlaps_region(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < type->cnt; i++)\n\t\tif (memblock_addrs_overlap(base, size, type->regions[i].base,\n\t\t\t\t\t   type->regions[i].size))\n\t\t\tbreak;\n\treturn i < type->cnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_overlaps_region(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < type->cnt; i++)\n\t\tif (memblock_addrs_overlap(base, size, type->regions[i].base,\n\t\t\t\t\t   type->regions[i].size))\n\t\t\tbreak;\n\treturn i < type->cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_cap_size",
          "args": [
            "base",
            "&size"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_cap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "134-137",
          "snippet": "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)\n{\n\tmemblock_cap_size(base, &size);\n\treturn memblock_overlaps_region(&memblock.reserved, base, size);\n}"
  },
  {
    "function_name": "memblock_is_region_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1776-1785",
    "snippet": "bool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)\n{\n\tint idx = memblock_search(&memblock.memory, base);\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\n\tif (idx == -1)\n\t\treturn false;\n\treturn (memblock.memory.regions[idx].base +\n\t\t memblock.memory.regions[idx].size) >= end;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_cap_size",
          "args": [
            "base",
            "&size"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_cap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "134-137",
          "snippet": "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_search",
          "args": [
            "&memblock.memory",
            "base"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1712-1728",
          "snippet": "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)\n{\n\tint idx = memblock_search(&memblock.memory, base);\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\n\tif (idx == -1)\n\t\treturn false;\n\treturn (memblock.memory.regions[idx].base +\n\t\t memblock.memory.regions[idx].size) >= end;\n}"
  },
  {
    "function_name": "memblock_search_pfn_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1750-1763",
    "snippet": "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,\n\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint mid = memblock_search(type, PFN_PHYS(pfn));\n\n\tif (mid == -1)\n\t\treturn -1;\n\n\t*start_pfn = PFN_DOWN(type->regions[mid].base);\n\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);\n\n\treturn type->regions[mid].nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "type->regions[mid].base + type->regions[mid].size"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "type->regions[mid].base"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_search",
          "args": [
            "type",
            "PFN_PHYS(pfn)"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1712-1728",
          "snippet": "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "pfn"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_search_pfn_nid(unsigned long pfn,\n\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint mid = memblock_search(type, PFN_PHYS(pfn));\n\n\tif (mid == -1)\n\t\treturn -1;\n\n\t*start_pfn = PFN_DOWN(type->regions[mid].base);\n\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);\n\n\treturn type->regions[mid].nid;\n}"
  },
  {
    "function_name": "memblock_is_map_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1740-1747",
    "snippet": "bool __init_memblock memblock_is_map_memory(phys_addr_t addr)\n{\n\tint i = memblock_search(&memblock.memory, addr);\n\n\tif (i == -1)\n\t\treturn false;\n\treturn !memblock_is_nomap(&memblock.memory.regions[i]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_is_nomap",
          "args": [
            "&memblock.memory.regions[i]"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_search",
          "args": [
            "&memblock.memory",
            "addr"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1712-1728",
          "snippet": "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_is_map_memory(phys_addr_t addr)\n{\n\tint i = memblock_search(&memblock.memory, addr);\n\n\tif (i == -1)\n\t\treturn false;\n\treturn !memblock_is_nomap(&memblock.memory.regions[i]);\n}"
  },
  {
    "function_name": "memblock_is_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1735-1738",
    "snippet": "bool __init_memblock memblock_is_memory(phys_addr_t addr)\n{\n\treturn memblock_search(&memblock.memory, addr) != -1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_search",
          "args": [
            "&memblock.memory",
            "addr"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1712-1728",
          "snippet": "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_is_memory(phys_addr_t addr)\n{\n\treturn memblock_search(&memblock.memory, addr) != -1;\n}"
  },
  {
    "function_name": "memblock_is_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1730-1733",
    "snippet": "bool __init memblock_is_reserved(phys_addr_t addr)\n{\n\treturn memblock_search(&memblock.reserved, addr) != -1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_search",
          "args": [
            "&memblock.reserved",
            "addr"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1712-1728",
          "snippet": "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nbool __init memblock_is_reserved(phys_addr_t addr)\n{\n\treturn memblock_search(&memblock.reserved, addr) != -1;\n}"
  },
  {
    "function_name": "memblock_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1712-1728",
    "snippet": "static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\n{\n\tunsigned int left = 0, right = type->cnt;\n\n\tdo {\n\t\tunsigned int mid = (right + left) / 2;\n\n\t\tif (addr < type->regions[mid].base)\n\t\t\tright = mid;\n\t\telse if (addr >= (type->regions[mid].base +\n\t\t\t\t  type->regions[mid].size))\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t} while (left < right);\n\treturn -1;\n}"
  },
  {
    "function_name": "memblock_mem_limit_remove_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1696-1710",
    "snippet": "void __init memblock_mem_limit_remove_map(phys_addr_t limit)\n{\n\tphys_addr_t max_addr;\n\n\tif (!limit)\n\t\treturn;\n\n\tmax_addr = __find_max_addr(limit);\n\n\t/* @limit exceeds the total size of the memory, do nothing */\n\tif (max_addr == PHYS_ADDR_MAX)\n\t\treturn;\n\n\tmemblock_cap_memory_range(0, max_addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_cap_memory_range",
          "args": [
            "0",
            "max_addr"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_cap_memory_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1668-1694",
          "snippet": "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tif (!size)\n\t\treturn;\n\n\tret = memblock_isolate_range(&memblock.memory, base, size,\n\t\t\t\t\t\t&start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn;\n\n\t/* remove all the MAP regions */\n\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\tfor (i = start_rgn - 1; i >= 0; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\t/* truncate the reserved regions */\n\tmemblock_remove_range(&memblock.reserved, 0, base);\n\tmemblock_remove_range(&memblock.reserved,\n\t\t\tbase + size, PHYS_ADDR_MAX);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tif (!size)\n\t\treturn;\n\n\tret = memblock_isolate_range(&memblock.memory, base, size,\n\t\t\t\t\t\t&start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn;\n\n\t/* remove all the MAP regions */\n\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\tfor (i = start_rgn - 1; i >= 0; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\t/* truncate the reserved regions */\n\tmemblock_remove_range(&memblock.reserved, 0, base);\n\tmemblock_remove_range(&memblock.reserved,\n\t\t\tbase + size, PHYS_ADDR_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_max_addr",
          "args": [
            "limit"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "__find_max_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1627-1646",
          "snippet": "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\tstruct memblock_region *r;\n\n\t/*\n\t * translate the memory @limit size into the max address within one of\n\t * the memory memblock regions, if the @limit exceeds the total size\n\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX\n\t */\n\tfor_each_memblock(memory, r) {\n\t\tif (limit <= r->size) {\n\t\t\tmax_addr = r->base + limit;\n\t\t\tbreak;\n\t\t}\n\t\tlimit -= r->size;\n\t}\n\n\treturn max_addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\tstruct memblock_region *r;\n\n\t/*\n\t * translate the memory @limit size into the max address within one of\n\t * the memory memblock regions, if the @limit exceeds the total size\n\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX\n\t */\n\tfor_each_memblock(memory, r) {\n\t\tif (limit <= r->size) {\n\t\t\tmax_addr = r->base + limit;\n\t\t\tbreak;\n\t\t}\n\t\tlimit -= r->size;\n\t}\n\n\treturn max_addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init memblock_mem_limit_remove_map(phys_addr_t limit)\n{\n\tphys_addr_t max_addr;\n\n\tif (!limit)\n\t\treturn;\n\n\tmax_addr = __find_max_addr(limit);\n\n\t/* @limit exceeds the total size of the memory, do nothing */\n\tif (max_addr == PHYS_ADDR_MAX)\n\t\treturn;\n\n\tmemblock_cap_memory_range(0, max_addr);\n}"
  },
  {
    "function_name": "memblock_cap_memory_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1668-1694",
    "snippet": "void __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tif (!size)\n\t\treturn;\n\n\tret = memblock_isolate_range(&memblock.memory, base, size,\n\t\t\t\t\t\t&start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn;\n\n\t/* remove all the MAP regions */\n\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\tfor (i = start_rgn - 1; i >= 0; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\t/* truncate the reserved regions */\n\tmemblock_remove_range(&memblock.reserved, 0, base);\n\tmemblock_remove_range(&memblock.reserved,\n\t\t\tbase + size, PHYS_ADDR_MAX);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_remove_range",
          "args": [
            "&memblock.reserved",
            "base + size",
            "PHYS_ADDR_MAX"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "778-791",
          "snippet": "static int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_remove_region",
          "args": [
            "&memblock.memory",
            "i"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "341-357",
          "snippet": "static void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_is_nomap",
          "args": [
            "&memblock.memory.regions[i]"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_nomap",
          "args": [
            "&memblock.memory.regions[i]"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_isolate_range",
          "args": [
            "&memblock.memory",
            "base",
            "size",
            "&start_rgn",
            "&end_rgn"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_isolate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "718-776",
          "snippet": "static int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tif (!size)\n\t\treturn;\n\n\tret = memblock_isolate_range(&memblock.memory, base, size,\n\t\t\t\t\t\t&start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn;\n\n\t/* remove all the MAP regions */\n\tfor (i = memblock.memory.cnt - 1; i >= end_rgn; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\tfor (i = start_rgn - 1; i >= 0; i--)\n\t\tif (!memblock_is_nomap(&memblock.memory.regions[i]))\n\t\t\tmemblock_remove_region(&memblock.memory, i);\n\n\t/* truncate the reserved regions */\n\tmemblock_remove_range(&memblock.reserved, 0, base);\n\tmemblock_remove_range(&memblock.reserved,\n\t\t\tbase + size, PHYS_ADDR_MAX);\n}"
  },
  {
    "function_name": "memblock_enforce_memory_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1648-1666",
    "snippet": "void __init memblock_enforce_memory_limit(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\n\tif (!limit)\n\t\treturn;\n\n\tmax_addr = __find_max_addr(limit);\n\n\t/* @limit exceeds the total size of the memory, do nothing */\n\tif (max_addr == PHYS_ADDR_MAX)\n\t\treturn;\n\n\t/* truncate both memory and reserved regions */\n\tmemblock_remove_range(&memblock.memory, max_addr,\n\t\t\t      PHYS_ADDR_MAX);\n\tmemblock_remove_range(&memblock.reserved, max_addr,\n\t\t\t      PHYS_ADDR_MAX);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_remove_range",
          "args": [
            "&memblock.reserved",
            "max_addr",
            "PHYS_ADDR_MAX"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "778-791",
          "snippet": "static int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_max_addr",
          "args": [
            "limit"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "__find_max_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1627-1646",
          "snippet": "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\tstruct memblock_region *r;\n\n\t/*\n\t * translate the memory @limit size into the max address within one of\n\t * the memory memblock regions, if the @limit exceeds the total size\n\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX\n\t */\n\tfor_each_memblock(memory, r) {\n\t\tif (limit <= r->size) {\n\t\t\tmax_addr = r->base + limit;\n\t\t\tbreak;\n\t\t}\n\t\tlimit -= r->size;\n\t}\n\n\treturn max_addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\tstruct memblock_region *r;\n\n\t/*\n\t * translate the memory @limit size into the max address within one of\n\t * the memory memblock regions, if the @limit exceeds the total size\n\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX\n\t */\n\tfor_each_memblock(memory, r) {\n\t\tif (limit <= r->size) {\n\t\t\tmax_addr = r->base + limit;\n\t\t\tbreak;\n\t\t}\n\t\tlimit -= r->size;\n\t}\n\n\treturn max_addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init memblock_enforce_memory_limit(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\n\tif (!limit)\n\t\treturn;\n\n\tmax_addr = __find_max_addr(limit);\n\n\t/* @limit exceeds the total size of the memory, do nothing */\n\tif (max_addr == PHYS_ADDR_MAX)\n\t\treturn;\n\n\t/* truncate both memory and reserved regions */\n\tmemblock_remove_range(&memblock.memory, max_addr,\n\t\t\t      PHYS_ADDR_MAX);\n\tmemblock_remove_range(&memblock.reserved, max_addr,\n\t\t\t      PHYS_ADDR_MAX);\n}"
  },
  {
    "function_name": "__find_max_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1627-1646",
    "snippet": "static phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\tstruct memblock_region *r;\n\n\t/*\n\t * translate the memory @limit size into the max address within one of\n\t * the memory memblock regions, if the @limit exceeds the total size\n\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX\n\t */\n\tfor_each_memblock(memory, r) {\n\t\tif (limit <= r->size) {\n\t\t\tmax_addr = r->base + limit;\n\t\t\tbreak;\n\t\t}\n\t\tlimit -= r->size;\n\t}\n\n\treturn max_addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "r"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic phys_addr_t __init_memblock __find_max_addr(phys_addr_t limit)\n{\n\tphys_addr_t max_addr = PHYS_ADDR_MAX;\n\tstruct memblock_region *r;\n\n\t/*\n\t * translate the memory @limit size into the max address within one of\n\t * the memory memblock regions, if the @limit exceeds the total size\n\t * of those regions, max_addr will keep original value PHYS_ADDR_MAX\n\t */\n\tfor_each_memblock(memory, r) {\n\t\tif (limit <= r->size) {\n\t\t\tmax_addr = r->base + limit;\n\t\t\tbreak;\n\t\t}\n\t\tlimit -= r->size;\n\t}\n\n\treturn max_addr;\n}"
  },
  {
    "function_name": "memblock_mem_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1597-1612",
    "snippet": "phys_addr_t __init memblock_mem_size(unsigned long limit_pfn)\n{\n\tunsigned long pages = 0;\n\tstruct memblock_region *r;\n\tunsigned long start_pfn, end_pfn;\n\n\tfor_each_memblock(memory, r) {\n\t\tstart_pfn = memblock_region_memory_base_pfn(r);\n\t\tend_pfn = memblock_region_memory_end_pfn(r);\n\t\tstart_pfn = min_t(unsigned long, start_pfn, limit_pfn);\n\t\tend_pfn = min_t(unsigned long, end_pfn, limit_pfn);\n\t\tpages += end_pfn - start_pfn;\n\t}\n\n\treturn PFN_PHYS(pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "pages"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "end_pfn",
            "limit_pfn"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "start_pfn",
            "limit_pfn"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_end_pfn",
          "args": [
            "r"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_base_pfn",
          "args": [
            "r"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "r"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_mem_size(unsigned long limit_pfn)\n{\n\tunsigned long pages = 0;\n\tstruct memblock_region *r;\n\tunsigned long start_pfn, end_pfn;\n\n\tfor_each_memblock(memory, r) {\n\t\tstart_pfn = memblock_region_memory_base_pfn(r);\n\t\tend_pfn = memblock_region_memory_end_pfn(r);\n\t\tstart_pfn = min_t(unsigned long, start_pfn, limit_pfn);\n\t\tend_pfn = min_t(unsigned long, end_pfn, limit_pfn);\n\t\tpages += end_pfn - start_pfn;\n\t}\n\n\treturn PFN_PHYS(pages);\n}"
  },
  {
    "function_name": "__memblock_free_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1566-1581",
    "snippet": "void __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_free_pages",
          "args": [
            "pfn_to_page(cursor)",
            "cursor",
            "0"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1341-1347",
          "snippet": "void __init memblock_free_pages(struct page *page, unsigned long pfn,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (early_page_uninitialised(pfn))\n\t\treturn;\n\treturn __free_pages_boot_core(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __init memblock_free_pages(struct page *page, unsigned long pfn,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (early_page_uninitialised(pfn))\n\t\treturn;\n\treturn __free_pages_boot_core(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "cursor"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "base + size"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "base"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_free_part_phys",
          "args": [
            "base",
            "size"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_part_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1235-1239",
          "snippet": "void __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"%s: [%pa-%pa] %pF\\n\"",
            "__func__",
            "&base",
            "&end",
            "(void *)_RET_IP_"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}"
  },
  {
    "function_name": "__memblock_free_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1547-1555",
    "snippet": "void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_remove_range",
          "args": [
            "&memblock.reserved",
            "base",
            "size"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "778-791",
          "snippet": "static int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free_part_phys",
          "args": [
            "base",
            "size"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_part_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1235-1239",
          "snippet": "void __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"%s: [%pa-%pa] %pF\\n\"",
            "__func__",
            "&base",
            "&end",
            "(void *)_RET_IP_"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tmemblock_remove_range(&memblock.reserved, base, size);\n}"
  },
  {
    "function_name": "memblock_alloc_try_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1517-1537",
    "snippet": "void * __init memblock_alloc_try_nid(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr) {\n\t\tmemset(ptr, 0, size);\n\t\treturn ptr;\n\t}\n\n\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa\\n\",\n\t      __func__, (u64)size, (u64)align, nid, &min_addr, &max_addr);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa\\n\"",
            "__func__",
            "(u64)size",
            "(u64)align",
            "nid",
            "&min_addr",
            "&max_addr"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "size"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_internal",
          "args": [
            "size",
            "align",
            "min_addr",
            "max_addr",
            "nid"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1358-1424",
          "snippet": "static void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\"",
            "__func__",
            "(u64)size",
            "(u64)align",
            "nid",
            "&min_addr",
            "&max_addr",
            "(void *)_RET_IP_"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr) {\n\t\tmemset(ptr, 0, size);\n\t\treturn ptr;\n\t}\n\n\tpanic(\"%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa\\n\",\n\t      __func__, (u64)size, (u64)align, nid, &min_addr, &max_addr);\n\treturn NULL;\n}"
  },
  {
    "function_name": "memblock_alloc_try_nid_nopanic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1481-1497",
    "snippet": "void * __init memblock_alloc_try_nid_nopanic(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\treturn ptr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "size"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_internal",
          "args": [
            "size",
            "align",
            "min_addr",
            "max_addr",
            "nid"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1358-1424",
          "snippet": "static void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\"",
            "__func__",
            "(u64)size",
            "(u64)align",
            "nid",
            "&min_addr",
            "&max_addr",
            "(void *)_RET_IP_"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid_nopanic(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\treturn ptr;\n}"
  },
  {
    "function_name": "memblock_alloc_try_nid_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1445-1462",
    "snippet": "void * __init memblock_alloc_try_nid_raw(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr && size > 0)\n\t\tpage_init_poison(ptr, size);\n\n\treturn ptr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_init_poison",
          "args": [
            "ptr",
            "size"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "page_init_poison",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "218-222",
          "snippet": "void page_init_poison(struct page *page, size_t size)\n{\n\tif (page_init_poisoning)\n\t\tmemset(page, PAGE_POISON_PATTERN, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid page_init_poison(struct page *page, size_t size)\n{\n\tif (page_init_poisoning)\n\t\tmemset(page, PAGE_POISON_PATTERN, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_internal",
          "args": [
            "size",
            "align",
            "min_addr",
            "max_addr",
            "nid"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1358-1424",
          "snippet": "static void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\"",
            "__func__",
            "(u64)size",
            "(u64)align",
            "nid",
            "&min_addr",
            "&max_addr",
            "(void *)_RET_IP_"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid_raw(\n\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr && size > 0)\n\t\tpage_init_poison(ptr, size);\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "memblock_alloc_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1358-1424",
    "snippet": "static void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "ptr",
            "size",
            "0",
            "0"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "alloc"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not allocate %pap bytes of mirrored memory\\n\"",
            "&size"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "alloc",
            "size"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "815-823",
          "snippet": "int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_find_in_range_node",
          "args": [
            "size",
            "align",
            "min_addr",
            "max_addr",
            "NUMA_NO_NODE",
            "flags"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_find_in_range_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "257-305",
          "snippet": "phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nphys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "size",
            "GFP_NOWAIT",
            "nid"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "slab_is_available()"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "slab_is_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "930-933",
          "snippet": "bool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum slab_state slab_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\n\nbool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "nid == MAX_NUMNODES",
            "\"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\""
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "choose_memblock_flags",
          "args": [],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void * __init memblock_alloc_internal(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tphys_addr_t alloc;\n\tvoid *ptr;\n\tenum memblock_flags flags = choose_memblock_flags();\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\t/*\n\t * Detect any accidental use of these APIs after slab is ready, as at\n\t * this moment memblock may be deinitialized already and its\n\t * internal data may be destroyed (after execution of memblock_free_all)\n\t */\n\tif (WARN_ON_ONCE(slab_is_available()))\n\t\treturn kzalloc_node(size, GFP_NOWAIT, nid);\n\n\tif (!align) {\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tif (max_addr > memblock.current_limit)\n\t\tmax_addr = memblock.current_limit;\nagain:\n\talloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\n\t\t\t\t\t    nid, flags);\n\tif (alloc && !memblock_reserve(alloc, size))\n\t\tgoto done;\n\n\tif (nid != NUMA_NO_NODE) {\n\t\talloc = memblock_find_in_range_node(size, align, min_addr,\n\t\t\t\t\t\t    max_addr, NUMA_NO_NODE,\n\t\t\t\t\t\t    flags);\n\t\tif (alloc && !memblock_reserve(alloc, size))\n\t\t\tgoto done;\n\t}\n\n\tif (min_addr) {\n\t\tmin_addr = 0;\n\t\tgoto again;\n\t}\n\n\tif (flags & MEMBLOCK_MIRROR) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tgoto again;\n\t}\n\n\treturn NULL;\ndone:\n\tptr = phys_to_virt(alloc);\n\n\t/*\n\t * The min_count is set to 0 so that bootmem allocated blocks\n\t * are never reported as leaks. This is because many of these blocks\n\t * are only referred via the physical address which is not\n\t * looked up by kmemleak.\n\t */\n\tkmemleak_alloc(ptr, size, 0, 0);\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "memblock_phys_alloc_try_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1324-1331",
    "snippet": "phys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)\n{\n\tphys_addr_t res = memblock_phys_alloc_nid(size, align, nid);\n\n\tif (res)\n\t\treturn res;\n\treturn memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_base",
          "args": [
            "size",
            "align",
            "MEMBLOCK_ALLOC_ACCESSIBLE"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1306-1317",
          "snippet": "phys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\tphys_addr_t alloc;\n\n\talloc = __memblock_alloc_base(size, align, max_addr);\n\n\tif (alloc == 0)\n\t\tpanic(\"ERROR: Failed to allocate %pa bytes below %pa.\\n\",\n\t\t      &size, &max_addr);\n\n\treturn alloc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\tphys_addr_t alloc;\n\n\talloc = __memblock_alloc_base(size, align, max_addr);\n\n\tif (alloc == 0)\n\t\tpanic(\"ERROR: Failed to allocate %pa bytes below %pa.\\n\",\n\t\t      &size, &max_addr);\n\n\treturn alloc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_phys_alloc_nid",
          "args": [
            "size",
            "align",
            "nid"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_phys_alloc_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1284-1298",
          "snippet": "phys_addr_t __init memblock_phys_alloc_nid(phys_addr_t size, phys_addr_t align, int nid)\n{\n\tenum memblock_flags flags = choose_memblock_flags();\n\tphys_addr_t ret;\n\nagain:\n\tret = memblock_alloc_base_nid(size, align, MEMBLOCK_ALLOC_ACCESSIBLE,\n\t\t\t\t      nid, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_phys_alloc_nid(phys_addr_t size, phys_addr_t align, int nid)\n{\n\tenum memblock_flags flags = choose_memblock_flags();\n\tphys_addr_t ret;\n\nagain:\n\tret = memblock_alloc_base_nid(size, align, MEMBLOCK_ALLOC_ACCESSIBLE,\n\t\t\t\t      nid, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_phys_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)\n{\n\tphys_addr_t res = memblock_phys_alloc_nid(size, align, nid);\n\n\tif (res)\n\t\treturn res;\n\treturn memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);\n}"
  },
  {
    "function_name": "memblock_phys_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1319-1322",
    "snippet": "phys_addr_t __init memblock_phys_alloc(phys_addr_t size, phys_addr_t align)\n{\n\treturn memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_base",
          "args": [
            "size",
            "align",
            "MEMBLOCK_ALLOC_ACCESSIBLE"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1306-1317",
          "snippet": "phys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\tphys_addr_t alloc;\n\n\talloc = __memblock_alloc_base(size, align, max_addr);\n\n\tif (alloc == 0)\n\t\tpanic(\"ERROR: Failed to allocate %pa bytes below %pa.\\n\",\n\t\t      &size, &max_addr);\n\n\treturn alloc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\tphys_addr_t alloc;\n\n\talloc = __memblock_alloc_base(size, align, max_addr);\n\n\tif (alloc == 0)\n\t\tpanic(\"ERROR: Failed to allocate %pa bytes below %pa.\\n\",\n\t\t      &size, &max_addr);\n\n\treturn alloc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_phys_alloc(phys_addr_t size, phys_addr_t align)\n{\n\treturn memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);\n}"
  },
  {
    "function_name": "memblock_alloc_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1306-1317",
    "snippet": "phys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\tphys_addr_t alloc;\n\n\talloc = __memblock_alloc_base(size, align, max_addr);\n\n\tif (alloc == 0)\n\t\tpanic(\"ERROR: Failed to allocate %pa bytes below %pa.\\n\",\n\t\t      &size, &max_addr);\n\n\treturn alloc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ERROR: Failed to allocate %pa bytes below %pa.\\n\"",
            "&size",
            "&max_addr"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__memblock_alloc_base",
          "args": [
            "size",
            "align",
            "max_addr"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_alloc_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1300-1304",
          "snippet": "phys_addr_t __init __memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\treturn memblock_alloc_base_nid(size, align, max_addr, NUMA_NO_NODE,\n\t\t\t\t       MEMBLOCK_NONE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init __memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\treturn memblock_alloc_base_nid(size, align, max_addr, NUMA_NO_NODE,\n\t\t\t\t       MEMBLOCK_NONE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\tphys_addr_t alloc;\n\n\talloc = __memblock_alloc_base(size, align, max_addr);\n\n\tif (alloc == 0)\n\t\tpanic(\"ERROR: Failed to allocate %pa bytes below %pa.\\n\",\n\t\t      &size, &max_addr);\n\n\treturn alloc;\n}"
  },
  {
    "function_name": "__memblock_alloc_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1300-1304",
    "snippet": "phys_addr_t __init __memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\treturn memblock_alloc_base_nid(size, align, max_addr, NUMA_NO_NODE,\n\t\t\t\t       MEMBLOCK_NONE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_base_nid",
          "args": [
            "size",
            "align",
            "max_addr",
            "NUMA_NO_NODE",
            "MEMBLOCK_NONE"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_base_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1277-1282",
          "snippet": "phys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t max_addr,\n\t\t\t\t\tint nid, enum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, 0, max_addr, nid, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t max_addr,\n\t\t\t\t\tint nid, enum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, 0, max_addr, nid, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init __memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\n{\n\treturn memblock_alloc_base_nid(size, align, max_addr, NUMA_NO_NODE,\n\t\t\t\t       MEMBLOCK_NONE);\n}"
  },
  {
    "function_name": "memblock_phys_alloc_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1284-1298",
    "snippet": "phys_addr_t __init memblock_phys_alloc_nid(phys_addr_t size, phys_addr_t align, int nid)\n{\n\tenum memblock_flags flags = choose_memblock_flags();\n\tphys_addr_t ret;\n\nagain:\n\tret = memblock_alloc_base_nid(size, align, MEMBLOCK_ALLOC_ACCESSIBLE,\n\t\t\t\t      nid, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_base_nid",
          "args": [
            "size",
            "align",
            "MEMBLOCK_ALLOC_ACCESSIBLE",
            "nid",
            "flags"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_base_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1277-1282",
          "snippet": "phys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t max_addr,\n\t\t\t\t\tint nid, enum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, 0, max_addr, nid, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t max_addr,\n\t\t\t\t\tint nid, enum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, 0, max_addr, nid, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "choose_memblock_flags",
          "args": [],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_phys_alloc_nid(phys_addr_t size, phys_addr_t align, int nid)\n{\n\tenum memblock_flags flags = choose_memblock_flags();\n\tphys_addr_t ret;\n\nagain:\n\tret = memblock_alloc_base_nid(size, align, MEMBLOCK_ALLOC_ACCESSIBLE,\n\t\t\t\t      nid, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "memblock_alloc_base_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1277-1282",
    "snippet": "phys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t max_addr,\n\t\t\t\t\tint nid, enum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, 0, max_addr, nid, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_range_nid",
          "args": [
            "size",
            "align",
            "0",
            "max_addr",
            "nid",
            "flags"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_range_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1243-1267",
          "snippet": "static phys_addr_t __init memblock_alloc_range_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t found;\n\n\tif (!align) {\n\t\t/* Can't use WARNs this early in boot on powerpc */\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tfound = memblock_find_in_range_node(size, align, start, end, nid,\n\t\t\t\t\t    flags);\n\tif (found && !memblock_reserve(found, size)) {\n\t\t/*\n\t\t * The min_count is set to 0 so that memblock allocations are\n\t\t * never reported as leaks.\n\t\t */\n\t\tkmemleak_alloc_phys(found, size, 0, 0);\n\t\treturn found;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic phys_addr_t __init memblock_alloc_range_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t found;\n\n\tif (!align) {\n\t\t/* Can't use WARNs this early in boot on powerpc */\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tfound = memblock_find_in_range_node(size, align, start, end, nid,\n\t\t\t\t\t    flags);\n\tif (found && !memblock_reserve(found, size)) {\n\t\t/*\n\t\t * The min_count is set to 0 so that memblock allocations are\n\t\t * never reported as leaks.\n\t\t */\n\t\tkmemleak_alloc_phys(found, size, 0, 0);\n\t\treturn found;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t max_addr,\n\t\t\t\t\tint nid, enum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, 0, max_addr, nid, flags);\n}"
  },
  {
    "function_name": "memblock_alloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1269-1275",
    "snippet": "phys_addr_t __init memblock_alloc_range(phys_addr_t size, phys_addr_t align,\n\t\t\t\t\tphys_addr_t start, phys_addr_t end,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,\n\t\t\t\t\tflags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_alloc_range_nid",
          "args": [
            "size",
            "align",
            "start",
            "end",
            "NUMA_NO_NODE",
            "flags"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_range_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1243-1267",
          "snippet": "static phys_addr_t __init memblock_alloc_range_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t found;\n\n\tif (!align) {\n\t\t/* Can't use WARNs this early in boot on powerpc */\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tfound = memblock_find_in_range_node(size, align, start, end, nid,\n\t\t\t\t\t    flags);\n\tif (found && !memblock_reserve(found, size)) {\n\t\t/*\n\t\t * The min_count is set to 0 so that memblock allocations are\n\t\t * never reported as leaks.\n\t\t */\n\t\tkmemleak_alloc_phys(found, size, 0, 0);\n\t\treturn found;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic phys_addr_t __init memblock_alloc_range_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t found;\n\n\tif (!align) {\n\t\t/* Can't use WARNs this early in boot on powerpc */\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tfound = memblock_find_in_range_node(size, align, start, end, nid,\n\t\t\t\t\t    flags);\n\tif (found && !memblock_reserve(found, size)) {\n\t\t/*\n\t\t * The min_count is set to 0 so that memblock allocations are\n\t\t * never reported as leaks.\n\t\t */\n\t\tkmemleak_alloc_phys(found, size, 0, 0);\n\t\treturn found;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_range(phys_addr_t size, phys_addr_t align,\n\t\t\t\t\tphys_addr_t start, phys_addr_t end,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,\n\t\t\t\t\tflags);\n}"
  },
  {
    "function_name": "memblock_alloc_range_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1243-1267",
    "snippet": "static phys_addr_t __init memblock_alloc_range_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t found;\n\n\tif (!align) {\n\t\t/* Can't use WARNs this early in boot on powerpc */\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tfound = memblock_find_in_range_node(size, align, start, end, nid,\n\t\t\t\t\t    flags);\n\tif (found && !memblock_reserve(found, size)) {\n\t\t/*\n\t\t * The min_count is set to 0 so that memblock allocations are\n\t\t * never reported as leaks.\n\t\t */\n\t\tkmemleak_alloc_phys(found, size, 0, 0);\n\t\treturn found;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_alloc_phys",
          "args": [
            "found",
            "size",
            "0",
            "0"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "found",
            "size"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "815-823",
          "snippet": "int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_find_in_range_node",
          "args": [
            "size",
            "align",
            "start",
            "end",
            "nid",
            "flags"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_find_in_range_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "257-305",
          "snippet": "phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nphys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic phys_addr_t __init memblock_alloc_range_nid(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t found;\n\n\tif (!align) {\n\t\t/* Can't use WARNs this early in boot on powerpc */\n\t\tdump_stack();\n\t\talign = SMP_CACHE_BYTES;\n\t}\n\n\tfound = memblock_find_in_range_node(size, align, start, end, nid,\n\t\t\t\t\t    flags);\n\tif (found && !memblock_reserve(found, size)) {\n\t\t/*\n\t\t * The min_count is set to 0 so that memblock allocations are\n\t\t * never reported as leaks.\n\t\t */\n\t\tkmemleak_alloc_phys(found, size, 0, 0);\n\t\treturn found;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_set_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1225-1240",
    "snippet": "int __init_memblock memblock_set_node(phys_addr_t base, phys_addr_t size,\n\t\t\t\t      struct memblock_type *type, int nid)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tmemblock_set_region_node(&type->regions[i], nid);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_merge_regions",
          "args": [
            "type"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_merge_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "506-529",
          "snippet": "static void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_set_region_node",
          "args": [
            "&type->regions[i]",
            "nid"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_isolate_range",
          "args": [
            "type",
            "base",
            "size",
            "&start_rgn",
            "&end_rgn"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_isolate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "718-776",
          "snippet": "static int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_set_node(phys_addr_t base, phys_addr_t size,\n\t\t\t\t      struct memblock_type *type, int nid)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tmemblock_set_region_node(&type->regions[i], nid);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}"
  },
  {
    "function_name": "__next_mem_pfn_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1184-1210",
    "snippet": "void __init_memblock __next_mem_pfn_range(int *idx, int nid,\n\t\t\t\tunsigned long *out_start_pfn,\n\t\t\t\tunsigned long *out_end_pfn, int *out_nid)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tstruct memblock_region *r;\n\n\twhile (++*idx < type->cnt) {\n\t\tr = &type->regions[*idx];\n\n\t\tif (PFN_UP(r->base) >= PFN_DOWN(r->base + r->size))\n\t\t\tcontinue;\n\t\tif (nid == MAX_NUMNODES || nid == r->nid)\n\t\t\tbreak;\n\t}\n\tif (*idx >= type->cnt) {\n\t\t*idx = -1;\n\t\treturn;\n\t}\n\n\tif (out_start_pfn)\n\t\t*out_start_pfn = PFN_UP(r->base);\n\tif (out_end_pfn)\n\t\t*out_end_pfn = PFN_DOWN(r->base + r->size);\n\tif (out_nid)\n\t\t*out_nid = r->nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "r->base + r->size"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "r->base"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "r->base + r->size"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "r->base"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nvoid __init_memblock __next_mem_pfn_range(int *idx, int nid,\n\t\t\t\tunsigned long *out_start_pfn,\n\t\t\t\tunsigned long *out_end_pfn, int *out_nid)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tstruct memblock_region *r;\n\n\twhile (++*idx < type->cnt) {\n\t\tr = &type->regions[*idx];\n\n\t\tif (PFN_UP(r->base) >= PFN_DOWN(r->base + r->size))\n\t\t\tcontinue;\n\t\tif (nid == MAX_NUMNODES || nid == r->nid)\n\t\t\tbreak;\n\t}\n\tif (*idx >= type->cnt) {\n\t\t*idx = -1;\n\t\treturn;\n\t}\n\n\tif (out_start_pfn)\n\t\t*out_start_pfn = PFN_UP(r->base);\n\tif (out_end_pfn)\n\t\t*out_end_pfn = PFN_DOWN(r->base + r->size);\n\tif (out_nid)\n\t\t*out_nid = r->nid;\n}"
  },
  {
    "function_name": "__next_mem_range_rev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "1086-1178",
    "snippet": "void __init_memblock __next_mem_range_rev(u64 *idx, int nid,\n\t\t\t\t\t  enum memblock_flags flags,\n\t\t\t\t\t  struct memblock_type *type_a,\n\t\t\t\t\t  struct memblock_type *type_b,\n\t\t\t\t\t  phys_addr_t *out_start,\n\t\t\t\t\t  phys_addr_t *out_end, int *out_nid)\n{\n\tint idx_a = *idx & 0xffffffff;\n\tint idx_b = *idx >> 32;\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\tif (*idx == (u64)ULLONG_MAX) {\n\t\tidx_a = type_a->cnt - 1;\n\t\tif (type_b != NULL)\n\t\t\tidx_b = type_b->cnt;\n\t\telse\n\t\t\tidx_b = 0;\n\t}\n\n\tfor (; idx_a >= 0; idx_a--) {\n\t\tstruct memblock_region *m = &type_a->regions[idx_a];\n\n\t\tphys_addr_t m_start = m->base;\n\t\tphys_addr_t m_end = m->base + m->size;\n\t\tint m_nid = memblock_get_region_node(m);\n\n\t\t/* only memory regions are associated with nodes, check it */\n\t\tif (nid != NUMA_NO_NODE && nid != m_nid)\n\t\t\tcontinue;\n\n\t\t/* skip hotpluggable memory regions if needed */\n\t\tif (movable_node_is_enabled() && memblock_is_hotpluggable(m))\n\t\t\tcontinue;\n\n\t\t/* if we want mirror memory skip non-mirror memory regions */\n\t\tif ((flags & MEMBLOCK_MIRROR) && !memblock_is_mirror(m))\n\t\t\tcontinue;\n\n\t\t/* skip nomap memory unless we were asked for it explicitly */\n\t\tif (!(flags & MEMBLOCK_NOMAP) && memblock_is_nomap(m))\n\t\t\tcontinue;\n\n\t\tif (!type_b) {\n\t\t\tif (out_start)\n\t\t\t\t*out_start = m_start;\n\t\t\tif (out_end)\n\t\t\t\t*out_end = m_end;\n\t\t\tif (out_nid)\n\t\t\t\t*out_nid = m_nid;\n\t\t\tidx_a--;\n\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\treturn;\n\t\t}\n\n\t\t/* scan areas before each reservation */\n\t\tfor (; idx_b >= 0; idx_b--) {\n\t\t\tstruct memblock_region *r;\n\t\t\tphys_addr_t r_start;\n\t\t\tphys_addr_t r_end;\n\n\t\t\tr = &type_b->regions[idx_b];\n\t\t\tr_start = idx_b ? r[-1].base + r[-1].size : 0;\n\t\t\tr_end = idx_b < type_b->cnt ?\n\t\t\t\tr->base : PHYS_ADDR_MAX;\n\t\t\t/*\n\t\t\t * if idx_b advanced past idx_a,\n\t\t\t * break out to advance idx_a\n\t\t\t */\n\n\t\t\tif (r_end <= m_start)\n\t\t\t\tbreak;\n\t\t\t/* if the two regions intersect, we're done */\n\t\t\tif (m_end > r_start) {\n\t\t\t\tif (out_start)\n\t\t\t\t\t*out_start = max(m_start, r_start);\n\t\t\t\tif (out_end)\n\t\t\t\t\t*out_end = min(m_end, r_end);\n\t\t\t\tif (out_nid)\n\t\t\t\t\t*out_nid = m_nid;\n\t\t\t\tif (m_start >= r_start)\n\t\t\t\t\tidx_a--;\n\t\t\t\telse\n\t\t\t\t\tidx_b--;\n\t\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t/* signal end of iteration */\n\t*idx = ULLONG_MAX;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "m_end",
            "r_end"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "m_start",
            "r_start"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_is_nomap",
          "args": [
            "m"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_mirror",
          "args": [
            "m"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_hotpluggable",
          "args": [
            "m"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "movable_node_is_enabled",
          "args": [],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "m"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "nid == MAX_NUMNODES",
            "\"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\""
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nvoid __init_memblock __next_mem_range_rev(u64 *idx, int nid,\n\t\t\t\t\t  enum memblock_flags flags,\n\t\t\t\t\t  struct memblock_type *type_a,\n\t\t\t\t\t  struct memblock_type *type_b,\n\t\t\t\t\t  phys_addr_t *out_start,\n\t\t\t\t\t  phys_addr_t *out_end, int *out_nid)\n{\n\tint idx_a = *idx & 0xffffffff;\n\tint idx_b = *idx >> 32;\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES, \"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\tif (*idx == (u64)ULLONG_MAX) {\n\t\tidx_a = type_a->cnt - 1;\n\t\tif (type_b != NULL)\n\t\t\tidx_b = type_b->cnt;\n\t\telse\n\t\t\tidx_b = 0;\n\t}\n\n\tfor (; idx_a >= 0; idx_a--) {\n\t\tstruct memblock_region *m = &type_a->regions[idx_a];\n\n\t\tphys_addr_t m_start = m->base;\n\t\tphys_addr_t m_end = m->base + m->size;\n\t\tint m_nid = memblock_get_region_node(m);\n\n\t\t/* only memory regions are associated with nodes, check it */\n\t\tif (nid != NUMA_NO_NODE && nid != m_nid)\n\t\t\tcontinue;\n\n\t\t/* skip hotpluggable memory regions if needed */\n\t\tif (movable_node_is_enabled() && memblock_is_hotpluggable(m))\n\t\t\tcontinue;\n\n\t\t/* if we want mirror memory skip non-mirror memory regions */\n\t\tif ((flags & MEMBLOCK_MIRROR) && !memblock_is_mirror(m))\n\t\t\tcontinue;\n\n\t\t/* skip nomap memory unless we were asked for it explicitly */\n\t\tif (!(flags & MEMBLOCK_NOMAP) && memblock_is_nomap(m))\n\t\t\tcontinue;\n\n\t\tif (!type_b) {\n\t\t\tif (out_start)\n\t\t\t\t*out_start = m_start;\n\t\t\tif (out_end)\n\t\t\t\t*out_end = m_end;\n\t\t\tif (out_nid)\n\t\t\t\t*out_nid = m_nid;\n\t\t\tidx_a--;\n\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\treturn;\n\t\t}\n\n\t\t/* scan areas before each reservation */\n\t\tfor (; idx_b >= 0; idx_b--) {\n\t\t\tstruct memblock_region *r;\n\t\t\tphys_addr_t r_start;\n\t\t\tphys_addr_t r_end;\n\n\t\t\tr = &type_b->regions[idx_b];\n\t\t\tr_start = idx_b ? r[-1].base + r[-1].size : 0;\n\t\t\tr_end = idx_b < type_b->cnt ?\n\t\t\t\tr->base : PHYS_ADDR_MAX;\n\t\t\t/*\n\t\t\t * if idx_b advanced past idx_a,\n\t\t\t * break out to advance idx_a\n\t\t\t */\n\n\t\t\tif (r_end <= m_start)\n\t\t\t\tbreak;\n\t\t\t/* if the two regions intersect, we're done */\n\t\t\tif (m_end > r_start) {\n\t\t\t\tif (out_start)\n\t\t\t\t\t*out_start = max(m_start, r_start);\n\t\t\t\tif (out_end)\n\t\t\t\t\t*out_end = min(m_end, r_end);\n\t\t\t\tif (out_nid)\n\t\t\t\t\t*out_nid = m_nid;\n\t\t\t\tif (m_start >= r_start)\n\t\t\t\t\tidx_a--;\n\t\t\t\telse\n\t\t\t\t\tidx_b--;\n\t\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t/* signal end of iteration */\n\t*idx = ULLONG_MAX;\n}"
  },
  {
    "function_name": "__next_mem_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "976-1067",
    "snippet": "void __init_memblock __next_mem_range(u64 *idx, int nid,\n\t\t\t\t      enum memblock_flags flags,\n\t\t\t\t      struct memblock_type *type_a,\n\t\t\t\t      struct memblock_type *type_b,\n\t\t\t\t      phys_addr_t *out_start,\n\t\t\t\t      phys_addr_t *out_end, int *out_nid)\n{\n\tint idx_a = *idx & 0xffffffff;\n\tint idx_b = *idx >> 32;\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES,\n\t\"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\tfor (; idx_a < type_a->cnt; idx_a++) {\n\t\tstruct memblock_region *m = &type_a->regions[idx_a];\n\n\t\tphys_addr_t m_start = m->base;\n\t\tphys_addr_t m_end = m->base + m->size;\n\t\tint\t    m_nid = memblock_get_region_node(m);\n\n\t\t/* only memory regions are associated with nodes, check it */\n\t\tif (nid != NUMA_NO_NODE && nid != m_nid)\n\t\t\tcontinue;\n\n\t\t/* skip hotpluggable memory regions if needed */\n\t\tif (movable_node_is_enabled() && memblock_is_hotpluggable(m))\n\t\t\tcontinue;\n\n\t\t/* if we want mirror memory skip non-mirror memory regions */\n\t\tif ((flags & MEMBLOCK_MIRROR) && !memblock_is_mirror(m))\n\t\t\tcontinue;\n\n\t\t/* skip nomap memory unless we were asked for it explicitly */\n\t\tif (!(flags & MEMBLOCK_NOMAP) && memblock_is_nomap(m))\n\t\t\tcontinue;\n\n\t\tif (!type_b) {\n\t\t\tif (out_start)\n\t\t\t\t*out_start = m_start;\n\t\t\tif (out_end)\n\t\t\t\t*out_end = m_end;\n\t\t\tif (out_nid)\n\t\t\t\t*out_nid = m_nid;\n\t\t\tidx_a++;\n\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\treturn;\n\t\t}\n\n\t\t/* scan areas before each reservation */\n\t\tfor (; idx_b < type_b->cnt + 1; idx_b++) {\n\t\t\tstruct memblock_region *r;\n\t\t\tphys_addr_t r_start;\n\t\t\tphys_addr_t r_end;\n\n\t\t\tr = &type_b->regions[idx_b];\n\t\t\tr_start = idx_b ? r[-1].base + r[-1].size : 0;\n\t\t\tr_end = idx_b < type_b->cnt ?\n\t\t\t\tr->base : PHYS_ADDR_MAX;\n\n\t\t\t/*\n\t\t\t * if idx_b advanced past idx_a,\n\t\t\t * break out to advance idx_a\n\t\t\t */\n\t\t\tif (r_start >= m_end)\n\t\t\t\tbreak;\n\t\t\t/* if the two regions intersect, we're done */\n\t\t\tif (m_start < r_end) {\n\t\t\t\tif (out_start)\n\t\t\t\t\t*out_start =\n\t\t\t\t\t\tmax(m_start, r_start);\n\t\t\t\tif (out_end)\n\t\t\t\t\t*out_end = min(m_end, r_end);\n\t\t\t\tif (out_nid)\n\t\t\t\t\t*out_nid = m_nid;\n\t\t\t\t/*\n\t\t\t\t * The region which ends first is\n\t\t\t\t * advanced for the next iteration.\n\t\t\t\t */\n\t\t\t\tif (m_end <= r_end)\n\t\t\t\t\tidx_a++;\n\t\t\t\telse\n\t\t\t\t\tidx_b++;\n\t\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* signal end of iteration */\n\t*idx = ULLONG_MAX;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "m_end",
            "r_end"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "m_start",
            "r_start"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_is_nomap",
          "args": [
            "m"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_mirror",
          "args": [
            "m"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_hotpluggable",
          "args": [
            "m"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "movable_node_is_enabled",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "m"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "nid == MAX_NUMNODES",
            "\"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nvoid __init_memblock __next_mem_range(u64 *idx, int nid,\n\t\t\t\t      enum memblock_flags flags,\n\t\t\t\t      struct memblock_type *type_a,\n\t\t\t\t      struct memblock_type *type_b,\n\t\t\t\t      phys_addr_t *out_start,\n\t\t\t\t      phys_addr_t *out_end, int *out_nid)\n{\n\tint idx_a = *idx & 0xffffffff;\n\tint idx_b = *idx >> 32;\n\n\tif (WARN_ONCE(nid == MAX_NUMNODES,\n\t\"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\\n\"))\n\t\tnid = NUMA_NO_NODE;\n\n\tfor (; idx_a < type_a->cnt; idx_a++) {\n\t\tstruct memblock_region *m = &type_a->regions[idx_a];\n\n\t\tphys_addr_t m_start = m->base;\n\t\tphys_addr_t m_end = m->base + m->size;\n\t\tint\t    m_nid = memblock_get_region_node(m);\n\n\t\t/* only memory regions are associated with nodes, check it */\n\t\tif (nid != NUMA_NO_NODE && nid != m_nid)\n\t\t\tcontinue;\n\n\t\t/* skip hotpluggable memory regions if needed */\n\t\tif (movable_node_is_enabled() && memblock_is_hotpluggable(m))\n\t\t\tcontinue;\n\n\t\t/* if we want mirror memory skip non-mirror memory regions */\n\t\tif ((flags & MEMBLOCK_MIRROR) && !memblock_is_mirror(m))\n\t\t\tcontinue;\n\n\t\t/* skip nomap memory unless we were asked for it explicitly */\n\t\tif (!(flags & MEMBLOCK_NOMAP) && memblock_is_nomap(m))\n\t\t\tcontinue;\n\n\t\tif (!type_b) {\n\t\t\tif (out_start)\n\t\t\t\t*out_start = m_start;\n\t\t\tif (out_end)\n\t\t\t\t*out_end = m_end;\n\t\t\tif (out_nid)\n\t\t\t\t*out_nid = m_nid;\n\t\t\tidx_a++;\n\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\treturn;\n\t\t}\n\n\t\t/* scan areas before each reservation */\n\t\tfor (; idx_b < type_b->cnt + 1; idx_b++) {\n\t\t\tstruct memblock_region *r;\n\t\t\tphys_addr_t r_start;\n\t\t\tphys_addr_t r_end;\n\n\t\t\tr = &type_b->regions[idx_b];\n\t\t\tr_start = idx_b ? r[-1].base + r[-1].size : 0;\n\t\t\tr_end = idx_b < type_b->cnt ?\n\t\t\t\tr->base : PHYS_ADDR_MAX;\n\n\t\t\t/*\n\t\t\t * if idx_b advanced past idx_a,\n\t\t\t * break out to advance idx_a\n\t\t\t */\n\t\t\tif (r_start >= m_end)\n\t\t\t\tbreak;\n\t\t\t/* if the two regions intersect, we're done */\n\t\t\tif (m_start < r_end) {\n\t\t\t\tif (out_start)\n\t\t\t\t\t*out_start =\n\t\t\t\t\t\tmax(m_start, r_start);\n\t\t\t\tif (out_end)\n\t\t\t\t\t*out_end = min(m_end, r_end);\n\t\t\t\tif (out_nid)\n\t\t\t\t\t*out_nid = m_nid;\n\t\t\t\t/*\n\t\t\t\t * The region which ends first is\n\t\t\t\t * advanced for the next iteration.\n\t\t\t\t */\n\t\t\t\tif (m_end <= r_end)\n\t\t\t\t\tidx_a++;\n\t\t\t\telse\n\t\t\t\t\tidx_b++;\n\t\t\t\t*idx = (u32)idx_a | (u64)idx_b << 32;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* signal end of iteration */\n\t*idx = ULLONG_MAX;\n}"
  },
  {
    "function_name": "__next_reserved_mem_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "926-948",
    "snippet": "void __init_memblock __next_reserved_mem_region(u64 *idx,\n\t\t\t\t\t   phys_addr_t *out_start,\n\t\t\t\t\t   phys_addr_t *out_end)\n{\n\tstruct memblock_type *type = &memblock.reserved;\n\n\tif (*idx < type->cnt) {\n\t\tstruct memblock_region *r = &type->regions[*idx];\n\t\tphys_addr_t base = r->base;\n\t\tphys_addr_t size = r->size;\n\n\t\tif (out_start)\n\t\t\t*out_start = base;\n\t\tif (out_end)\n\t\t\t*out_end = base + size - 1;\n\n\t\t*idx += 1;\n\t\treturn;\n\t}\n\n\t/* signal end of iteration */\n\t*idx = ULLONG_MAX;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nvoid __init_memblock __next_reserved_mem_region(u64 *idx,\n\t\t\t\t\t   phys_addr_t *out_start,\n\t\t\t\t\t   phys_addr_t *out_end)\n{\n\tstruct memblock_type *type = &memblock.reserved;\n\n\tif (*idx < type->cnt) {\n\t\tstruct memblock_region *r = &type->regions[*idx];\n\t\tphys_addr_t base = r->base;\n\t\tphys_addr_t size = r->size;\n\n\t\tif (out_start)\n\t\t\t*out_start = base;\n\t\tif (out_end)\n\t\t\t*out_end = base + size - 1;\n\n\t\t*idx += 1;\n\t\treturn;\n\t}\n\n\t/* signal end of iteration */\n\t*idx = ULLONG_MAX;\n}"
  },
  {
    "function_name": "memblock_clear_nomap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "913-916",
    "snippet": "int __init_memblock memblock_clear_nomap(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 0, MEMBLOCK_NOMAP);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_setclr_flag",
          "args": [
            "base",
            "size",
            "0",
            "MEMBLOCK_NOMAP"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_setclr_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "836-854",
          "snippet": "static int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_clear_nomap(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 0, MEMBLOCK_NOMAP);\n}"
  },
  {
    "function_name": "memblock_mark_nomap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "901-904",
    "snippet": "int __init_memblock memblock_mark_nomap(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 1, MEMBLOCK_NOMAP);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_setclr_flag",
          "args": [
            "base",
            "size",
            "1",
            "MEMBLOCK_NOMAP"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_setclr_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "836-854",
          "snippet": "static int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_mark_nomap(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 1, MEMBLOCK_NOMAP);\n}"
  },
  {
    "function_name": "memblock_mark_mirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "887-892",
    "snippet": "int __init_memblock memblock_mark_mirror(phys_addr_t base, phys_addr_t size)\n{\n\tsystem_has_some_mirror = true;\n\n\treturn memblock_setclr_flag(base, size, 1, MEMBLOCK_MIRROR);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool system_has_some_mirror",
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_setclr_flag",
          "args": [
            "base",
            "size",
            "1",
            "MEMBLOCK_MIRROR"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_setclr_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "836-854",
          "snippet": "static int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool system_has_some_mirror;\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_mark_mirror(phys_addr_t base, phys_addr_t size)\n{\n\tsystem_has_some_mirror = true;\n\n\treturn memblock_setclr_flag(base, size, 1, MEMBLOCK_MIRROR);\n}"
  },
  {
    "function_name": "memblock_clear_hotplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "875-878",
    "snippet": "int __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 0, MEMBLOCK_HOTPLUG);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_setclr_flag",
          "args": [
            "base",
            "size",
            "0",
            "MEMBLOCK_HOTPLUG"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_setclr_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "836-854",
          "snippet": "static int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 0, MEMBLOCK_HOTPLUG);\n}"
  },
  {
    "function_name": "memblock_mark_hotplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "863-866",
    "snippet": "int __init_memblock memblock_mark_hotplug(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 1, MEMBLOCK_HOTPLUG);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_setclr_flag",
          "args": [
            "base",
            "size",
            "1",
            "MEMBLOCK_HOTPLUG"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_setclr_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "836-854",
          "snippet": "static int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_mark_hotplug(phys_addr_t base, phys_addr_t size)\n{\n\treturn memblock_setclr_flag(base, size, 1, MEMBLOCK_HOTPLUG);\n}"
  },
  {
    "function_name": "memblock_setclr_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "836-854",
    "snippet": "static int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_merge_regions",
          "args": [
            "type"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_merge_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "506-529",
          "snippet": "static void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_clear_region_flags",
          "args": [
            "&type->regions[i]",
            "flag"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_set_region_flags",
          "args": [
            "&type->regions[i]",
            "flag"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_isolate_range",
          "args": [
            "type",
            "base",
            "size",
            "&start_rgn",
            "&end_rgn"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_isolate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "718-776",
          "snippet": "static int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_setclr_flag(phys_addr_t base,\n\t\t\t\tphys_addr_t size, int set, int flag)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint i, ret, start_rgn, end_rgn;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = start_rgn; i < end_rgn; i++)\n\t\tif (set)\n\t\t\tmemblock_set_region_flags(&type->regions[i], flag);\n\t\telse\n\t\t\tmemblock_clear_region_flags(&type->regions[i], flag);\n\n\tmemblock_merge_regions(type);\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "815-823",
    "snippet": "int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_add_range",
          "args": [
            "&memblock.reserved",
            "base",
            "size",
            "MAX_NUMNODES",
            "0"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_add_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "577-661",
          "snippet": "int __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"memblock_reserve: [%pa-%pa] %pF\\n\"",
            "&base",
            "&end",
            "(void *)_RET_IP_"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}"
  },
  {
    "function_name": "memblock_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "804-813",
    "snippet": "int __init_memblock memblock_free(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"   memblock_free: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\tkmemleak_free_part_phys(base, size);\n\treturn memblock_remove_range(&memblock.reserved, base, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_remove_range",
          "args": [
            "&memblock.reserved",
            "base",
            "size"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "778-791",
          "snippet": "static int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free_part_phys",
          "args": [
            "base",
            "size"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_part_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1235-1239",
          "snippet": "void __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"   memblock_free: [%pa-%pa] %pF\\n\"",
            "&base",
            "&end",
            "(void *)_RET_IP_"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_free(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"   memblock_free: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\tkmemleak_free_part_phys(base, size);\n\treturn memblock_remove_range(&memblock.reserved, base, size);\n}"
  },
  {
    "function_name": "memblock_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "793-801",
    "snippet": "int __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_remove: [%pa-%pa] %pS\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_remove_range(&memblock.memory, base, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_remove_range",
          "args": [
            "&memblock.memory",
            "base",
            "size"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "778-791",
          "snippet": "static int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"memblock_remove: [%pa-%pa] %pS\\n\"",
            "&base",
            "&end",
            "(void *)_RET_IP_"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_remove: [%pa-%pa] %pS\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_remove_range(&memblock.memory, base, size);\n}"
  },
  {
    "function_name": "memblock_remove_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "778-791",
    "snippet": "static int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_remove_region",
          "args": [
            "type",
            "i"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_remove_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "341-357",
          "snippet": "static void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_isolate_range",
          "args": [
            "type",
            "base",
            "size",
            "&start_rgn",
            "&end_rgn"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_isolate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "718-776",
          "snippet": "static int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_remove_range(struct memblock_type *type,\n\t\t\t\t\t  phys_addr_t base, phys_addr_t size)\n{\n\tint start_rgn, end_rgn;\n\tint i, ret;\n\n\tret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = end_rgn - 1; i >= start_rgn; i--)\n\t\tmemblock_remove_region(type, i);\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_isolate_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "718-776",
    "snippet": "static int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_insert_region",
          "args": [
            "type",
            "idx--",
            "rbase",
            "end - rbase",
            "memblock_get_region_node(rgn)",
            "rgn->flags"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_insert_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "543-559",
          "snippet": "static void __init_memblock memblock_insert_region(struct memblock_type *type,\n\t\t\t\t\t\t   int idx, phys_addr_t base,\n\t\t\t\t\t\t   phys_addr_t size,\n\t\t\t\t\t\t   int nid,\n\t\t\t\t\t\t   enum memblock_flags flags)\n{\n\tstruct memblock_region *rgn = &type->regions[idx];\n\n\tBUG_ON(type->cnt >= type->max);\n\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));\n\trgn->base = base;\n\trgn->size = size;\n\trgn->flags = flags;\n\tmemblock_set_region_node(rgn, nid);\n\ttype->cnt++;\n\ttype->total_size += size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_insert_region(struct memblock_type *type,\n\t\t\t\t\t\t   int idx, phys_addr_t base,\n\t\t\t\t\t\t   phys_addr_t size,\n\t\t\t\t\t\t   int nid,\n\t\t\t\t\t\t   enum memblock_flags flags)\n{\n\tstruct memblock_region *rgn = &type->regions[idx];\n\n\tBUG_ON(type->cnt >= type->max);\n\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));\n\trgn->base = base;\n\trgn->size = size;\n\trgn->flags = flags;\n\tmemblock_set_region_node(rgn, nid);\n\ttype->cnt++;\n\ttype->total_size += size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "rgn"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "rgn"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock_type",
          "args": [
            "idx",
            "type",
            "rgn"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_double_array",
          "args": [
            "type",
            "base",
            "size"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_double_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "398-498",
          "snippet": "static int __init_memblock memblock_double_array(struct memblock_type *type,\n\t\t\t\t\t\tphys_addr_t new_area_start,\n\t\t\t\t\t\tphys_addr_t new_area_size)\n{\n\tstruct memblock_region *new_array, *old_array;\n\tphys_addr_t old_alloc_size, new_alloc_size;\n\tphys_addr_t old_size, new_size, addr, new_end;\n\tint use_slab = slab_is_available();\n\tint *in_slab;\n\n\t/* We don't allow resizing until we know about the reserved regions\n\t * of memory that aren't suitable for allocation\n\t */\n\tif (!memblock_can_resize)\n\t\treturn -1;\n\n\t/* Calculate new doubled size */\n\told_size = type->max * sizeof(struct memblock_region);\n\tnew_size = old_size << 1;\n\t/*\n\t * We need to allocated new one align to PAGE_SIZE,\n\t *   so we can free them completely later.\n\t */\n\told_alloc_size = PAGE_ALIGN(old_size);\n\tnew_alloc_size = PAGE_ALIGN(new_size);\n\n\t/* Retrieve the slab flag */\n\tif (type == &memblock.memory)\n\t\tin_slab = &memblock_memory_in_slab;\n\telse\n\t\tin_slab = &memblock_reserved_in_slab;\n\n\t/* Try to find some space for it.\n\t *\n\t * WARNING: We assume that either slab_is_available() and we use it or\n\t * we use MEMBLOCK for allocations. That means that this is unsafe to\n\t * use when bootmem is currently active (unless bootmem itself is\n\t * implemented on top of MEMBLOCK which isn't the case yet)\n\t *\n\t * This should however not be an issue for now, as we currently only\n\t * call into MEMBLOCK while it's still active, or much later when slab\n\t * is active for memory hotplug operations\n\t */\n\tif (use_slab) {\n\t\tnew_array = kmalloc(new_size, GFP_KERNEL);\n\t\taddr = new_array ? __pa(new_array) : 0;\n\t} else {\n\t\t/* only exclude range when trying to double reserved.regions */\n\t\tif (type != &memblock.reserved)\n\t\t\tnew_area_start = new_area_size = 0;\n\n\t\taddr = memblock_find_in_range(new_area_start + new_area_size,\n\t\t\t\t\t\tmemblock.current_limit,\n\t\t\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\t\tif (!addr && new_area_size)\n\t\t\taddr = memblock_find_in_range(0,\n\t\t\t\tmin(new_area_start, memblock.current_limit),\n\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\n\t\tnew_array = addr ? __va(addr) : NULL;\n\t}\n\tif (!addr) {\n\t\tpr_err(\"memblock: Failed to double %s array from %ld to %ld entries !\\n\",\n\t\t       type->name, type->max, type->max * 2);\n\t\treturn -1;\n\t}\n\n\tnew_end = addr + new_size - 1;\n\tmemblock_dbg(\"memblock: %s is doubled to %ld at [%pa-%pa]\",\n\t\t\ttype->name, type->max * 2, &addr, &new_end);\n\n\t/*\n\t * Found space, we now need to move the array over before we add the\n\t * reserved region since it may be our reserved array itself that is\n\t * full.\n\t */\n\tmemcpy(new_array, type->regions, old_size);\n\tmemset(new_array + type->max, 0, old_size);\n\told_array = type->regions;\n\ttype->regions = new_array;\n\ttype->max <<= 1;\n\n\t/* Free old array. We needn't free it if the array is the static one */\n\tif (*in_slab)\n\t\tkfree(old_array);\n\telse if (old_array != memblock_memory_init_regions &&\n\t\t old_array != memblock_reserved_init_regions)\n\t\tmemblock_free(__pa(old_array), old_alloc_size);\n\n\t/*\n\t * Reserve the new array if that comes from the memblock.  Otherwise, we\n\t * needn't do it\n\t */\n\tif (!use_slab)\n\t\tBUG_ON(memblock_reserve(addr, new_alloc_size));\n\n\t/* Update slab flag */\n\t*in_slab = use_slab;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS]",
            "static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS]",
            "static int memblock_can_resize",
            "static int memblock_memory_in_slab",
            "static int memblock_reserved_in_slab",
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic int memblock_can_resize;\nstatic int memblock_memory_in_slab;\nstatic int memblock_reserved_in_slab;\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_double_array(struct memblock_type *type,\n\t\t\t\t\t\tphys_addr_t new_area_start,\n\t\t\t\t\t\tphys_addr_t new_area_size)\n{\n\tstruct memblock_region *new_array, *old_array;\n\tphys_addr_t old_alloc_size, new_alloc_size;\n\tphys_addr_t old_size, new_size, addr, new_end;\n\tint use_slab = slab_is_available();\n\tint *in_slab;\n\n\t/* We don't allow resizing until we know about the reserved regions\n\t * of memory that aren't suitable for allocation\n\t */\n\tif (!memblock_can_resize)\n\t\treturn -1;\n\n\t/* Calculate new doubled size */\n\told_size = type->max * sizeof(struct memblock_region);\n\tnew_size = old_size << 1;\n\t/*\n\t * We need to allocated new one align to PAGE_SIZE,\n\t *   so we can free them completely later.\n\t */\n\told_alloc_size = PAGE_ALIGN(old_size);\n\tnew_alloc_size = PAGE_ALIGN(new_size);\n\n\t/* Retrieve the slab flag */\n\tif (type == &memblock.memory)\n\t\tin_slab = &memblock_memory_in_slab;\n\telse\n\t\tin_slab = &memblock_reserved_in_slab;\n\n\t/* Try to find some space for it.\n\t *\n\t * WARNING: We assume that either slab_is_available() and we use it or\n\t * we use MEMBLOCK for allocations. That means that this is unsafe to\n\t * use when bootmem is currently active (unless bootmem itself is\n\t * implemented on top of MEMBLOCK which isn't the case yet)\n\t *\n\t * This should however not be an issue for now, as we currently only\n\t * call into MEMBLOCK while it's still active, or much later when slab\n\t * is active for memory hotplug operations\n\t */\n\tif (use_slab) {\n\t\tnew_array = kmalloc(new_size, GFP_KERNEL);\n\t\taddr = new_array ? __pa(new_array) : 0;\n\t} else {\n\t\t/* only exclude range when trying to double reserved.regions */\n\t\tif (type != &memblock.reserved)\n\t\t\tnew_area_start = new_area_size = 0;\n\n\t\taddr = memblock_find_in_range(new_area_start + new_area_size,\n\t\t\t\t\t\tmemblock.current_limit,\n\t\t\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\t\tif (!addr && new_area_size)\n\t\t\taddr = memblock_find_in_range(0,\n\t\t\t\tmin(new_area_start, memblock.current_limit),\n\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\n\t\tnew_array = addr ? __va(addr) : NULL;\n\t}\n\tif (!addr) {\n\t\tpr_err(\"memblock: Failed to double %s array from %ld to %ld entries !\\n\",\n\t\t       type->name, type->max, type->max * 2);\n\t\treturn -1;\n\t}\n\n\tnew_end = addr + new_size - 1;\n\tmemblock_dbg(\"memblock: %s is doubled to %ld at [%pa-%pa]\",\n\t\t\ttype->name, type->max * 2, &addr, &new_end);\n\n\t/*\n\t * Found space, we now need to move the array over before we add the\n\t * reserved region since it may be our reserved array itself that is\n\t * full.\n\t */\n\tmemcpy(new_array, type->regions, old_size);\n\tmemset(new_array + type->max, 0, old_size);\n\told_array = type->regions;\n\ttype->regions = new_array;\n\ttype->max <<= 1;\n\n\t/* Free old array. We needn't free it if the array is the static one */\n\tif (*in_slab)\n\t\tkfree(old_array);\n\telse if (old_array != memblock_memory_init_regions &&\n\t\t old_array != memblock_reserved_init_regions)\n\t\tmemblock_free(__pa(old_array), old_alloc_size);\n\n\t/*\n\t * Reserve the new array if that comes from the memblock.  Otherwise, we\n\t * needn't do it\n\t */\n\tif (!use_slab)\n\t\tBUG_ON(memblock_reserve(addr, new_alloc_size));\n\n\t/* Update slab flag */\n\t*in_slab = use_slab;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_cap_size",
          "args": [
            "base",
            "&size"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_cap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "134-137",
          "snippet": "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_isolate_range(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\t\tint *start_rgn, int *end_rgn)\n{\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx;\n\tstruct memblock_region *rgn;\n\n\t*start_rgn = *end_rgn = 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* we'll create at most two more regions */\n\twhile (type->cnt + 2 > type->max)\n\t\tif (memblock_double_array(type, base, size) < 0)\n\t\t\treturn -ENOMEM;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\n\t\tif (rbase < base) {\n\t\t\t/*\n\t\t\t * @rgn intersects from below.  Split and continue\n\t\t\t * to process the next region - the new top half.\n\t\t\t */\n\t\t\trgn->base = base;\n\t\t\trgn->size -= base - rbase;\n\t\t\ttype->total_size -= base - rbase;\n\t\t\tmemblock_insert_region(type, idx, rbase, base - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else if (rend > end) {\n\t\t\t/*\n\t\t\t * @rgn intersects from above.  Split and redo the\n\t\t\t * current region - the new bottom half.\n\t\t\t */\n\t\t\trgn->base = end;\n\t\t\trgn->size -= end - rbase;\n\t\t\ttype->total_size -= end - rbase;\n\t\t\tmemblock_insert_region(type, idx--, rbase, end - rbase,\n\t\t\t\t\t       memblock_get_region_node(rgn),\n\t\t\t\t\t       rgn->flags);\n\t\t} else {\n\t\t\t/* @rgn is fully contained, record it */\n\t\t\tif (!*end_rgn)\n\t\t\t\t*start_rgn = idx;\n\t\t\t*end_rgn = idx + 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "692-700",
    "snippet": "int __init_memblock memblock_add(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_add: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.memory, base, size, MAX_NUMNODES, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_add_range",
          "args": [
            "&memblock.memory",
            "base",
            "size",
            "MAX_NUMNODES",
            "0"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_add_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "577-661",
          "snippet": "int __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"memblock_add: [%pa-%pa] %pF\\n\"",
            "&base",
            "&end",
            "(void *)_RET_IP_"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_add(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_add: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.memory, base, size, MAX_NUMNODES, 0);\n}"
  },
  {
    "function_name": "memblock_add_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "675-679",
    "snippet": "int __init_memblock memblock_add_node(phys_addr_t base, phys_addr_t size,\n\t\t\t\t       int nid)\n{\n\treturn memblock_add_range(&memblock.memory, base, size, nid, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_add_range",
          "args": [
            "&memblock.memory",
            "base",
            "size",
            "nid",
            "0"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_add_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "577-661",
          "snippet": "int __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_add_node(phys_addr_t base, phys_addr_t size,\n\t\t\t\t       int nid)\n{\n\treturn memblock_add_range(&memblock.memory, base, size, nid, 0);\n}"
  },
  {
    "function_name": "memblock_add_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "577-661",
    "snippet": "int __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_merge_regions",
          "args": [
            "type"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_merge_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "506-529",
          "snippet": "static void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_double_array",
          "args": [
            "type",
            "obase",
            "size"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_double_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "398-498",
          "snippet": "static int __init_memblock memblock_double_array(struct memblock_type *type,\n\t\t\t\t\t\tphys_addr_t new_area_start,\n\t\t\t\t\t\tphys_addr_t new_area_size)\n{\n\tstruct memblock_region *new_array, *old_array;\n\tphys_addr_t old_alloc_size, new_alloc_size;\n\tphys_addr_t old_size, new_size, addr, new_end;\n\tint use_slab = slab_is_available();\n\tint *in_slab;\n\n\t/* We don't allow resizing until we know about the reserved regions\n\t * of memory that aren't suitable for allocation\n\t */\n\tif (!memblock_can_resize)\n\t\treturn -1;\n\n\t/* Calculate new doubled size */\n\told_size = type->max * sizeof(struct memblock_region);\n\tnew_size = old_size << 1;\n\t/*\n\t * We need to allocated new one align to PAGE_SIZE,\n\t *   so we can free them completely later.\n\t */\n\told_alloc_size = PAGE_ALIGN(old_size);\n\tnew_alloc_size = PAGE_ALIGN(new_size);\n\n\t/* Retrieve the slab flag */\n\tif (type == &memblock.memory)\n\t\tin_slab = &memblock_memory_in_slab;\n\telse\n\t\tin_slab = &memblock_reserved_in_slab;\n\n\t/* Try to find some space for it.\n\t *\n\t * WARNING: We assume that either slab_is_available() and we use it or\n\t * we use MEMBLOCK for allocations. That means that this is unsafe to\n\t * use when bootmem is currently active (unless bootmem itself is\n\t * implemented on top of MEMBLOCK which isn't the case yet)\n\t *\n\t * This should however not be an issue for now, as we currently only\n\t * call into MEMBLOCK while it's still active, or much later when slab\n\t * is active for memory hotplug operations\n\t */\n\tif (use_slab) {\n\t\tnew_array = kmalloc(new_size, GFP_KERNEL);\n\t\taddr = new_array ? __pa(new_array) : 0;\n\t} else {\n\t\t/* only exclude range when trying to double reserved.regions */\n\t\tif (type != &memblock.reserved)\n\t\t\tnew_area_start = new_area_size = 0;\n\n\t\taddr = memblock_find_in_range(new_area_start + new_area_size,\n\t\t\t\t\t\tmemblock.current_limit,\n\t\t\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\t\tif (!addr && new_area_size)\n\t\t\taddr = memblock_find_in_range(0,\n\t\t\t\tmin(new_area_start, memblock.current_limit),\n\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\n\t\tnew_array = addr ? __va(addr) : NULL;\n\t}\n\tif (!addr) {\n\t\tpr_err(\"memblock: Failed to double %s array from %ld to %ld entries !\\n\",\n\t\t       type->name, type->max, type->max * 2);\n\t\treturn -1;\n\t}\n\n\tnew_end = addr + new_size - 1;\n\tmemblock_dbg(\"memblock: %s is doubled to %ld at [%pa-%pa]\",\n\t\t\ttype->name, type->max * 2, &addr, &new_end);\n\n\t/*\n\t * Found space, we now need to move the array over before we add the\n\t * reserved region since it may be our reserved array itself that is\n\t * full.\n\t */\n\tmemcpy(new_array, type->regions, old_size);\n\tmemset(new_array + type->max, 0, old_size);\n\told_array = type->regions;\n\ttype->regions = new_array;\n\ttype->max <<= 1;\n\n\t/* Free old array. We needn't free it if the array is the static one */\n\tif (*in_slab)\n\t\tkfree(old_array);\n\telse if (old_array != memblock_memory_init_regions &&\n\t\t old_array != memblock_reserved_init_regions)\n\t\tmemblock_free(__pa(old_array), old_alloc_size);\n\n\t/*\n\t * Reserve the new array if that comes from the memblock.  Otherwise, we\n\t * needn't do it\n\t */\n\tif (!use_slab)\n\t\tBUG_ON(memblock_reserve(addr, new_alloc_size));\n\n\t/* Update slab flag */\n\t*in_slab = use_slab;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS]",
            "static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS]",
            "static int memblock_can_resize",
            "static int memblock_memory_in_slab",
            "static int memblock_reserved_in_slab",
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic int memblock_can_resize;\nstatic int memblock_memory_in_slab;\nstatic int memblock_reserved_in_slab;\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_double_array(struct memblock_type *type,\n\t\t\t\t\t\tphys_addr_t new_area_start,\n\t\t\t\t\t\tphys_addr_t new_area_size)\n{\n\tstruct memblock_region *new_array, *old_array;\n\tphys_addr_t old_alloc_size, new_alloc_size;\n\tphys_addr_t old_size, new_size, addr, new_end;\n\tint use_slab = slab_is_available();\n\tint *in_slab;\n\n\t/* We don't allow resizing until we know about the reserved regions\n\t * of memory that aren't suitable for allocation\n\t */\n\tif (!memblock_can_resize)\n\t\treturn -1;\n\n\t/* Calculate new doubled size */\n\told_size = type->max * sizeof(struct memblock_region);\n\tnew_size = old_size << 1;\n\t/*\n\t * We need to allocated new one align to PAGE_SIZE,\n\t *   so we can free them completely later.\n\t */\n\told_alloc_size = PAGE_ALIGN(old_size);\n\tnew_alloc_size = PAGE_ALIGN(new_size);\n\n\t/* Retrieve the slab flag */\n\tif (type == &memblock.memory)\n\t\tin_slab = &memblock_memory_in_slab;\n\telse\n\t\tin_slab = &memblock_reserved_in_slab;\n\n\t/* Try to find some space for it.\n\t *\n\t * WARNING: We assume that either slab_is_available() and we use it or\n\t * we use MEMBLOCK for allocations. That means that this is unsafe to\n\t * use when bootmem is currently active (unless bootmem itself is\n\t * implemented on top of MEMBLOCK which isn't the case yet)\n\t *\n\t * This should however not be an issue for now, as we currently only\n\t * call into MEMBLOCK while it's still active, or much later when slab\n\t * is active for memory hotplug operations\n\t */\n\tif (use_slab) {\n\t\tnew_array = kmalloc(new_size, GFP_KERNEL);\n\t\taddr = new_array ? __pa(new_array) : 0;\n\t} else {\n\t\t/* only exclude range when trying to double reserved.regions */\n\t\tif (type != &memblock.reserved)\n\t\t\tnew_area_start = new_area_size = 0;\n\n\t\taddr = memblock_find_in_range(new_area_start + new_area_size,\n\t\t\t\t\t\tmemblock.current_limit,\n\t\t\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\t\tif (!addr && new_area_size)\n\t\t\taddr = memblock_find_in_range(0,\n\t\t\t\tmin(new_area_start, memblock.current_limit),\n\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\n\t\tnew_array = addr ? __va(addr) : NULL;\n\t}\n\tif (!addr) {\n\t\tpr_err(\"memblock: Failed to double %s array from %ld to %ld entries !\\n\",\n\t\t       type->name, type->max, type->max * 2);\n\t\treturn -1;\n\t}\n\n\tnew_end = addr + new_size - 1;\n\tmemblock_dbg(\"memblock: %s is doubled to %ld at [%pa-%pa]\",\n\t\t\ttype->name, type->max * 2, &addr, &new_end);\n\n\t/*\n\t * Found space, we now need to move the array over before we add the\n\t * reserved region since it may be our reserved array itself that is\n\t * full.\n\t */\n\tmemcpy(new_array, type->regions, old_size);\n\tmemset(new_array + type->max, 0, old_size);\n\told_array = type->regions;\n\ttype->regions = new_array;\n\ttype->max <<= 1;\n\n\t/* Free old array. We needn't free it if the array is the static one */\n\tif (*in_slab)\n\t\tkfree(old_array);\n\telse if (old_array != memblock_memory_init_regions &&\n\t\t old_array != memblock_reserved_init_regions)\n\t\tmemblock_free(__pa(old_array), old_alloc_size);\n\n\t/*\n\t * Reserve the new array if that comes from the memblock.  Otherwise, we\n\t * needn't do it\n\t */\n\tif (!use_slab)\n\t\tBUG_ON(memblock_reserve(addr, new_alloc_size));\n\n\t/* Update slab flag */\n\t*in_slab = use_slab;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_insert_region",
          "args": [
            "type",
            "idx",
            "base",
            "end - base",
            "nid",
            "flags"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_insert_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "543-559",
          "snippet": "static void __init_memblock memblock_insert_region(struct memblock_type *type,\n\t\t\t\t\t\t   int idx, phys_addr_t base,\n\t\t\t\t\t\t   phys_addr_t size,\n\t\t\t\t\t\t   int nid,\n\t\t\t\t\t\t   enum memblock_flags flags)\n{\n\tstruct memblock_region *rgn = &type->regions[idx];\n\n\tBUG_ON(type->cnt >= type->max);\n\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));\n\trgn->base = base;\n\trgn->size = size;\n\trgn->flags = flags;\n\tmemblock_set_region_node(rgn, nid);\n\ttype->cnt++;\n\ttype->total_size += size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_insert_region(struct memblock_type *type,\n\t\t\t\t\t\t   int idx, phys_addr_t base,\n\t\t\t\t\t\t   phys_addr_t size,\n\t\t\t\t\t\t   int nid,\n\t\t\t\t\t\t   enum memblock_flags flags)\n{\n\tstruct memblock_region *rgn = &type->regions[idx];\n\n\tBUG_ON(type->cnt >= type->max);\n\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));\n\trgn->base = base;\n\trgn->size = size;\n\trgn->flags = flags;\n\tmemblock_set_region_node(rgn, nid);\n\ttype->cnt++;\n\ttype->total_size += size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rend",
            "end"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "flags != rgn->flags"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nid != memblock_get_region_node(rgn)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "rgn"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock_type",
          "args": [
            "idx",
            "type",
            "rgn"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_set_region_node",
          "args": [
            "&type->regions[0]",
            "nid"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "type->cnt != 1 || type->total_size"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_cap_size",
          "args": [
            "base",
            "&size"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_cap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "134-137",
          "snippet": "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_add_range(struct memblock_type *type,\n\t\t\t\tphys_addr_t base, phys_addr_t size,\n\t\t\t\tint nid, enum memblock_flags flags)\n{\n\tbool insert = false;\n\tphys_addr_t obase = base;\n\tphys_addr_t end = base + memblock_cap_size(base, &size);\n\tint idx, nr_new;\n\tstruct memblock_region *rgn;\n\n\tif (!size)\n\t\treturn 0;\n\n\t/* special case for empty array */\n\tif (type->regions[0].size == 0) {\n\t\tWARN_ON(type->cnt != 1 || type->total_size);\n\t\ttype->regions[0].base = base;\n\t\ttype->regions[0].size = size;\n\t\ttype->regions[0].flags = flags;\n\t\tmemblock_set_region_node(&type->regions[0], nid);\n\t\ttype->total_size = size;\n\t\treturn 0;\n\t}\nrepeat:\n\t/*\n\t * The following is executed twice.  Once with %false @insert and\n\t * then with %true.  The first counts the number of regions needed\n\t * to accommodate the new area.  The second actually inserts them.\n\t */\n\tbase = obase;\n\tnr_new = 0;\n\n\tfor_each_memblock_type(idx, type, rgn) {\n\t\tphys_addr_t rbase = rgn->base;\n\t\tphys_addr_t rend = rbase + rgn->size;\n\n\t\tif (rbase >= end)\n\t\t\tbreak;\n\t\tif (rend <= base)\n\t\t\tcontinue;\n\t\t/*\n\t\t * @rgn overlaps.  If it separates the lower part of new\n\t\t * area, insert that portion.\n\t\t */\n\t\tif (rbase > base) {\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\t\t\tWARN_ON(nid != memblock_get_region_node(rgn));\n#endif\n\t\t\tWARN_ON(flags != rgn->flags);\n\t\t\tnr_new++;\n\t\t\tif (insert)\n\t\t\t\tmemblock_insert_region(type, idx++, base,\n\t\t\t\t\t\t       rbase - base, nid,\n\t\t\t\t\t\t       flags);\n\t\t}\n\t\t/* area below @rend is dealt with, forget about it */\n\t\tbase = min(rend, end);\n\t}\n\n\t/* insert the remaining portion */\n\tif (base < end) {\n\t\tnr_new++;\n\t\tif (insert)\n\t\t\tmemblock_insert_region(type, idx, base, end - base,\n\t\t\t\t\t       nid, flags);\n\t}\n\n\tif (!nr_new)\n\t\treturn 0;\n\n\t/*\n\t * If this was the first round, resize array and repeat for actual\n\t * insertions; otherwise, merge and return.\n\t */\n\tif (!insert) {\n\t\twhile (type->cnt + nr_new > type->max)\n\t\t\tif (memblock_double_array(type, obase, size) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\tinsert = true;\n\t\tgoto repeat;\n\t} else {\n\t\tmemblock_merge_regions(type);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "memblock_insert_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "543-559",
    "snippet": "static void __init_memblock memblock_insert_region(struct memblock_type *type,\n\t\t\t\t\t\t   int idx, phys_addr_t base,\n\t\t\t\t\t\t   phys_addr_t size,\n\t\t\t\t\t\t   int nid,\n\t\t\t\t\t\t   enum memblock_flags flags)\n{\n\tstruct memblock_region *rgn = &type->regions[idx];\n\n\tBUG_ON(type->cnt >= type->max);\n\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));\n\trgn->base = base;\n\trgn->size = size;\n\trgn->flags = flags;\n\tmemblock_set_region_node(rgn, nid);\n\ttype->cnt++;\n\ttype->total_size += size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_set_region_node",
          "args": [
            "rgn",
            "nid"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rgn + 1",
            "rgn",
            "(type->cnt - idx) * sizeof(*rgn)"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type->cnt >= type->max"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_insert_region(struct memblock_type *type,\n\t\t\t\t\t\t   int idx, phys_addr_t base,\n\t\t\t\t\t\t   phys_addr_t size,\n\t\t\t\t\t\t   int nid,\n\t\t\t\t\t\t   enum memblock_flags flags)\n{\n\tstruct memblock_region *rgn = &type->regions[idx];\n\n\tBUG_ON(type->cnt >= type->max);\n\tmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));\n\trgn->base = base;\n\trgn->size = size;\n\trgn->flags = flags;\n\tmemblock_set_region_node(rgn, nid);\n\ttype->cnt++;\n\ttype->total_size += size;\n}"
  },
  {
    "function_name": "memblock_merge_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "506-529",
    "snippet": "static void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "next",
            "next + 1",
            "(type->cnt - (i + 2)) * sizeof(*next)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "this->base + this->size > next->base"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "next"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_get_region_node",
          "args": [
            "this"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_merge_regions(struct memblock_type *type)\n{\n\tint i = 0;\n\n\t/* cnt never goes below 1 */\n\twhile (i < type->cnt - 1) {\n\t\tstruct memblock_region *this = &type->regions[i];\n\t\tstruct memblock_region *next = &type->regions[i + 1];\n\n\t\tif (this->base + this->size != next->base ||\n\t\t    memblock_get_region_node(this) !=\n\t\t    memblock_get_region_node(next) ||\n\t\t    this->flags != next->flags) {\n\t\t\tBUG_ON(this->base + this->size > next->base);\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis->size += next->size;\n\t\t/* move forward from next + 1, index of which is i + 2 */\n\t\tmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\n\t\ttype->cnt--;\n\t}\n}"
  },
  {
    "function_name": "memblock_double_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "398-498",
    "snippet": "static int __init_memblock memblock_double_array(struct memblock_type *type,\n\t\t\t\t\t\tphys_addr_t new_area_start,\n\t\t\t\t\t\tphys_addr_t new_area_size)\n{\n\tstruct memblock_region *new_array, *old_array;\n\tphys_addr_t old_alloc_size, new_alloc_size;\n\tphys_addr_t old_size, new_size, addr, new_end;\n\tint use_slab = slab_is_available();\n\tint *in_slab;\n\n\t/* We don't allow resizing until we know about the reserved regions\n\t * of memory that aren't suitable for allocation\n\t */\n\tif (!memblock_can_resize)\n\t\treturn -1;\n\n\t/* Calculate new doubled size */\n\told_size = type->max * sizeof(struct memblock_region);\n\tnew_size = old_size << 1;\n\t/*\n\t * We need to allocated new one align to PAGE_SIZE,\n\t *   so we can free them completely later.\n\t */\n\told_alloc_size = PAGE_ALIGN(old_size);\n\tnew_alloc_size = PAGE_ALIGN(new_size);\n\n\t/* Retrieve the slab flag */\n\tif (type == &memblock.memory)\n\t\tin_slab = &memblock_memory_in_slab;\n\telse\n\t\tin_slab = &memblock_reserved_in_slab;\n\n\t/* Try to find some space for it.\n\t *\n\t * WARNING: We assume that either slab_is_available() and we use it or\n\t * we use MEMBLOCK for allocations. That means that this is unsafe to\n\t * use when bootmem is currently active (unless bootmem itself is\n\t * implemented on top of MEMBLOCK which isn't the case yet)\n\t *\n\t * This should however not be an issue for now, as we currently only\n\t * call into MEMBLOCK while it's still active, or much later when slab\n\t * is active for memory hotplug operations\n\t */\n\tif (use_slab) {\n\t\tnew_array = kmalloc(new_size, GFP_KERNEL);\n\t\taddr = new_array ? __pa(new_array) : 0;\n\t} else {\n\t\t/* only exclude range when trying to double reserved.regions */\n\t\tif (type != &memblock.reserved)\n\t\t\tnew_area_start = new_area_size = 0;\n\n\t\taddr = memblock_find_in_range(new_area_start + new_area_size,\n\t\t\t\t\t\tmemblock.current_limit,\n\t\t\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\t\tif (!addr && new_area_size)\n\t\t\taddr = memblock_find_in_range(0,\n\t\t\t\tmin(new_area_start, memblock.current_limit),\n\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\n\t\tnew_array = addr ? __va(addr) : NULL;\n\t}\n\tif (!addr) {\n\t\tpr_err(\"memblock: Failed to double %s array from %ld to %ld entries !\\n\",\n\t\t       type->name, type->max, type->max * 2);\n\t\treturn -1;\n\t}\n\n\tnew_end = addr + new_size - 1;\n\tmemblock_dbg(\"memblock: %s is doubled to %ld at [%pa-%pa]\",\n\t\t\ttype->name, type->max * 2, &addr, &new_end);\n\n\t/*\n\t * Found space, we now need to move the array over before we add the\n\t * reserved region since it may be our reserved array itself that is\n\t * full.\n\t */\n\tmemcpy(new_array, type->regions, old_size);\n\tmemset(new_array + type->max, 0, old_size);\n\told_array = type->regions;\n\ttype->regions = new_array;\n\ttype->max <<= 1;\n\n\t/* Free old array. We needn't free it if the array is the static one */\n\tif (*in_slab)\n\t\tkfree(old_array);\n\telse if (old_array != memblock_memory_init_regions &&\n\t\t old_array != memblock_reserved_init_regions)\n\t\tmemblock_free(__pa(old_array), old_alloc_size);\n\n\t/*\n\t * Reserve the new array if that comes from the memblock.  Otherwise, we\n\t * needn't do it\n\t */\n\tif (!use_slab)\n\t\tBUG_ON(memblock_reserve(addr, new_alloc_size));\n\n\t/* Update slab flag */\n\t*in_slab = use_slab;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS]",
      "static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS]",
      "static int memblock_can_resize",
      "static int memblock_memory_in_slab",
      "static int memblock_reserved_in_slab",
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "memblock_reserve(addr, new_alloc_size)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "addr",
            "new_alloc_size"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "815-823",
          "snippet": "int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_free",
          "args": [
            "__pa(old_array)",
            "old_alloc_size"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1566-1581",
          "snippet": "void __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "old_array"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old_array"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_array + type->max",
            "0",
            "old_size"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_array",
            "type->regions",
            "old_size"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_dbg",
          "args": [
            "\"memblock: %s is doubled to %ld at [%pa-%pa]\"",
            "type->name",
            "type->max * 2",
            "&addr",
            "&new_end"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"memblock: Failed to double %s array from %ld to %ld entries !\\n\"",
            "type->name",
            "type->max",
            "type->max * 2"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "addr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_find_in_range",
          "args": [
            "0",
            "min(new_area_start, memblock.current_limit)",
            "new_alloc_size",
            "PAGE_SIZE"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_find_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "320-339",
          "snippet": "phys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, phys_addr_t size,\n\t\t\t\t\tphys_addr_t align)\n{\n\tphys_addr_t ret;\n\tenum memblock_flags flags = choose_memblock_flags();\n\nagain:\n\tret = memblock_find_in_range_node(size, align, start, end,\n\t\t\t\t\t    NUMA_NO_NODE, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nphys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, phys_addr_t size,\n\t\t\t\t\tphys_addr_t align)\n{\n\tphys_addr_t ret;\n\tenum memblock_flags flags = choose_memblock_flags();\n\nagain:\n\tret = memblock_find_in_range_node(size, align, start, end,\n\t\t\t\t\t    NUMA_NO_NODE, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "new_area_start",
            "memblock.current_limit"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "new_size",
            "GFP_KERNEL"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "new_size"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "old_size"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "slab_is_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "930-933",
          "snippet": "bool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum slab_state slab_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\n\nbool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic int memblock_can_resize;\nstatic int memblock_memory_in_slab;\nstatic int memblock_reserved_in_slab;\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic int __init_memblock memblock_double_array(struct memblock_type *type,\n\t\t\t\t\t\tphys_addr_t new_area_start,\n\t\t\t\t\t\tphys_addr_t new_area_size)\n{\n\tstruct memblock_region *new_array, *old_array;\n\tphys_addr_t old_alloc_size, new_alloc_size;\n\tphys_addr_t old_size, new_size, addr, new_end;\n\tint use_slab = slab_is_available();\n\tint *in_slab;\n\n\t/* We don't allow resizing until we know about the reserved regions\n\t * of memory that aren't suitable for allocation\n\t */\n\tif (!memblock_can_resize)\n\t\treturn -1;\n\n\t/* Calculate new doubled size */\n\told_size = type->max * sizeof(struct memblock_region);\n\tnew_size = old_size << 1;\n\t/*\n\t * We need to allocated new one align to PAGE_SIZE,\n\t *   so we can free them completely later.\n\t */\n\told_alloc_size = PAGE_ALIGN(old_size);\n\tnew_alloc_size = PAGE_ALIGN(new_size);\n\n\t/* Retrieve the slab flag */\n\tif (type == &memblock.memory)\n\t\tin_slab = &memblock_memory_in_slab;\n\telse\n\t\tin_slab = &memblock_reserved_in_slab;\n\n\t/* Try to find some space for it.\n\t *\n\t * WARNING: We assume that either slab_is_available() and we use it or\n\t * we use MEMBLOCK for allocations. That means that this is unsafe to\n\t * use when bootmem is currently active (unless bootmem itself is\n\t * implemented on top of MEMBLOCK which isn't the case yet)\n\t *\n\t * This should however not be an issue for now, as we currently only\n\t * call into MEMBLOCK while it's still active, or much later when slab\n\t * is active for memory hotplug operations\n\t */\n\tif (use_slab) {\n\t\tnew_array = kmalloc(new_size, GFP_KERNEL);\n\t\taddr = new_array ? __pa(new_array) : 0;\n\t} else {\n\t\t/* only exclude range when trying to double reserved.regions */\n\t\tif (type != &memblock.reserved)\n\t\t\tnew_area_start = new_area_size = 0;\n\n\t\taddr = memblock_find_in_range(new_area_start + new_area_size,\n\t\t\t\t\t\tmemblock.current_limit,\n\t\t\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\t\tif (!addr && new_area_size)\n\t\t\taddr = memblock_find_in_range(0,\n\t\t\t\tmin(new_area_start, memblock.current_limit),\n\t\t\t\tnew_alloc_size, PAGE_SIZE);\n\n\t\tnew_array = addr ? __va(addr) : NULL;\n\t}\n\tif (!addr) {\n\t\tpr_err(\"memblock: Failed to double %s array from %ld to %ld entries !\\n\",\n\t\t       type->name, type->max, type->max * 2);\n\t\treturn -1;\n\t}\n\n\tnew_end = addr + new_size - 1;\n\tmemblock_dbg(\"memblock: %s is doubled to %ld at [%pa-%pa]\",\n\t\t\ttype->name, type->max * 2, &addr, &new_end);\n\n\t/*\n\t * Found space, we now need to move the array over before we add the\n\t * reserved region since it may be our reserved array itself that is\n\t * full.\n\t */\n\tmemcpy(new_array, type->regions, old_size);\n\tmemset(new_array + type->max, 0, old_size);\n\told_array = type->regions;\n\ttype->regions = new_array;\n\ttype->max <<= 1;\n\n\t/* Free old array. We needn't free it if the array is the static one */\n\tif (*in_slab)\n\t\tkfree(old_array);\n\telse if (old_array != memblock_memory_init_regions &&\n\t\t old_array != memblock_reserved_init_regions)\n\t\tmemblock_free(__pa(old_array), old_alloc_size);\n\n\t/*\n\t * Reserve the new array if that comes from the memblock.  Otherwise, we\n\t * needn't do it\n\t */\n\tif (!use_slab)\n\t\tBUG_ON(memblock_reserve(addr, new_alloc_size));\n\n\t/* Update slab flag */\n\t*in_slab = use_slab;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "363-380",
    "snippet": "void __init memblock_discard(void)\n{\n\tphys_addr_t addr, size;\n\n\tif (memblock.reserved.regions != memblock_reserved_init_regions) {\n\t\taddr = __pa(memblock.reserved.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.reserved.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n\n\tif (memblock.memory.regions != memblock_memory_init_regions) {\n\t\taddr = __pa(memblock.memory.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.memory.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS]",
      "static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__memblock_free_late",
          "args": [
            "addr",
            "size"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_free_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1566-1581",
          "snippet": "void __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t cursor, end;\n\n\tend = base + size - 1;\n\tmemblock_dbg(\"%s: [%pa-%pa] %pF\\n\",\n\t\t     __func__, &base, &end, (void *)_RET_IP_);\n\tkmemleak_free_part_phys(base, size);\n\tcursor = PFN_UP(base);\n\tend = PFN_DOWN(base + size);\n\n\tfor (; cursor < end; cursor++) {\n\t\tmemblock_free_pages(pfn_to_page(cursor), cursor, 0);\n\t\ttotalram_pages++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct memblock_region) *\n\t\t\t\t  memblock.memory.max"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "memblock.memory.regions"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct memblock_region) *\n\t\t\t\t  memblock.reserved.max"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS];\n\nvoid __init memblock_discard(void)\n{\n\tphys_addr_t addr, size;\n\n\tif (memblock.reserved.regions != memblock_reserved_init_regions) {\n\t\taddr = __pa(memblock.reserved.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.reserved.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n\n\tif (memblock.memory.regions != memblock_memory_init_regions) {\n\t\taddr = __pa(memblock.memory.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.memory.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n}"
  },
  {
    "function_name": "memblock_remove_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "341-357",
    "snippet": "static void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_set_region_node",
          "args": [
            "&type->regions[0]",
            "MAX_NUMNODES"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "type->total_size != 0"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&type->regions[r]",
            "&type->regions[r + 1]",
            "(type->cnt - (r + 1)) * sizeof(type->regions[r])"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\n{\n\ttype->total_size -= type->regions[r].size;\n\tmemmove(&type->regions[r], &type->regions[r + 1],\n\t\t(type->cnt - (r + 1)) * sizeof(type->regions[r]));\n\ttype->cnt--;\n\n\t/* Special case for empty arrays */\n\tif (type->cnt == 0) {\n\t\tWARN_ON(type->total_size != 0);\n\t\ttype->cnt = 1;\n\t\ttype->regions[0].base = 0;\n\t\ttype->regions[0].size = 0;\n\t\ttype->regions[0].flags = 0;\n\t\tmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\n\t}\n}"
  },
  {
    "function_name": "memblock_find_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "320-339",
    "snippet": "phys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, phys_addr_t size,\n\t\t\t\t\tphys_addr_t align)\n{\n\tphys_addr_t ret;\n\tenum memblock_flags flags = choose_memblock_flags();\n\nagain:\n\tret = memblock_find_in_range_node(size, align, start, end,\n\t\t\t\t\t    NUMA_NO_NODE, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not allocate %pap bytes of mirrored memory\\n\"",
            "&size"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_find_in_range_node",
          "args": [
            "size",
            "align",
            "start",
            "end",
            "NUMA_NO_NODE",
            "flags"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_find_in_range_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "257-305",
          "snippet": "phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nphys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "choose_memblock_flags",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nphys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, phys_addr_t size,\n\t\t\t\t\tphys_addr_t align)\n{\n\tphys_addr_t ret;\n\tenum memblock_flags flags = choose_memblock_flags();\n\nagain:\n\tret = memblock_find_in_range_node(size, align, start, end,\n\t\t\t\t\t    NUMA_NO_NODE, flags);\n\n\tif (!ret && (flags & MEMBLOCK_MIRROR)) {\n\t\tpr_warn(\"Could not allocate %pap bytes of mirrored memory\\n\",\n\t\t\t&size);\n\t\tflags &= ~MEMBLOCK_MIRROR;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "memblock_find_in_range_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "257-305",
    "snippet": "phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__memblock_find_range_top_down",
          "args": [
            "start",
            "end",
            "size",
            "align",
            "nid",
            "flags"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_find_range_top_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "210-232",
          "snippet": "static phys_addr_t __init_memblock\n__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,\n\t\t\t       phys_addr_t size, phys_addr_t align, int nid,\n\t\t\t       enum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range_reverse(i, nid, flags, &this_start, &this_end,\n\t\t\t\t\tNULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tif (this_end < size)\n\t\t\tcontinue;\n\n\t\tcand = round_down(this_end - size, align);\n\t\tif (cand >= this_start)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic phys_addr_t __init_memblock\n__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,\n\t\t\t       phys_addr_t size, phys_addr_t align, int nid,\n\t\t\t       enum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range_reverse(i, nid, flags, &this_start, &this_end,\n\t\t\t\t\tNULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tif (this_end < size)\n\t\t\tcontinue;\n\n\t\tcand = round_down(this_end - size, align);\n\t\tif (cand >= this_start)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_MEMORY_HOTREMOVE)",
            "\"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MEMORY_HOTREMOVE"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__memblock_find_range_bottom_up",
          "args": [
            "bottom_up_start",
            "end",
            "size",
            "align",
            "nid",
            "flags"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__memblock_find_range_bottom_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "175-193",
          "snippet": "static phys_addr_t __init_memblock\n__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,\n\t\t\t\tphys_addr_t size, phys_addr_t align, int nid,\n\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tcand = round_up(this_start, align);\n\t\tif (cand < this_end && this_end - cand >= size)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic phys_addr_t __init_memblock\n__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,\n\t\t\t\tphys_addr_t size, phys_addr_t align, int nid,\n\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tcand = round_up(this_start, align);\n\t\tif (cand < this_end && this_end - cand >= size)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "kernel_end"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_bottom_up",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa_symbol",
          "args": [
            "_end"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "phys_addr_t",
            "start",
            "PAGE_SIZE"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nphys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\n\t\t\t\t\tphys_addr_t align, phys_addr_t start,\n\t\t\t\t\tphys_addr_t end, int nid,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t kernel_end, ret;\n\n\t/* pump up @end */\n\tif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\n\t\tend = memblock.current_limit;\n\n\t/* avoid allocating the first page */\n\tstart = max_t(phys_addr_t, start, PAGE_SIZE);\n\tend = max(start, end);\n\tkernel_end = __pa_symbol(_end);\n\n\t/*\n\t * try bottom-up allocation only when bottom-up mode\n\t * is set and @end is above the kernel image.\n\t */\n\tif (memblock_bottom_up() && end > kernel_end) {\n\t\tphys_addr_t bottom_up_start;\n\n\t\t/* make sure we will allocate above the kernel */\n\t\tbottom_up_start = max(start, kernel_end);\n\n\t\t/* ok, try bottom-up allocation first */\n\t\tret = __memblock_find_range_bottom_up(bottom_up_start, end,\n\t\t\t\t\t\t      size, align, nid, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * we always limit bottom-up allocation above the kernel,\n\t\t * but top-down allocation doesn't have the limit, so\n\t\t * retrying top-down allocation may succeed when bottom-up\n\t\t * allocation failed.\n\t\t *\n\t\t * bottom-up allocation is expected to be fail very rarely,\n\t\t * so we use WARN_ONCE() here to see the stack trace if\n\t\t * fail happens.\n\t\t */\n\t\tWARN_ONCE(IS_ENABLED(CONFIG_MEMORY_HOTREMOVE),\n\t\t\t  \"memblock: bottom-up allocation failed, memory hotremove may be affected\\n\");\n\t}\n\n\treturn __memblock_find_range_top_down(start, end, size, align, nid,\n\t\t\t\t\t      flags);\n}"
  },
  {
    "function_name": "__memblock_find_range_top_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "210-232",
    "snippet": "static phys_addr_t __init_memblock\n__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,\n\t\t\t       phys_addr_t size, phys_addr_t align, int nid,\n\t\t\t       enum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range_reverse(i, nid, flags, &this_start, &this_end,\n\t\t\t\t\tNULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tif (this_end < size)\n\t\t\tcontinue;\n\n\t\tcand = round_down(this_end - size, align);\n\t\tif (cand >= this_start)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "this_end - size",
            "align"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "this_end",
            "start",
            "end"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "this_start",
            "start",
            "end"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range_reverse",
          "args": [
            "i",
            "nid",
            "flags",
            "&this_start",
            "&this_end",
            "NULL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic phys_addr_t __init_memblock\n__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,\n\t\t\t       phys_addr_t size, phys_addr_t align, int nid,\n\t\t\t       enum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range_reverse(i, nid, flags, &this_start, &this_end,\n\t\t\t\t\tNULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tif (this_end < size)\n\t\t\tcontinue;\n\n\t\tcand = round_down(this_end - size, align);\n\t\tif (cand >= this_start)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__memblock_find_range_bottom_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "175-193",
    "snippet": "static phys_addr_t __init_memblock\n__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,\n\t\t\t\tphys_addr_t size, phys_addr_t align, int nid,\n\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tcand = round_up(this_start, align);\n\t\tif (cand < this_end && this_end - cand >= size)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "this_start",
            "align"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "this_end",
            "start",
            "end"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "this_start",
            "start",
            "end"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "nid",
            "flags",
            "&this_start",
            "&this_end",
            "NULL"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic phys_addr_t __init_memblock\n__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,\n\t\t\t\tphys_addr_t size, phys_addr_t align, int nid,\n\t\t\t\tenum memblock_flags flags)\n{\n\tphys_addr_t this_start, this_end, cand;\n\tu64 i;\n\n\tfor_each_free_mem_range(i, nid, flags, &this_start, &this_end, NULL) {\n\t\tthis_start = clamp(this_start, start, end);\n\t\tthis_end = clamp(this_end, start, end);\n\n\t\tcand = round_up(this_start, align);\n\t\tif (cand < this_end && this_end - cand >= size)\n\t\t\treturn cand;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memblock_overlaps_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "148-158",
    "snippet": "bool __init_memblock memblock_overlaps_region(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < type->cnt; i++)\n\t\tif (memblock_addrs_overlap(base, size, type->regions[i].base,\n\t\t\t\t\t   type->regions[i].size))\n\t\t\tbreak;\n\treturn i < type->cnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_addrs_overlap",
          "args": [
            "base",
            "size",
            "type->regions[i].base",
            "type->regions[i].size"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_addrs_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "142-146",
          "snippet": "static unsigned long __init_memblock memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1,\n\t\t\t\t       phys_addr_t base2, phys_addr_t size2)\n{\n\treturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic unsigned long __init_memblock memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1,\n\t\t\t\t       phys_addr_t base2, phys_addr_t size2)\n{\n\treturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_overlaps_region(struct memblock_type *type,\n\t\t\t\t\tphys_addr_t base, phys_addr_t size)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < type->cnt; i++)\n\t\tif (memblock_addrs_overlap(base, size, type->regions[i].base,\n\t\t\t\t\t   type->regions[i].size))\n\t\t\tbreak;\n\treturn i < type->cnt;\n}"
  },
  {
    "function_name": "memblock_addrs_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "142-146",
    "snippet": "static unsigned long __init_memblock memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1,\n\t\t\t\t       phys_addr_t base2, phys_addr_t size2)\n{\n\treturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum memblock_flags __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "phys_addr_t __init_memblock",
      "void __init_memblock"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nstatic unsigned long __init_memblock memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1,\n\t\t\t\t       phys_addr_t base2, phys_addr_t size2)\n{\n\treturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));\n}"
  },
  {
    "function_name": "memblock_cap_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
    "lines": "134-137",
    "snippet": "static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/io.h>",
      "#include <asm/sections.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pfn.h>",
      "#include <linux/poison.h>",
      "#include <linux/bitops.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*size",
            "PHYS_ADDR_MAX - base"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\n{\n\treturn *size = min(*size, PHYS_ADDR_MAX - base);\n}"
  }
]