[
  {
    "function_name": "page_mapped_in_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
    "lines": "258-277",
    "snippet": "int page_mapped_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.flags = PVMW_SYNC,\n\t};\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\tif (unlikely(end < vma->vm_start || start >= vma->vm_end))\n\t\treturn 0;\n\tpvmw.address = max(start, vma->vm_start);\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\treturn 0;\n\tpage_vma_mapped_walk_done(&pvmw);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "page_vma_mapped_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "138-247",
          "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "vma->vm_start"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "end < vma->vm_start || start >= vma->vm_end"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vma_address",
          "args": [
            "page",
            "vma"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "336-341",
          "snippet": "static inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nint page_mapped_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.flags = PVMW_SYNC,\n\t};\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\tif (unlikely(end < vma->vm_start || start >= vma->vm_end))\n\t\treturn 0;\n\tpvmw.address = max(start, vma->vm_start);\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\treturn 0;\n\tpage_vma_mapped_walk_done(&pvmw);\n\treturn 1;\n}"
  },
  {
    "function_name": "page_vma_mapped_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
    "lines": "138-247",
    "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pvmw->ptl"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "mm",
            "pvmw->pmd"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pvmw->pte"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pvmw->ptl"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pvmw->pte"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "not_found",
          "args": [
            "pvmw"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "not_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "10-14",
          "snippet": "static inline bool not_found(struct page_vma_mapped_walk *pvmw)\n{\n\tpage_vma_mapped_walk_done(pvmw);\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic inline bool not_found(struct page_vma_mapped_walk *pvmw)\n{\n\tpage_vma_mapped_walk_done(pvmw);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "pvmw->page"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vma_address",
          "args": [
            "pvmw->page",
            "pvmw->vma"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "336-341",
          "snippet": "static inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "pvmw->page"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "pvmw->page"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_pte",
          "args": [
            "pvmw"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "check_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "81-112",
          "snippet": "static bool check_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tunsigned long pfn;\n\n\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\tswp_entry_t entry;\n\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\treturn false;\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\n\t\tif (!is_migration_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = migration_entry_to_pfn(entry);\n\t} else if (is_swap_pte(*pvmw->pte)) {\n\t\tswp_entry_t entry;\n\n\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\tif (!is_device_private_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = device_private_entry_to_pfn(entry);\n\t} else {\n\t\tif (!pte_present(*pvmw->pte))\n\t\t\treturn false;\n\n\t\tpfn = pte_pfn(*pvmw->pte);\n\t}\n\n\treturn pfn_in_hpage(pvmw->page, pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic bool check_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tunsigned long pfn;\n\n\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\tswp_entry_t entry;\n\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\treturn false;\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\n\t\tif (!is_migration_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = migration_entry_to_pfn(entry);\n\t} else if (is_swap_pte(*pvmw->pte)) {\n\t\tswp_entry_t entry;\n\n\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\tif (!is_device_private_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = device_private_entry_to_pfn(entry);\n\t} else {\n\t\tif (!pte_present(*pvmw->pte))\n\t\t\treturn false;\n\n\t\tpfn = pte_pfn(*pvmw->pte);\n\t}\n\n\treturn pfn_in_hpage(pvmw->page, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_pte",
          "args": [
            "pvmw"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "map_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "16-53",
          "snippet": "static bool map_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tpvmw->pte = pte_offset_map(pvmw->pmd, pvmw->address);\n\tif (!(pvmw->flags & PVMW_SYNC)) {\n\t\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We get here when we are trying to unmap a private\n\t\t\t * device page from the process address space. Such\n\t\t\t * page is not CPU accessible and thus is mapped as\n\t\t\t * a special swap entry, nonetheless it still does\n\t\t\t * count as a valid regular mapping for the page (and\n\t\t\t * is accounted as such in page maps count).\n\t\t\t *\n\t\t\t * So handle this special case as if it was a normal\n\t\t\t * page mapping ie lock CPU page table and returns\n\t\t\t * true.\n\t\t\t *\n\t\t\t * For more details on device private memory see HMM\n\t\t\t * (include/linux/hmm.h or mm/hmm.c).\n\t\t\t */\n\t\t\tif (is_swap_pte(*pvmw->pte)) {\n\t\t\t\tswp_entry_t entry;\n\n\t\t\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\t\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\t\treturn false;\n\t\t\t} else if (!pte_present(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tpvmw->ptl = pte_lockptr(pvmw->vma->vm_mm, pvmw->pmd);\n\tspin_lock(pvmw->ptl);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic bool map_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tpvmw->pte = pte_offset_map(pvmw->pmd, pvmw->address);\n\tif (!(pvmw->flags & PVMW_SYNC)) {\n\t\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We get here when we are trying to unmap a private\n\t\t\t * device page from the process address space. Such\n\t\t\t * page is not CPU accessible and thus is mapped as\n\t\t\t * a special swap entry, nonetheless it still does\n\t\t\t * count as a valid regular mapping for the page (and\n\t\t\t * is accounted as such in page maps count).\n\t\t\t *\n\t\t\t * So handle this special case as if it was a normal\n\t\t\t * page mapping ie lock CPU page table and returns\n\t\t\t * true.\n\t\t\t *\n\t\t\t * For more details on device private memory see HMM\n\t\t\t * (include/linux/hmm.h or mm/hmm.c).\n\t\t\t */\n\t\t\tif (is_swap_pte(*pvmw->pte)) {\n\t\t\t\tswp_entry_t entry;\n\n\t\t\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\t\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\t\treturn false;\n\t\t\t} else if (!pte_present(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tpvmw->ptl = pte_lockptr(pvmw->vma->vm_mm, pvmw->pmd);\n\tspin_lock(pvmw->ptl);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmde"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pvmw->ptl"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "pmd_to_swp_entry(*pvmw->pmd)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pmd_trans_huge(*pvmw->pmd)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pvmw->pmd"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "pmde"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "pmde"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "pvmw->address"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "pvmw->address"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_present",
          "args": [
            "*p4d"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "pvmw->address"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pgd"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "pvmw->address"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pvmw->ptl"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lockptr",
          "args": [
            "page_hstate(page)",
            "mm",
            "pvmw->pte"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "mm",
            "pvmw->address",
            "PAGE_SIZE << compound_order(page)"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageHuge(pvmw->page)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
    "lines": "81-112",
    "snippet": "static bool check_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tunsigned long pfn;\n\n\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\tswp_entry_t entry;\n\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\treturn false;\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\n\t\tif (!is_migration_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = migration_entry_to_pfn(entry);\n\t} else if (is_swap_pte(*pvmw->pte)) {\n\t\tswp_entry_t entry;\n\n\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\tif (!is_device_private_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = device_private_entry_to_pfn(entry);\n\t} else {\n\t\tif (!pte_present(*pvmw->pte))\n\t\t\treturn false;\n\n\t\tpfn = pte_pfn(*pvmw->pte);\n\t}\n\n\treturn pfn_in_hpage(pvmw->page, pfn);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_in_hpage",
          "args": [
            "pvmw->page",
            "pfn"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_in_hpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "55-61",
          "snippet": "static inline bool pfn_in_hpage(struct page *hpage, unsigned long pfn)\n{\n\tunsigned long hpage_pfn = page_to_pfn(hpage);\n\n\t/* THP can be referenced by any subpage */\n\treturn pfn >= hpage_pfn && pfn - hpage_pfn < hpage_nr_pages(hpage);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic inline bool pfn_in_hpage(struct page *hpage, unsigned long pfn)\n{\n\tunsigned long hpage_pfn = page_to_pfn(hpage);\n\n\t/* THP can be referenced by any subpage */\n\treturn pfn >= hpage_pfn && pfn - hpage_pfn < hpage_nr_pages(hpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pvmw->pte"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pvmw->pte"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_private_entry_to_pfn",
          "args": [
            "entry"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "*pvmw->pte"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "*pvmw->pte"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_pfn",
          "args": [
            "entry"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "*pvmw->pte"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "*pvmw->pte"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic bool check_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tunsigned long pfn;\n\n\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\tswp_entry_t entry;\n\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\treturn false;\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\n\t\tif (!is_migration_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = migration_entry_to_pfn(entry);\n\t} else if (is_swap_pte(*pvmw->pte)) {\n\t\tswp_entry_t entry;\n\n\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\tif (!is_device_private_entry(entry))\n\t\t\treturn false;\n\n\t\tpfn = device_private_entry_to_pfn(entry);\n\t} else {\n\t\tif (!pte_present(*pvmw->pte))\n\t\t\treturn false;\n\n\t\tpfn = pte_pfn(*pvmw->pte);\n\t}\n\n\treturn pfn_in_hpage(pvmw->page, pfn);\n}"
  },
  {
    "function_name": "pfn_in_hpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
    "lines": "55-61",
    "snippet": "static inline bool pfn_in_hpage(struct page *hpage, unsigned long pfn)\n{\n\tunsigned long hpage_pfn = page_to_pfn(hpage);\n\n\t/* THP can be referenced by any subpage */\n\treturn pfn >= hpage_pfn && pfn - hpage_pfn < hpage_nr_pages(hpage);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "hpage"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "hpage"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic inline bool pfn_in_hpage(struct page *hpage, unsigned long pfn)\n{\n\tunsigned long hpage_pfn = page_to_pfn(hpage);\n\n\t/* THP can be referenced by any subpage */\n\treturn pfn >= hpage_pfn && pfn - hpage_pfn < hpage_nr_pages(hpage);\n}"
  },
  {
    "function_name": "map_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
    "lines": "16-53",
    "snippet": "static bool map_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tpvmw->pte = pte_offset_map(pvmw->pmd, pvmw->address);\n\tif (!(pvmw->flags & PVMW_SYNC)) {\n\t\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We get here when we are trying to unmap a private\n\t\t\t * device page from the process address space. Such\n\t\t\t * page is not CPU accessible and thus is mapped as\n\t\t\t * a special swap entry, nonetheless it still does\n\t\t\t * count as a valid regular mapping for the page (and\n\t\t\t * is accounted as such in page maps count).\n\t\t\t *\n\t\t\t * So handle this special case as if it was a normal\n\t\t\t * page mapping ie lock CPU page table and returns\n\t\t\t * true.\n\t\t\t *\n\t\t\t * For more details on device private memory see HMM\n\t\t\t * (include/linux/hmm.h or mm/hmm.c).\n\t\t\t */\n\t\t\tif (is_swap_pte(*pvmw->pte)) {\n\t\t\t\tswp_entry_t entry;\n\n\t\t\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\t\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\t\treturn false;\n\t\t\t} else if (!pte_present(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tpvmw->ptl = pte_lockptr(pvmw->vma->vm_mm, pvmw->pmd);\n\tspin_lock(pvmw->ptl);\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pvmw->ptl"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "pvmw->vma->vm_mm",
            "pvmw->pmd"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pvmw->pte"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "*pvmw->pte"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "*pvmw->pte"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "*pvmw->pte"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pvmw->pmd",
            "pvmw->address"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic bool map_pte(struct page_vma_mapped_walk *pvmw)\n{\n\tpvmw->pte = pte_offset_map(pvmw->pmd, pvmw->address);\n\tif (!(pvmw->flags & PVMW_SYNC)) {\n\t\tif (pvmw->flags & PVMW_MIGRATION) {\n\t\t\tif (!is_swap_pte(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We get here when we are trying to unmap a private\n\t\t\t * device page from the process address space. Such\n\t\t\t * page is not CPU accessible and thus is mapped as\n\t\t\t * a special swap entry, nonetheless it still does\n\t\t\t * count as a valid regular mapping for the page (and\n\t\t\t * is accounted as such in page maps count).\n\t\t\t *\n\t\t\t * So handle this special case as if it was a normal\n\t\t\t * page mapping ie lock CPU page table and returns\n\t\t\t * true.\n\t\t\t *\n\t\t\t * For more details on device private memory see HMM\n\t\t\t * (include/linux/hmm.h or mm/hmm.c).\n\t\t\t */\n\t\t\tif (is_swap_pte(*pvmw->pte)) {\n\t\t\t\tswp_entry_t entry;\n\n\t\t\t\t/* Handle un-addressable ZONE_DEVICE memory */\n\t\t\t\tentry = pte_to_swp_entry(*pvmw->pte);\n\t\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\t\treturn false;\n\t\t\t} else if (!pte_present(*pvmw->pte))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tpvmw->ptl = pte_lockptr(pvmw->vma->vm_mm, pvmw->pmd);\n\tspin_lock(pvmw->ptl);\n\treturn true;\n}"
  },
  {
    "function_name": "not_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
    "lines": "10-14",
    "snippet": "static inline bool not_found(struct page_vma_mapped_walk *pvmw)\n{\n\tpage_vma_mapped_walk_done(pvmw);\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "pvmw"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nstatic inline bool not_found(struct page_vma_mapped_walk *pvmw)\n{\n\tpage_vma_mapped_walk_done(pvmw);\n\treturn false;\n}"
  }
]