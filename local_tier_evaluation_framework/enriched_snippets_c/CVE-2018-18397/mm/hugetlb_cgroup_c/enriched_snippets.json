[
  {
    "function_name": "hugetlb_cgroup_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "416-434",
    "snippet": "void hugetlb_cgroup_migrate(struct page *oldhpage, struct page *newhpage)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\tstruct hstate *h = page_hstate(oldhpage);\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageHuge(oldhpage), oldhpage);\n\tspin_lock(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(oldhpage);\n\tset_hugetlb_cgroup(oldhpage, NULL);\n\n\t/* move the h_cg details to new cgroup */\n\tset_hugetlb_cgroup(newhpage, h_cg);\n\tlist_move(&newhpage->lru, &h->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\treturn;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&newhpage->lru",
            "&h->hugepage_activelist"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_hugetlb_cgroup",
          "args": [
            "newhpage",
            "h_cg"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_hugetlb_cgroup",
          "args": [
            "oldhpage",
            "NULL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_page",
          "args": [
            "oldhpage"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHuge(oldhpage)",
            "oldhpage"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "oldhpage"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_disabled",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "oldhpage"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_migrate(struct page *oldhpage, struct page *newhpage)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\tstruct hstate *h = page_hstate(oldhpage);\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageHuge(oldhpage), oldhpage);\n\tspin_lock(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(oldhpage);\n\tset_hugetlb_cgroup(oldhpage, NULL);\n\n\t/* move the h_cg details to new cgroup */\n\tset_hugetlb_cgroup(newhpage, h_cg);\n\tlist_move(&newhpage->lru, &h->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\treturn;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_file_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "397-410",
    "snippet": "void __init hugetlb_cgroup_file_init(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\t/*\n\t\t * Add cgroup control files only if the huge page consists\n\t\t * of more than two normal pages. This is because we use\n\t\t * page[2].private for storing cgroup details.\n\t\t */\n\t\tif (huge_page_order(h) >= HUGETLB_CGROUP_MIN_ORDER)\n\t\t\t__hugetlb_cgroup_file_init(hstate_index(h));\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hugetlb_cgroup_file_init",
          "args": [
            "hstate_index(h)"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "__hugetlb_cgroup_file_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "353-395",
          "snippet": "static void __init __hugetlb_cgroup_file_init(int idx)\n{\n\tchar buf[32];\n\tstruct cftype *cft;\n\tstruct hstate *h = &hstates[idx];\n\n\t/* format the size */\n\tmem_fmt(buf, 32, huge_page_size(h));\n\n\t/* Add the limit file */\n\tcft = &h->cgroup_files[0];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.limit_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_LIMIT);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\tcft->write = hugetlb_cgroup_write;\n\n\t/* Add the usage file */\n\tcft = &h->cgroup_files[1];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_USAGE);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the MAX usage file */\n\tcft = &h->cgroup_files[2];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.max_usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_MAX_USAGE);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the failcntfile */\n\tcft = &h->cgroup_files[3];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.failcnt\", buf);\n\tcft->private  = MEMFILE_PRIVATE(idx, RES_FAILCNT);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* NULL terminate the last cft */\n\tcft = &h->cgroup_files[4];\n\tmemset(cft, 0, sizeof(*cft));\n\n\tWARN_ON(cgroup_add_legacy_cftypes(&hugetlb_cgrp_subsys,\n\t\t\t\t\t  h->cgroup_files));\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys hugetlb_cgrp_subsys = {\n\t.css_alloc\t= hugetlb_cgroup_css_alloc,\n\t.css_offline\t= hugetlb_cgroup_css_offline,\n\t.css_free\t= hugetlb_cgroup_css_free,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstruct cgroup_subsys hugetlb_cgrp_subsys = {\n\t.css_alloc\t= hugetlb_cgroup_css_alloc,\n\t.css_offline\t= hugetlb_cgroup_css_offline,\n\t.css_free\t= hugetlb_cgroup_css_free,\n};\n\nstatic void __init __hugetlb_cgroup_file_init(int idx)\n{\n\tchar buf[32];\n\tstruct cftype *cft;\n\tstruct hstate *h = &hstates[idx];\n\n\t/* format the size */\n\tmem_fmt(buf, 32, huge_page_size(h));\n\n\t/* Add the limit file */\n\tcft = &h->cgroup_files[0];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.limit_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_LIMIT);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\tcft->write = hugetlb_cgroup_write;\n\n\t/* Add the usage file */\n\tcft = &h->cgroup_files[1];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_USAGE);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the MAX usage file */\n\tcft = &h->cgroup_files[2];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.max_usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_MAX_USAGE);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the failcntfile */\n\tcft = &h->cgroup_files[3];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.failcnt\", buf);\n\tcft->private  = MEMFILE_PRIVATE(idx, RES_FAILCNT);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* NULL terminate the last cft */\n\tcft = &h->cgroup_files[4];\n\tmemset(cft, 0, sizeof(*cft));\n\n\tWARN_ON(cgroup_add_legacy_cftypes(&hugetlb_cgrp_subsys,\n\t\t\t\t\t  h->cgroup_files));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hstate_index",
          "args": [
            "h"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "h"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid __init hugetlb_cgroup_file_init(void)\n{\n\tstruct hstate *h;\n\n\tfor_each_hstate(h) {\n\t\t/*\n\t\t * Add cgroup control files only if the huge page consists\n\t\t * of more than two normal pages. This is because we use\n\t\t * page[2].private for storing cgroup details.\n\t\t */\n\t\tif (huge_page_order(h) >= HUGETLB_CGROUP_MIN_ORDER)\n\t\t\t__hugetlb_cgroup_file_init(hstate_index(h));\n\t}\n}"
  },
  {
    "function_name": "__hugetlb_cgroup_file_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "353-395",
    "snippet": "static void __init __hugetlb_cgroup_file_init(int idx)\n{\n\tchar buf[32];\n\tstruct cftype *cft;\n\tstruct hstate *h = &hstates[idx];\n\n\t/* format the size */\n\tmem_fmt(buf, 32, huge_page_size(h));\n\n\t/* Add the limit file */\n\tcft = &h->cgroup_files[0];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.limit_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_LIMIT);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\tcft->write = hugetlb_cgroup_write;\n\n\t/* Add the usage file */\n\tcft = &h->cgroup_files[1];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_USAGE);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the MAX usage file */\n\tcft = &h->cgroup_files[2];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.max_usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_MAX_USAGE);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the failcntfile */\n\tcft = &h->cgroup_files[3];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.failcnt\", buf);\n\tcft->private  = MEMFILE_PRIVATE(idx, RES_FAILCNT);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* NULL terminate the last cft */\n\tcft = &h->cgroup_files[4];\n\tmemset(cft, 0, sizeof(*cft));\n\n\tWARN_ON(cgroup_add_legacy_cftypes(&hugetlb_cgrp_subsys,\n\t\t\t\t\t  h->cgroup_files));\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys hugetlb_cgrp_subsys = {\n\t.css_alloc\t= hugetlb_cgroup_css_alloc,\n\t.css_offline\t= hugetlb_cgroup_css_offline,\n\t.css_free\t= hugetlb_cgroup_css_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_legacy_cftypes(&hugetlb_cgrp_subsys,\n\t\t\t\t\t  h->cgroup_files)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_legacy_cftypes",
          "args": [
            "&hugetlb_cgrp_subsys",
            "h->cgroup_files"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cft",
            "0",
            "sizeof(*cft)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MEMFILE_PRIVATE",
          "args": [
            "idx",
            "RES_FAILCNT"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cft->name",
            "MAX_CFTYPE_NAME",
            "\"%s.failcnt\"",
            "buf"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_PRIVATE",
          "args": [
            "idx",
            "RES_MAX_USAGE"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cft->name",
            "MAX_CFTYPE_NAME",
            "\"%s.max_usage_in_bytes\"",
            "buf"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_PRIVATE",
          "args": [
            "idx",
            "RES_USAGE"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cft->name",
            "MAX_CFTYPE_NAME",
            "\"%s.usage_in_bytes\"",
            "buf"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_PRIVATE",
          "args": [
            "idx",
            "RES_LIMIT"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cft->name",
            "MAX_CFTYPE_NAME",
            "\"%s.limit_in_bytes\"",
            "buf"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_fmt",
          "args": [
            "buf",
            "32",
            "huge_page_size(h)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "mem_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "342-351",
          "snippet": "static char *mem_fmt(char *buf, int size, unsigned long hsize)\n{\n\tif (hsize >= (1UL << 30))\n\t\tsnprintf(buf, size, \"%luGB\", hsize >> 30);\n\telse if (hsize >= (1UL << 20))\n\t\tsnprintf(buf, size, \"%luMB\", hsize >> 20);\n\telse\n\t\tsnprintf(buf, size, \"%luKB\", hsize >> 10);\n\treturn buf;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic char *mem_fmt(char *buf, int size, unsigned long hsize)\n{\n\tif (hsize >= (1UL << 30))\n\t\tsnprintf(buf, size, \"%luGB\", hsize >> 30);\n\telse if (hsize >= (1UL << 20))\n\t\tsnprintf(buf, size, \"%luMB\", hsize >> 20);\n\telse\n\t\tsnprintf(buf, size, \"%luKB\", hsize >> 10);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstruct cgroup_subsys hugetlb_cgrp_subsys = {\n\t.css_alloc\t= hugetlb_cgroup_css_alloc,\n\t.css_offline\t= hugetlb_cgroup_css_offline,\n\t.css_free\t= hugetlb_cgroup_css_free,\n};\n\nstatic void __init __hugetlb_cgroup_file_init(int idx)\n{\n\tchar buf[32];\n\tstruct cftype *cft;\n\tstruct hstate *h = &hstates[idx];\n\n\t/* format the size */\n\tmem_fmt(buf, 32, huge_page_size(h));\n\n\t/* Add the limit file */\n\tcft = &h->cgroup_files[0];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.limit_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_LIMIT);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\tcft->write = hugetlb_cgroup_write;\n\n\t/* Add the usage file */\n\tcft = &h->cgroup_files[1];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_USAGE);\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the MAX usage file */\n\tcft = &h->cgroup_files[2];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.max_usage_in_bytes\", buf);\n\tcft->private = MEMFILE_PRIVATE(idx, RES_MAX_USAGE);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* Add the failcntfile */\n\tcft = &h->cgroup_files[3];\n\tsnprintf(cft->name, MAX_CFTYPE_NAME, \"%s.failcnt\", buf);\n\tcft->private  = MEMFILE_PRIVATE(idx, RES_FAILCNT);\n\tcft->write = hugetlb_cgroup_reset;\n\tcft->read_u64 = hugetlb_cgroup_read_u64;\n\n\t/* NULL terminate the last cft */\n\tcft = &h->cgroup_files[4];\n\tmemset(cft, 0, sizeof(*cft));\n\n\tWARN_ON(cgroup_add_legacy_cftypes(&hugetlb_cgrp_subsys,\n\t\t\t\t\t  h->cgroup_files));\n}"
  },
  {
    "function_name": "mem_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "342-351",
    "snippet": "static char *mem_fmt(char *buf, int size, unsigned long hsize)\n{\n\tif (hsize >= (1UL << 30))\n\t\tsnprintf(buf, size, \"%luGB\", hsize >> 30);\n\telse if (hsize >= (1UL << 20))\n\t\tsnprintf(buf, size, \"%luMB\", hsize >> 20);\n\telse\n\t\tsnprintf(buf, size, \"%luKB\", hsize >> 10);\n\treturn buf;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "size",
            "\"%luKB\"",
            "hsize >> 10"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "size",
            "\"%luMB\"",
            "hsize >> 20"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "size",
            "\"%luGB\"",
            "hsize >> 30"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic char *mem_fmt(char *buf, int size, unsigned long hsize)\n{\n\tif (hsize >= (1UL << 30))\n\t\tsnprintf(buf, size, \"%luGB\", hsize >> 30);\n\telse if (hsize >= (1UL << 20))\n\t\tsnprintf(buf, size, \"%luMB\", hsize >> 20);\n\telse\n\t\tsnprintf(buf, size, \"%luKB\", hsize >> 10);\n\treturn buf;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "319-340",
    "snippet": "static ssize_t hugetlb_cgroup_reset(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tint ret = 0;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(of_css(of));\n\n\tcounter = &h_cg->hugepage[MEMFILE_IDX(of_cft(of)->private)];\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_MAX_USAGE:\n\t\tpage_counter_reset_watermark(counter);\n\t\tbreak;\n\tcase RES_FAILCNT:\n\t\tcounter->failcnt = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret ?: nbytes;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_reset_watermark",
          "args": [
            "counter"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_ATTR",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_IDX",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic ssize_t hugetlb_cgroup_reset(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tint ret = 0;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(of_css(of));\n\n\tcounter = &h_cg->hugepage[MEMFILE_IDX(of_cft(of)->private)];\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_MAX_USAGE:\n\t\tpage_counter_reset_watermark(counter);\n\t\tbreak;\n\tcase RES_FAILCNT:\n\t\tcounter->failcnt = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret ?: nbytes;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "288-317",
    "snippet": "static ssize_t hugetlb_cgroup_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tint ret, idx;\n\tunsigned long nr_pages;\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(of_css(of));\n\n\tif (hugetlb_cgroup_is_root(h_cg)) /* Can't set limit on root */\n\t\treturn -EINVAL;\n\n\tbuf = strstrip(buf);\n\tret = page_counter_memparse(buf, \"-1\", &nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tidx = MEMFILE_IDX(of_cft(of)->private);\n\tnr_pages = round_down(nr_pages, 1 << huge_page_order(&hstates[idx]));\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_LIMIT:\n\t\tmutex_lock(&hugetlb_limit_mutex);\n\t\tret = page_counter_set_max(&h_cg->hugepage[idx], nr_pages);\n\t\tmutex_unlock(&hugetlb_limit_mutex);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret ?: nbytes;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(hugetlb_limit_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hugetlb_limit_mutex"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_set_max",
          "args": [
            "&h_cg->hugepage[idx]",
            "nr_pages"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "173-203",
          "snippet": "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hugetlb_limit_mutex"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_ATTR",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "nr_pages",
            "1 << huge_page_order(&hstates[idx])"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "&hstates[idx]"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_IDX",
          "args": [
            "of_cft(of)->private"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_memparse",
          "args": [
            "buf",
            "\"-1\"",
            "&nr_pages"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "248-266",
          "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_is_root",
          "args": [
            "h_cg"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_is_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "48-51",
          "snippet": "static inline bool hugetlb_cgroup_is_root(struct hugetlb_cgroup *h_cg)\n{\n\treturn (h_cg == root_h_cgroup);\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hugetlb_cgroup *root_h_cgroup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic struct hugetlb_cgroup *root_h_cgroup;\n\nstatic inline bool hugetlb_cgroup_is_root(struct hugetlb_cgroup *h_cg)\n{\n\treturn (h_cg == root_h_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "of_css(of)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic DEFINE_MUTEX(hugetlb_limit_mutex);\n\nstatic ssize_t hugetlb_cgroup_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tint ret, idx;\n\tunsigned long nr_pages;\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(of_css(of));\n\n\tif (hugetlb_cgroup_is_root(h_cg)) /* Can't set limit on root */\n\t\treturn -EINVAL;\n\n\tbuf = strstrip(buf);\n\tret = page_counter_memparse(buf, \"-1\", &nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tidx = MEMFILE_IDX(of_cft(of)->private);\n\tnr_pages = round_down(nr_pages, 1 << huge_page_order(&hstates[idx]));\n\n\tswitch (MEMFILE_ATTR(of_cft(of)->private)) {\n\tcase RES_LIMIT:\n\t\tmutex_lock(&hugetlb_limit_mutex);\n\t\tret = page_counter_set_max(&h_cg->hugepage[idx], nr_pages);\n\t\tmutex_unlock(&hugetlb_limit_mutex);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret ?: nbytes;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_read_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "264-284",
    "snippet": "static u64 hugetlb_cgroup_read_u64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(css);\n\n\tcounter = &h_cg->hugepage[MEMFILE_IDX(cft->private)];\n\n\tswitch (MEMFILE_ATTR(cft->private)) {\n\tcase RES_USAGE:\n\t\treturn (u64)page_counter_read(counter) * PAGE_SIZE;\n\tcase RES_LIMIT:\n\t\treturn (u64)counter->max * PAGE_SIZE;\n\tcase RES_MAX_USAGE:\n\t\treturn (u64)counter->watermark * PAGE_SIZE;\n\tcase RES_FAILCNT:\n\t\treturn counter->failcnt;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "counter"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_ATTR",
          "args": [
            "cft->private"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMFILE_IDX",
          "args": [
            "cft->private"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic u64 hugetlb_cgroup_read_u64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(css);\n\n\tcounter = &h_cg->hugepage[MEMFILE_IDX(cft->private)];\n\n\tswitch (MEMFILE_ATTR(cft->private)) {\n\tcase RES_USAGE:\n\t\treturn (u64)page_counter_read(counter) * PAGE_SIZE;\n\tcase RES_LIMIT:\n\t\treturn (u64)counter->max * PAGE_SIZE;\n\tcase RES_MAX_USAGE:\n\t\treturn (u64)counter->watermark * PAGE_SIZE;\n\tcase RES_FAILCNT:\n\t\treturn counter->failcnt;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "hugetlb_cgroup_uncharge_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "244-255",
    "snippet": "void hugetlb_cgroup_uncharge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t    struct hugetlb_cgroup *h_cg)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\treturn;\n\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&h_cg->hugepage[idx]",
            "nr_pages"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "&hstates[idx]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_disabled",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_uncharge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t    struct hugetlb_cgroup *h_cg)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\treturn;\n\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_uncharge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "228-242",
    "snippet": "void hugetlb_cgroup_uncharge_page(int idx, unsigned long nr_pages,\n\t\t\t\t  struct page *page)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\tlockdep_assert_held(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(page);\n\tif (unlikely(!h_cg))\n\t\treturn;\n\tset_hugetlb_cgroup(page, NULL);\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_uncharge",
          "args": [
            "&h_cg->hugepage[idx]",
            "nr_pages"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "155-161",
          "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_hugetlb_cgroup",
          "args": [
            "page",
            "NULL"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!h_cg"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_page",
          "args": [
            "page"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_disabled",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_uncharge_page(int idx, unsigned long nr_pages,\n\t\t\t\t  struct page *page)\n{\n\tstruct hugetlb_cgroup *h_cg;\n\n\tif (hugetlb_cgroup_disabled())\n\t\treturn;\n\tlockdep_assert_held(&hugetlb_lock);\n\th_cg = hugetlb_cgroup_from_page(page);\n\tif (unlikely(!h_cg))\n\t\treturn;\n\tset_hugetlb_cgroup(page, NULL);\n\tpage_counter_uncharge(&h_cg->hugepage[idx], nr_pages);\n\treturn;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_commit_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "214-223",
    "snippet": "void hugetlb_cgroup_commit_charge(int idx, unsigned long nr_pages,\n\t\t\t\t  struct hugetlb_cgroup *h_cg,\n\t\t\t\t  struct page *page)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tset_hugetlb_cgroup(page, h_cg);\n\treturn;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_hugetlb_cgroup",
          "args": [
            "page",
            "h_cg"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_disabled",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nvoid hugetlb_cgroup_commit_charge(int idx, unsigned long nr_pages,\n\t\t\t\t  struct hugetlb_cgroup *h_cg,\n\t\t\t\t  struct page *page)\n{\n\tif (hugetlb_cgroup_disabled() || !h_cg)\n\t\treturn;\n\n\tset_hugetlb_cgroup(page, h_cg);\n\treturn;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_charge_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "181-211",
    "snippet": "int hugetlb_cgroup_charge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t struct hugetlb_cgroup **ptr)\n{\n\tint ret = 0;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = NULL;\n\n\tif (hugetlb_cgroup_disabled())\n\t\tgoto done;\n\t/*\n\t * We don't charge any cgroup if the compound page have less\n\t * than 3 pages.\n\t */\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\tgoto done;\nagain:\n\trcu_read_lock();\n\th_cg = hugetlb_cgroup_from_task(current);\n\tif (!css_tryget_online(&h_cg->css)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tif (!page_counter_try_charge(&h_cg->hugepage[idx], nr_pages, &counter))\n\t\tret = -ENOMEM;\n\tcss_put(&h_cg->css);\ndone:\n\t*ptr = h_cg;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&h_cg->css"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_try_charge",
          "args": [
            "&h_cg->hugepage[idx]",
            "nr_pages",
            "&counter"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "99-148",
          "snippet": "bool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nbool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&h_cg->css"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_task",
          "args": [
            "current"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "42-46",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_task(struct task_struct *task)\n{\n\treturn hugetlb_cgroup_from_css(task_css(task, hugetlb_cgrp_id));\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_task(struct task_struct *task)\n{\n\treturn hugetlb_cgroup_from_css(task_css(task, hugetlb_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "&hstates[idx]"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_disabled",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nint hugetlb_cgroup_charge_cgroup(int idx, unsigned long nr_pages,\n\t\t\t\t struct hugetlb_cgroup **ptr)\n{\n\tint ret = 0;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *h_cg = NULL;\n\n\tif (hugetlb_cgroup_disabled())\n\t\tgoto done;\n\t/*\n\t * We don't charge any cgroup if the compound page have less\n\t * than 3 pages.\n\t */\n\tif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\n\t\tgoto done;\nagain:\n\trcu_read_lock();\n\th_cg = hugetlb_cgroup_from_task(current);\n\tif (!css_tryget_online(&h_cg->css)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tif (!page_counter_try_charge(&h_cg->hugepage[idx], nr_pages, &counter))\n\t\tret = -ENOMEM;\n\tcss_put(&h_cg->css);\ndone:\n\t*ptr = h_cg;\n\treturn ret;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_css_offline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "161-179",
    "snippet": "static void hugetlb_cgroup_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(css);\n\tstruct hstate *h;\n\tstruct page *page;\n\tint idx = 0;\n\n\tdo {\n\t\tfor_each_hstate(h) {\n\t\t\tspin_lock(&hugetlb_lock);\n\t\t\tlist_for_each_entry(page, &h->hugepage_activelist, lru)\n\t\t\t\thugetlb_cgroup_move_parent(idx, h_cg, page);\n\n\t\t\tspin_unlock(&hugetlb_lock);\n\t\t\tidx++;\n\t\t}\n\t\tcond_resched();\n\t} while (hugetlb_cgroup_have_usage(h_cg));\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_cgroup_have_usage",
          "args": [
            "h_cg"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_have_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "59-68",
          "snippet": "static inline bool hugetlb_cgroup_have_usage(struct hugetlb_cgroup *h_cg)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < hugetlb_max_hstate; idx++) {\n\t\tif (page_counter_read(&h_cg->hugepage[idx]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline bool hugetlb_cgroup_have_usage(struct hugetlb_cgroup *h_cg)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < hugetlb_max_hstate; idx++) {\n\t\tif (page_counter_read(&h_cg->hugepage[idx]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_move_parent",
          "args": [
            "idx",
            "h_cg",
            "page"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_move_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "125-155",
          "snippet": "static void hugetlb_cgroup_move_parent(int idx, struct hugetlb_cgroup *h_cg,\n\t\t\t\t       struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *page_hcg;\n\tstruct hugetlb_cgroup *parent = parent_hugetlb_cgroup(h_cg);\n\n\tpage_hcg = hugetlb_cgroup_from_page(page);\n\t/*\n\t * We can have pages in active list without any cgroup\n\t * ie, hugepage with less than 3 pages. We can safely\n\t * ignore those pages.\n\t */\n\tif (!page_hcg || page_hcg != h_cg)\n\t\tgoto out;\n\n\tnr_pages = 1 << compound_order(page);\n\tif (!parent) {\n\t\tparent = root_h_cgroup;\n\t\t/* root has no limit */\n\t\tpage_counter_charge(&parent->hugepage[idx], nr_pages);\n\t}\n\tcounter = &h_cg->hugepage[idx];\n\t/* Take the pages off the local counter */\n\tpage_counter_cancel(counter, nr_pages);\n\n\tset_hugetlb_cgroup(page, parent);\nout:\n\treturn;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hugetlb_cgroup *root_h_cgroup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic struct hugetlb_cgroup *root_h_cgroup;\n\nstatic void hugetlb_cgroup_move_parent(int idx, struct hugetlb_cgroup *h_cg,\n\t\t\t\t       struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *page_hcg;\n\tstruct hugetlb_cgroup *parent = parent_hugetlb_cgroup(h_cg);\n\n\tpage_hcg = hugetlb_cgroup_from_page(page);\n\t/*\n\t * We can have pages in active list without any cgroup\n\t * ie, hugepage with less than 3 pages. We can safely\n\t * ignore those pages.\n\t */\n\tif (!page_hcg || page_hcg != h_cg)\n\t\tgoto out;\n\n\tnr_pages = 1 << compound_order(page);\n\tif (!parent) {\n\t\tparent = root_h_cgroup;\n\t\t/* root has no limit */\n\t\tpage_counter_charge(&parent->hugepage[idx], nr_pages);\n\t}\n\tcounter = &h_cg->hugepage[idx];\n\t/* Take the pages off the local counter */\n\tpage_counter_cancel(counter, nr_pages);\n\n\tset_hugetlb_cgroup(page, parent);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&h->hugepage_activelist",
            "lru"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hugetlb_lock"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic void hugetlb_cgroup_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_css(css);\n\tstruct hstate *h;\n\tstruct page *page;\n\tint idx = 0;\n\n\tdo {\n\t\tfor_each_hstate(h) {\n\t\t\tspin_lock(&hugetlb_lock);\n\t\t\tlist_for_each_entry(page, &h->hugepage_activelist, lru)\n\t\t\t\thugetlb_cgroup_move_parent(idx, h_cg, page);\n\n\t\t\tspin_unlock(&hugetlb_lock);\n\t\t\tidx++;\n\t\t}\n\t\tcond_resched();\n\t} while (hugetlb_cgroup_have_usage(h_cg));\n}"
  },
  {
    "function_name": "hugetlb_cgroup_move_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "125-155",
    "snippet": "static void hugetlb_cgroup_move_parent(int idx, struct hugetlb_cgroup *h_cg,\n\t\t\t\t       struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *page_hcg;\n\tstruct hugetlb_cgroup *parent = parent_hugetlb_cgroup(h_cg);\n\n\tpage_hcg = hugetlb_cgroup_from_page(page);\n\t/*\n\t * We can have pages in active list without any cgroup\n\t * ie, hugepage with less than 3 pages. We can safely\n\t * ignore those pages.\n\t */\n\tif (!page_hcg || page_hcg != h_cg)\n\t\tgoto out;\n\n\tnr_pages = 1 << compound_order(page);\n\tif (!parent) {\n\t\tparent = root_h_cgroup;\n\t\t/* root has no limit */\n\t\tpage_counter_charge(&parent->hugepage[idx], nr_pages);\n\t}\n\tcounter = &h_cg->hugepage[idx];\n\t/* Take the pages off the local counter */\n\tpage_counter_cancel(counter, nr_pages);\n\n\tset_hugetlb_cgroup(page, parent);\nout:\n\treturn;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hugetlb_cgroup *root_h_cgroup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_hugetlb_cgroup",
          "args": [
            "page",
            "parent"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_cancel",
          "args": [
            "counter",
            "nr_pages"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "55-63",
          "snippet": "void page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_counter_charge",
          "args": [
            "&parent->hugepage[idx]",
            "nr_pages"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "72-88",
          "snippet": "void page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_page",
          "args": [
            "page"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_hugetlb_cgroup",
          "args": [
            "h_cg"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "parent_hugetlb_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "53-57",
          "snippet": "static inline struct hugetlb_cgroup *\nparent_hugetlb_cgroup(struct hugetlb_cgroup *h_cg)\n{\n\treturn hugetlb_cgroup_from_css(h_cg->css.parent);\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline struct hugetlb_cgroup *\nparent_hugetlb_cgroup(struct hugetlb_cgroup *h_cg)\n{\n\treturn hugetlb_cgroup_from_css(h_cg->css.parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic struct hugetlb_cgroup *root_h_cgroup;\n\nstatic void hugetlb_cgroup_move_parent(int idx, struct hugetlb_cgroup *h_cg,\n\t\t\t\t       struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct page_counter *counter;\n\tstruct hugetlb_cgroup *page_hcg;\n\tstruct hugetlb_cgroup *parent = parent_hugetlb_cgroup(h_cg);\n\n\tpage_hcg = hugetlb_cgroup_from_page(page);\n\t/*\n\t * We can have pages in active list without any cgroup\n\t * ie, hugepage with less than 3 pages. We can safely\n\t * ignore those pages.\n\t */\n\tif (!page_hcg || page_hcg != h_cg)\n\t\tgoto out;\n\n\tnr_pages = 1 << compound_order(page);\n\tif (!parent) {\n\t\tparent = root_h_cgroup;\n\t\t/* root has no limit */\n\t\tpage_counter_charge(&parent->hugepage[idx], nr_pages);\n\t}\n\tcounter = &h_cg->hugepage[idx];\n\t/* Take the pages off the local counter */\n\tpage_counter_cancel(counter, nr_pages);\n\n\tset_hugetlb_cgroup(page, parent);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_css_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "109-115",
    "snippet": "static void hugetlb_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct hugetlb_cgroup *h_cgroup;\n\n\th_cgroup = hugetlb_cgroup_from_css(css);\n\tkfree(h_cgroup);\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "h_cgroup"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic void hugetlb_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct hugetlb_cgroup *h_cgroup;\n\n\th_cgroup = hugetlb_cgroup_from_css(css);\n\tkfree(h_cgroup);\n}"
  },
  {
    "function_name": "hugetlb_cgroup_css_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "92-107",
    "snippet": "static struct cgroup_subsys_state *\nhugetlb_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct hugetlb_cgroup *parent_h_cgroup = hugetlb_cgroup_from_css(parent_css);\n\tstruct hugetlb_cgroup *h_cgroup;\n\n\th_cgroup = kzalloc(sizeof(*h_cgroup), GFP_KERNEL);\n\tif (!h_cgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!parent_h_cgroup)\n\t\troot_h_cgroup = h_cgroup;\n\n\thugetlb_cgroup_init(h_cgroup, parent_h_cgroup);\n\treturn &h_cgroup->css;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hugetlb_cgroup *root_h_cgroup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_cgroup_init",
          "args": [
            "h_cgroup",
            "parent_h_cgroup"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "70-90",
          "snippet": "static void hugetlb_cgroup_init(struct hugetlb_cgroup *h_cgroup,\n\t\t\t\tstruct hugetlb_cgroup *parent_h_cgroup)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HUGE_MAX_HSTATE; idx++) {\n\t\tstruct page_counter *counter = &h_cgroup->hugepage[idx];\n\t\tstruct page_counter *parent = NULL;\n\t\tunsigned long limit;\n\t\tint ret;\n\n\t\tif (parent_h_cgroup)\n\t\t\tparent = &parent_h_cgroup->hugepage[idx];\n\t\tpage_counter_init(counter, parent);\n\n\t\tlimit = round_down(PAGE_COUNTER_MAX,\n\t\t\t\t   1 << huge_page_order(&hstates[idx]));\n\t\tret = page_counter_set_max(counter, limit);\n\t\tVM_BUG_ON(ret);\n\t}\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic void hugetlb_cgroup_init(struct hugetlb_cgroup *h_cgroup,\n\t\t\t\tstruct hugetlb_cgroup *parent_h_cgroup)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HUGE_MAX_HSTATE; idx++) {\n\t\tstruct page_counter *counter = &h_cgroup->hugepage[idx];\n\t\tstruct page_counter *parent = NULL;\n\t\tunsigned long limit;\n\t\tint ret;\n\n\t\tif (parent_h_cgroup)\n\t\t\tparent = &parent_h_cgroup->hugepage[idx];\n\t\tpage_counter_init(counter, parent);\n\n\t\tlimit = round_down(PAGE_COUNTER_MAX,\n\t\t\t\t   1 << huge_page_order(&hstates[idx]));\n\t\tret = page_counter_set_max(counter, limit);\n\t\tVM_BUG_ON(ret);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*h_cgroup)",
            "GFP_KERNEL"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "parent_css"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic struct hugetlb_cgroup *root_h_cgroup;\n\nstatic struct cgroup_subsys_state *\nhugetlb_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct hugetlb_cgroup *parent_h_cgroup = hugetlb_cgroup_from_css(parent_css);\n\tstruct hugetlb_cgroup *h_cgroup;\n\n\th_cgroup = kzalloc(sizeof(*h_cgroup), GFP_KERNEL);\n\tif (!h_cgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!parent_h_cgroup)\n\t\troot_h_cgroup = h_cgroup;\n\n\thugetlb_cgroup_init(h_cgroup, parent_h_cgroup);\n\treturn &h_cgroup->css;\n}"
  },
  {
    "function_name": "hugetlb_cgroup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "70-90",
    "snippet": "static void hugetlb_cgroup_init(struct hugetlb_cgroup *h_cgroup,\n\t\t\t\tstruct hugetlb_cgroup *parent_h_cgroup)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HUGE_MAX_HSTATE; idx++) {\n\t\tstruct page_counter *counter = &h_cgroup->hugepage[idx];\n\t\tstruct page_counter *parent = NULL;\n\t\tunsigned long limit;\n\t\tint ret;\n\n\t\tif (parent_h_cgroup)\n\t\t\tparent = &parent_h_cgroup->hugepage[idx];\n\t\tpage_counter_init(counter, parent);\n\n\t\tlimit = round_down(PAGE_COUNTER_MAX,\n\t\t\t\t   1 << huge_page_order(&hstates[idx]));\n\t\tret = page_counter_set_max(counter, limit);\n\t\tVM_BUG_ON(ret);\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "ret"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_set_max",
          "args": [
            "counter",
            "limit"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "173-203",
          "snippet": "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "PAGE_COUNTER_MAX",
            "1 << huge_page_order(&hstates[idx])"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_order",
          "args": [
            "&hstates[idx]"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_counter_init",
          "args": [
            "counter",
            "parent"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic void hugetlb_cgroup_init(struct hugetlb_cgroup *h_cgroup,\n\t\t\t\tstruct hugetlb_cgroup *parent_h_cgroup)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HUGE_MAX_HSTATE; idx++) {\n\t\tstruct page_counter *counter = &h_cgroup->hugepage[idx];\n\t\tstruct page_counter *parent = NULL;\n\t\tunsigned long limit;\n\t\tint ret;\n\n\t\tif (parent_h_cgroup)\n\t\t\tparent = &parent_h_cgroup->hugepage[idx];\n\t\tpage_counter_init(counter, parent);\n\n\t\tlimit = round_down(PAGE_COUNTER_MAX,\n\t\t\t\t   1 << huge_page_order(&hstates[idx]));\n\t\tret = page_counter_set_max(counter, limit);\n\t\tVM_BUG_ON(ret);\n\t}\n}"
  },
  {
    "function_name": "hugetlb_cgroup_have_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "59-68",
    "snippet": "static inline bool hugetlb_cgroup_have_usage(struct hugetlb_cgroup *h_cg)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < hugetlb_max_hstate; idx++) {\n\t\tif (page_counter_read(&h_cg->hugepage[idx]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_read",
          "args": [
            "&h_cg->hugepage[idx]"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline bool hugetlb_cgroup_have_usage(struct hugetlb_cgroup *h_cg)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < hugetlb_max_hstate; idx++) {\n\t\tif (page_counter_read(&h_cg->hugepage[idx]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "parent_hugetlb_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "53-57",
    "snippet": "static inline struct hugetlb_cgroup *\nparent_hugetlb_cgroup(struct hugetlb_cgroup *h_cg)\n{\n\treturn hugetlb_cgroup_from_css(h_cg->css.parent);\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "h_cg->css.parent"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline struct hugetlb_cgroup *\nparent_hugetlb_cgroup(struct hugetlb_cgroup *h_cg)\n{\n\treturn hugetlb_cgroup_from_css(h_cg->css.parent);\n}"
  },
  {
    "function_name": "hugetlb_cgroup_is_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "48-51",
    "snippet": "static inline bool hugetlb_cgroup_is_root(struct hugetlb_cgroup *h_cg)\n{\n\treturn (h_cg == root_h_cgroup);\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hugetlb_cgroup *root_h_cgroup"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic struct hugetlb_cgroup *root_h_cgroup;\n\nstatic inline bool hugetlb_cgroup_is_root(struct hugetlb_cgroup *h_cg)\n{\n\treturn (h_cg == root_h_cgroup);\n}"
  },
  {
    "function_name": "hugetlb_cgroup_from_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "42-46",
    "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_task(struct task_struct *task)\n{\n\treturn hugetlb_cgroup_from_css(task_css(task, hugetlb_cgrp_id));\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugetlb_cgroup_from_css",
          "args": [
            "task_css(task, hugetlb_cgrp_id)"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_cgroup_from_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
          "lines": "36-40",
          "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/slab.h>",
            "#include <linux/page_counter.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "hugetlb_cgrp_id"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_task(struct task_struct *task)\n{\n\treturn hugetlb_cgroup_from_css(task_css(task, hugetlb_cgrp_id));\n}"
  },
  {
    "function_name": "hugetlb_cgroup_from_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb_cgroup.c",
    "lines": "36-40",
    "snippet": "static inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}",
    "includes": [
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/slab.h>",
      "#include <linux/page_counter.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "s",
            "structhugetlb_cgroup",
            "css"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/page_counter.h>\n#include <linux/cgroup.h>\n\nstatic inline\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct hugetlb_cgroup, css) : NULL;\n}"
  }
]