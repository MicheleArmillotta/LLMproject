[
  {
    "function_name": "ksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4465-4480",
    "snippet": "size_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_unpoison_shadow",
          "args": [
            "objp",
            "size"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_unpoison_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "67-75",
          "snippet": "void kasan_unpoison_shadow(const void *address, size_t size)\n{\n\tkasan_poison_shadow(address, size, 0);\n\n\tif (size & KASAN_SHADOW_MASK) {\n\t\tu8 *shadow = (u8 *)kasan_mem_to_shadow(address + size);\n\t\t*shadow = size & KASAN_SHADOW_MASK;\n\t}\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_unpoison_shadow(const void *address, size_t size)\n{\n\tkasan_poison_shadow(address, size, 0);\n\n\tif (size & KASAN_SHADOW_MASK) {\n\t\tu8 *shadow = (u8 *)kasan_mem_to_shadow(address + size);\n\t\t*shadow = size & KASAN_SHADOW_MASK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_cache",
          "args": [
            "objp"
          ],
          "line": 4473
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "397-401",
          "snippet": "static inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "objp == ZERO_SIZE_PTR"
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!objp"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nsize_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}"
  },
  {
    "function_name": "__check_heap_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4415-4450",
    "snippet": "void __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\t bool to_user)\n{\n\tstruct kmem_cache *cachep;\n\tunsigned int objnr;\n\tunsigned long offset;\n\n\t/* Find and validate object. */\n\tcachep = page->slab_cache;\n\tobjnr = obj_to_index(cachep, page, (void *)ptr);\n\tBUG_ON(objnr >= cachep->num);\n\n\t/* Find offset within object. */\n\toffset = ptr - index_to_obj(cachep, page, objnr) - obj_offset(cachep);\n\n\t/* Allow address range falling entirely within usercopy region. */\n\tif (offset >= cachep->useroffset &&\n\t    offset - cachep->useroffset <= cachep->usersize &&\n\t    n <= cachep->useroffset - offset + cachep->usersize)\n\t\treturn;\n\n\t/*\n\t * If the copy is still within the allocated object, produce\n\t * a warning instead of rejecting the copy. This is intended\n\t * to be a temporary method to find any missing usercopy\n\t * whitelists.\n\t */\n\tif (usercopy_fallback &&\n\t    offset <= cachep->object_size &&\n\t    n <= cachep->object_size - offset) {\n\t\tusercopy_warn(\"SLAB object\", cachep->name, to_user, offset, n);\n\t\treturn;\n\t}\n\n\tusercopy_abort(\"SLAB object\", cachep->name, to_user, offset, n);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usercopy_abort",
          "args": [
            "\"SLAB object\"",
            "cachep->name",
            "to_user",
            "offset",
            "n"
          ],
          "line": 4449
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "86-103",
          "snippet": "void __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "usercopy_warn",
          "args": [
            "\"SLAB object\"",
            "cachep->name",
            "to_user",
            "offset",
            "n"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "75-84",
          "snippet": "void usercopy_warn(const char *name, const char *detail, bool to_user,\n\t\t   unsigned long offset, unsigned long len)\n{\n\tWARN_ONCE(1, \"Bad or missing usercopy whitelist? Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid usercopy_warn(const char *name, const char *detail, bool to_user,\n\t\t   unsigned long offset, unsigned long len)\n{\n\tWARN_ONCE(1, \"Bad or missing usercopy whitelist? Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 4428
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "objnr"
          ],
          "line": 4428
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "objnr >= cachep->num"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_to_index",
          "args": [
            "cachep",
            "page",
            "(void *)ptr"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "obj_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "415-420",
          "snippet": "static inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\t bool to_user)\n{\n\tstruct kmem_cache *cachep;\n\tunsigned int objnr;\n\tunsigned long offset;\n\n\t/* Find and validate object. */\n\tcachep = page->slab_cache;\n\tobjnr = obj_to_index(cachep, page, (void *)ptr);\n\tBUG_ON(objnr >= cachep->num);\n\n\t/* Find offset within object. */\n\toffset = ptr - index_to_obj(cachep, page, objnr) - obj_offset(cachep);\n\n\t/* Allow address range falling entirely within usercopy region. */\n\tif (offset >= cachep->useroffset &&\n\t    offset - cachep->useroffset <= cachep->usersize &&\n\t    n <= cachep->useroffset - offset + cachep->usersize)\n\t\treturn;\n\n\t/*\n\t * If the copy is still within the allocated object, produce\n\t * a warning instead of rejecting the copy. This is intended\n\t * to be a temporary method to find any missing usercopy\n\t * whitelists.\n\t */\n\tif (usercopy_fallback &&\n\t    offset <= cachep->object_size &&\n\t    n <= cachep->object_size - offset) {\n\t\tusercopy_warn(\"SLAB object\", cachep->name, to_user, offset, n);\n\t\treturn;\n\t}\n\n\tusercopy_abort(\"SLAB object\", cachep->name, to_user, offset, n);\n}"
  },
  {
    "function_name": "slab_proc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4397-4403",
    "snippet": "static int __init slab_proc_init(void)\n{\n#ifdef CONFIG_DEBUG_SLAB_LEAK\n\tproc_create(\"slab_allocators\", 0, NULL, &proc_slabstats_operations);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"slab_allocators\"",
            "0",
            "NULL",
            "&proc_slabstats_operations"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int __init slab_proc_init(void)\n{\n#ifdef CONFIG_DEBUG_SLAB_LEAK\n\tproc_create(\"slab_allocators\", 0, NULL, &proc_slabstats_operations);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "slabstats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4376-4387",
    "snippet": "static int slabstats_open(struct inode *inode, struct file *file)\n{\n\tunsigned long *n;\n\n\tn = __seq_open_private(file, &slabstats_op, PAGE_SIZE);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\t*n = PAGE_SIZE / (2 * sizeof(unsigned long));\n\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&slabstats_op",
            "PAGE_SIZE"
          ],
          "line": 4380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int slabstats_open(struct inode *inode, struct file *file)\n{\n\tunsigned long *n;\n\n\tn = __seq_open_private(file, &slabstats_op, PAGE_SIZE);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\t*n = PAGE_SIZE / (2 * sizeof(unsigned long));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "leaks_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4301-4367",
    "snippet": "static int leaks_show(struct seq_file *m, void *p)\n{\n\tstruct kmem_cache *cachep = list_entry(p, struct kmem_cache, list);\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tconst char *name;\n\tunsigned long *x = m->private;\n\tint node;\n\tint i;\n\n\tif (!(cachep->flags & SLAB_STORE_USER))\n\t\treturn 0;\n\tif (!(cachep->flags & SLAB_RED_ZONE))\n\t\treturn 0;\n\n\t/*\n\t * Set store_user_clean and start to grab stored user information\n\t * for all objects on this cache. If some alloc/free requests comes\n\t * during the processing, information would be wrong so restart\n\t * whole processing.\n\t */\n\tdo {\n\t\tset_store_user_clean(cachep);\n\t\tdrain_cpu_caches(cachep);\n\n\t\tx[1] = 0;\n\n\t\tfor_each_kmem_cache_node(cachep, node, n) {\n\n\t\t\tcheck_irq_on();\n\t\t\tspin_lock_irq(&n->list_lock);\n\n\t\t\tlist_for_each_entry(page, &n->slabs_full, lru)\n\t\t\t\thandle_slab(x, cachep, page);\n\t\t\tlist_for_each_entry(page, &n->slabs_partial, lru)\n\t\t\t\thandle_slab(x, cachep, page);\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t}\n\t} while (!is_store_user_clean(cachep));\n\n\tname = cachep->name;\n\tif (x[0] == x[1]) {\n\t\t/* Increase the buffer size */\n\t\tmutex_unlock(&slab_mutex);\n\t\tm->private = kcalloc(x[0] * 4, sizeof(unsigned long),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!m->private) {\n\t\t\t/* Too bad, we are really out */\n\t\t\tm->private = x;\n\t\t\tmutex_lock(&slab_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t*(unsigned long *)m->private = x[0] * 2;\n\t\tkfree(x);\n\t\tmutex_lock(&slab_mutex);\n\t\t/* Now make sure this entry will be retried */\n\t\tm->count = m->size;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < x[1]; i++) {\n\t\tseq_printf(m, \"%s: %lu \", name, x[2*i+3]);\n\t\tshow_symbol(m, x[2*i+2]);\n\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_symbol",
          "args": [
            "m",
            "x[2*i+2]"
          ],
          "line": 4362
        },
        "resolved": true,
        "details": {
          "function_name": "show_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4285-4299",
          "snippet": "static void show_symbol(struct seq_file *m, unsigned long address)\n{\n#ifdef CONFIG_KALLSYMS\n\tunsigned long offset, size;\n\tchar modname[MODULE_NAME_LEN], name[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_attrs(address, &size, &offset, modname, name) == 0) {\n\t\tseq_printf(m, \"%s+%#lx/%#lx\", name, offset, size);\n\t\tif (modname[0])\n\t\t\tseq_printf(m, \" [%s]\", modname);\n\t\treturn;\n\t}\n#endif\n\tseq_printf(m, \"%px\", (void *)address);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void show_symbol(struct seq_file *m, unsigned long address)\n{\n#ifdef CONFIG_KALLSYMS\n\tunsigned long offset, size;\n\tchar modname[MODULE_NAME_LEN], name[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_attrs(address, &size, &offset, modname, name) == 0) {\n\t\tseq_printf(m, \"%s+%#lx/%#lx\", name, offset, size);\n\t\tif (modname[0])\n\t\t\tseq_printf(m, \" [%s]\", modname);\n\t\treturn;\n\t}\n#endif\n\tseq_printf(m, \"%px\", (void *)address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s: %lu \"",
            "name",
            "x[2*i+3]"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "x"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3802-3819",
          "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "x[0] * 4",
            "sizeof(unsigned long)",
            "GFP_KERNEL"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_store_user_clean",
          "args": [
            "cachep"
          ],
          "line": 4339
        },
        "resolved": true,
        "details": {
          "function_name": "is_store_user_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "367-370",
          "snippet": "static inline bool is_store_user_clean(struct kmem_cache *cachep)\n{\n\treturn atomic_read(&cachep->store_user_clean) == 1;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline bool is_store_user_clean(struct kmem_cache *cachep)\n{\n\treturn atomic_read(&cachep->store_user_clean) == 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_slab",
          "args": [
            "x",
            "cachep",
            "page"
          ],
          "line": 4336
        },
        "resolved": true,
        "details": {
          "function_name": "handle_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4249-4283",
          "snippet": "static void handle_slab(unsigned long *n, struct kmem_cache *c,\n\t\t\t\t\t\tstruct page *page)\n{\n\tvoid *p;\n\tint i, j;\n\tunsigned long v;\n\n\tif (n[0] == n[1])\n\t\treturn;\n\tfor (i = 0, p = page->s_mem; i < c->num; i++, p += c->size) {\n\t\tbool active = true;\n\n\t\tfor (j = page->active; j < c->num; j++) {\n\t\t\tif (get_free_obj(page, j) == i) {\n\t\t\t\tactive = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!active)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * probe_kernel_read() is used for DEBUG_PAGEALLOC. page table\n\t\t * mapping is established when actual object allocation and\n\t\t * we could mistakenly access the unmapped object in the cpu\n\t\t * cache.\n\t\t */\n\t\tif (probe_kernel_read(&v, dbg_userword(c, p), sizeof(v)))\n\t\t\tcontinue;\n\n\t\tif (!add_caller(n, v))\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void handle_slab(unsigned long *n, struct kmem_cache *c,\n\t\t\t\t\t\tstruct page *page)\n{\n\tvoid *p;\n\tint i, j;\n\tunsigned long v;\n\n\tif (n[0] == n[1])\n\t\treturn;\n\tfor (i = 0, p = page->s_mem; i < c->num; i++, p += c->size) {\n\t\tbool active = true;\n\n\t\tfor (j = page->active; j < c->num; j++) {\n\t\t\tif (get_free_obj(page, j) == i) {\n\t\t\t\tactive = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!active)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * probe_kernel_read() is used for DEBUG_PAGEALLOC. page table\n\t\t * mapping is established when actual object allocation and\n\t\t * we could mistakenly access the unmapped object in the cpu\n\t\t * cache.\n\t\t */\n\t\tif (probe_kernel_read(&v, dbg_userword(c, p), sizeof(v)))\n\t\t\tcontinue;\n\n\t\tif (!add_caller(n, v))\n\t\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->slabs_partial",
            "lru"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->slabs_full",
            "lru"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_on",
          "args": [],
          "line": 4330
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2162-2165",
          "snippet": "static void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "n"
          ],
          "line": 4328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_cpu_caches",
          "args": [
            "cachep"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "drain_cpu_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2231-2250",
          "snippet": "static void drain_cpu_caches(struct kmem_cache *cachep)\n{\n\tstruct kmem_cache_node *n;\n\tint node;\n\tLIST_HEAD(list);\n\n\ton_each_cpu(do_drain, cachep, 1);\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n)\n\t\tif (n->alien)\n\t\t\tdrain_alien_cache(cachep, n->alien);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tdrain_array_locked(cachep, n->shared, node, true, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tslabs_destroy(cachep, &list);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_cpu_caches(struct kmem_cache *cachep)\n{\n\tstruct kmem_cache_node *n;\n\tint node;\n\tLIST_HEAD(list);\n\n\ton_each_cpu(do_drain, cachep, 1);\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n)\n\t\tif (n->alien)\n\t\t\tdrain_alien_cache(cachep, n->alien);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tdrain_array_locked(cachep, n->shared, node, true, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tslabs_destroy(cachep, &list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_store_user_clean",
          "args": [
            "cachep"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "set_store_user_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "372-375",
          "snippet": "static inline void set_store_user_clean(struct kmem_cache *cachep)\n{\n\tatomic_set(&cachep->store_user_clean, 1);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_store_user_clean(struct kmem_cache *cachep)\n{\n\tatomic_set(&cachep->store_user_clean, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structkmem_cache",
            "list"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int leaks_show(struct seq_file *m, void *p)\n{\n\tstruct kmem_cache *cachep = list_entry(p, struct kmem_cache, list);\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tconst char *name;\n\tunsigned long *x = m->private;\n\tint node;\n\tint i;\n\n\tif (!(cachep->flags & SLAB_STORE_USER))\n\t\treturn 0;\n\tif (!(cachep->flags & SLAB_RED_ZONE))\n\t\treturn 0;\n\n\t/*\n\t * Set store_user_clean and start to grab stored user information\n\t * for all objects on this cache. If some alloc/free requests comes\n\t * during the processing, information would be wrong so restart\n\t * whole processing.\n\t */\n\tdo {\n\t\tset_store_user_clean(cachep);\n\t\tdrain_cpu_caches(cachep);\n\n\t\tx[1] = 0;\n\n\t\tfor_each_kmem_cache_node(cachep, node, n) {\n\n\t\t\tcheck_irq_on();\n\t\t\tspin_lock_irq(&n->list_lock);\n\n\t\t\tlist_for_each_entry(page, &n->slabs_full, lru)\n\t\t\t\thandle_slab(x, cachep, page);\n\t\t\tlist_for_each_entry(page, &n->slabs_partial, lru)\n\t\t\t\thandle_slab(x, cachep, page);\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t}\n\t} while (!is_store_user_clean(cachep));\n\n\tname = cachep->name;\n\tif (x[0] == x[1]) {\n\t\t/* Increase the buffer size */\n\t\tmutex_unlock(&slab_mutex);\n\t\tm->private = kcalloc(x[0] * 4, sizeof(unsigned long),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!m->private) {\n\t\t\t/* Too bad, we are really out */\n\t\t\tm->private = x;\n\t\t\tmutex_lock(&slab_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t*(unsigned long *)m->private = x[0] * 2;\n\t\tkfree(x);\n\t\tmutex_lock(&slab_mutex);\n\t\t/* Now make sure this entry will be retried */\n\t\tm->count = m->size;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < x[1]; i++) {\n\t\tseq_printf(m, \"%s: %lu \", name, x[2*i+3]);\n\t\tshow_symbol(m, x[2*i+2]);\n\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "show_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4285-4299",
    "snippet": "static void show_symbol(struct seq_file *m, unsigned long address)\n{\n#ifdef CONFIG_KALLSYMS\n\tunsigned long offset, size;\n\tchar modname[MODULE_NAME_LEN], name[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_attrs(address, &size, &offset, modname, name) == 0) {\n\t\tseq_printf(m, \"%s+%#lx/%#lx\", name, offset, size);\n\t\tif (modname[0])\n\t\t\tseq_printf(m, \" [%s]\", modname);\n\t\treturn;\n\t}\n#endif\n\tseq_printf(m, \"%px\", (void *)address);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%px\"",
            "(void *)address"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" [%s]\"",
            "modname"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s+%#lx/%#lx\"",
            "name",
            "offset",
            "size"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_symbol_attrs",
          "args": [
            "address",
            "&size",
            "&offset",
            "modname",
            "name"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void show_symbol(struct seq_file *m, unsigned long address)\n{\n#ifdef CONFIG_KALLSYMS\n\tunsigned long offset, size;\n\tchar modname[MODULE_NAME_LEN], name[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_attrs(address, &size, &offset, modname, name) == 0) {\n\t\tseq_printf(m, \"%s+%#lx/%#lx\", name, offset, size);\n\t\tif (modname[0])\n\t\t\tseq_printf(m, \" [%s]\", modname);\n\t\treturn;\n\t}\n#endif\n\tseq_printf(m, \"%px\", (void *)address);\n}"
  },
  {
    "function_name": "handle_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4249-4283",
    "snippet": "static void handle_slab(unsigned long *n, struct kmem_cache *c,\n\t\t\t\t\t\tstruct page *page)\n{\n\tvoid *p;\n\tint i, j;\n\tunsigned long v;\n\n\tif (n[0] == n[1])\n\t\treturn;\n\tfor (i = 0, p = page->s_mem; i < c->num; i++, p += c->size) {\n\t\tbool active = true;\n\n\t\tfor (j = page->active; j < c->num; j++) {\n\t\t\tif (get_free_obj(page, j) == i) {\n\t\t\t\tactive = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!active)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * probe_kernel_read() is used for DEBUG_PAGEALLOC. page table\n\t\t * mapping is established when actual object allocation and\n\t\t * we could mistakenly access the unmapped object in the cpu\n\t\t * cache.\n\t\t */\n\t\tif (probe_kernel_read(&v, dbg_userword(c, p), sizeof(v)))\n\t\t\tcontinue;\n\n\t\tif (!add_caller(n, v))\n\t\t\treturn;\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_caller",
          "args": [
            "n",
            "v"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "add_caller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4219-4247",
          "snippet": "static inline int add_caller(unsigned long *n, unsigned long v)\n{\n\tunsigned long *p;\n\tint l;\n\tif (!v)\n\t\treturn 1;\n\tl = n[1];\n\tp = n + 2;\n\twhile (l) {\n\t\tint i = l/2;\n\t\tunsigned long *q = p + 2 * i;\n\t\tif (*q == v) {\n\t\t\tq[1]++;\n\t\t\treturn 1;\n\t\t}\n\t\tif (*q > v) {\n\t\t\tl = i;\n\t\t} else {\n\t\t\tp = q + 2;\n\t\t\tl -= i + 1;\n\t\t}\n\t}\n\tif (++n[1] == n[0])\n\t\treturn 0;\n\tmemmove(p + 2, p, n[1] * 2 * sizeof(unsigned long) - ((void *)p - (void *)n));\n\tp[0] = v;\n\tp[1] = 1;\n\treturn 1;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic inline int add_caller(unsigned long *n, unsigned long v)\n{\n\tunsigned long *p;\n\tint l;\n\tif (!v)\n\t\treturn 1;\n\tl = n[1];\n\tp = n + 2;\n\twhile (l) {\n\t\tint i = l/2;\n\t\tunsigned long *q = p + 2 * i;\n\t\tif (*q == v) {\n\t\t\tq[1]++;\n\t\t\treturn 1;\n\t\t}\n\t\tif (*q > v) {\n\t\t\tl = i;\n\t\t} else {\n\t\t\tp = q + 2;\n\t\t\tl -= i + 1;\n\t\t}\n\t}\n\tif (++n[1] == n[0])\n\t\treturn 0;\n\tmemmove(p + 2, p, n[1] * 2 * sizeof(unsigned long) - ((void *)p - (void *)n));\n\tp[0] = v;\n\tp[1] = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&v",
            "dbg_userword(c, p)",
            "sizeof(v)"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "__probe_kernel_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/maccess.c",
          "lines": "26-41",
          "snippet": "long __probe_kernel_read(void *dst, const void *src, size_t size)\n{\n\tlong ret;\n\tmm_segment_t old_fs = get_fs();\n\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\tcurrent->kernel_uaccess_faults_ok++;\n\tret = __copy_from_user_inatomic(dst,\n\t\t\t(__force const void __user *)src, size);\n\tcurrent->kernel_uaccess_faults_ok--;\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long __weak probe_kernel_read(void *dst, const void *src, size_t size)\n    __attribute__((alias(\"__probe_kernel_read\")));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nlong __weak probe_kernel_read(void *dst, const void *src, size_t size)\n    __attribute__((alias(\"__probe_kernel_read\")));\n\nlong __probe_kernel_read(void *dst, const void *src, size_t size)\n{\n\tlong ret;\n\tmm_segment_t old_fs = get_fs();\n\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\tcurrent->kernel_uaccess_faults_ok++;\n\tret = __copy_from_user_inatomic(dst,\n\t\t\t(__force const void __user *)src, size);\n\tcurrent->kernel_uaccess_faults_ok--;\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_userword",
          "args": [
            "c",
            "p"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_userword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "350-354",
          "snippet": "static void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tBYTES_PER_WORD\t\tsizeof(void *)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n\nstatic noinline struct;\n\nstatic void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_free_obj",
          "args": [
            "page",
            "j"
          ],
          "line": 4262
        },
        "resolved": true,
        "details": {
          "function_name": "get_free_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2393-2396",
          "snippet": "static inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void handle_slab(unsigned long *n, struct kmem_cache *c,\n\t\t\t\t\t\tstruct page *page)\n{\n\tvoid *p;\n\tint i, j;\n\tunsigned long v;\n\n\tif (n[0] == n[1])\n\t\treturn;\n\tfor (i = 0, p = page->s_mem; i < c->num; i++, p += c->size) {\n\t\tbool active = true;\n\n\t\tfor (j = page->active; j < c->num; j++) {\n\t\t\tif (get_free_obj(page, j) == i) {\n\t\t\t\tactive = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!active)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * probe_kernel_read() is used for DEBUG_PAGEALLOC. page table\n\t\t * mapping is established when actual object allocation and\n\t\t * we could mistakenly access the unmapped object in the cpu\n\t\t * cache.\n\t\t */\n\t\tif (probe_kernel_read(&v, dbg_userword(c, p), sizeof(v)))\n\t\t\tcontinue;\n\n\t\tif (!add_caller(n, v))\n\t\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "add_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4219-4247",
    "snippet": "static inline int add_caller(unsigned long *n, unsigned long v)\n{\n\tunsigned long *p;\n\tint l;\n\tif (!v)\n\t\treturn 1;\n\tl = n[1];\n\tp = n + 2;\n\twhile (l) {\n\t\tint i = l/2;\n\t\tunsigned long *q = p + 2 * i;\n\t\tif (*q == v) {\n\t\t\tq[1]++;\n\t\t\treturn 1;\n\t\t}\n\t\tif (*q > v) {\n\t\t\tl = i;\n\t\t} else {\n\t\t\tp = q + 2;\n\t\t\tl -= i + 1;\n\t\t}\n\t}\n\tif (++n[1] == n[0])\n\t\treturn 0;\n\tmemmove(p + 2, p, n[1] * 2 * sizeof(unsigned long) - ((void *)p - (void *)n));\n\tp[0] = v;\n\tp[1] = 1;\n\treturn 1;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p + 2",
            "p",
            "n[1] * 2 * sizeof(unsigned long) - ((void *)p - (void *)n)"
          ],
          "line": 4243
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic inline int add_caller(unsigned long *n, unsigned long v)\n{\n\tunsigned long *p;\n\tint l;\n\tif (!v)\n\t\treturn 1;\n\tl = n[1];\n\tp = n + 2;\n\twhile (l) {\n\t\tint i = l/2;\n\t\tunsigned long *q = p + 2 * i;\n\t\tif (*q == v) {\n\t\t\tq[1]++;\n\t\t\treturn 1;\n\t\t}\n\t\tif (*q > v) {\n\t\t\tl = i;\n\t\t} else {\n\t\t\tp = q + 2;\n\t\t\tl -= i + 1;\n\t\t}\n\t}\n\tif (++n[1] == n[0])\n\t\treturn 0;\n\tmemmove(p + 2, p, n[1] * 2 * sizeof(unsigned long) - ((void *)p - (void *)n));\n\tp[0] = v;\n\tp[1] = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "slabinfo_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4174-4215",
    "snippet": "ssize_t slabinfo_write(struct file *file, const char __user *buffer,\n\t\t       size_t count, loff_t *ppos)\n{\n\tchar kbuf[MAX_SLABINFO_WRITE + 1], *tmp;\n\tint limit, batchcount, shared, res;\n\tstruct kmem_cache *cachep;\n\n\tif (count > MAX_SLABINFO_WRITE)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&kbuf, buffer, count))\n\t\treturn -EFAULT;\n\tkbuf[MAX_SLABINFO_WRITE] = '\\0';\n\n\ttmp = strchr(kbuf, ' ');\n\tif (!tmp)\n\t\treturn -EINVAL;\n\t*tmp = '\\0';\n\ttmp++;\n\tif (sscanf(tmp, \" %d %d %d\", &limit, &batchcount, &shared) != 3)\n\t\treturn -EINVAL;\n\n\t/* Find the cache in the chain of caches. */\n\tmutex_lock(&slab_mutex);\n\tres = -EINVAL;\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tif (!strcmp(cachep->name, kbuf)) {\n\t\t\tif (limit < 1 || batchcount < 1 ||\n\t\t\t\t\tbatchcount > limit || shared < 0) {\n\t\t\t\tres = 0;\n\t\t\t} else {\n\t\t\t\tres = do_tune_cpucache(cachep, limit,\n\t\t\t\t\t\t       batchcount, shared,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&slab_mutex);\n\tif (res >= 0)\n\t\tres = count;\n\treturn res;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define MAX_SLABINFO_WRITE 128"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_tune_cpucache",
          "args": [
            "cachep",
            "limit",
            "batchcount",
            "shared",
            "GFP_KERNEL"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "do_tune_cpucache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3905-3926",
          "snippet": "static int do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tint ret;\n\tstruct kmem_cache *c;\n\n\tret = __do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\n\n\tif (slab_state < FULL)\n\t\treturn ret;\n\n\tif ((ret < 0) || !is_root_cache(cachep))\n\t\treturn ret;\n\n\tlockdep_assert_held(&slab_mutex);\n\tfor_each_memcg_cache(c, cachep) {\n\t\t/* return value determined by the root cache only */\n\t\t__do_tune_cpucache(c, limit, batchcount, shared, gfp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tint ret;\n\tstruct kmem_cache *c;\n\n\tret = __do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\n\n\tif (slab_state < FULL)\n\t\treturn ret;\n\n\tif ((ret < 0) || !is_root_cache(cachep))\n\t\treturn ret;\n\n\tlockdep_assert_held(&slab_mutex);\n\tfor_each_memcg_cache(c, cachep) {\n\t\t/* return value determined by the root cache only */\n\t\t__do_tune_cpucache(c, limit, batchcount, shared, gfp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cachep->name",
            "kbuf"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cachep",
            "&slab_caches",
            "list"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tmp",
            "\" %d %d %d\"",
            "&limit",
            "&batchcount",
            "&shared"
          ],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "kbuf",
            "' '"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&kbuf",
            "buffer",
            "count"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define MAX_SLABINFO_WRITE 128\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nssize_t slabinfo_write(struct file *file, const char __user *buffer,\n\t\t       size_t count, loff_t *ppos)\n{\n\tchar kbuf[MAX_SLABINFO_WRITE + 1], *tmp;\n\tint limit, batchcount, shared, res;\n\tstruct kmem_cache *cachep;\n\n\tif (count > MAX_SLABINFO_WRITE)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&kbuf, buffer, count))\n\t\treturn -EFAULT;\n\tkbuf[MAX_SLABINFO_WRITE] = '\\0';\n\n\ttmp = strchr(kbuf, ' ');\n\tif (!tmp)\n\t\treturn -EINVAL;\n\t*tmp = '\\0';\n\ttmp++;\n\tif (sscanf(tmp, \" %d %d %d\", &limit, &batchcount, &shared) != 3)\n\t\treturn -EINVAL;\n\n\t/* Find the cache in the chain of caches. */\n\tmutex_lock(&slab_mutex);\n\tres = -EINVAL;\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tif (!strcmp(cachep->name, kbuf)) {\n\t\t\tif (limit < 1 || batchcount < 1 ||\n\t\t\t\t\tbatchcount > limit || shared < 0) {\n\t\t\t\tres = 0;\n\t\t\t} else {\n\t\t\t\tres = do_tune_cpucache(cachep, limit,\n\t\t\t\t\t\t       batchcount, shared,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&slab_mutex);\n\tif (res >= 0)\n\t\tres = count;\n\treturn res;\n}"
  },
  {
    "function_name": "slabinfo_show_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4134-4164",
    "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *cachep)\n{\n#if STATS\n\t{\t\t\t/* node stats */\n\t\tunsigned long high = cachep->high_mark;\n\t\tunsigned long allocs = cachep->num_allocations;\n\t\tunsigned long grown = cachep->grown;\n\t\tunsigned long reaped = cachep->reaped;\n\t\tunsigned long errors = cachep->errors;\n\t\tunsigned long max_freeable = cachep->max_freeable;\n\t\tunsigned long node_allocs = cachep->node_allocs;\n\t\tunsigned long node_frees = cachep->node_frees;\n\t\tunsigned long overflows = cachep->node_overflow;\n\n\t\tseq_printf(m, \" : globalstat %7lu %6lu %5lu %4lu %4lu %4lu %4lu %4lu %4lu\",\n\t\t\t   allocs, high, grown,\n\t\t\t   reaped, errors, max_freeable, node_allocs,\n\t\t\t   node_frees, overflows);\n\t}\n\t/* cpu stats */\n\t{\n\t\tunsigned long allochit = atomic_read(&cachep->allochit);\n\t\tunsigned long allocmiss = atomic_read(&cachep->allocmiss);\n\t\tunsigned long freehit = atomic_read(&cachep->freehit);\n\t\tunsigned long freemiss = atomic_read(&cachep->freemiss);\n\n\t\tseq_printf(m, \" : cpustat %6lu %6lu %6lu %6lu\",\n\t\t\t   allochit, allocmiss, freehit, freemiss);\n\t}\n#endif\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tSTATS\t\t0",
      "#define\tSTATS\t\t1"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" : cpustat %6lu %6lu %6lu %6lu\"",
            "allochit",
            "allocmiss",
            "freehit",
            "freemiss"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cachep->freemiss"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cachep->freehit"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cachep->allocmiss"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cachep->allochit"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" : globalstat %7lu %6lu %5lu %4lu %4lu %4lu %4lu %4lu %4lu\"",
            "allocs",
            "high",
            "grown",
            "reaped",
            "errors",
            "max_freeable",
            "node_allocs",
            "node_frees",
            "overflows"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tSTATS\t\t0\n#define\tSTATS\t\t1\n\nstatic noinline struct;\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *cachep)\n{\n#if STATS\n\t{\t\t\t/* node stats */\n\t\tunsigned long high = cachep->high_mark;\n\t\tunsigned long allocs = cachep->num_allocations;\n\t\tunsigned long grown = cachep->grown;\n\t\tunsigned long reaped = cachep->reaped;\n\t\tunsigned long errors = cachep->errors;\n\t\tunsigned long max_freeable = cachep->max_freeable;\n\t\tunsigned long node_allocs = cachep->node_allocs;\n\t\tunsigned long node_frees = cachep->node_frees;\n\t\tunsigned long overflows = cachep->node_overflow;\n\n\t\tseq_printf(m, \" : globalstat %7lu %6lu %5lu %4lu %4lu %4lu %4lu %4lu %4lu\",\n\t\t\t   allocs, high, grown,\n\t\t\t   reaped, errors, max_freeable, node_allocs,\n\t\t\t   node_frees, overflows);\n\t}\n\t/* cpu stats */\n\t{\n\t\tunsigned long allochit = atomic_read(&cachep->allochit);\n\t\tunsigned long allocmiss = atomic_read(&cachep->allocmiss);\n\t\tunsigned long freehit = atomic_read(&cachep->freehit);\n\t\tunsigned long freemiss = atomic_read(&cachep->freemiss);\n\n\t\tseq_printf(m, \" : cpustat %6lu %6lu %6lu %6lu\",\n\t\t\t   allochit, allocmiss, freehit, freemiss);\n\t}\n#endif\n}"
  },
  {
    "function_name": "get_slabinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4097-4132",
    "snippet": "void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_on",
          "args": [],
          "line": 4106
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2162-2165",
          "snippet": "static void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "n"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}"
  },
  {
    "function_name": "cache_reap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4040-4095",
    "snippet": "static void cache_reap(struct work_struct *w)\n{\n\tstruct kmem_cache *searchp;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tstruct delayed_work *work = to_delayed_work(w);\n\n\tif (!mutex_trylock(&slab_mutex))\n\t\t/* Give up. Setup the next iteration. */\n\t\tgoto out;\n\n\tlist_for_each_entry(searchp, &slab_caches, list) {\n\t\tcheck_irq_on();\n\n\t\t/*\n\t\t * We only take the node lock if absolutely necessary and we\n\t\t * have established with reasonable certainty that\n\t\t * we can do some work if the lock was obtained.\n\t\t */\n\t\tn = get_node(searchp, node);\n\n\t\treap_alien(searchp, n);\n\n\t\tdrain_array(searchp, n, cpu_cache_get(searchp), node);\n\n\t\t/*\n\t\t * These are racy checks but it does not matter\n\t\t * if we skip one check or scan twice.\n\t\t */\n\t\tif (time_after(n->next_reap, jiffies))\n\t\t\tgoto next;\n\n\t\tn->next_reap = jiffies + REAPTIMEOUT_NODE;\n\n\t\tdrain_array(searchp, n, n->shared, node);\n\n\t\tif (n->free_touched)\n\t\t\tn->free_touched = 0;\n\t\telse {\n\t\t\tint freed;\n\n\t\t\tfreed = drain_freelist(searchp, n, (n->free_limit +\n\t\t\t\t5 * searchp->num - 1) / (5 * searchp->num));\n\t\t\tSTATS_ADD_REAPED(searchp, freed);\n\t\t}\nnext:\n\t\tcond_resched();\n\t}\n\tcheck_irq_on();\n\tmutex_unlock(&slab_mutex);\n\tnext_reap_node();\nout:\n\t/* Set up the next iteration */\n\tschedule_delayed_work_on(smp_processor_id(), work,\n\t\t\t\tround_jiffies_relative(REAPTIMEOUT_AC));\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define REAPTIMEOUT_NODE\t(4*HZ)",
      "#define REAPTIMEOUT_AC\t\t(2*HZ)"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work_on",
          "args": [
            "smp_processor_id()",
            "work",
            "round_jiffies_relative(REAPTIMEOUT_AC)"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_relative",
          "args": [
            "REAPTIMEOUT_AC"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_reap_node",
          "args": [],
          "line": 4090
        },
        "resolved": true,
        "details": {
          "function_name": "next_reap_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "532-538",
          "snippet": "static void next_reap_node(void)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tnode = next_node_in(node, node_online_map);\n\t__this_cpu_write(slab_reap_node, node);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void next_reap_node(void)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tnode = next_node_in(node, node_online_map);\n\t__this_cpu_write(slab_reap_node, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_on",
          "args": [],
          "line": 4088
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2162-2165",
          "snippet": "static void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_ADD_REAPED",
          "args": [
            "searchp",
            "freed"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_freelist",
          "args": [
            "searchp",
            "n",
            "(n->free_limit +\n\t\t\t\t5 * searchp->num - 1) / (5 * searchp->num)"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "drain_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2258-2290",
          "snippet": "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic noinline struct;\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_array",
          "args": [
            "searchp",
            "n",
            "n->shared",
            "node"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "drain_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4005-4026",
          "snippet": "static void drain_array(struct kmem_cache *cachep, struct kmem_cache_node *n,\n\t\t\t struct array_cache *ac, int node)\n{\n\tLIST_HEAD(list);\n\n\t/* ac from n->shared can be freed if we don't hold the slab_mutex. */\n\tcheck_mutex_acquired();\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\tif (ac->touched) {\n\t\tac->touched = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&n->list_lock);\n\tdrain_array_locked(cachep, ac, node, false, &list);\n\tspin_unlock_irq(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_array(struct kmem_cache *cachep, struct kmem_cache_node *n,\n\t\t\t struct array_cache *ac, int node)\n{\n\tLIST_HEAD(list);\n\n\t/* ac from n->shared can be freed if we don't hold the slab_mutex. */\n\tcheck_mutex_acquired();\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\tif (ac->touched) {\n\t\tac->touched = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&n->list_lock);\n\tdrain_array_locked(cachep, ac, node, false, &list);\n\tspin_unlock_irq(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "n->next_reap",
            "jiffies"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_cache_get",
          "args": [
            "searchp"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "434-437",
          "snippet": "static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reap_alien",
          "args": [
            "searchp",
            "n"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "reap_alien",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "749-768",
          "snippet": "static void reap_alien(struct kmem_cache *cachep, struct kmem_cache_node *n)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tif (n->alien) {\n\t\tstruct alien_cache *alc = n->alien[node];\n\t\tstruct array_cache *ac;\n\n\t\tif (alc) {\n\t\t\tac = &alc->ac;\n\t\t\tif (ac->avail && spin_trylock_irq(&alc->lock)) {\n\t\t\t\tLIST_HEAD(list);\n\n\t\t\t\t__drain_alien_cache(cachep, ac, node, &list);\n\t\t\t\tspin_unlock_irq(&alc->lock);\n\t\t\t\tslabs_destroy(cachep, &list);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void reap_alien(struct kmem_cache *cachep, struct kmem_cache_node *n)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tif (n->alien) {\n\t\tstruct alien_cache *alc = n->alien[node];\n\t\tstruct array_cache *ac;\n\n\t\tif (alc) {\n\t\t\tac = &alc->ac;\n\t\t\tif (ac->avail && spin_trylock_irq(&alc->lock)) {\n\t\t\t\tLIST_HEAD(list);\n\n\t\t\t\t__drain_alien_cache(cachep, ac, node, &list);\n\t\t\t\tspin_unlock_irq(&alc->lock);\n\t\t\t\tslabs_destroy(cachep, &list);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "searchp",
            "node"
          ],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "searchp",
            "&slab_caches",
            "list"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "w"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define REAPTIMEOUT_NODE\t(4*HZ)\n#define REAPTIMEOUT_AC\t\t(2*HZ)\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cache_reap(struct work_struct *w)\n{\n\tstruct kmem_cache *searchp;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tstruct delayed_work *work = to_delayed_work(w);\n\n\tif (!mutex_trylock(&slab_mutex))\n\t\t/* Give up. Setup the next iteration. */\n\t\tgoto out;\n\n\tlist_for_each_entry(searchp, &slab_caches, list) {\n\t\tcheck_irq_on();\n\n\t\t/*\n\t\t * We only take the node lock if absolutely necessary and we\n\t\t * have established with reasonable certainty that\n\t\t * we can do some work if the lock was obtained.\n\t\t */\n\t\tn = get_node(searchp, node);\n\n\t\treap_alien(searchp, n);\n\n\t\tdrain_array(searchp, n, cpu_cache_get(searchp), node);\n\n\t\t/*\n\t\t * These are racy checks but it does not matter\n\t\t * if we skip one check or scan twice.\n\t\t */\n\t\tif (time_after(n->next_reap, jiffies))\n\t\t\tgoto next;\n\n\t\tn->next_reap = jiffies + REAPTIMEOUT_NODE;\n\n\t\tdrain_array(searchp, n, n->shared, node);\n\n\t\tif (n->free_touched)\n\t\t\tn->free_touched = 0;\n\t\telse {\n\t\t\tint freed;\n\n\t\t\tfreed = drain_freelist(searchp, n, (n->free_limit +\n\t\t\t\t5 * searchp->num - 1) / (5 * searchp->num));\n\t\t\tSTATS_ADD_REAPED(searchp, freed);\n\t\t}\nnext:\n\t\tcond_resched();\n\t}\n\tcheck_irq_on();\n\tmutex_unlock(&slab_mutex);\n\tnext_reap_node();\nout:\n\t/* Set up the next iteration */\n\tschedule_delayed_work_on(smp_processor_id(), work,\n\t\t\t\tround_jiffies_relative(REAPTIMEOUT_AC));\n}"
  },
  {
    "function_name": "drain_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "4005-4026",
    "snippet": "static void drain_array(struct kmem_cache *cachep, struct kmem_cache_node *n,\n\t\t\t struct array_cache *ac, int node)\n{\n\tLIST_HEAD(list);\n\n\t/* ac from n->shared can be freed if we don't hold the slab_mutex. */\n\tcheck_mutex_acquired();\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\tif (ac->touched) {\n\t\tac->touched = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&n->list_lock);\n\tdrain_array_locked(cachep, ac, node, false, &list);\n\tspin_unlock_irq(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_array_locked",
          "args": [
            "cachep",
            "ac",
            "node",
            "false",
            "&list"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "drain_array_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2196-2211",
          "snippet": "static void drain_array_locked(struct kmem_cache *cachep, struct array_cache *ac,\n\t\t\t\tint node, bool free_all, struct list_head *list)\n{\n\tint tofree;\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\ttofree = free_all ? ac->avail : (ac->limit + 4) / 5;\n\tif (tofree > ac->avail)\n\t\ttofree = (ac->avail + 1) / 2;\n\n\tfree_block(cachep, ac->entry, tofree, node, list);\n\tac->avail -= tofree;\n\tmemmove(ac->entry, &(ac->entry[tofree]), sizeof(void *) * ac->avail);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_array_locked(struct kmem_cache *cachep, struct array_cache *ac,\n\t\t\t\tint node, bool free_all, struct list_head *list)\n{\n\tint tofree;\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\ttofree = free_all ? ac->avail : (ac->limit + 4) / 5;\n\tif (tofree > ac->avail)\n\t\ttofree = (ac->avail + 1) / 2;\n\n\tfree_block(cachep, ac->entry, tofree, node, list);\n\tac->avail -= tofree;\n\tmemmove(ac->entry, &(ac->entry[tofree]), sizeof(void *) * ac->avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mutex_acquired",
          "args": [],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "check_mutex_acquired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2167-2170",
          "snippet": "static void check_mutex_acquired(void)\n{\n\tBUG_ON(!mutex_is_locked(&slab_mutex));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_mutex_acquired(void)\n{\n\tBUG_ON(!mutex_is_locked(&slab_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_array(struct kmem_cache *cachep, struct kmem_cache_node *n,\n\t\t\t struct array_cache *ac, int node)\n{\n\tLIST_HEAD(list);\n\n\t/* ac from n->shared can be freed if we don't hold the slab_mutex. */\n\tcheck_mutex_acquired();\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\tif (ac->touched) {\n\t\tac->touched = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&n->list_lock);\n\tdrain_array_locked(cachep, ac, node, false, &list);\n\tspin_unlock_irq(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}"
  },
  {
    "function_name": "enable_cpucache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3929-3998",
    "snippet": "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"enable_cpucache failed for %s, error %d\\n\"",
            "cachep->name",
            "-err"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_tune_cpucache",
          "args": [
            "cachep",
            "limit",
            "batchcount",
            "shared",
            "gfp"
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "do_tune_cpucache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3905-3926",
          "snippet": "static int do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tint ret;\n\tstruct kmem_cache *c;\n\n\tret = __do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\n\n\tif (slab_state < FULL)\n\t\treturn ret;\n\n\tif ((ret < 0) || !is_root_cache(cachep))\n\t\treturn ret;\n\n\tlockdep_assert_held(&slab_mutex);\n\tfor_each_memcg_cache(c, cachep) {\n\t\t/* return value determined by the root cache only */\n\t\t__do_tune_cpucache(c, limit, batchcount, shared, gfp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tint ret;\n\tstruct kmem_cache *c;\n\n\tret = __do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\n\n\tif (slab_state < FULL)\n\t\treturn ret;\n\n\tif ((ret < 0) || !is_root_cache(cachep))\n\t\treturn ret;\n\n\tlockdep_assert_held(&slab_mutex);\n\tfor_each_memcg_cache(c, cachep) {\n\t\t/* return value determined by the root cache only */\n\t\t__do_tune_cpucache(c, limit, batchcount, shared, gfp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_root_cache",
          "args": [
            "cachep"
          ],
          "line": 3941
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "330-333",
          "snippet": "static inline struct kmem_cache *memcg_root_cache(struct kmem_cache *s)\n{\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *memcg_root_cache(struct kmem_cache *s)\n{\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "cachep"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_random_seq_create",
          "args": [
            "cachep",
            "cachep->num",
            "gfp"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "cache_random_seq_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "523-527",
          "snippet": "static inline int cache_random_seq_create(struct kmem_cache *cachep,\n\t\t\t\t\tunsigned int count, gfp_t gfp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline int cache_random_seq_create(struct kmem_cache *cachep,\n\t\t\t\t\tunsigned int count, gfp_t gfp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}"
  },
  {
    "function_name": "do_tune_cpucache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3905-3926",
    "snippet": "static int do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tint ret;\n\tstruct kmem_cache *c;\n\n\tret = __do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\n\n\tif (slab_state < FULL)\n\t\treturn ret;\n\n\tif ((ret < 0) || !is_root_cache(cachep))\n\t\treturn ret;\n\n\tlockdep_assert_held(&slab_mutex);\n\tfor_each_memcg_cache(c, cachep) {\n\t\t/* return value determined by the root cache only */\n\t\t__do_tune_cpucache(c, limit, batchcount, shared, gfp);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_tune_cpucache",
          "args": [
            "c",
            "limit",
            "batchcount",
            "shared",
            "gfp"
          ],
          "line": 3922
        },
        "resolved": true,
        "details": {
          "function_name": "__do_tune_cpucache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3859-3903",
          "snippet": "static int __do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tstruct array_cache __percpu *cpu_cache, *prev;\n\tint cpu;\n\n\tcpu_cache = alloc_kmem_cache_cpus(cachep, limit, batchcount);\n\tif (!cpu_cache)\n\t\treturn -ENOMEM;\n\n\tprev = cachep->cpu_cache;\n\tcachep->cpu_cache = cpu_cache;\n\t/*\n\t * Without a previous cpu_cache there's no need to synchronize remote\n\t * cpus, so skip the IPIs.\n\t */\n\tif (prev)\n\t\tkick_all_cpus_sync();\n\n\tcheck_irq_on();\n\tcachep->batchcount = batchcount;\n\tcachep->limit = limit;\n\tcachep->shared = shared;\n\n\tif (!prev)\n\t\tgoto setup_node;\n\n\tfor_each_online_cpu(cpu) {\n\t\tLIST_HEAD(list);\n\t\tint node;\n\t\tstruct kmem_cache_node *n;\n\t\tstruct array_cache *ac = per_cpu_ptr(prev, cpu);\n\n\t\tnode = cpu_to_mem(cpu);\n\t\tn = get_node(cachep, node);\n\t\tspin_lock_irq(&n->list_lock);\n\t\tfree_block(cachep, ac->entry, ac->avail, node, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\tfree_percpu(prev);\n\nsetup_node:\n\treturn setup_kmem_cache_nodes(cachep, gfp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int __do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tstruct array_cache __percpu *cpu_cache, *prev;\n\tint cpu;\n\n\tcpu_cache = alloc_kmem_cache_cpus(cachep, limit, batchcount);\n\tif (!cpu_cache)\n\t\treturn -ENOMEM;\n\n\tprev = cachep->cpu_cache;\n\tcachep->cpu_cache = cpu_cache;\n\t/*\n\t * Without a previous cpu_cache there's no need to synchronize remote\n\t * cpus, so skip the IPIs.\n\t */\n\tif (prev)\n\t\tkick_all_cpus_sync();\n\n\tcheck_irq_on();\n\tcachep->batchcount = batchcount;\n\tcachep->limit = limit;\n\tcachep->shared = shared;\n\n\tif (!prev)\n\t\tgoto setup_node;\n\n\tfor_each_online_cpu(cpu) {\n\t\tLIST_HEAD(list);\n\t\tint node;\n\t\tstruct kmem_cache_node *n;\n\t\tstruct array_cache *ac = per_cpu_ptr(prev, cpu);\n\n\t\tnode = cpu_to_mem(cpu);\n\t\tn = get_node(cachep, node);\n\t\tspin_lock_irq(&n->list_lock);\n\t\tfree_block(cachep, ac->entry, ac->avail, node, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\tfree_percpu(prev);\n\nsetup_node:\n\treturn setup_kmem_cache_nodes(cachep, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_memcg_cache",
          "args": [
            "c",
            "cachep"
          ],
          "line": 3920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&slab_mutex"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "cachep"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tint ret;\n\tstruct kmem_cache *c;\n\n\tret = __do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\n\n\tif (slab_state < FULL)\n\t\treturn ret;\n\n\tif ((ret < 0) || !is_root_cache(cachep))\n\t\treturn ret;\n\n\tlockdep_assert_held(&slab_mutex);\n\tfor_each_memcg_cache(c, cachep) {\n\t\t/* return value determined by the root cache only */\n\t\t__do_tune_cpucache(c, limit, batchcount, shared, gfp);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__do_tune_cpucache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3859-3903",
    "snippet": "static int __do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tstruct array_cache __percpu *cpu_cache, *prev;\n\tint cpu;\n\n\tcpu_cache = alloc_kmem_cache_cpus(cachep, limit, batchcount);\n\tif (!cpu_cache)\n\t\treturn -ENOMEM;\n\n\tprev = cachep->cpu_cache;\n\tcachep->cpu_cache = cpu_cache;\n\t/*\n\t * Without a previous cpu_cache there's no need to synchronize remote\n\t * cpus, so skip the IPIs.\n\t */\n\tif (prev)\n\t\tkick_all_cpus_sync();\n\n\tcheck_irq_on();\n\tcachep->batchcount = batchcount;\n\tcachep->limit = limit;\n\tcachep->shared = shared;\n\n\tif (!prev)\n\t\tgoto setup_node;\n\n\tfor_each_online_cpu(cpu) {\n\t\tLIST_HEAD(list);\n\t\tint node;\n\t\tstruct kmem_cache_node *n;\n\t\tstruct array_cache *ac = per_cpu_ptr(prev, cpu);\n\n\t\tnode = cpu_to_mem(cpu);\n\t\tn = get_node(cachep, node);\n\t\tspin_lock_irq(&n->list_lock);\n\t\tfree_block(cachep, ac->entry, ac->avail, node, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\tfree_percpu(prev);\n\nsetup_node:\n\treturn setup_kmem_cache_nodes(cachep, gfp);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_kmem_cache_nodes",
          "args": [
            "cachep",
            "gfp"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "setup_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3825-3856",
          "snippet": "static int setup_kmem_cache_nodes(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint ret;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_online_node(node) {\n\t\tret = setup_kmem_cache_node(cachep, node, gfp, true);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t}\n\n\treturn 0;\n\nfail:\n\tif (!cachep->list.next) {\n\t\t/* Cache is not active yet. Roll back what we did */\n\t\tnode--;\n\t\twhile (node >= 0) {\n\t\t\tn = get_node(cachep, node);\n\t\t\tif (n) {\n\t\t\t\tkfree(n->shared);\n\t\t\t\tfree_alien_cache(n->alien);\n\t\t\t\tkfree(n);\n\t\t\t\tcachep->node[node] = NULL;\n\t\t\t}\n\t\t\tnode--;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int setup_kmem_cache_nodes(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint ret;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_online_node(node) {\n\t\tret = setup_kmem_cache_node(cachep, node, gfp, true);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t}\n\n\treturn 0;\n\nfail:\n\tif (!cachep->list.next) {\n\t\t/* Cache is not active yet. Roll back what we did */\n\t\tnode--;\n\t\twhile (node >= 0) {\n\t\t\tn = get_node(cachep, node);\n\t\t\tif (n) {\n\t\t\t\tkfree(n->shared);\n\t\t\t\tfree_alien_cache(n->alien);\n\t\t\t\tkfree(n);\n\t\t\t\tcachep->node[node] = NULL;\n\t\t\t}\n\t\t\tnode--;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "prev"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 3897
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "ac->entry",
            "ac->avail",
            "node",
            "&list"
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_mem",
          "args": [
            "cpu"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "prev",
            "cpu"
          ],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_on",
          "args": [],
          "line": 3878
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2162-2165",
          "snippet": "static void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kick_all_cpus_sync",
          "args": [],
          "line": 3876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_kmem_cache_cpus",
          "args": [
            "cachep",
            "limit",
            "batchcount"
          ],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_kmem_cache_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1810-1829",
          "snippet": "static struct array_cache __percpu *alloc_kmem_cache_cpus(\n\t\tstruct kmem_cache *cachep, int entries, int batchcount)\n{\n\tint cpu;\n\tsize_t size;\n\tstruct array_cache __percpu *cpu_cache;\n\n\tsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tcpu_cache = __alloc_percpu(size, sizeof(void *));\n\n\tif (!cpu_cache)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinit_arraycache(per_cpu_ptr(cpu_cache, cpu),\n\t\t\t\tentries, batchcount);\n\t}\n\n\treturn cpu_cache;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct array_cache __percpu *alloc_kmem_cache_cpus(\n\t\tstruct kmem_cache *cachep, int entries, int batchcount)\n{\n\tint cpu;\n\tsize_t size;\n\tstruct array_cache __percpu *cpu_cache;\n\n\tsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tcpu_cache = __alloc_percpu(size, sizeof(void *));\n\n\tif (!cpu_cache)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinit_arraycache(per_cpu_ptr(cpu_cache, cpu),\n\t\t\t\tentries, batchcount);\n\t}\n\n\treturn cpu_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int __do_tune_cpucache(struct kmem_cache *cachep, int limit,\n\t\t\t\tint batchcount, int shared, gfp_t gfp)\n{\n\tstruct array_cache __percpu *cpu_cache, *prev;\n\tint cpu;\n\n\tcpu_cache = alloc_kmem_cache_cpus(cachep, limit, batchcount);\n\tif (!cpu_cache)\n\t\treturn -ENOMEM;\n\n\tprev = cachep->cpu_cache;\n\tcachep->cpu_cache = cpu_cache;\n\t/*\n\t * Without a previous cpu_cache there's no need to synchronize remote\n\t * cpus, so skip the IPIs.\n\t */\n\tif (prev)\n\t\tkick_all_cpus_sync();\n\n\tcheck_irq_on();\n\tcachep->batchcount = batchcount;\n\tcachep->limit = limit;\n\tcachep->shared = shared;\n\n\tif (!prev)\n\t\tgoto setup_node;\n\n\tfor_each_online_cpu(cpu) {\n\t\tLIST_HEAD(list);\n\t\tint node;\n\t\tstruct kmem_cache_node *n;\n\t\tstruct array_cache *ac = per_cpu_ptr(prev, cpu);\n\n\t\tnode = cpu_to_mem(cpu);\n\t\tn = get_node(cachep, node);\n\t\tspin_lock_irq(&n->list_lock);\n\t\tfree_block(cachep, ac->entry, ac->avail, node, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\tfree_percpu(prev);\n\nsetup_node:\n\treturn setup_kmem_cache_nodes(cachep, gfp);\n}"
  },
  {
    "function_name": "setup_kmem_cache_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3825-3856",
    "snippet": "static int setup_kmem_cache_nodes(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint ret;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_online_node(node) {\n\t\tret = setup_kmem_cache_node(cachep, node, gfp, true);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t}\n\n\treturn 0;\n\nfail:\n\tif (!cachep->list.next) {\n\t\t/* Cache is not active yet. Roll back what we did */\n\t\tnode--;\n\t\twhile (node >= 0) {\n\t\t\tn = get_node(cachep, node);\n\t\t\tif (n) {\n\t\t\t\tkfree(n->shared);\n\t\t\t\tfree_alien_cache(n->alien);\n\t\t\t\tkfree(n);\n\t\t\t\tcachep->node[node] = NULL;\n\t\t\t}\n\t\t\tnode--;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3802-3819",
          "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_alien_cache",
          "args": [
            "n->alien"
          ],
          "line": 3848
        },
        "resolved": true,
        "details": {
          "function_name": "free_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "713-722",
          "snippet": "static void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 3845
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "gfp",
            "true"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "setup_kmem_cache_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "912-976",
          "snippet": "static int setup_kmem_cache_node(struct kmem_cache *cachep,\n\t\t\t\tint node, gfp_t gfp, bool force_change)\n{\n\tint ret = -ENOMEM;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *old_shared = NULL;\n\tstruct array_cache *new_shared = NULL;\n\tstruct alien_cache **new_alien = NULL;\n\tLIST_HEAD(list);\n\n\tif (use_alien_caches) {\n\t\tnew_alien = alloc_alien_cache(node, cachep->limit, gfp);\n\t\tif (!new_alien)\n\t\t\tgoto fail;\n\t}\n\n\tif (cachep->shared) {\n\t\tnew_shared = alloc_arraycache(node,\n\t\t\tcachep->shared * cachep->batchcount, 0xbaadf00d, gfp);\n\t\tif (!new_shared)\n\t\t\tgoto fail;\n\t}\n\n\tret = init_cache_node(cachep, node, gfp);\n\tif (ret)\n\t\tgoto fail;\n\n\tn = get_node(cachep, node);\n\tspin_lock_irq(&n->list_lock);\n\tif (n->shared && force_change) {\n\t\tfree_block(cachep, n->shared->entry,\n\t\t\t\tn->shared->avail, node, &list);\n\t\tn->shared->avail = 0;\n\t}\n\n\tif (!n->shared || force_change) {\n\t\told_shared = n->shared;\n\t\tn->shared = new_shared;\n\t\tnew_shared = NULL;\n\t}\n\n\tif (!n->alien) {\n\t\tn->alien = new_alien;\n\t\tnew_alien = NULL;\n\t}\n\n\tspin_unlock_irq(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\n\t/*\n\t * To protect lockless access to n->shared during irq disabled context.\n\t * If n->shared isn't NULL in irq disabled context, accessing to it is\n\t * guaranteed to be valid until irq is re-enabled, because it will be\n\t * freed after synchronize_sched().\n\t */\n\tif (old_shared && force_change)\n\t\tsynchronize_sched();\n\nfail:\n\tkfree(old_shared);\n\tkfree(new_shared);\n\tfree_alien_cache(new_alien);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static int use_alien_caches",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic int use_alien_caches;\nstatic noinline struct;\n\nstatic int setup_kmem_cache_node(struct kmem_cache *cachep,\n\t\t\t\tint node, gfp_t gfp, bool force_change)\n{\n\tint ret = -ENOMEM;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *old_shared = NULL;\n\tstruct array_cache *new_shared = NULL;\n\tstruct alien_cache **new_alien = NULL;\n\tLIST_HEAD(list);\n\n\tif (use_alien_caches) {\n\t\tnew_alien = alloc_alien_cache(node, cachep->limit, gfp);\n\t\tif (!new_alien)\n\t\t\tgoto fail;\n\t}\n\n\tif (cachep->shared) {\n\t\tnew_shared = alloc_arraycache(node,\n\t\t\tcachep->shared * cachep->batchcount, 0xbaadf00d, gfp);\n\t\tif (!new_shared)\n\t\t\tgoto fail;\n\t}\n\n\tret = init_cache_node(cachep, node, gfp);\n\tif (ret)\n\t\tgoto fail;\n\n\tn = get_node(cachep, node);\n\tspin_lock_irq(&n->list_lock);\n\tif (n->shared && force_change) {\n\t\tfree_block(cachep, n->shared->entry,\n\t\t\t\tn->shared->avail, node, &list);\n\t\tn->shared->avail = 0;\n\t}\n\n\tif (!n->shared || force_change) {\n\t\told_shared = n->shared;\n\t\tn->shared = new_shared;\n\t\tnew_shared = NULL;\n\t}\n\n\tif (!n->alien) {\n\t\tn->alien = new_alien;\n\t\tnew_alien = NULL;\n\t}\n\n\tspin_unlock_irq(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\n\t/*\n\t * To protect lockless access to n->shared during irq disabled context.\n\t * If n->shared isn't NULL in irq disabled context, accessing to it is\n\t * guaranteed to be valid until irq is re-enabled, because it will be\n\t * freed after synchronize_sched().\n\t */\n\tif (old_shared && force_change)\n\t\tsynchronize_sched();\n\nfail:\n\tkfree(old_shared);\n\tkfree(new_shared);\n\tfree_alien_cache(new_alien);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int setup_kmem_cache_nodes(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint ret;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_online_node(node) {\n\t\tret = setup_kmem_cache_node(cachep, node, gfp, true);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t}\n\n\treturn 0;\n\nfail:\n\tif (!cachep->list.next) {\n\t\t/* Cache is not active yet. Roll back what we did */\n\t\tnode--;\n\t\twhile (node >= 0) {\n\t\t\tn = get_node(cachep, node);\n\t\t\tif (n) {\n\t\t\t\tkfree(n->shared);\n\t\t\t\tfree_alien_cache(n->alien);\n\t\t\t\tkfree(n);\n\t\t\t\tcachep->node[node] = NULL;\n\t\t\t}\n\t\t\tnode--;\n\t\t}\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "kfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3802-3819",
    "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cache_free",
          "args": [
            "c",
            "(void *)objp",
            "_RET_IP_"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "___cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3504-3540",
          "snippet": "void ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_obj_freed",
          "args": [
            "objp",
            "c->object_size"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "objp",
            "c->object_size"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_cache",
          "args": [
            "objp"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "397-401",
          "snippet": "static inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_debugcheck",
          "args": [
            "objp"
          ],
          "line": 3812
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_debugcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2754-2761",
          "snippet": "static void kfree_debugcheck(const void *objp)\n{\n\tif (!virt_addr_valid(objp)) {\n\t\tpr_err(\"kfree_debugcheck: out of range ptr %lxh\\n\",\n\t\t       (unsigned long)objp);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void kfree_debugcheck(const void *objp)\n{\n\tif (!virt_addr_valid(objp)) {\n\t\tpr_err(\"kfree_debugcheck: out of range ptr %lxh\\n\",\n\t\t       (unsigned long)objp);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(objp)"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "objp"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kfree",
          "args": [
            "_RET_IP_",
            "objp"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "kmem_cache_free_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3767-3790",
    "snippet": "void kmem_cache_free_bulk(struct kmem_cache *orig_s, size_t size, void **p)\n{\n\tstruct kmem_cache *s;\n\tsize_t i;\n\n\tlocal_irq_disable();\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *objp = p[i];\n\n\t\tif (!orig_s) /* called via kfree_bulk */\n\t\t\ts = virt_to_cache(objp);\n\t\telse\n\t\t\ts = cache_from_obj(orig_s, objp);\n\n\t\tdebug_check_no_locks_freed(objp, s->object_size);\n\t\tif (!(s->flags & SLAB_DEBUG_OBJECTS))\n\t\t\tdebug_check_no_obj_freed(objp, s->object_size);\n\n\t\t__cache_free(s, objp, _RET_IP_);\n\t}\n\tlocal_irq_enable();\n\n\t/* FIXME: add tracing */\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cache_free",
          "args": [
            "s",
            "objp",
            "_RET_IP_"
          ],
          "line": 3785
        },
        "resolved": true,
        "details": {
          "function_name": "___cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3504-3540",
          "snippet": "void ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_obj_freed",
          "args": [
            "objp",
            "s->object_size"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "objp",
            "s->object_size"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_from_obj",
          "args": [
            "orig_s",
            "objp"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "cache_from_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "356-381",
          "snippet": "static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_cache",
          "args": [
            "objp"
          ],
          "line": 3777
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "397-401",
          "snippet": "static inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free_bulk(struct kmem_cache *orig_s, size_t size, void **p)\n{\n\tstruct kmem_cache *s;\n\tsize_t i;\n\n\tlocal_irq_disable();\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *objp = p[i];\n\n\t\tif (!orig_s) /* called via kfree_bulk */\n\t\t\ts = virt_to_cache(objp);\n\t\telse\n\t\t\ts = cache_from_obj(orig_s, objp);\n\n\t\tdebug_check_no_locks_freed(objp, s->object_size);\n\t\tif (!(s->flags & SLAB_DEBUG_OBJECTS))\n\t\t\tdebug_check_no_obj_freed(objp, s->object_size);\n\n\t\t__cache_free(s, objp, _RET_IP_);\n\t}\n\tlocal_irq_enable();\n\n\t/* FIXME: add tracing */\n}"
  },
  {
    "function_name": "kmem_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3749-3764",
    "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmem_cache_free",
          "args": [
            "_RET_IP_",
            "objp"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cache_free",
          "args": [
            "cachep",
            "objp",
            "_RET_IP_"
          ],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "___cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3504-3540",
          "snippet": "void ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_obj_freed",
          "args": [
            "objp",
            "cachep->object_size"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "objp",
            "cachep->object_size"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_from_obj",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 3752
        },
        "resolved": true,
        "details": {
          "function_name": "cache_from_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "356-381",
          "snippet": "static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
  },
  {
    "function_name": "__kmalloc_track_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3735-3738",
    "snippet": "void *__kmalloc_track_caller(size_t size, gfp_t flags, unsigned long caller)\n{\n\treturn __do_kmalloc(size, flags, caller);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc",
          "args": [
            "size",
            "flags",
            "caller"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3709-3727",
          "snippet": "static __always_inline void *__do_kmalloc(size_t size, gfp_t flags,\n\t\t\t\t\t  unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = slab_alloc(cachep, flags, caller);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(caller, ret,\n\t\t      size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *__do_kmalloc(size_t size, gfp_t flags,\n\t\t\t\t\t  unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = slab_alloc(cachep, flags, caller);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(caller, ret,\n\t\t      size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_track_caller(size_t size, gfp_t flags, unsigned long caller)\n{\n\treturn __do_kmalloc(size, flags, caller);\n}"
  },
  {
    "function_name": "__kmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3729-3732",
    "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc",
          "args": [
            "size",
            "flags",
            "_RET_IP_"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3709-3727",
          "snippet": "static __always_inline void *__do_kmalloc(size_t size, gfp_t flags,\n\t\t\t\t\t  unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = slab_alloc(cachep, flags, caller);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(caller, ret,\n\t\t      size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *__do_kmalloc(size_t size, gfp_t flags,\n\t\t\t\t\t  unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = slab_alloc(cachep, flags, caller);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(caller, ret,\n\t\t      size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
  },
  {
    "function_name": "__do_kmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3709-3727",
    "snippet": "static __always_inline void *__do_kmalloc(size_t size, gfp_t flags,\n\t\t\t\t\t  unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = slab_alloc(cachep, flags, caller);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(caller, ret,\n\t\t      size, cachep->size, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmalloc",
          "args": [
            "caller",
            "ret",
            "size",
            "cachep->size",
            "flags"
          ],
          "line": 3723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "cachep",
            "ret",
            "size",
            "flags"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_alloc",
          "args": [
            "cachep",
            "flags",
            "caller"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3371-3394",
          "snippet": "static __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(cachep)"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "cachep"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "size",
            "flags"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > KMALLOC_MAX_CACHE_SIZE"
          ],
          "line": 3715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *__do_kmalloc(size_t size, gfp_t flags,\n\t\t\t\t\t  unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = slab_alloc(cachep, flags, caller);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(caller, ret,\n\t\t      size, cachep->size, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__kmalloc_node_track_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3695-3699",
    "snippet": "void *__kmalloc_node_track_caller(size_t size, gfp_t flags,\n\t\tint node, unsigned long caller)\n{\n\treturn __do_kmalloc_node(size, flags, node, caller);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc_node",
          "args": [
            "size",
            "flags",
            "node",
            "caller"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3672-3687",
          "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = kmem_cache_alloc_node_trace(cachep, flags, node, size);\n\tkasan_kmalloc(cachep, ret, size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = kmem_cache_alloc_node_trace(cachep, flags, node, size);\n\tkasan_kmalloc(cachep, ret, size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node_track_caller(size_t size, gfp_t flags,\n\t\tint node, unsigned long caller)\n{\n\treturn __do_kmalloc_node(size, flags, node, caller);\n}"
  },
  {
    "function_name": "__kmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3689-3692",
    "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc_node",
          "args": [
            "size",
            "flags",
            "node",
            "_RET_IP_"
          ],
          "line": 3691
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3672-3687",
          "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = kmem_cache_alloc_node_trace(cachep, flags, node, size);\n\tkasan_kmalloc(cachep, ret, size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = kmem_cache_alloc_node_trace(cachep, flags, node, size);\n\tkasan_kmalloc(cachep, ret, size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
  },
  {
    "function_name": "__do_kmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3672-3687",
    "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = kmem_cache_alloc_node_trace(cachep, flags, node, size);\n\tkasan_kmalloc(cachep, ret, size, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "cachep",
            "ret",
            "size",
            "flags"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc_node_trace",
          "args": [
            "cachep",
            "flags",
            "node",
            "size"
          ],
          "line": 3683
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc_node_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3654-3668",
          "snippet": "void *kmem_cache_alloc_node_trace(struct kmem_cache *cachep,\n\t\t\t\t  gfp_t flags,\n\t\t\t\t  int nodeid,\n\t\t\t\t  size_t size)\n{\n\tvoid *ret;\n\n\tret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, cachep->size,\n\t\t\t   flags, nodeid);\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc_node_trace(struct kmem_cache *cachep,\n\t\t\t\t  gfp_t flags,\n\t\t\t\t  int nodeid,\n\t\t\t\t  size_t size)\n{\n\tvoid *ret;\n\n\tret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, cachep->size,\n\t\t\t   flags, nodeid);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(cachep)"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "cachep"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "size",
            "flags"
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > KMALLOC_MAX_CACHE_SIZE"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn NULL;\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = kmem_cache_alloc_node_trace(cachep, flags, node, size);\n\tkasan_kmalloc(cachep, ret, size, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_node_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3654-3668",
    "snippet": "void *kmem_cache_alloc_node_trace(struct kmem_cache *cachep,\n\t\t\t\t  gfp_t flags,\n\t\t\t\t  int nodeid,\n\t\t\t\t  size_t size)\n{\n\tvoid *ret;\n\n\tret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, cachep->size,\n\t\t\t   flags, nodeid);\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "cachep->size",
            "flags",
            "nodeid"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "cachep",
            "ret",
            "size",
            "flags"
          ],
          "line": 3663
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_alloc_node",
          "args": [
            "cachep",
            "flags",
            "nodeid",
            "_RET_IP_"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3290-3337",
          "snippet": "static __always_inline void *\nslab_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid,\n\t\t   unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *ptr;\n\tint slab_node = numa_mem_id();\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\n\tif (nodeid == NUMA_NO_NODE)\n\t\tnodeid = slab_node;\n\n\tif (unlikely(!get_node(cachep, nodeid))) {\n\t\t/* Node not bootstrapped yet */\n\t\tptr = fallback_alloc(cachep, flags);\n\t\tgoto out;\n\t}\n\n\tif (nodeid == slab_node) {\n\t\t/*\n\t\t * Use the locally cached objects if possible.\n\t\t * However ____cache_alloc does not allow fallback\n\t\t * to other nodes. It may fail while we still have\n\t\t * objects on other nodes available.\n\t\t */\n\t\tptr = ____cache_alloc(cachep, flags);\n\t\tif (ptr)\n\t\t\tgoto out;\n\t}\n\t/* ___cache_alloc_node can fall back to other nodes */\n\tptr = ____cache_alloc_node(cachep, flags, nodeid);\n  out:\n\tlocal_irq_restore(save_flags);\n\tptr = cache_alloc_debugcheck_after(cachep, flags, ptr, caller);\n\n\tif (unlikely(flags & __GFP_ZERO) && ptr)\n\t\tmemset(ptr, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &ptr);\n\treturn ptr;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\nslab_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid,\n\t\t   unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *ptr;\n\tint slab_node = numa_mem_id();\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\n\tif (nodeid == NUMA_NO_NODE)\n\t\tnodeid = slab_node;\n\n\tif (unlikely(!get_node(cachep, nodeid))) {\n\t\t/* Node not bootstrapped yet */\n\t\tptr = fallback_alloc(cachep, flags);\n\t\tgoto out;\n\t}\n\n\tif (nodeid == slab_node) {\n\t\t/*\n\t\t * Use the locally cached objects if possible.\n\t\t * However ____cache_alloc does not allow fallback\n\t\t * to other nodes. It may fail while we still have\n\t\t * objects on other nodes available.\n\t\t */\n\t\tptr = ____cache_alloc(cachep, flags);\n\t\tif (ptr)\n\t\t\tgoto out;\n\t}\n\t/* ___cache_alloc_node can fall back to other nodes */\n\tptr = ____cache_alloc_node(cachep, flags, nodeid);\n  out:\n\tlocal_irq_restore(save_flags);\n\tptr = cache_alloc_debugcheck_after(cachep, flags, ptr, caller);\n\n\tif (unlikely(flags & __GFP_ZERO) && ptr)\n\t\tmemset(ptr, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &ptr);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc_node_trace(struct kmem_cache *cachep,\n\t\t\t\t  gfp_t flags,\n\t\t\t\t  int nodeid,\n\t\t\t\t  size_t size)\n{\n\tvoid *ret;\n\n\tret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, cachep->size,\n\t\t\t   flags, nodeid);\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3640-3650",
    "snippet": "void *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid)\n{\n\tvoid *ret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    cachep->object_size, cachep->size,\n\t\t\t\t    flags, nodeid);\n\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmem_cache_alloc_node",
          "args": [
            "_RET_IP_",
            "ret",
            "cachep->object_size",
            "cachep->size",
            "flags",
            "nodeid"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_slab_alloc",
          "args": [
            "cachep",
            "ret",
            "flags"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "488-491",
          "snippet": "void kasan_slab_alloc(struct kmem_cache *cache, void *object, gfp_t flags)\n{\n\tkasan_kmalloc(cache, object, cache->object_size, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_slab_alloc(struct kmem_cache *cache, void *object, gfp_t flags)\n{\n\tkasan_kmalloc(cache, object, cache->object_size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_alloc_node",
          "args": [
            "cachep",
            "flags",
            "nodeid",
            "_RET_IP_"
          ],
          "line": 3642
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3290-3337",
          "snippet": "static __always_inline void *\nslab_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid,\n\t\t   unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *ptr;\n\tint slab_node = numa_mem_id();\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\n\tif (nodeid == NUMA_NO_NODE)\n\t\tnodeid = slab_node;\n\n\tif (unlikely(!get_node(cachep, nodeid))) {\n\t\t/* Node not bootstrapped yet */\n\t\tptr = fallback_alloc(cachep, flags);\n\t\tgoto out;\n\t}\n\n\tif (nodeid == slab_node) {\n\t\t/*\n\t\t * Use the locally cached objects if possible.\n\t\t * However ____cache_alloc does not allow fallback\n\t\t * to other nodes. It may fail while we still have\n\t\t * objects on other nodes available.\n\t\t */\n\t\tptr = ____cache_alloc(cachep, flags);\n\t\tif (ptr)\n\t\t\tgoto out;\n\t}\n\t/* ___cache_alloc_node can fall back to other nodes */\n\tptr = ____cache_alloc_node(cachep, flags, nodeid);\n  out:\n\tlocal_irq_restore(save_flags);\n\tptr = cache_alloc_debugcheck_after(cachep, flags, ptr, caller);\n\n\tif (unlikely(flags & __GFP_ZERO) && ptr)\n\t\tmemset(ptr, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &ptr);\n\treturn ptr;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\nslab_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid,\n\t\t   unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *ptr;\n\tint slab_node = numa_mem_id();\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\n\tif (nodeid == NUMA_NO_NODE)\n\t\tnodeid = slab_node;\n\n\tif (unlikely(!get_node(cachep, nodeid))) {\n\t\t/* Node not bootstrapped yet */\n\t\tptr = fallback_alloc(cachep, flags);\n\t\tgoto out;\n\t}\n\n\tif (nodeid == slab_node) {\n\t\t/*\n\t\t * Use the locally cached objects if possible.\n\t\t * However ____cache_alloc does not allow fallback\n\t\t * to other nodes. It may fail while we still have\n\t\t * objects on other nodes available.\n\t\t */\n\t\tptr = ____cache_alloc(cachep, flags);\n\t\tif (ptr)\n\t\t\tgoto out;\n\t}\n\t/* ___cache_alloc_node can fall back to other nodes */\n\tptr = ____cache_alloc_node(cachep, flags, nodeid);\n  out:\n\tlocal_irq_restore(save_flags);\n\tptr = cache_alloc_debugcheck_after(cachep, flags, ptr, caller);\n\n\tif (unlikely(flags & __GFP_ZERO) && ptr)\n\t\tmemset(ptr, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &ptr);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid)\n{\n\tvoid *ret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    cachep->object_size, cachep->size,\n\t\t\t\t    flags, nodeid);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3613-3624",
    "snippet": "void *\nkmem_cache_alloc_trace(struct kmem_cache *cachep, gfp_t flags, size_t size)\n{\n\tvoid *ret;\n\n\tret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(_RET_IP_, ret,\n\t\t      size, cachep->size, flags);\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmalloc",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "cachep->size",
            "flags"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "cachep",
            "ret",
            "size",
            "flags"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_alloc",
          "args": [
            "cachep",
            "flags",
            "_RET_IP_"
          ],
          "line": 3618
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3371-3394",
          "snippet": "static __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *\nkmem_cache_alloc_trace(struct kmem_cache *cachep, gfp_t flags, size_t size)\n{\n\tvoid *ret;\n\n\tret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_kmalloc(cachep, ret, size, flags);\n\ttrace_kmalloc(_RET_IP_, ret,\n\t\t      size, cachep->size, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3572-3609",
    "snippet": "int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,\n\t\t\t  void **p)\n{\n\tsize_t i;\n\n\ts = slab_pre_alloc_hook(s, flags);\n\tif (!s)\n\t\treturn 0;\n\n\tcache_alloc_debugcheck_before(s, flags);\n\n\tlocal_irq_disable();\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *objp = __do_cache_alloc(s, flags);\n\n\t\tif (unlikely(!objp))\n\t\t\tgoto error;\n\t\tp[i] = objp;\n\t}\n\tlocal_irq_enable();\n\n\tcache_alloc_debugcheck_after_bulk(s, flags, size, p, _RET_IP_);\n\n\t/* Clear memory outside IRQ disabled section */\n\tif (unlikely(flags & __GFP_ZERO))\n\t\tfor (i = 0; i < size; i++)\n\t\t\tmemset(p[i], 0, s->object_size);\n\n\tslab_post_alloc_hook(s, flags, size, p);\n\t/* FIXME: Trace call missing. Christoph would like a bulk variant */\n\treturn size;\nerror:\n\tlocal_irq_enable();\n\tcache_alloc_debugcheck_after_bulk(s, flags, i, p, _RET_IP_);\n\tslab_post_alloc_hook(s, flags, i, p);\n\t__kmem_cache_free_bulk(s, i, p);\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_free_bulk",
          "args": [
            "s",
            "i",
            "p"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_free_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "103-113",
          "snippet": "void __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_post_alloc_hook",
          "args": [
            "s",
            "flags",
            "i",
            "p"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "slab_post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "433-449",
          "snippet": "static inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_alloc_debugcheck_after_bulk",
          "args": [
            "s",
            "flags",
            "i",
            "p",
            "_RET_IP_"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_debugcheck_after_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3562-3570",
          "snippet": "static __always_inline void\ncache_alloc_debugcheck_after_bulk(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t  size_t size, void **p, unsigned long caller)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tp[i] = cache_alloc_debugcheck_after(s, flags, p[i], caller);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void\ncache_alloc_debugcheck_after_bulk(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t  size_t size, void **p, unsigned long caller)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tp[i] = cache_alloc_debugcheck_after(s, flags, p[i], caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p[i]",
            "0",
            "s->object_size"
          ],
          "line": 3598
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & __GFP_ZERO"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!objp"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_cache_alloc",
          "args": [
            "s",
            "flags"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "__do_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3363-3367",
          "snippet": "static __always_inline void *\n__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn ____cache_alloc(cachep, flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\n__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn ____cache_alloc(cachep, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_alloc_debugcheck_before",
          "args": [
            "s",
            "flags"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_debugcheck_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3063-3067",
          "snippet": "static inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_pre_alloc_hook",
          "args": [
            "s",
            "flags"
          ],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "slab_pre_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "413-431",
          "snippet": "static inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nint kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,\n\t\t\t  void **p)\n{\n\tsize_t i;\n\n\ts = slab_pre_alloc_hook(s, flags);\n\tif (!s)\n\t\treturn 0;\n\n\tcache_alloc_debugcheck_before(s, flags);\n\n\tlocal_irq_disable();\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *objp = __do_cache_alloc(s, flags);\n\n\t\tif (unlikely(!objp))\n\t\t\tgoto error;\n\t\tp[i] = objp;\n\t}\n\tlocal_irq_enable();\n\n\tcache_alloc_debugcheck_after_bulk(s, flags, size, p, _RET_IP_);\n\n\t/* Clear memory outside IRQ disabled section */\n\tif (unlikely(flags & __GFP_ZERO))\n\t\tfor (i = 0; i < size; i++)\n\t\t\tmemset(p[i], 0, s->object_size);\n\n\tslab_post_alloc_hook(s, flags, size, p);\n\t/* FIXME: Trace call missing. Christoph would like a bulk variant */\n\treturn size;\nerror:\n\tlocal_irq_enable();\n\tcache_alloc_debugcheck_after_bulk(s, flags, i, p, _RET_IP_);\n\tslab_post_alloc_hook(s, flags, i, p);\n\t__kmem_cache_free_bulk(s, i, p);\n\treturn 0;\n}"
  },
  {
    "function_name": "cache_alloc_debugcheck_after_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3562-3570",
    "snippet": "static __always_inline void\ncache_alloc_debugcheck_after_bulk(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t  size_t size, void **p, unsigned long caller)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tp[i] = cache_alloc_debugcheck_after(s, flags, p[i], caller);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_alloc_debugcheck_after",
          "args": [
            "s",
            "flags",
            "p[i]",
            "caller"
          ],
          "line": 3569
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_debugcheck_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3070-3105",
          "snippet": "static void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void\ncache_alloc_debugcheck_after_bulk(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t  size_t size, void **p, unsigned long caller)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tp[i] = cache_alloc_debugcheck_after(s, flags, p[i], caller);\n}"
  },
  {
    "function_name": "kmem_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3550-3559",
    "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmem_cache_alloc",
          "args": [
            "_RET_IP_",
            "ret",
            "cachep->object_size",
            "cachep->size",
            "flags"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_slab_alloc",
          "args": [
            "cachep",
            "ret",
            "flags"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "488-491",
          "snippet": "void kasan_slab_alloc(struct kmem_cache *cache, void *object, gfp_t flags)\n{\n\tkasan_kmalloc(cache, object, cache->object_size, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_slab_alloc(struct kmem_cache *cache, void *object, gfp_t flags)\n{\n\tkasan_kmalloc(cache, object, cache->object_size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_alloc",
          "args": [
            "cachep",
            "flags",
            "_RET_IP_"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3371-3394",
          "snippet": "static __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "___cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3504-3540",
    "snippet": "void ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_free_pfmemalloc",
          "args": [
            "cachep",
            "page",
            "objp"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "cache_free_pfmemalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "593-608",
          "snippet": "static noinline void cache_free_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\t\tstruct page *page, void *objp)\n{\n\tstruct kmem_cache_node *n;\n\tint page_node;\n\tLIST_HEAD(list);\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\tspin_lock(&n->list_lock);\n\tfree_block(cachep, &objp, 1, page_node, &list);\n\tspin_unlock(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic noinline void cache_free_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\t\tstruct page *page, void *objp)\n{\n\tstruct kmem_cache_node *n;\n\tint page_node;\n\tLIST_HEAD(list);\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\tspin_lock(&n->list_lock);\n\tfree_block(cachep, &objp, 1, page_node, &list);\n\tspin_unlock(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageSlabPfmemalloc(page)"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "objp"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_memalloc_socks",
          "args": [],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_flusharray",
          "args": [
            "cachep",
            "ac"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "cache_flusharray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3444-3488",
          "snippet": "static void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tLIST_HEAD(list);\n\n\tbatchcount = ac->batchcount;\n\n\tcheck_irq_off();\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tif (n->shared) {\n\t\tstruct array_cache *shared_array = n->shared;\n\t\tint max = shared_array->limit - shared_array->avail;\n\t\tif (max) {\n\t\t\tif (batchcount > max)\n\t\t\t\tbatchcount = max;\n\t\t\tmemcpy(&(shared_array->entry[shared_array->avail]),\n\t\t\t       ac->entry, sizeof(void *) * batchcount);\n\t\t\tshared_array->avail += batchcount;\n\t\t\tgoto free_done;\n\t\t}\n\t}\n\n\tfree_block(cachep, ac->entry, batchcount, node, &list);\nfree_done:\n#if STATS\n\t{\n\t\tint i = 0;\n\t\tstruct page *page;\n\n\t\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\t\tBUG_ON(page->active);\n\n\t\t\ti++;\n\t\t}\n\t\tSTATS_SET_FREEABLE(cachep, i);\n\t}\n#endif\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail -= batchcount;\n\tmemmove(ac->entry, &(ac->entry[batchcount]), sizeof(void *)*ac->avail);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tSTATS\t\t0",
            "#define\tSTATS\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tSTATS\t\t0\n#define\tSTATS\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tLIST_HEAD(list);\n\n\tbatchcount = ac->batchcount;\n\n\tcheck_irq_off();\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tif (n->shared) {\n\t\tstruct array_cache *shared_array = n->shared;\n\t\tint max = shared_array->limit - shared_array->avail;\n\t\tif (max) {\n\t\t\tif (batchcount > max)\n\t\t\t\tbatchcount = max;\n\t\t\tmemcpy(&(shared_array->entry[shared_array->avail]),\n\t\t\t       ac->entry, sizeof(void *) * batchcount);\n\t\t\tshared_array->avail += batchcount;\n\t\t\tgoto free_done;\n\t\t}\n\t}\n\n\tfree_block(cachep, ac->entry, batchcount, node, &list);\nfree_done:\n#if STATS\n\t{\n\t\tint i = 0;\n\t\tstruct page *page;\n\n\t\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\t\tBUG_ON(page->active);\n\n\t\t\ti++;\n\t\t}\n\t\tSTATS_SET_FREEABLE(cachep, i);\n\t}\n#endif\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail -= batchcount;\n\tmemmove(ac->entry, &(ac->entry[batchcount]), sizeof(void *)*ac->avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATS_INC_FREEMISS",
          "args": [
            "cachep"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_FREEHIT",
          "args": [
            "cachep"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_free_alien",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "cache_free_alien",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "823-835",
          "snippet": "static inline int cache_free_alien(struct kmem_cache *cachep, void *objp)\n{\n\tint page_node = page_to_nid(virt_to_page(objp));\n\tint node = numa_mem_id();\n\t/*\n\t * Make sure we are not freeing a object from another node to the array\n\t * cache on this cpu.\n\t */\n\tif (likely(node == page_node))\n\t\treturn 0;\n\n\treturn __cache_free_alien(cachep, objp, node, page_node);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline int cache_free_alien(struct kmem_cache *cachep, void *objp)\n{\n\tint page_node = page_to_nid(virt_to_page(objp));\n\tint node = numa_mem_id();\n\t/*\n\t * Make sure we are not freeing a object from another node to the array\n\t * cache on this cpu.\n\t */\n\tif (likely(node == page_node))\n\t\treturn 0;\n\n\treturn __cache_free_alien(cachep, objp, node, page_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_free_debugcheck",
          "args": [
            "cachep",
            "objp",
            "caller"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "cache_free_debugcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2785-2817",
          "snippet": "static void *cache_free_debugcheck(struct kmem_cache *cachep, void *objp,\n\t\t\t\t   unsigned long caller)\n{\n\tunsigned int objnr;\n\tstruct page *page;\n\n\tBUG_ON(virt_to_cache(objp) != cachep);\n\n\tobjp -= obj_offset(cachep);\n\tkfree_debugcheck(objp);\n\tpage = virt_to_head_page(objp);\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tverify_redzone_free(cachep, objp);\n\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t}\n\tif (cachep->flags & SLAB_STORE_USER) {\n\t\tset_store_user_dirty(cachep);\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\t}\n\n\tobjnr = obj_to_index(cachep, page, objp);\n\n\tBUG_ON(objnr >= cachep->num);\n\tBUG_ON(objp != index_to_obj(cachep, page, objnr));\n\n\tif (cachep->flags & SLAB_POISON) {\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\tslab_kernel_map(cachep, objp, 0, caller);\n\t}\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *cache_free_debugcheck(struct kmem_cache *cachep, void *objp,\n\t\t\t\t   unsigned long caller)\n{\n\tunsigned int objnr;\n\tstruct page *page;\n\n\tBUG_ON(virt_to_cache(objp) != cachep);\n\n\tobjp -= obj_offset(cachep);\n\tkfree_debugcheck(objp);\n\tpage = virt_to_head_page(objp);\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tverify_redzone_free(cachep, objp);\n\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t}\n\tif (cachep->flags & SLAB_STORE_USER) {\n\t\tset_store_user_dirty(cachep);\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\t}\n\n\tobjnr = obj_to_index(cachep, page, objp);\n\n\tBUG_ON(objnr >= cachep->num);\n\tBUG_ON(objp != index_to_obj(cachep, page, objnr));\n\n\tif (cachep->flags & SLAB_POISON) {\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\tslab_kernel_map(cachep, objp, 0, caller);\n\t}\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free_recursive",
          "args": [
            "objp",
            "cachep->flags"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_cache_get",
          "args": [
            "cachep"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "434-437",
          "snippet": "static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}"
  },
  {
    "function_name": "__cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3494-3502",
    "snippet": "static __always_inline void __cache_free(struct kmem_cache *cachep, void *objp,\n\t\t\t\t\t unsigned long caller)\n{\n\t/* Put the object into the quarantine, don't touch it for now. */\n\tif (kasan_slab_free(cachep, objp, _RET_IP_))\n\t\treturn;\n\n\t___cache_free(cachep, objp, caller);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "___cache_free",
          "args": [
            "cachep",
            "objp",
            "caller"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "___cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3504-3540",
          "snippet": "void ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid ___cache_free(struct kmem_cache *cachep, void *objp,\n\t\tunsigned long caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (ac->avail < ac->limit) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t}\n\n\tif (sk_memalloc_socks()) {\n\t\tstruct page *page = virt_to_head_page(objp);\n\n\t\tif (unlikely(PageSlabPfmemalloc(page))) {\n\t\t\tcache_free_pfmemalloc(cachep, page, objp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tac->entry[ac->avail++] = objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_slab_free",
          "args": [
            "cachep",
            "objp",
            "_RET_IP_"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "526-529",
          "snippet": "bool kasan_slab_free(struct kmem_cache *cache, void *object, unsigned long ip)\n{\n\treturn __kasan_slab_free(cache, object, ip, true);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nbool kasan_slab_free(struct kmem_cache *cache, void *object, unsigned long ip)\n{\n\treturn __kasan_slab_free(cache, object, ip, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void __cache_free(struct kmem_cache *cachep, void *objp,\n\t\t\t\t\t unsigned long caller)\n{\n\t/* Put the object into the quarantine, don't touch it for now. */\n\tif (kasan_slab_free(cachep, objp, _RET_IP_))\n\t\treturn;\n\n\t___cache_free(cachep, objp, caller);\n}"
  },
  {
    "function_name": "cache_flusharray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3444-3488",
    "snippet": "static void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tLIST_HEAD(list);\n\n\tbatchcount = ac->batchcount;\n\n\tcheck_irq_off();\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tif (n->shared) {\n\t\tstruct array_cache *shared_array = n->shared;\n\t\tint max = shared_array->limit - shared_array->avail;\n\t\tif (max) {\n\t\t\tif (batchcount > max)\n\t\t\t\tbatchcount = max;\n\t\t\tmemcpy(&(shared_array->entry[shared_array->avail]),\n\t\t\t       ac->entry, sizeof(void *) * batchcount);\n\t\t\tshared_array->avail += batchcount;\n\t\t\tgoto free_done;\n\t\t}\n\t}\n\n\tfree_block(cachep, ac->entry, batchcount, node, &list);\nfree_done:\n#if STATS\n\t{\n\t\tint i = 0;\n\t\tstruct page *page;\n\n\t\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\t\tBUG_ON(page->active);\n\n\t\t\ti++;\n\t\t}\n\t\tSTATS_SET_FREEABLE(cachep, i);\n\t}\n#endif\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail -= batchcount;\n\tmemmove(ac->entry, &(ac->entry[batchcount]), sizeof(void *)*ac->avail);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tSTATS\t\t0",
      "#define\tSTATS\t\t1"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ac->entry",
            "&(ac->entry[batchcount])",
            "sizeof(void *)*ac->avail"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_SET_FREEABLE",
          "args": [
            "cachep",
            "i"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->active"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->slabs_free",
            "lru"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "ac->entry",
            "batchcount",
            "node",
            "&list"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&(shared_array->entry[shared_array->avail])",
            "ac->entry",
            "sizeof(void *) * batchcount"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 3454
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tSTATS\t\t0\n#define\tSTATS\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tLIST_HEAD(list);\n\n\tbatchcount = ac->batchcount;\n\n\tcheck_irq_off();\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tif (n->shared) {\n\t\tstruct array_cache *shared_array = n->shared;\n\t\tint max = shared_array->limit - shared_array->avail;\n\t\tif (max) {\n\t\t\tif (batchcount > max)\n\t\t\t\tbatchcount = max;\n\t\t\tmemcpy(&(shared_array->entry[shared_array->avail]),\n\t\t\t       ac->entry, sizeof(void *) * batchcount);\n\t\t\tshared_array->avail += batchcount;\n\t\t\tgoto free_done;\n\t\t}\n\t}\n\n\tfree_block(cachep, ac->entry, batchcount, node, &list);\nfree_done:\n#if STATS\n\t{\n\t\tint i = 0;\n\t\tstruct page *page;\n\n\t\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\t\tBUG_ON(page->active);\n\n\t\t\ti++;\n\t\t}\n\t\tSTATS_SET_FREEABLE(cachep, i);\n\t}\n#endif\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail -= batchcount;\n\tmemmove(ac->entry, &(ac->entry[batchcount]), sizeof(void *)*ac->avail);\n}"
  },
  {
    "function_name": "free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3400-3442",
    "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "list"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "&n->slabs_free",
            "structpage",
            "lru"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&n->slabs_free"
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&n->slabs_partial"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&n->slabs_free"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_DEC_ACTIVE",
          "args": [
            "cachep"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_put_obj",
          "args": [
            "cachep",
            "page",
            "objp"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "slab_put_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2606-2627",
          "snippet": "static void slab_put_obj(struct kmem_cache *cachep,\n\t\t\tstruct page *page, void *objp)\n{\n\tunsigned int objnr = obj_to_index(cachep, page, objp);\n#if DEBUG\n\tunsigned int i;\n\n\t/* Verify double free bug */\n\tfor (i = page->active; i < cachep->num; i++) {\n\t\tif (get_free_obj(page, i) == objnr) {\n\t\t\tpr_err(\"slab: double free detected in cache '%s', objp %px\\n\",\n\t\t\t       cachep->name, objp);\n\t\t\tBUG();\n\t\t}\n\t}\n#endif\n\tpage->active--;\n\tif (!page->freelist)\n\t\tpage->freelist = objp + obj_offset(cachep);\n\n\tset_free_obj(page, page->active, objnr);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void slab_put_obj(struct kmem_cache *cachep,\n\t\t\tstruct page *page, void *objp)\n{\n\tunsigned int objnr = obj_to_index(cachep, page, objp);\n#if DEBUG\n\tunsigned int i;\n\n\t/* Verify double free bug */\n\tfor (i = page->active; i < cachep->num; i++) {\n\t\tif (get_free_obj(page, i) == objnr) {\n\t\t\tpr_err(\"slab: double free detected in cache '%s', objp %px\\n\",\n\t\t\t       cachep->name, objp);\n\t\t\tBUG();\n\t\t}\n\t}\n#endif\n\tpage->active--;\n\tif (!page->freelist)\n\t\tpage->freelist = objp + obj_offset(cachep);\n\n\tset_free_obj(page, page->active, objnr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_spinlock_acquired_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "check_spinlock_acquired_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2180-2186",
          "snippet": "static void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, node)->list_lock);\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, node)->list_lock);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "objp"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
  },
  {
    "function_name": "slab_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3371-3394",
    "snippet": "static __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_post_alloc_hook",
          "args": [
            "cachep",
            "flags",
            "1",
            "&objp"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "slab_post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "433-449",
          "snippet": "static inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "objp",
            "0",
            "cachep->object_size"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & __GFP_ZERO"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefetchw",
          "args": [
            "objp"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_alloc_debugcheck_after",
          "args": [
            "cachep",
            "flags",
            "objp",
            "caller"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_debugcheck_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3070-3105",
          "snippet": "static void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "save_flags"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_cache_alloc",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "__do_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3363-3367",
          "snippet": "static __always_inline void *\n__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn ____cache_alloc(cachep, flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\n__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn ____cache_alloc(cachep, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "save_flags"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_alloc_debugcheck_before",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_debugcheck_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3063-3067",
          "snippet": "static inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cachep"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_pre_alloc_hook",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "slab_pre_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "413-431",
          "snippet": "static inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\nslab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *objp;\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\tobjp = __do_cache_alloc(cachep, flags);\n\tlocal_irq_restore(save_flags);\n\tobjp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);\n\tprefetchw(objp);\n\n\tif (unlikely(flags & __GFP_ZERO) && objp)\n\t\tmemset(objp, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &objp);\n\treturn objp;\n}"
  },
  {
    "function_name": "__do_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3363-3367",
    "snippet": "static __always_inline void *\n__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn ____cache_alloc(cachep, flags);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "____cache_alloc",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "____cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3110-3143",
          "snippet": "static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\n__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn ____cache_alloc(cachep, flags);\n}"
  },
  {
    "function_name": "__do_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3339-3360",
    "snippet": "static __always_inline void *\n__do_cache_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tvoid *objp;\n\n\tif (current->mempolicy || cpuset_do_slab_mem_spread()) {\n\t\tobjp = alternate_node_alloc(cache, flags);\n\t\tif (objp)\n\t\t\tgoto out;\n\t}\n\tobjp = ____cache_alloc(cache, flags);\n\n\t/*\n\t * We may just have run out of memory on the local node.\n\t * ____cache_alloc_node() knows how to locate memory on other nodes\n\t */\n\tif (!objp)\n\t\tobjp = ____cache_alloc_node(cache, flags, numa_mem_id());\n\n  out:\n\treturn objp;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "____cache_alloc_node",
          "args": [
            "cache",
            "flags",
            "numa_mem_id()"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "____cache_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3243-3288",
          "snippet": "static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "____cache_alloc",
          "args": [
            "cache",
            "flags"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "____cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3110-3143",
          "snippet": "static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alternate_node_alloc",
          "args": [
            "cache",
            "flags"
          ],
          "line": 3345
        },
        "resolved": true,
        "details": {
          "function_name": "alternate_node_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3152-3166",
          "snippet": "static void *alternate_node_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint nid_alloc, nid_here;\n\n\tif (in_interrupt() || (flags & __GFP_THISNODE))\n\t\treturn NULL;\n\tnid_alloc = nid_here = numa_mem_id();\n\tif (cpuset_do_slab_mem_spread() && (cachep->flags & SLAB_MEM_SPREAD))\n\t\tnid_alloc = cpuset_slab_spread_node();\n\telse if (current->mempolicy)\n\t\tnid_alloc = mempolicy_slab_node();\n\tif (nid_alloc != nid_here)\n\t\treturn ____cache_alloc_node(cachep, flags, nid_alloc);\n\treturn NULL;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *alternate_node_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint nid_alloc, nid_here;\n\n\tif (in_interrupt() || (flags & __GFP_THISNODE))\n\t\treturn NULL;\n\tnid_alloc = nid_here = numa_mem_id();\n\tif (cpuset_do_slab_mem_spread() && (cachep->flags & SLAB_MEM_SPREAD))\n\t\tnid_alloc = cpuset_slab_spread_node();\n\telse if (current->mempolicy)\n\t\tnid_alloc = mempolicy_slab_node();\n\tif (nid_alloc != nid_here)\n\t\treturn ____cache_alloc_node(cachep, flags, nid_alloc);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_do_slab_mem_spread",
          "args": [],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\n__do_cache_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tvoid *objp;\n\n\tif (current->mempolicy || cpuset_do_slab_mem_spread()) {\n\t\tobjp = alternate_node_alloc(cache, flags);\n\t\tif (objp)\n\t\t\tgoto out;\n\t}\n\tobjp = ____cache_alloc(cache, flags);\n\n\t/*\n\t * We may just have run out of memory on the local node.\n\t * ____cache_alloc_node() knows how to locate memory on other nodes\n\t */\n\tif (!objp)\n\t\tobjp = ____cache_alloc_node(cache, flags, numa_mem_id());\n\n  out:\n\treturn objp;\n}"
  },
  {
    "function_name": "slab_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3290-3337",
    "snippet": "static __always_inline void *\nslab_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid,\n\t\t   unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *ptr;\n\tint slab_node = numa_mem_id();\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\n\tif (nodeid == NUMA_NO_NODE)\n\t\tnodeid = slab_node;\n\n\tif (unlikely(!get_node(cachep, nodeid))) {\n\t\t/* Node not bootstrapped yet */\n\t\tptr = fallback_alloc(cachep, flags);\n\t\tgoto out;\n\t}\n\n\tif (nodeid == slab_node) {\n\t\t/*\n\t\t * Use the locally cached objects if possible.\n\t\t * However ____cache_alloc does not allow fallback\n\t\t * to other nodes. It may fail while we still have\n\t\t * objects on other nodes available.\n\t\t */\n\t\tptr = ____cache_alloc(cachep, flags);\n\t\tif (ptr)\n\t\t\tgoto out;\n\t}\n\t/* ___cache_alloc_node can fall back to other nodes */\n\tptr = ____cache_alloc_node(cachep, flags, nodeid);\n  out:\n\tlocal_irq_restore(save_flags);\n\tptr = cache_alloc_debugcheck_after(cachep, flags, ptr, caller);\n\n\tif (unlikely(flags & __GFP_ZERO) && ptr)\n\t\tmemset(ptr, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &ptr);\n\treturn ptr;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_post_alloc_hook",
          "args": [
            "cachep",
            "flags",
            "1",
            "&ptr"
          ],
          "line": 3335
        },
        "resolved": true,
        "details": {
          "function_name": "slab_post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "433-449",
          "snippet": "static inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "cachep->object_size"
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & __GFP_ZERO"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_alloc_debugcheck_after",
          "args": [
            "cachep",
            "flags",
            "ptr",
            "caller"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_debugcheck_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3070-3105",
          "snippet": "static void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "save_flags"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "____cache_alloc_node",
          "args": [
            "cachep",
            "flags",
            "nodeid"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "____cache_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3243-3288",
          "snippet": "static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "____cache_alloc",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3322
        },
        "resolved": true,
        "details": {
          "function_name": "____cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3110-3143",
          "snippet": "static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fallback_alloc",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3176-3238",
          "snippet": "static void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *obj = NULL;\n\tstruct page *page;\n\tint nid;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (flags & __GFP_THISNODE)\n\t\treturn NULL;\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\nretry:\n\t/*\n\t * Look through allowed nodes for objects available\n\t * from existing per node queues.\n\t */\n\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\tnid = zone_to_nid(zone);\n\n\t\tif (cpuset_zone_allowed(zone, flags) &&\n\t\t\tget_node(cache, nid) &&\n\t\t\tget_node(cache, nid)->free_objects) {\n\t\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\t\tgfp_exact_node(flags), nid);\n\t\t\t\tif (obj)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!obj) {\n\t\t/*\n\t\t * This allocation will be performed within the constraints\n\t\t * of the current cpuset / memory policy requirements.\n\t\t * We may trigger various forms of reclaim on the allowed\n\t\t * set and go into memory reserves if necessary.\n\t\t */\n\t\tpage = cache_grow_begin(cache, flags, numa_mem_id());\n\t\tcache_grow_end(cache, page);\n\t\tif (page) {\n\t\t\tnid = page_to_nid(page);\n\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\tgfp_exact_node(flags), nid);\n\n\t\t\t/*\n\t\t\t * Another processor may allocate the objects in\n\t\t\t * the slab since we are not holding any locks.\n\t\t\t */\n\t\t\tif (!obj)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (unlikely(!obj && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn obj;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *obj = NULL;\n\tstruct page *page;\n\tint nid;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (flags & __GFP_THISNODE)\n\t\treturn NULL;\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\nretry:\n\t/*\n\t * Look through allowed nodes for objects available\n\t * from existing per node queues.\n\t */\n\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\tnid = zone_to_nid(zone);\n\n\t\tif (cpuset_zone_allowed(zone, flags) &&\n\t\t\tget_node(cache, nid) &&\n\t\t\tget_node(cache, nid)->free_objects) {\n\t\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\t\tgfp_exact_node(flags), nid);\n\t\t\t\tif (obj)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!obj) {\n\t\t/*\n\t\t * This allocation will be performed within the constraints\n\t\t * of the current cpuset / memory policy requirements.\n\t\t * We may trigger various forms of reclaim on the allowed\n\t\t * set and go into memory reserves if necessary.\n\t\t */\n\t\tpage = cache_grow_begin(cache, flags, numa_mem_id());\n\t\tcache_grow_end(cache, page);\n\t\tif (page) {\n\t\t\tnid = page_to_nid(page);\n\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\tgfp_exact_node(flags), nid);\n\n\t\t\t/*\n\t\t\t * Another processor may allocate the objects in\n\t\t\t * the slab since we are not holding any locks.\n\t\t\t */\n\t\t\tif (!obj)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (unlikely(!obj && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!get_node(cachep, nodeid)"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "nodeid"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "save_flags"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_alloc_debugcheck_before",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_debugcheck_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3063-3067",
          "snippet": "static inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cachep"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_pre_alloc_hook",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3299
        },
        "resolved": true,
        "details": {
          "function_name": "slab_pre_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "413-431",
          "snippet": "static inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline void *\nslab_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid,\n\t\t   unsigned long caller)\n{\n\tunsigned long save_flags;\n\tvoid *ptr;\n\tint slab_node = numa_mem_id();\n\n\tflags &= gfp_allowed_mask;\n\tcachep = slab_pre_alloc_hook(cachep, flags);\n\tif (unlikely(!cachep))\n\t\treturn NULL;\n\n\tcache_alloc_debugcheck_before(cachep, flags);\n\tlocal_irq_save(save_flags);\n\n\tif (nodeid == NUMA_NO_NODE)\n\t\tnodeid = slab_node;\n\n\tif (unlikely(!get_node(cachep, nodeid))) {\n\t\t/* Node not bootstrapped yet */\n\t\tptr = fallback_alloc(cachep, flags);\n\t\tgoto out;\n\t}\n\n\tif (nodeid == slab_node) {\n\t\t/*\n\t\t * Use the locally cached objects if possible.\n\t\t * However ____cache_alloc does not allow fallback\n\t\t * to other nodes. It may fail while we still have\n\t\t * objects on other nodes available.\n\t\t */\n\t\tptr = ____cache_alloc(cachep, flags);\n\t\tif (ptr)\n\t\t\tgoto out;\n\t}\n\t/* ___cache_alloc_node can fall back to other nodes */\n\tptr = ____cache_alloc_node(cachep, flags, nodeid);\n  out:\n\tlocal_irq_restore(save_flags);\n\tptr = cache_alloc_debugcheck_after(cachep, flags, ptr, caller);\n\n\tif (unlikely(flags & __GFP_ZERO) && ptr)\n\t\tmemset(ptr, 0, cachep->object_size);\n\n\tslab_post_alloc_hook(cachep, flags, 1, &ptr);\n\treturn ptr;\n}"
  },
  {
    "function_name": "____cache_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3243-3288",
    "snippet": "static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fallback_alloc",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3176-3238",
          "snippet": "static void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *obj = NULL;\n\tstruct page *page;\n\tint nid;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (flags & __GFP_THISNODE)\n\t\treturn NULL;\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\nretry:\n\t/*\n\t * Look through allowed nodes for objects available\n\t * from existing per node queues.\n\t */\n\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\tnid = zone_to_nid(zone);\n\n\t\tif (cpuset_zone_allowed(zone, flags) &&\n\t\t\tget_node(cache, nid) &&\n\t\t\tget_node(cache, nid)->free_objects) {\n\t\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\t\tgfp_exact_node(flags), nid);\n\t\t\t\tif (obj)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!obj) {\n\t\t/*\n\t\t * This allocation will be performed within the constraints\n\t\t * of the current cpuset / memory policy requirements.\n\t\t * We may trigger various forms of reclaim on the allowed\n\t\t * set and go into memory reserves if necessary.\n\t\t */\n\t\tpage = cache_grow_begin(cache, flags, numa_mem_id());\n\t\tcache_grow_end(cache, page);\n\t\tif (page) {\n\t\t\tnid = page_to_nid(page);\n\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\tgfp_exact_node(flags), nid);\n\n\t\t\t/*\n\t\t\t * Another processor may allocate the objects in\n\t\t\t * the slab since we are not holding any locks.\n\t\t\t */\n\t\t\tif (!obj)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (unlikely(!obj && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn obj;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *obj = NULL;\n\tstruct page *page;\n\tint nid;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (flags & __GFP_THISNODE)\n\t\treturn NULL;\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\nretry:\n\t/*\n\t * Look through allowed nodes for objects available\n\t * from existing per node queues.\n\t */\n\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\tnid = zone_to_nid(zone);\n\n\t\tif (cpuset_zone_allowed(zone, flags) &&\n\t\t\tget_node(cache, nid) &&\n\t\t\tget_node(cache, nid)->free_objects) {\n\t\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\t\tgfp_exact_node(flags), nid);\n\t\t\t\tif (obj)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!obj) {\n\t\t/*\n\t\t * This allocation will be performed within the constraints\n\t\t * of the current cpuset / memory policy requirements.\n\t\t * We may trigger various forms of reclaim on the allowed\n\t\t * set and go into memory reserves if necessary.\n\t\t */\n\t\tpage = cache_grow_begin(cache, flags, numa_mem_id());\n\t\tcache_grow_end(cache, page);\n\t\tif (page) {\n\t\t\tnid = page_to_nid(page);\n\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\tgfp_exact_node(flags), nid);\n\n\t\t\t/*\n\t\t\t * Another processor may allocate the objects in\n\t\t\t * the slab since we are not holding any locks.\n\t\t\t */\n\t\t\tif (!obj)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (unlikely(!obj && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_grow_end",
          "args": [
            "cachep",
            "page"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "cache_grow_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2719-2745",
          "snippet": "static void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_get_obj",
          "args": [
            "cachep",
            "page"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "slab_get_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2591-2604",
          "snippet": "static void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_grow_begin",
          "args": [
            "cachep",
            "gfp_exact_node(flags)",
            "nodeid"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "cache_grow_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2645-2717",
          "snippet": "static struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_exact_node",
          "args": [
            "flags"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "gfp_exact_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "841-844",
          "snippet": "static inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_objfreelist_debug",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_objfreelist_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2824-2837",
          "snippet": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_slab_list",
          "args": [
            "cachep",
            "n",
            "page",
            "&list"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_slab_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2839-2861",
          "snippet": "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->active == cachep->num"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_SET_HIGH",
          "args": [
            "cachep"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_ACTIVE",
          "args": [
            "cachep"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_NODEALLOCS",
          "args": [
            "cachep"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_spinlock_acquired_node",
          "args": [
            "cachep",
            "nodeid"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "check_spinlock_acquired_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2180-2186",
          "snippet": "static void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, node)->list_lock);\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, node)->list_lock);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_slab",
          "args": [
            "n",
            "false"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2906-2924",
          "snippet": "static struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!n"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "nodeid"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "nodeid < 0 || nodeid >= MAX_NUMNODES"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}"
  },
  {
    "function_name": "fallback_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3176-3238",
    "snippet": "static void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *obj = NULL;\n\tstruct page *page;\n\tint nid;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (flags & __GFP_THISNODE)\n\t\treturn NULL;\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\nretry:\n\t/*\n\t * Look through allowed nodes for objects available\n\t * from existing per node queues.\n\t */\n\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\tnid = zone_to_nid(zone);\n\n\t\tif (cpuset_zone_allowed(zone, flags) &&\n\t\t\tget_node(cache, nid) &&\n\t\t\tget_node(cache, nid)->free_objects) {\n\t\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\t\tgfp_exact_node(flags), nid);\n\t\t\t\tif (obj)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!obj) {\n\t\t/*\n\t\t * This allocation will be performed within the constraints\n\t\t * of the current cpuset / memory policy requirements.\n\t\t * We may trigger various forms of reclaim on the allowed\n\t\t * set and go into memory reserves if necessary.\n\t\t */\n\t\tpage = cache_grow_begin(cache, flags, numa_mem_id());\n\t\tcache_grow_end(cache, page);\n\t\tif (page) {\n\t\t\tnid = page_to_nid(page);\n\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\tgfp_exact_node(flags), nid);\n\n\t\t\t/*\n\t\t\t * Another processor may allocate the objects in\n\t\t\t * the slab since we are not holding any locks.\n\t\t\t */\n\t\t\tif (!obj)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (unlikely(!obj && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn obj;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!obj && read_mems_allowed_retry(cpuset_mems_cookie)"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_retry",
          "args": [
            "cpuset_mems_cookie"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "____cache_alloc_node",
          "args": [
            "cache",
            "gfp_exact_node(flags)",
            "nid"
          ],
          "line": 3223
        },
        "resolved": true,
        "details": {
          "function_name": "____cache_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3243-3288",
          "snippet": "static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_exact_node",
          "args": [
            "flags"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "gfp_exact_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "841-844",
          "snippet": "static inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_grow_end",
          "args": [
            "cache",
            "page"
          ],
          "line": 3220
        },
        "resolved": true,
        "details": {
          "function_name": "cache_grow_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2719-2745",
          "snippet": "static void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_grow_begin",
          "args": [
            "cache",
            "flags",
            "numa_mem_id()"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "cache_grow_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2645-2717",
          "snippet": "static struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cache",
            "nid"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_zone_allowed",
          "args": [
            "zone",
            "flags"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist",
          "args": [
            "zone",
            "z",
            "zonelist",
            "high_zoneidx"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "mempolicy_slab_node()",
            "flags"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempolicy_slab_node",
          "args": [],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "mempolicy_slab_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1767-1807",
          "snippet": "unsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nunsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_begin",
          "args": [],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "flags"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)\n{\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *obj = NULL;\n\tstruct page *page;\n\tint nid;\n\tunsigned int cpuset_mems_cookie;\n\n\tif (flags & __GFP_THISNODE)\n\t\treturn NULL;\n\nretry_cpuset:\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\nretry:\n\t/*\n\t * Look through allowed nodes for objects available\n\t * from existing per node queues.\n\t */\n\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\tnid = zone_to_nid(zone);\n\n\t\tif (cpuset_zone_allowed(zone, flags) &&\n\t\t\tget_node(cache, nid) &&\n\t\t\tget_node(cache, nid)->free_objects) {\n\t\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\t\tgfp_exact_node(flags), nid);\n\t\t\t\tif (obj)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!obj) {\n\t\t/*\n\t\t * This allocation will be performed within the constraints\n\t\t * of the current cpuset / memory policy requirements.\n\t\t * We may trigger various forms of reclaim on the allowed\n\t\t * set and go into memory reserves if necessary.\n\t\t */\n\t\tpage = cache_grow_begin(cache, flags, numa_mem_id());\n\t\tcache_grow_end(cache, page);\n\t\tif (page) {\n\t\t\tnid = page_to_nid(page);\n\t\t\tobj = ____cache_alloc_node(cache,\n\t\t\t\tgfp_exact_node(flags), nid);\n\n\t\t\t/*\n\t\t\t * Another processor may allocate the objects in\n\t\t\t * the slab since we are not holding any locks.\n\t\t\t */\n\t\t\tif (!obj)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (unlikely(!obj && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn obj;\n}"
  },
  {
    "function_name": "alternate_node_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3152-3166",
    "snippet": "static void *alternate_node_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint nid_alloc, nid_here;\n\n\tif (in_interrupt() || (flags & __GFP_THISNODE))\n\t\treturn NULL;\n\tnid_alloc = nid_here = numa_mem_id();\n\tif (cpuset_do_slab_mem_spread() && (cachep->flags & SLAB_MEM_SPREAD))\n\t\tnid_alloc = cpuset_slab_spread_node();\n\telse if (current->mempolicy)\n\t\tnid_alloc = mempolicy_slab_node();\n\tif (nid_alloc != nid_here)\n\t\treturn ____cache_alloc_node(cachep, flags, nid_alloc);\n\treturn NULL;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "____cache_alloc_node",
          "args": [
            "cachep",
            "flags",
            "nid_alloc"
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "____cache_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3243-3288",
          "snippet": "static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tvoid *obj = NULL;\n\tvoid *list = NULL;\n\n\tVM_BUG_ON(nodeid < 0 || nodeid >= MAX_NUMNODES);\n\tn = get_node(cachep, nodeid);\n\tBUG_ON(!n);\n\n\tcheck_irq_off();\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, false);\n\tif (!page)\n\t\tgoto must_grow;\n\n\tcheck_spinlock_acquired_node(cachep, nodeid);\n\n\tSTATS_INC_NODEALLOCS(cachep);\n\tSTATS_INC_ACTIVE(cachep);\n\tSTATS_SET_HIGH(cachep);\n\n\tBUG_ON(page->active == cachep->num);\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\treturn obj;\n\nmust_grow:\n\tspin_unlock(&n->list_lock);\n\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), nodeid);\n\tif (page) {\n\t\t/* This slab isn't counted yet so don't update free_objects */\n\t\tobj = slab_get_obj(cachep, page);\n\t}\n\tcache_grow_end(cachep, page);\n\n\treturn obj ? obj : fallback_alloc(cachep, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempolicy_slab_node",
          "args": [],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "mempolicy_slab_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1767-1807",
          "snippet": "unsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nunsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_slab_spread_node",
          "args": [],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_do_slab_mem_spread",
          "args": [],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *alternate_node_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint nid_alloc, nid_here;\n\n\tif (in_interrupt() || (flags & __GFP_THISNODE))\n\t\treturn NULL;\n\tnid_alloc = nid_here = numa_mem_id();\n\tif (cpuset_do_slab_mem_spread() && (cachep->flags & SLAB_MEM_SPREAD))\n\t\tnid_alloc = cpuset_slab_spread_node();\n\telse if (current->mempolicy)\n\t\tnid_alloc = mempolicy_slab_node();\n\tif (nid_alloc != nid_here)\n\t\treturn ____cache_alloc_node(cachep, flags, nid_alloc);\n\treturn NULL;\n}"
  },
  {
    "function_name": "____cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3110-3143",
    "snippet": "static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_erase",
          "args": [
            "&ac->entry[ac->avail]"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_cache_get",
          "args": [
            "cachep"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "434-437",
          "snippet": "static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_alloc_refill",
          "args": [
            "cachep",
            "flags"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_refill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2978-3061",
          "snippet": "static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *ac, *shared;\n\tint node;\n\tvoid *list = NULL;\n\tstruct page *page;\n\n\tcheck_irq_off();\n\tnode = numa_mem_id();\n\n\tac = cpu_cache_get(cachep);\n\tbatchcount = ac->batchcount;\n\tif (!ac->touched && batchcount > BATCHREFILL_LIMIT) {\n\t\t/*\n\t\t * If there was little recent activity on this cache, then\n\t\t * perform only a partial refill.  Otherwise we could generate\n\t\t * refill bouncing.\n\t\t */\n\t\tbatchcount = BATCHREFILL_LIMIT;\n\t}\n\tn = get_node(cachep, node);\n\n\tBUG_ON(ac->avail > 0 || !n);\n\tshared = READ_ONCE(n->shared);\n\tif (!n->free_objects && (!shared || !shared->avail))\n\t\tgoto direct_grow;\n\n\tspin_lock(&n->list_lock);\n\tshared = READ_ONCE(n->shared);\n\n\t/* See if we can refill from the shared array */\n\tif (shared && transfer_objects(ac, shared, batchcount)) {\n\t\tshared->touched = 1;\n\t\tgoto alloc_done;\n\t}\n\n\twhile (batchcount > 0) {\n\t\t/* Get slab alloc is to come from. */\n\t\tpage = get_first_slab(n, false);\n\t\tif (!page)\n\t\t\tgoto must_grow;\n\n\t\tcheck_spinlock_acquired(cachep);\n\n\t\tbatchcount = alloc_block(cachep, ac, page, batchcount);\n\t\tfixup_slab_list(cachep, n, page, &list);\n\t}\n\nmust_grow:\n\tn->free_objects -= ac->avail;\nalloc_done:\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\ndirect_grow:\n\tif (unlikely(!ac->avail)) {\n\t\t/* Check if we can use obj in pfmemalloc slab */\n\t\tif (sk_memalloc_socks()) {\n\t\t\tvoid *obj = cache_alloc_pfmemalloc(cachep, n, flags);\n\n\t\t\tif (obj)\n\t\t\t\treturn obj;\n\t\t}\n\n\t\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), node);\n\n\t\t/*\n\t\t * cache_grow_begin() can reenable interrupts,\n\t\t * then ac could change.\n\t\t */\n\t\tac = cpu_cache_get(cachep);\n\t\tif (!ac->avail && page)\n\t\t\talloc_block(cachep, ac, page, batchcount);\n\t\tcache_grow_end(cachep, page);\n\n\t\tif (!ac->avail)\n\t\t\treturn NULL;\n\t}\n\tac->touched = 1;\n\n\treturn ac->entry[--ac->avail];\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define BATCHREFILL_LIMIT\t16"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define BATCHREFILL_LIMIT\t16\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *ac, *shared;\n\tint node;\n\tvoid *list = NULL;\n\tstruct page *page;\n\n\tcheck_irq_off();\n\tnode = numa_mem_id();\n\n\tac = cpu_cache_get(cachep);\n\tbatchcount = ac->batchcount;\n\tif (!ac->touched && batchcount > BATCHREFILL_LIMIT) {\n\t\t/*\n\t\t * If there was little recent activity on this cache, then\n\t\t * perform only a partial refill.  Otherwise we could generate\n\t\t * refill bouncing.\n\t\t */\n\t\tbatchcount = BATCHREFILL_LIMIT;\n\t}\n\tn = get_node(cachep, node);\n\n\tBUG_ON(ac->avail > 0 || !n);\n\tshared = READ_ONCE(n->shared);\n\tif (!n->free_objects && (!shared || !shared->avail))\n\t\tgoto direct_grow;\n\n\tspin_lock(&n->list_lock);\n\tshared = READ_ONCE(n->shared);\n\n\t/* See if we can refill from the shared array */\n\tif (shared && transfer_objects(ac, shared, batchcount)) {\n\t\tshared->touched = 1;\n\t\tgoto alloc_done;\n\t}\n\n\twhile (batchcount > 0) {\n\t\t/* Get slab alloc is to come from. */\n\t\tpage = get_first_slab(n, false);\n\t\tif (!page)\n\t\t\tgoto must_grow;\n\n\t\tcheck_spinlock_acquired(cachep);\n\n\t\tbatchcount = alloc_block(cachep, ac, page, batchcount);\n\t\tfixup_slab_list(cachep, n, page, &list);\n\t}\n\nmust_grow:\n\tn->free_objects -= ac->avail;\nalloc_done:\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\ndirect_grow:\n\tif (unlikely(!ac->avail)) {\n\t\t/* Check if we can use obj in pfmemalloc slab */\n\t\tif (sk_memalloc_socks()) {\n\t\t\tvoid *obj = cache_alloc_pfmemalloc(cachep, n, flags);\n\n\t\t\tif (obj)\n\t\t\t\treturn obj;\n\t\t}\n\n\t\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), node);\n\n\t\t/*\n\t\t * cache_grow_begin() can reenable interrupts,\n\t\t * then ac could change.\n\t\t */\n\t\tac = cpu_cache_get(cachep);\n\t\tif (!ac->avail && page)\n\t\t\talloc_block(cachep, ac, page, batchcount);\n\t\tcache_grow_end(cachep, page);\n\n\t\tif (!ac->avail)\n\t\t\treturn NULL;\n\t}\n\tac->touched = 1;\n\n\treturn ac->entry[--ac->avail];\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATS_INC_ALLOCMISS",
          "args": [
            "cachep"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_ALLOCHIT",
          "args": [
            "cachep"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ac->avail"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n\tstruct array_cache *ac;\n\n\tcheck_irq_off();\n\n\tac = cpu_cache_get(cachep);\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n\t\tobjp = ac->entry[--ac->avail];\n\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}"
  },
  {
    "function_name": "cache_alloc_debugcheck_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3070-3105",
    "snippet": "static void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\"",
            "objp",
            "(int)ARCH_SLAB_MINALIGN"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachep->ctor",
          "args": [
            "objp"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_redzone2",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "339-348",
          "snippet": "static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_redzone1",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "332-337",
          "snippet": "static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\"",
            "objp",
            "*dbg_redzone1(cachep, objp)",
            "*dbg_redzone2(cachep, objp)"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_error",
          "args": [
            "cachep",
            "\"double free, or memory outside object was overwritten\""
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_userword",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_userword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "350-354",
          "snippet": "static void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tBYTES_PER_WORD\t\tsizeof(void *)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n\nstatic noinline struct;\n\nstatic void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poison_obj",
          "args": [
            "cachep",
            "objp",
            "POISON_INUSE"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "poison_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1531-1538",
          "snippet": "static void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_kernel_map",
          "args": [
            "cachep",
            "objp",
            "1",
            "0"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "slab_kernel_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1526-1527",
          "snippet": "static inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}"
        }
      },
      {
        "call_info": {
          "callee": "check_poison_obj",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "check_poison_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1596-1656",
          "snippet": "static void check_poison_obj(struct kmem_cache *cachep, void *objp)\n{\n\tchar *realobj;\n\tint size, i;\n\tint lines = 0;\n\n\tif (is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\n\tfor (i = 0; i < size; i++) {\n\t\tchar exp = POISON_FREE;\n\t\tif (i == size - 1)\n\t\t\texp = POISON_END;\n\t\tif (realobj[i] != exp) {\n\t\t\tint limit;\n\t\t\t/* Mismatch ! */\n\t\t\t/* Print header */\n\t\t\tif (lines == 0) {\n\t\t\t\tpr_err(\"Slab corruption (%s): %s start=%px, len=%d\\n\",\n\t\t\t\t       print_tainted(), cachep->name,\n\t\t\t\t       realobj, size);\n\t\t\t\tprint_objinfo(cachep, objp, 0);\n\t\t\t}\n\t\t\t/* Hexdump the affected line */\n\t\t\ti = (i / 16) * 16;\n\t\t\tlimit = 16;\n\t\t\tif (i + limit > size)\n\t\t\t\tlimit = size - i;\n\t\t\tdump_line(realobj, i, limit);\n\t\t\ti += 16;\n\t\t\tlines++;\n\t\t\t/* Limit to 5 lines */\n\t\t\tif (lines > 5)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (lines != 0) {\n\t\t/* Print some data about the neighboring objects, if they\n\t\t * exist:\n\t\t */\n\t\tstruct page *page = virt_to_head_page(objp);\n\t\tunsigned int objnr;\n\n\t\tobjnr = obj_to_index(cachep, page, objp);\n\t\tif (objnr) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr - 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Prev obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t\tif (objnr + 1 < cachep->num) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr + 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Next obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_poison_obj(struct kmem_cache *cachep, void *objp)\n{\n\tchar *realobj;\n\tint size, i;\n\tint lines = 0;\n\n\tif (is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\n\tfor (i = 0; i < size; i++) {\n\t\tchar exp = POISON_FREE;\n\t\tif (i == size - 1)\n\t\t\texp = POISON_END;\n\t\tif (realobj[i] != exp) {\n\t\t\tint limit;\n\t\t\t/* Mismatch ! */\n\t\t\t/* Print header */\n\t\t\tif (lines == 0) {\n\t\t\t\tpr_err(\"Slab corruption (%s): %s start=%px, len=%d\\n\",\n\t\t\t\t       print_tainted(), cachep->name,\n\t\t\t\t       realobj, size);\n\t\t\t\tprint_objinfo(cachep, objp, 0);\n\t\t\t}\n\t\t\t/* Hexdump the affected line */\n\t\t\ti = (i / 16) * 16;\n\t\t\tlimit = 16;\n\t\t\tif (i + limit > size)\n\t\t\t\tlimit = size - i;\n\t\t\tdump_line(realobj, i, limit);\n\t\t\ti += 16;\n\t\t\tlines++;\n\t\t\t/* Limit to 5 lines */\n\t\t\tif (lines > 5)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (lines != 0) {\n\t\t/* Print some data about the neighboring objects, if they\n\t\t * exist:\n\t\t */\n\t\tstruct page *page = virt_to_head_page(objp);\n\t\tunsigned int objnr;\n\n\t\tobjnr = obj_to_index(cachep, page, objp);\n\t\tif (objnr) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr - 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Prev obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t\tif (objnr + 1 < cachep->num) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr + 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Next obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cachep->ctor && (flags & __GFP_ZERO)"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, void *objp, unsigned long caller)\n{\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tif (!objp)\n\t\treturn objp;\n\tif (cachep->flags & SLAB_POISON) {\n\t\tcheck_poison_obj(cachep, objp);\n\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\tpoison_obj(cachep, objp, POISON_INUSE);\n\t}\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE ||\n\t\t\t\t*dbg_redzone2(cachep, objp) != RED_INACTIVE) {\n\t\t\tslab_error(cachep, \"double free, or memory outside object was overwritten\");\n\t\t\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t\t\t       objp, *dbg_redzone1(cachep, objp),\n\t\t\t       *dbg_redzone2(cachep, objp));\n\t\t}\n\t\t*dbg_redzone1(cachep, objp) = RED_ACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_ACTIVE;\n\t}\n\n\tobjp += obj_offset(cachep);\n\tif (cachep->ctor && cachep->flags & SLAB_POISON)\n\t\tcachep->ctor(objp);\n\tif (ARCH_SLAB_MINALIGN &&\n\t    ((unsigned long)objp & (ARCH_SLAB_MINALIGN-1))) {\n\t\tpr_err(\"0x%px: not aligned to ARCH_SLAB_MINALIGN=%d\\n\",\n\t\t       objp, (int)ARCH_SLAB_MINALIGN);\n\t}\n\treturn objp;\n}"
  },
  {
    "function_name": "cache_alloc_debugcheck_before",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "3063-3067",
    "snippet": "static inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "might_sleep_if",
          "args": [
            "gfpflags_allow_blocking(flags)"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "flags"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n}"
  },
  {
    "function_name": "cache_alloc_refill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2978-3061",
    "snippet": "static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *ac, *shared;\n\tint node;\n\tvoid *list = NULL;\n\tstruct page *page;\n\n\tcheck_irq_off();\n\tnode = numa_mem_id();\n\n\tac = cpu_cache_get(cachep);\n\tbatchcount = ac->batchcount;\n\tif (!ac->touched && batchcount > BATCHREFILL_LIMIT) {\n\t\t/*\n\t\t * If there was little recent activity on this cache, then\n\t\t * perform only a partial refill.  Otherwise we could generate\n\t\t * refill bouncing.\n\t\t */\n\t\tbatchcount = BATCHREFILL_LIMIT;\n\t}\n\tn = get_node(cachep, node);\n\n\tBUG_ON(ac->avail > 0 || !n);\n\tshared = READ_ONCE(n->shared);\n\tif (!n->free_objects && (!shared || !shared->avail))\n\t\tgoto direct_grow;\n\n\tspin_lock(&n->list_lock);\n\tshared = READ_ONCE(n->shared);\n\n\t/* See if we can refill from the shared array */\n\tif (shared && transfer_objects(ac, shared, batchcount)) {\n\t\tshared->touched = 1;\n\t\tgoto alloc_done;\n\t}\n\n\twhile (batchcount > 0) {\n\t\t/* Get slab alloc is to come from. */\n\t\tpage = get_first_slab(n, false);\n\t\tif (!page)\n\t\t\tgoto must_grow;\n\n\t\tcheck_spinlock_acquired(cachep);\n\n\t\tbatchcount = alloc_block(cachep, ac, page, batchcount);\n\t\tfixup_slab_list(cachep, n, page, &list);\n\t}\n\nmust_grow:\n\tn->free_objects -= ac->avail;\nalloc_done:\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\ndirect_grow:\n\tif (unlikely(!ac->avail)) {\n\t\t/* Check if we can use obj in pfmemalloc slab */\n\t\tif (sk_memalloc_socks()) {\n\t\t\tvoid *obj = cache_alloc_pfmemalloc(cachep, n, flags);\n\n\t\t\tif (obj)\n\t\t\t\treturn obj;\n\t\t}\n\n\t\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), node);\n\n\t\t/*\n\t\t * cache_grow_begin() can reenable interrupts,\n\t\t * then ac could change.\n\t\t */\n\t\tac = cpu_cache_get(cachep);\n\t\tif (!ac->avail && page)\n\t\t\talloc_block(cachep, ac, page, batchcount);\n\t\tcache_grow_end(cachep, page);\n\n\t\tif (!ac->avail)\n\t\t\treturn NULL;\n\t}\n\tac->touched = 1;\n\n\treturn ac->entry[--ac->avail];\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define BATCHREFILL_LIMIT\t16"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_grow_end",
          "args": [
            "cachep",
            "page"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "cache_grow_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2719-2745",
          "snippet": "static void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_block",
          "args": [
            "cachep",
            "ac",
            "page",
            "batchcount"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2958-2976",
          "snippet": "static __always_inline int alloc_block(struct kmem_cache *cachep,\n\t\tstruct array_cache *ac, struct page *page, int batchcount)\n{\n\t/*\n\t * There must be at least one object available for\n\t * allocation.\n\t */\n\tBUG_ON(page->active >= cachep->num);\n\n\twhile (page->active < cachep->num && batchcount--) {\n\t\tSTATS_INC_ALLOCED(cachep);\n\t\tSTATS_INC_ACTIVE(cachep);\n\t\tSTATS_SET_HIGH(cachep);\n\n\t\tac->entry[ac->avail++] = slab_get_obj(cachep, page);\n\t}\n\n\treturn batchcount;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline int alloc_block(struct kmem_cache *cachep,\n\t\tstruct array_cache *ac, struct page *page, int batchcount)\n{\n\t/*\n\t * There must be at least one object available for\n\t * allocation.\n\t */\n\tBUG_ON(page->active >= cachep->num);\n\n\twhile (page->active < cachep->num && batchcount--) {\n\t\tSTATS_INC_ALLOCED(cachep);\n\t\tSTATS_INC_ACTIVE(cachep);\n\t\tSTATS_SET_HIGH(cachep);\n\n\t\tac->entry[ac->avail++] = slab_get_obj(cachep, page);\n\t}\n\n\treturn batchcount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_cache_get",
          "args": [
            "cachep"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "434-437",
          "snippet": "static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_grow_begin",
          "args": [
            "cachep",
            "gfp_exact_node(flags)",
            "node"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "cache_grow_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2645-2717",
          "snippet": "static struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_exact_node",
          "args": [
            "flags"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "gfp_exact_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "841-844",
          "snippet": "static inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_alloc_pfmemalloc",
          "args": [
            "cachep",
            "n",
            "flags"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "cache_alloc_pfmemalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2926-2952",
          "snippet": "static noinline void *cache_alloc_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, gfp_t flags)\n{\n\tstruct page *page;\n\tvoid *obj;\n\tvoid *list = NULL;\n\n\tif (!gfp_pfmemalloc_allowed(flags))\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, true);\n\tif (!page) {\n\t\tspin_unlock(&n->list_lock);\n\t\treturn NULL;\n\t}\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\n\treturn obj;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic noinline void *cache_alloc_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, gfp_t flags)\n{\n\tstruct page *page;\n\tvoid *obj;\n\tvoid *list = NULL;\n\n\tif (!gfp_pfmemalloc_allowed(flags))\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, true);\n\tif (!page) {\n\t\tspin_unlock(&n->list_lock);\n\t\treturn NULL;\n\t}\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\n\treturn obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_memalloc_socks",
          "args": [],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ac->avail"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_objfreelist_debug",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_objfreelist_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2824-2837",
          "snippet": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_slab_list",
          "args": [
            "cachep",
            "n",
            "page",
            "&list"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_slab_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2839-2861",
          "snippet": "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_spinlock_acquired",
          "args": [
            "cachep"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "check_spinlock_acquired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2172-2178",
          "snippet": "static void check_spinlock_acquired(struct kmem_cache *cachep)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, numa_mem_id())->list_lock);\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_spinlock_acquired(struct kmem_cache *cachep)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, numa_mem_id())->list_lock);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_slab",
          "args": [
            "n",
            "false"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2906-2924",
          "snippet": "static struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transfer_objects",
          "args": [
            "ac",
            "shared",
            "batchcount"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "transfer_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "616-631",
          "snippet": "static int transfer_objects(struct array_cache *to,\n\t\tstruct array_cache *from, unsigned int max)\n{\n\t/* Figure out how many entries to transfer */\n\tint nr = min3(from->avail, max, to->limit - to->avail);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tmemcpy(to->entry + to->avail, from->entry + from->avail -nr,\n\t\t\tsizeof(void *) *nr);\n\n\tfrom->avail -= nr;\n\tto->avail += nr;\n\treturn nr;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int transfer_objects(struct array_cache *to,\n\t\tstruct array_cache *from, unsigned int max)\n{\n\t/* Figure out how many entries to transfer */\n\tint nr = min3(from->avail, max, to->limit - to->avail);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tmemcpy(to->entry + to->avail, from->entry + from->avail -nr,\n\t\t\tsizeof(void *) *nr);\n\n\tfrom->avail -= nr;\n\tto->avail += nr;\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "n->shared"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "n->shared"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->avail > 0 || !n"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define BATCHREFILL_LIMIT\t16\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *ac, *shared;\n\tint node;\n\tvoid *list = NULL;\n\tstruct page *page;\n\n\tcheck_irq_off();\n\tnode = numa_mem_id();\n\n\tac = cpu_cache_get(cachep);\n\tbatchcount = ac->batchcount;\n\tif (!ac->touched && batchcount > BATCHREFILL_LIMIT) {\n\t\t/*\n\t\t * If there was little recent activity on this cache, then\n\t\t * perform only a partial refill.  Otherwise we could generate\n\t\t * refill bouncing.\n\t\t */\n\t\tbatchcount = BATCHREFILL_LIMIT;\n\t}\n\tn = get_node(cachep, node);\n\n\tBUG_ON(ac->avail > 0 || !n);\n\tshared = READ_ONCE(n->shared);\n\tif (!n->free_objects && (!shared || !shared->avail))\n\t\tgoto direct_grow;\n\n\tspin_lock(&n->list_lock);\n\tshared = READ_ONCE(n->shared);\n\n\t/* See if we can refill from the shared array */\n\tif (shared && transfer_objects(ac, shared, batchcount)) {\n\t\tshared->touched = 1;\n\t\tgoto alloc_done;\n\t}\n\n\twhile (batchcount > 0) {\n\t\t/* Get slab alloc is to come from. */\n\t\tpage = get_first_slab(n, false);\n\t\tif (!page)\n\t\t\tgoto must_grow;\n\n\t\tcheck_spinlock_acquired(cachep);\n\n\t\tbatchcount = alloc_block(cachep, ac, page, batchcount);\n\t\tfixup_slab_list(cachep, n, page, &list);\n\t}\n\nmust_grow:\n\tn->free_objects -= ac->avail;\nalloc_done:\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\ndirect_grow:\n\tif (unlikely(!ac->avail)) {\n\t\t/* Check if we can use obj in pfmemalloc slab */\n\t\tif (sk_memalloc_socks()) {\n\t\t\tvoid *obj = cache_alloc_pfmemalloc(cachep, n, flags);\n\n\t\t\tif (obj)\n\t\t\t\treturn obj;\n\t\t}\n\n\t\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), node);\n\n\t\t/*\n\t\t * cache_grow_begin() can reenable interrupts,\n\t\t * then ac could change.\n\t\t */\n\t\tac = cpu_cache_get(cachep);\n\t\tif (!ac->avail && page)\n\t\t\talloc_block(cachep, ac, page, batchcount);\n\t\tcache_grow_end(cachep, page);\n\n\t\tif (!ac->avail)\n\t\t\treturn NULL;\n\t}\n\tac->touched = 1;\n\n\treturn ac->entry[--ac->avail];\n}"
  },
  {
    "function_name": "alloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2958-2976",
    "snippet": "static __always_inline int alloc_block(struct kmem_cache *cachep,\n\t\tstruct array_cache *ac, struct page *page, int batchcount)\n{\n\t/*\n\t * There must be at least one object available for\n\t * allocation.\n\t */\n\tBUG_ON(page->active >= cachep->num);\n\n\twhile (page->active < cachep->num && batchcount--) {\n\t\tSTATS_INC_ALLOCED(cachep);\n\t\tSTATS_INC_ACTIVE(cachep);\n\t\tSTATS_SET_HIGH(cachep);\n\n\t\tac->entry[ac->avail++] = slab_get_obj(cachep, page);\n\t}\n\n\treturn batchcount;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_get_obj",
          "args": [
            "cachep",
            "page"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "slab_get_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2591-2604",
          "snippet": "static void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATS_SET_HIGH",
          "args": [
            "cachep"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_ACTIVE",
          "args": [
            "cachep"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_ALLOCED",
          "args": [
            "cachep"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->active >= cachep->num"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic __always_inline int alloc_block(struct kmem_cache *cachep,\n\t\tstruct array_cache *ac, struct page *page, int batchcount)\n{\n\t/*\n\t * There must be at least one object available for\n\t * allocation.\n\t */\n\tBUG_ON(page->active >= cachep->num);\n\n\twhile (page->active < cachep->num && batchcount--) {\n\t\tSTATS_INC_ALLOCED(cachep);\n\t\tSTATS_INC_ACTIVE(cachep);\n\t\tSTATS_SET_HIGH(cachep);\n\n\t\tac->entry[ac->avail++] = slab_get_obj(cachep, page);\n\t}\n\n\treturn batchcount;\n}"
  },
  {
    "function_name": "cache_alloc_pfmemalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2926-2952",
    "snippet": "static noinline void *cache_alloc_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, gfp_t flags)\n{\n\tstruct page *page;\n\tvoid *obj;\n\tvoid *list = NULL;\n\n\tif (!gfp_pfmemalloc_allowed(flags))\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, true);\n\tif (!page) {\n\t\tspin_unlock(&n->list_lock);\n\t\treturn NULL;\n\t}\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\n\treturn obj;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixup_objfreelist_debug",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_objfreelist_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2824-2837",
          "snippet": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_slab_list",
          "args": [
            "cachep",
            "n",
            "page",
            "&list"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_slab_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2839-2861",
          "snippet": "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_get_obj",
          "args": [
            "cachep",
            "page"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "slab_get_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2591-2604",
          "snippet": "static void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_first_slab",
          "args": [
            "n",
            "true"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2906-2924",
          "snippet": "static struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_pfmemalloc_allowed",
          "args": [
            "flags"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "gfp_pfmemalloc_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3908-3911",
          "snippet": "bool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic noinline void *cache_alloc_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, gfp_t flags)\n{\n\tstruct page *page;\n\tvoid *obj;\n\tvoid *list = NULL;\n\n\tif (!gfp_pfmemalloc_allowed(flags))\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tpage = get_first_slab(n, true);\n\tif (!page) {\n\t\tspin_unlock(&n->list_lock);\n\t\treturn NULL;\n\t}\n\n\tobj = slab_get_obj(cachep, page);\n\tn->free_objects--;\n\n\tfixup_slab_list(cachep, n, page, &list);\n\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\n\treturn obj;\n}"
  },
  {
    "function_name": "get_first_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2906-2924",
    "snippet": "static struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_valid_first_slab",
          "args": [
            "n",
            "page",
            "pfmemalloc"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_first_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2864-2904",
          "snippet": "page *get_valid_first_slab(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page, bool pfmemalloc)\n{\n\tif (!page)\n\t\treturn NULL;\n\n\tif (pfmemalloc)\n\t\treturn page;\n\n\tif (!PageSlabPfmemalloc(page))\n\t\treturn page;\n\n\t/* No need to keep pfmemalloc slab if we have enough free objects */\n\tif (n->free_objects > n->free_limit) {\n\t\tClearPageSlabPfmemalloc(page);\n\t\treturn page;\n\t}\n\n\t/* Move pfmemalloc slab to the end of list to speed up next search */\n\tlist_del(&page->lru);\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &n->slabs_free);\n\t\tn->free_slabs++;\n\t} else\n\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\n\tlist_for_each_entry(page, &n->slabs_partial, lru) {\n\t\tif (!PageSlabPfmemalloc(page))\n\t\t\treturn page;\n\t}\n\n\tn->free_touched = 1;\n\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\tif (!PageSlabPfmemalloc(page)) {\n\t\t\tn->free_slabs--;\n\t\t\treturn page;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\npage *get_valid_first_slab(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page, bool pfmemalloc)\n{\n\tif (!page)\n\t\treturn NULL;\n\n\tif (pfmemalloc)\n\t\treturn page;\n\n\tif (!PageSlabPfmemalloc(page))\n\t\treturn page;\n\n\t/* No need to keep pfmemalloc slab if we have enough free objects */\n\tif (n->free_objects > n->free_limit) {\n\t\tClearPageSlabPfmemalloc(page);\n\t\treturn page;\n\t}\n\n\t/* Move pfmemalloc slab to the end of list to speed up next search */\n\tlist_del(&page->lru);\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &n->slabs_free);\n\t\tn->free_slabs++;\n\t} else\n\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\n\tlist_for_each_entry(page, &n->slabs_partial, lru) {\n\t\tif (!PageSlabPfmemalloc(page))\n\t\t\treturn page;\n\t}\n\n\tn->free_touched = 1;\n\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\tif (!PageSlabPfmemalloc(page)) {\n\t\t\tn->free_slabs--;\n\t\t\treturn page;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_memalloc_socks",
          "args": [],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&n->slabs_free",
            "structpage",
            "lru"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&n->slabs_partial",
            "structpage",
            "lru"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&n->list_lock"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n\n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page, lru);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tlru);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}"
  },
  {
    "function_name": "get_valid_first_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2864-2904",
    "snippet": "page *get_valid_first_slab(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page, bool pfmemalloc)\n{\n\tif (!page)\n\t\treturn NULL;\n\n\tif (pfmemalloc)\n\t\treturn page;\n\n\tif (!PageSlabPfmemalloc(page))\n\t\treturn page;\n\n\t/* No need to keep pfmemalloc slab if we have enough free objects */\n\tif (n->free_objects > n->free_limit) {\n\t\tClearPageSlabPfmemalloc(page);\n\t\treturn page;\n\t}\n\n\t/* Move pfmemalloc slab to the end of list to speed up next search */\n\tlist_del(&page->lru);\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &n->slabs_free);\n\t\tn->free_slabs++;\n\t} else\n\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\n\tlist_for_each_entry(page, &n->slabs_partial, lru) {\n\t\tif (!PageSlabPfmemalloc(page))\n\t\t\treturn page;\n\t}\n\n\tn->free_touched = 1;\n\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\tif (!PageSlabPfmemalloc(page)) {\n\t\t\tn->free_slabs--;\n\t\t\treturn page;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->slabs_free",
            "lru"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->slabs_partial",
            "lru"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&n->slabs_partial"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&n->slabs_free"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\npage *get_valid_first_slab(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page, bool pfmemalloc)\n{\n\tif (!page)\n\t\treturn NULL;\n\n\tif (pfmemalloc)\n\t\treturn page;\n\n\tif (!PageSlabPfmemalloc(page))\n\t\treturn page;\n\n\t/* No need to keep pfmemalloc slab if we have enough free objects */\n\tif (n->free_objects > n->free_limit) {\n\t\tClearPageSlabPfmemalloc(page);\n\t\treturn page;\n\t}\n\n\t/* Move pfmemalloc slab to the end of list to speed up next search */\n\tlist_del(&page->lru);\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &n->slabs_free);\n\t\tn->free_slabs++;\n\t} else\n\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\n\tlist_for_each_entry(page, &n->slabs_partial, lru) {\n\t\tif (!PageSlabPfmemalloc(page))\n\t\t\treturn page;\n\t}\n\n\tn->free_touched = 1;\n\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\tif (!PageSlabPfmemalloc(page)) {\n\t\t\tn->free_slabs--;\n\t\t\treturn page;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "fixup_slab_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2839-2861",
    "snippet": "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&n->slabs_partial"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJFREELIST_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&n->slabs_full"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}"
  },
  {
    "function_name": "fixup_objfreelist_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2824-2837",
    "snippet": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "poison_obj",
          "args": [
            "cachep",
            "objp",
            "POISON_FREE"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "poison_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1531-1538",
          "snippet": "static void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}"
  },
  {
    "function_name": "cache_free_debugcheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2785-2817",
    "snippet": "static void *cache_free_debugcheck(struct kmem_cache *cachep, void *objp,\n\t\t\t\t   unsigned long caller)\n{\n\tunsigned int objnr;\n\tstruct page *page;\n\n\tBUG_ON(virt_to_cache(objp) != cachep);\n\n\tobjp -= obj_offset(cachep);\n\tkfree_debugcheck(objp);\n\tpage = virt_to_head_page(objp);\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tverify_redzone_free(cachep, objp);\n\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t}\n\tif (cachep->flags & SLAB_STORE_USER) {\n\t\tset_store_user_dirty(cachep);\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\t}\n\n\tobjnr = obj_to_index(cachep, page, objp);\n\n\tBUG_ON(objnr >= cachep->num);\n\tBUG_ON(objp != index_to_obj(cachep, page, objnr));\n\n\tif (cachep->flags & SLAB_POISON) {\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\tslab_kernel_map(cachep, objp, 0, caller);\n\t}\n\treturn objp;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_kernel_map",
          "args": [
            "cachep",
            "objp",
            "0",
            "caller"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "slab_kernel_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1526-1527",
          "snippet": "static inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}"
        }
      },
      {
        "call_info": {
          "callee": "poison_obj",
          "args": [
            "cachep",
            "objp",
            "POISON_FREE"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "poison_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1531-1538",
          "snippet": "static void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "objp != index_to_obj(cachep, page, objnr)"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "objnr"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "objnr >= cachep->num"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_to_index",
          "args": [
            "cachep",
            "page",
            "objp"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "obj_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "415-420",
          "snippet": "static inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_userword",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_userword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "350-354",
          "snippet": "static void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tBYTES_PER_WORD\t\tsizeof(void *)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n\nstatic noinline struct;\n\nstatic void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_store_user_dirty",
          "args": [
            "cachep"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "set_store_user_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "384-384",
          "snippet": "static inline void set_store_user_dirty(struct kmem_cache *cachep) {}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_store_user_dirty(struct kmem_cache *cachep) {}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_redzone2",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "339-348",
          "snippet": "static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_redzone1",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "332-337",
          "snippet": "static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_redzone_free",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "verify_redzone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2763-2783",
          "snippet": "static inline void verify_redzone_free(struct kmem_cache *cache, void *obj)\n{\n\tunsigned long long redzone1, redzone2;\n\n\tredzone1 = *dbg_redzone1(cache, obj);\n\tredzone2 = *dbg_redzone2(cache, obj);\n\n\t/*\n\t * Redzone is ok.\n\t */\n\tif (redzone1 == RED_ACTIVE && redzone2 == RED_ACTIVE)\n\t\treturn;\n\n\tif (redzone1 == RED_INACTIVE && redzone2 == RED_INACTIVE)\n\t\tslab_error(cache, \"double free detected\");\n\telse\n\t\tslab_error(cache, \"memory outside object was overwritten\");\n\n\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t       obj, redzone1, redzone2);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void verify_redzone_free(struct kmem_cache *cache, void *obj)\n{\n\tunsigned long long redzone1, redzone2;\n\n\tredzone1 = *dbg_redzone1(cache, obj);\n\tredzone2 = *dbg_redzone2(cache, obj);\n\n\t/*\n\t * Redzone is ok.\n\t */\n\tif (redzone1 == RED_ACTIVE && redzone2 == RED_ACTIVE)\n\t\treturn;\n\n\tif (redzone1 == RED_INACTIVE && redzone2 == RED_INACTIVE)\n\t\tslab_error(cache, \"double free detected\");\n\telse\n\t\tslab_error(cache, \"memory outside object was overwritten\");\n\n\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t       obj, redzone1, redzone2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "objp"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_debugcheck",
          "args": [
            "objp"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_debugcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2754-2761",
          "snippet": "static void kfree_debugcheck(const void *objp)\n{\n\tif (!virt_addr_valid(objp)) {\n\t\tpr_err(\"kfree_debugcheck: out of range ptr %lxh\\n\",\n\t\t       (unsigned long)objp);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void kfree_debugcheck(const void *objp)\n{\n\tif (!virt_addr_valid(objp)) {\n\t\tpr_err(\"kfree_debugcheck: out of range ptr %lxh\\n\",\n\t\t       (unsigned long)objp);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "virt_to_cache(objp) != cachep"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_cache",
          "args": [
            "objp"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "397-401",
          "snippet": "static inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *cache_free_debugcheck(struct kmem_cache *cachep, void *objp,\n\t\t\t\t   unsigned long caller)\n{\n\tunsigned int objnr;\n\tstruct page *page;\n\n\tBUG_ON(virt_to_cache(objp) != cachep);\n\n\tobjp -= obj_offset(cachep);\n\tkfree_debugcheck(objp);\n\tpage = virt_to_head_page(objp);\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tverify_redzone_free(cachep, objp);\n\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t}\n\tif (cachep->flags & SLAB_STORE_USER) {\n\t\tset_store_user_dirty(cachep);\n\t\t*dbg_userword(cachep, objp) = (void *)caller;\n\t}\n\n\tobjnr = obj_to_index(cachep, page, objp);\n\n\tBUG_ON(objnr >= cachep->num);\n\tBUG_ON(objp != index_to_obj(cachep, page, objnr));\n\n\tif (cachep->flags & SLAB_POISON) {\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\tslab_kernel_map(cachep, objp, 0, caller);\n\t}\n\treturn objp;\n}"
  },
  {
    "function_name": "verify_redzone_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2763-2783",
    "snippet": "static inline void verify_redzone_free(struct kmem_cache *cache, void *obj)\n{\n\tunsigned long long redzone1, redzone2;\n\n\tredzone1 = *dbg_redzone1(cache, obj);\n\tredzone2 = *dbg_redzone2(cache, obj);\n\n\t/*\n\t * Redzone is ok.\n\t */\n\tif (redzone1 == RED_ACTIVE && redzone2 == RED_ACTIVE)\n\t\treturn;\n\n\tif (redzone1 == RED_INACTIVE && redzone2 == RED_INACTIVE)\n\t\tslab_error(cache, \"double free detected\");\n\telse\n\t\tslab_error(cache, \"memory outside object was overwritten\");\n\n\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t       obj, redzone1, redzone2);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\"",
            "obj",
            "redzone1",
            "redzone2"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_error",
          "args": [
            "cache",
            "\"memory outside object was overwritten\""
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_error",
          "args": [
            "cache",
            "\"double free detected\""
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_redzone2",
          "args": [
            "cache",
            "obj"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "339-348",
          "snippet": "static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_redzone1",
          "args": [
            "cache",
            "obj"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "332-337",
          "snippet": "static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void verify_redzone_free(struct kmem_cache *cache, void *obj)\n{\n\tunsigned long long redzone1, redzone2;\n\n\tredzone1 = *dbg_redzone1(cache, obj);\n\tredzone2 = *dbg_redzone2(cache, obj);\n\n\t/*\n\t * Redzone is ok.\n\t */\n\tif (redzone1 == RED_ACTIVE && redzone2 == RED_ACTIVE)\n\t\treturn;\n\n\tif (redzone1 == RED_INACTIVE && redzone2 == RED_INACTIVE)\n\t\tslab_error(cache, \"double free detected\");\n\telse\n\t\tslab_error(cache, \"memory outside object was overwritten\");\n\n\tpr_err(\"%px: redzone 1:0x%llx, redzone 2:0x%llx\\n\",\n\t       obj, redzone1, redzone2);\n}"
  },
  {
    "function_name": "kfree_debugcheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2754-2761",
    "snippet": "static void kfree_debugcheck(const void *objp)\n{\n\tif (!virt_addr_valid(objp)) {\n\t\tpr_err(\"kfree_debugcheck: out of range ptr %lxh\\n\",\n\t\t       (unsigned long)objp);\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kfree_debugcheck: out of range ptr %lxh\\n\"",
            "(unsigned long)objp"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "objp"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void kfree_debugcheck(const void *objp)\n{\n\tif (!virt_addr_valid(objp)) {\n\t\tpr_err(\"kfree_debugcheck: out of range ptr %lxh\\n\",\n\t\t       (unsigned long)objp);\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "cache_grow_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2719-2745",
    "snippet": "static void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixup_objfreelist_debug",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_objfreelist_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2824-2837",
          "snippet": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_GROWN",
          "args": [
            "cachep"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_slab_list",
          "args": [
            "cachep",
            "n",
            "page",
            "&list"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_slab_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2839-2861",
          "snippet": "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list)\n{\n\t/* move slabp to correct slabp list: */\n\tlist_del(&page->lru);\n\tif (page->active == cachep->num) {\n\t\tlist_add(&page->lru, &n->slabs_full);\n\t\tif (OBJFREELIST_SLAB(cachep)) {\n#if DEBUG\n\t\t\t/* Poisoning will be done without holding the lock */\n\t\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\t\tvoid **objp = page->freelist;\n\n\t\t\t\t*objp = *list;\n\t\t\t\t*list = objp;\n\t\t\t}\n#endif\n\t\t\tpage->freelist = NULL;\n\t\t}\n\t} else\n\t\tlist_add(&page->lru, &n->slabs_partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&(n->slabs_free)"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "page_to_nid(page)"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page->lru"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cache_grow_end(struct kmem_cache *cachep, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\tvoid *list = NULL;\n\n\tcheck_irq_off();\n\n\tif (!page)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&page->lru);\n\tn = get_node(cachep, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tn->total_slabs++;\n\tif (!page->active) {\n\t\tlist_add_tail(&page->lru, &(n->slabs_free));\n\t\tn->free_slabs++;\n\t} else\n\t\tfixup_slab_list(cachep, n, page, &list);\n\n\tSTATS_INC_GROWN(cachep);\n\tn->free_objects += cachep->num - page->active;\n\tspin_unlock(&n->list_lock);\n\n\tfixup_objfreelist_debug(cachep, &list);\n}"
  },
  {
    "function_name": "cache_grow_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2645-2717",
    "snippet": "static struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "local_flags"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_freepages",
          "args": [
            "cachep",
            "page"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1437-1457",
          "snippet": "static void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "local_flags"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_init_objs",
          "args": [
            "cachep",
            "page"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "cache_init_objs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2558-2589",
          "snippet": "static void cache_init_objs(struct kmem_cache *cachep,\n\t\t\t    struct page *page)\n{\n\tint i;\n\tvoid *objp;\n\tbool shuffled;\n\n\tcache_init_objs_debug(cachep, page);\n\n\t/* Try to randomize the freelist if enabled */\n\tshuffled = shuffle_freelist(cachep, page);\n\n\tif (!shuffled && OBJFREELIST_SLAB(cachep)) {\n\t\tpage->freelist = index_to_obj(cachep, page, cachep->num - 1) +\n\t\t\t\t\t\tobj_offset(cachep);\n\t}\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tobjp = index_to_obj(cachep, page, i);\n\t\tkasan_init_slab_obj(cachep, objp);\n\n\t\t/* constructor could break poison info */\n\t\tif (DEBUG == 0 && cachep->ctor) {\n\t\t\tkasan_unpoison_object_data(cachep, objp);\n\t\t\tcachep->ctor(objp);\n\t\t\tkasan_poison_object_data(cachep, objp);\n\t\t}\n\n\t\tif (!shuffled)\n\t\t\tset_free_obj(page, i, i);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void cache_init_objs(struct kmem_cache *cachep,\n\t\t\t    struct page *page)\n{\n\tint i;\n\tvoid *objp;\n\tbool shuffled;\n\n\tcache_init_objs_debug(cachep, page);\n\n\t/* Try to randomize the freelist if enabled */\n\tshuffled = shuffle_freelist(cachep, page);\n\n\tif (!shuffled && OBJFREELIST_SLAB(cachep)) {\n\t\tpage->freelist = index_to_obj(cachep, page, cachep->num - 1) +\n\t\t\t\t\t\tobj_offset(cachep);\n\t}\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tobjp = index_to_obj(cachep, page, i);\n\t\tkasan_init_slab_obj(cachep, objp);\n\n\t\t/* constructor could break poison info */\n\t\tif (DEBUG == 0 && cachep->ctor) {\n\t\t\tkasan_unpoison_object_data(cachep, objp);\n\t\t\tcachep->ctor(objp);\n\t\t\tkasan_poison_object_data(cachep, objp);\n\t\t}\n\n\t\tif (!shuffled)\n\t\t\tset_free_obj(page, i, i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_poison_slab",
          "args": [
            "page"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_poison_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "397-402",
          "snippet": "void kasan_poison_slab(struct page *page)\n{\n\tkasan_poison_shadow(page_address(page),\n\t\t\tPAGE_SIZE << compound_order(page),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_poison_slab(struct page *page)\n{\n\tkasan_poison_shadow(page_address(page),\n\t\t\tPAGE_SIZE << compound_order(page),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_map_pages",
          "args": [
            "cachep",
            "page",
            "freelist"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "slab_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2634-2639",
          "snippet": "static void slab_map_pages(struct kmem_cache *cache, struct page *page,\n\t\t\t   void *freelist)\n{\n\tpage->slab_cache = cache;\n\tpage->freelist = freelist;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_map_pages(struct kmem_cache *cache, struct page *page,\n\t\t\t   void *freelist)\n{\n\tpage->slab_cache = cache;\n\tpage->freelist = freelist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFF_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_slabmgmt",
          "args": [
            "cachep",
            "page",
            "offset",
            "local_flags & ~GFP_CONSTRAINT_MASK",
            "page_node"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_slabmgmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2366-2391",
          "snippet": "static void *alloc_slabmgmt(struct kmem_cache *cachep,\n\t\t\t\t   struct page *page, int colour_off,\n\t\t\t\t   gfp_t local_flags, int nodeid)\n{\n\tvoid *freelist;\n\tvoid *addr = page_address(page);\n\n\tpage->s_mem = addr + colour_off;\n\tpage->active = 0;\n\n\tif (OBJFREELIST_SLAB(cachep))\n\t\tfreelist = NULL;\n\telse if (OFF_SLAB(cachep)) {\n\t\t/* Slab management obj is off-slab. */\n\t\tfreelist = kmem_cache_alloc_node(cachep->freelist_cache,\n\t\t\t\t\t      local_flags, nodeid);\n\t\tif (!freelist)\n\t\t\treturn NULL;\n\t} else {\n\t\t/* We will use last bytes at the slab for freelist */\n\t\tfreelist = addr + (PAGE_SIZE << cachep->gfporder) -\n\t\t\t\tcachep->freelist_size;\n\t}\n\n\treturn freelist;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *alloc_slabmgmt(struct kmem_cache *cachep,\n\t\t\t\t   struct page *page, int colour_off,\n\t\t\t\t   gfp_t local_flags, int nodeid)\n{\n\tvoid *freelist;\n\tvoid *addr = page_address(page);\n\n\tpage->s_mem = addr + colour_off;\n\tpage->active = 0;\n\n\tif (OBJFREELIST_SLAB(cachep))\n\t\tfreelist = NULL;\n\telse if (OFF_SLAB(cachep)) {\n\t\t/* Slab management obj is off-slab. */\n\t\tfreelist = kmem_cache_alloc_node(cachep->freelist_cache,\n\t\t\t\t\t      local_flags, nodeid);\n\t\tif (!freelist)\n\t\t\treturn NULL;\n\t} else {\n\t\t/* We will use last bytes at the slab for freelist */\n\t\tfreelist = addr + (PAGE_SIZE << cachep->gfporder) -\n\t\t\t\tcachep->freelist_size;\n\t}\n\n\treturn freelist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "page_node"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_getpages",
          "args": [
            "cachep",
            "local_flags",
            "nodeid"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_getpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1401-1432",
          "snippet": "static struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\t\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tint nr_pages;\n\n\tflags |= cachep->allocflags;\n\n\tpage = __alloc_pages_node(nodeid, flags, cachep->gfporder);\n\tif (!page) {\n\t\tslab_out_of_memory(cachep, flags, nodeid);\n\t\treturn NULL;\n\t}\n\n\tif (memcg_charge_slab(page, flags, cachep->gfporder, cachep)) {\n\t\t__free_pages(page, cachep->gfporder);\n\t\treturn NULL;\n\t}\n\n\tnr_pages = (1 << cachep->gfporder);\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, nr_pages);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, nr_pages);\n\n\t__SetPageSlab(page);\n\t/* Record if ALLOC_NO_WATERMARKS was set when allocating the slab */\n\tif (sk_memalloc_socks() && page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\treturn page;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\t\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tint nr_pages;\n\n\tflags |= cachep->allocflags;\n\n\tpage = __alloc_pages_node(nodeid, flags, cachep->gfporder);\n\tif (!page) {\n\t\tslab_out_of_memory(cachep, flags, nodeid);\n\t\treturn NULL;\n\t}\n\n\tif (memcg_charge_slab(page, flags, cachep->gfporder, cachep)) {\n\t\t__free_pages(page, cachep->gfporder);\n\t\treturn NULL;\n\t}\n\n\tnr_pages = (1 << cachep->gfporder);\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, nr_pages);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, nr_pages);\n\n\t__SetPageSlab(page);\n\t/* Record if ALLOC_NO_WATERMARKS was set when allocating the slab */\n\tif (sk_memalloc_socks() && page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "local_flags"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cachep->ctor && (flags & __GFP_ZERO)"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\"",
            "invalid_mask",
            "&invalid_mask",
            "flags",
            "&flags"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & GFP_SLAB_BUG_MASK"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct page *cache_grow_begin(struct kmem_cache *cachep,\n\t\t\t\tgfp_t flags, int nodeid)\n{\n\tvoid *freelist;\n\tsize_t offset;\n\tgfp_t local_flags;\n\tint page_node;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\n\t/*\n\t * Be lazy and only check for valid flags here,  keeping it out of the\n\t * critical path in kmem_cache_alloc().\n\t */\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\tWARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));\n\tlocal_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);\n\n\tcheck_irq_off();\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * Get mem for the objs.  Attempt to allocate a physical page from\n\t * 'nodeid'.\n\t */\n\tpage = kmem_getpages(cachep, local_flags, nodeid);\n\tif (!page)\n\t\tgoto failed;\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\t/* Get colour for the slab, and cal the next value. */\n\tn->colour_next++;\n\tif (n->colour_next >= cachep->colour)\n\t\tn->colour_next = 0;\n\n\toffset = n->colour_next;\n\tif (offset >= cachep->colour)\n\t\toffset = 0;\n\n\toffset *= cachep->colour_off;\n\n\t/* Get slab management. */\n\tfreelist = alloc_slabmgmt(cachep, page, offset,\n\t\t\tlocal_flags & ~GFP_CONSTRAINT_MASK, page_node);\n\tif (OFF_SLAB(cachep) && !freelist)\n\t\tgoto opps1;\n\n\tslab_map_pages(cachep, page, freelist);\n\n\tkasan_poison_slab(page);\n\tcache_init_objs(cachep, page);\n\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\n\treturn page;\n\nopps1:\n\tkmem_freepages(cachep, page);\nfailed:\n\tif (gfpflags_allow_blocking(local_flags))\n\t\tlocal_irq_disable();\n\treturn NULL;\n}"
  },
  {
    "function_name": "slab_map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2634-2639",
    "snippet": "static void slab_map_pages(struct kmem_cache *cache, struct page *page,\n\t\t\t   void *freelist)\n{\n\tpage->slab_cache = cache;\n\tpage->freelist = freelist;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_map_pages(struct kmem_cache *cache, struct page *page,\n\t\t\t   void *freelist)\n{\n\tpage->slab_cache = cache;\n\tpage->freelist = freelist;\n}"
  },
  {
    "function_name": "slab_put_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2606-2627",
    "snippet": "static void slab_put_obj(struct kmem_cache *cachep,\n\t\t\tstruct page *page, void *objp)\n{\n\tunsigned int objnr = obj_to_index(cachep, page, objp);\n#if DEBUG\n\tunsigned int i;\n\n\t/* Verify double free bug */\n\tfor (i = page->active; i < cachep->num; i++) {\n\t\tif (get_free_obj(page, i) == objnr) {\n\t\t\tpr_err(\"slab: double free detected in cache '%s', objp %px\\n\",\n\t\t\t       cachep->name, objp);\n\t\t\tBUG();\n\t\t}\n\t}\n#endif\n\tpage->active--;\n\tif (!page->freelist)\n\t\tpage->freelist = objp + obj_offset(cachep);\n\n\tset_free_obj(page, page->active, objnr);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_free_obj",
          "args": [
            "page",
            "page->active",
            "objnr"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "set_free_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2398-2402",
          "snippet": "static inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"slab: double free detected in cache '%s', objp %px\\n\"",
            "cachep->name",
            "objp"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_free_obj",
          "args": [
            "page",
            "i"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "get_free_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2393-2396",
          "snippet": "static inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_to_index",
          "args": [
            "cachep",
            "page",
            "objp"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "obj_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "415-420",
          "snippet": "static inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void slab_put_obj(struct kmem_cache *cachep,\n\t\t\tstruct page *page, void *objp)\n{\n\tunsigned int objnr = obj_to_index(cachep, page, objp);\n#if DEBUG\n\tunsigned int i;\n\n\t/* Verify double free bug */\n\tfor (i = page->active; i < cachep->num; i++) {\n\t\tif (get_free_obj(page, i) == objnr) {\n\t\t\tpr_err(\"slab: double free detected in cache '%s', objp %px\\n\",\n\t\t\t       cachep->name, objp);\n\t\t\tBUG();\n\t\t}\n\t}\n#endif\n\tpage->active--;\n\tif (!page->freelist)\n\t\tpage->freelist = objp + obj_offset(cachep);\n\n\tset_free_obj(page, page->active, objnr);\n}"
  },
  {
    "function_name": "slab_get_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2591-2604",
    "snippet": "static void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_store_user_dirty",
          "args": [
            "cachep"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "set_store_user_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "384-384",
          "snippet": "static inline void set_store_user_dirty(struct kmem_cache *cachep) {}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_store_user_dirty(struct kmem_cache *cachep) {}"
        }
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "get_free_obj(page, page->active)"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_free_obj",
          "args": [
            "page",
            "page->active"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "get_free_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2393-2396",
          "snippet": "static inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void *slab_get_obj(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *objp;\n\n\tobjp = index_to_obj(cachep, page, get_free_obj(page, page->active));\n\tpage->active++;\n\n#if DEBUG\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tset_store_user_dirty(cachep);\n#endif\n\n\treturn objp;\n}"
  },
  {
    "function_name": "cache_init_objs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2558-2589",
    "snippet": "static void cache_init_objs(struct kmem_cache *cachep,\n\t\t\t    struct page *page)\n{\n\tint i;\n\tvoid *objp;\n\tbool shuffled;\n\n\tcache_init_objs_debug(cachep, page);\n\n\t/* Try to randomize the freelist if enabled */\n\tshuffled = shuffle_freelist(cachep, page);\n\n\tif (!shuffled && OBJFREELIST_SLAB(cachep)) {\n\t\tpage->freelist = index_to_obj(cachep, page, cachep->num - 1) +\n\t\t\t\t\t\tobj_offset(cachep);\n\t}\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tobjp = index_to_obj(cachep, page, i);\n\t\tkasan_init_slab_obj(cachep, objp);\n\n\t\t/* constructor could break poison info */\n\t\tif (DEBUG == 0 && cachep->ctor) {\n\t\t\tkasan_unpoison_object_data(cachep, objp);\n\t\t\tcachep->ctor(objp);\n\t\t\tkasan_poison_object_data(cachep, objp);\n\t\t}\n\n\t\tif (!shuffled)\n\t\t\tset_free_obj(page, i, i);\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_free_obj",
          "args": [
            "page",
            "i",
            "i"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "set_free_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2398-2402",
          "snippet": "static inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_poison_object_data",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_poison_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "409-414",
          "snippet": "void kasan_poison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_poison_shadow(object,\n\t\t\tround_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_poison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_poison_shadow(object,\n\t\t\tround_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachep->ctor",
          "args": [
            "objp"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_object_data",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_unpoison_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "404-407",
          "snippet": "void kasan_unpoison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_unpoison_shadow(object, cache->object_size);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_unpoison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_unpoison_shadow(object, cache->object_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_init_slab_obj",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_init_slab_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "477-486",
          "snippet": "void kasan_init_slab_obj(struct kmem_cache *cache, const void *object)\n{\n\tstruct kasan_alloc_meta *alloc_info;\n\n\tif (!(cache->flags & SLAB_KASAN))\n\t\treturn;\n\n\talloc_info = get_alloc_info(cache, object);\n\t__memset(alloc_info, 0, sizeof(*alloc_info));\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_init_slab_obj(struct kmem_cache *cache, const void *object)\n{\n\tstruct kasan_alloc_meta *alloc_info;\n\n\tif (!(cache->flags & SLAB_KASAN))\n\t\treturn;\n\n\talloc_info = get_alloc_info(cache, object);\n\t__memset(alloc_info, 0, sizeof(*alloc_info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "i"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OBJFREELIST_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shuffle_freelist",
          "args": [
            "cachep",
            "page"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "shuffle_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2551-2555",
          "snippet": "static inline bool shuffle_freelist(struct kmem_cache *cachep,\n\t\t\t\tstruct page *page)\n{\n\treturn false;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline bool shuffle_freelist(struct kmem_cache *cachep,\n\t\t\t\tstruct page *page)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_init_objs_debug",
          "args": [
            "cachep",
            "page"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "cache_init_objs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2404-2445",
          "snippet": "static void cache_init_objs_debug(struct kmem_cache *cachep, struct page *page)\n{\n#if DEBUG\n\tint i;\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tvoid *objp = index_to_obj(cachep, page, i);\n\n\t\tif (cachep->flags & SLAB_STORE_USER)\n\t\t\t*dbg_userword(cachep, objp) = NULL;\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t\t}\n\t\t/*\n\t\t * Constructors are not allowed to allocate memory from the same\n\t\t * cache which they are a constructor for.  Otherwise, deadlock.\n\t\t * They must also be threaded.\n\t\t */\n\t\tif (cachep->ctor && !(cachep->flags & SLAB_POISON)) {\n\t\t\tkasan_unpoison_object_data(cachep,\n\t\t\t\t\t\t   objp + obj_offset(cachep));\n\t\t\tcachep->ctor(objp + obj_offset(cachep));\n\t\t\tkasan_poison_object_data(\n\t\t\t\tcachep, objp + obj_offset(cachep));\n\t\t}\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\tif (*dbg_redzone2(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the end of an object\");\n\t\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the start of an object\");\n\t\t}\n\t\t/* need to poison the objs? */\n\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\t\tslab_kernel_map(cachep, objp, 0, 0);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void cache_init_objs_debug(struct kmem_cache *cachep, struct page *page)\n{\n#if DEBUG\n\tint i;\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tvoid *objp = index_to_obj(cachep, page, i);\n\n\t\tif (cachep->flags & SLAB_STORE_USER)\n\t\t\t*dbg_userword(cachep, objp) = NULL;\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t\t}\n\t\t/*\n\t\t * Constructors are not allowed to allocate memory from the same\n\t\t * cache which they are a constructor for.  Otherwise, deadlock.\n\t\t * They must also be threaded.\n\t\t */\n\t\tif (cachep->ctor && !(cachep->flags & SLAB_POISON)) {\n\t\t\tkasan_unpoison_object_data(cachep,\n\t\t\t\t\t\t   objp + obj_offset(cachep));\n\t\t\tcachep->ctor(objp + obj_offset(cachep));\n\t\t\tkasan_poison_object_data(\n\t\t\t\tcachep, objp + obj_offset(cachep));\n\t\t}\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\tif (*dbg_redzone2(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the end of an object\");\n\t\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the start of an object\");\n\t\t}\n\t\t/* need to poison the objs? */\n\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\t\tslab_kernel_map(cachep, objp, 0, 0);\n\t\t}\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void cache_init_objs(struct kmem_cache *cachep,\n\t\t\t    struct page *page)\n{\n\tint i;\n\tvoid *objp;\n\tbool shuffled;\n\n\tcache_init_objs_debug(cachep, page);\n\n\t/* Try to randomize the freelist if enabled */\n\tshuffled = shuffle_freelist(cachep, page);\n\n\tif (!shuffled && OBJFREELIST_SLAB(cachep)) {\n\t\tpage->freelist = index_to_obj(cachep, page, cachep->num - 1) +\n\t\t\t\t\t\tobj_offset(cachep);\n\t}\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tobjp = index_to_obj(cachep, page, i);\n\t\tkasan_init_slab_obj(cachep, objp);\n\n\t\t/* constructor could break poison info */\n\t\tif (DEBUG == 0 && cachep->ctor) {\n\t\t\tkasan_unpoison_object_data(cachep, objp);\n\t\t\tcachep->ctor(objp);\n\t\t\tkasan_poison_object_data(cachep, objp);\n\t\t}\n\n\t\tif (!shuffled)\n\t\t\tset_free_obj(page, i, i);\n\t}\n}"
  },
  {
    "function_name": "shuffle_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2551-2555",
    "snippet": "static inline bool shuffle_freelist(struct kmem_cache *cachep,\n\t\t\t\tstruct page *page)\n{\n\treturn false;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline bool shuffle_freelist(struct kmem_cache *cachep,\n\t\t\t\tstruct page *page)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "shuffle_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2504-2549",
    "snippet": "static bool shuffle_freelist(struct kmem_cache *cachep, struct page *page)\n{\n\tunsigned int objfreelist = 0, i, rand, count = cachep->num;\n\tunion freelist_init_state state;\n\tbool precomputed;\n\n\tif (count < 2)\n\t\treturn false;\n\n\tprecomputed = freelist_state_initialize(&state, cachep, count);\n\n\t/* Take a random entry as the objfreelist */\n\tif (OBJFREELIST_SLAB(cachep)) {\n\t\tif (!precomputed)\n\t\t\tobjfreelist = count - 1;\n\t\telse\n\t\t\tobjfreelist = next_random_slot(&state);\n\t\tpage->freelist = index_to_obj(cachep, page, objfreelist) +\n\t\t\t\t\t\tobj_offset(cachep);\n\t\tcount--;\n\t}\n\n\t/*\n\t * On early boot, generate the list dynamically.\n\t * Later use a pre-computed list for speed.\n\t */\n\tif (!precomputed) {\n\t\tfor (i = 0; i < count; i++)\n\t\t\tset_free_obj(page, i, i);\n\n\t\t/* Fisher-Yates shuffle */\n\t\tfor (i = count - 1; i > 0; i--) {\n\t\t\trand = prandom_u32_state(&state.rnd_state);\n\t\t\trand %= (i + 1);\n\t\t\tswap_free_obj(page, i, rand);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < count; i++)\n\t\t\tset_free_obj(page, i, next_random_slot(&state));\n\t}\n\n\tif (OBJFREELIST_SLAB(cachep))\n\t\tset_free_obj(page, cachep->num - 1, objfreelist);\n\n\treturn true;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_free_obj",
          "args": [
            "page",
            "cachep->num - 1",
            "objfreelist"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "set_free_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2398-2402",
          "snippet": "static inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OBJFREELIST_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_random_slot",
          "args": [
            "&state"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "next_random_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2486-2491",
          "snippet": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\tif (state->pos >= state->count)\n\t\tstate->pos = 0;\n\treturn state->list[state->pos++];\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\n\nstatic freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\tif (state->pos >= state->count)\n\t\tstate->pos = 0;\n\treturn state->list[state->pos++];\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_free_obj",
          "args": [
            "page",
            "i",
            "rand"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "swap_free_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2494-2498",
          "snippet": "static void swap_free_obj(struct page *page, unsigned int a, unsigned int b)\n{\n\tswap(((freelist_idx_t *)page->freelist)[a],\n\t\t((freelist_idx_t *)page->freelist)[b]);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void swap_free_obj(struct page *page, unsigned int a, unsigned int b)\n{\n\tswap(((freelist_idx_t *)page->freelist)[a],\n\t\t((freelist_idx_t *)page->freelist)[b]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32_state",
          "args": [
            "&state.rnd_state"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "objfreelist"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OBJFREELIST_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freelist_state_initialize",
          "args": [
            "&state",
            "cachep",
            "count"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "freelist_state_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2462-2483",
          "snippet": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\n\t/* Use best entropy available to define a random shift */\n\trand = get_random_int();\n\n\t/* Use a random state if the pre-computed list is not available */\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = rand % count;\n\t\tret = true;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\n\t/* Use best entropy available to define a random shift */\n\trand = get_random_int();\n\n\t/* Use a random state if the pre-computed list is not available */\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = rand % count;\n\t\tret = true;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic bool shuffle_freelist(struct kmem_cache *cachep, struct page *page)\n{\n\tunsigned int objfreelist = 0, i, rand, count = cachep->num;\n\tunion freelist_init_state state;\n\tbool precomputed;\n\n\tif (count < 2)\n\t\treturn false;\n\n\tprecomputed = freelist_state_initialize(&state, cachep, count);\n\n\t/* Take a random entry as the objfreelist */\n\tif (OBJFREELIST_SLAB(cachep)) {\n\t\tif (!precomputed)\n\t\t\tobjfreelist = count - 1;\n\t\telse\n\t\t\tobjfreelist = next_random_slot(&state);\n\t\tpage->freelist = index_to_obj(cachep, page, objfreelist) +\n\t\t\t\t\t\tobj_offset(cachep);\n\t\tcount--;\n\t}\n\n\t/*\n\t * On early boot, generate the list dynamically.\n\t * Later use a pre-computed list for speed.\n\t */\n\tif (!precomputed) {\n\t\tfor (i = 0; i < count; i++)\n\t\t\tset_free_obj(page, i, i);\n\n\t\t/* Fisher-Yates shuffle */\n\t\tfor (i = count - 1; i > 0; i--) {\n\t\t\trand = prandom_u32_state(&state.rnd_state);\n\t\t\trand %= (i + 1);\n\t\t\tswap_free_obj(page, i, rand);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < count; i++)\n\t\t\tset_free_obj(page, i, next_random_slot(&state));\n\t}\n\n\tif (OBJFREELIST_SLAB(cachep))\n\t\tset_free_obj(page, cachep->num - 1, objfreelist);\n\n\treturn true;\n}"
  },
  {
    "function_name": "swap_free_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2494-2498",
    "snippet": "static void swap_free_obj(struct page *page, unsigned int a, unsigned int b)\n{\n\tswap(((freelist_idx_t *)page->freelist)[a],\n\t\t((freelist_idx_t *)page->freelist)[b]);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "((freelist_idx_t *)page->freelist)[a]",
            "((freelist_idx_t *)page->freelist)[b]"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "me_swapcache_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "765-773",
          "snippet": "static int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void swap_free_obj(struct page *page, unsigned int a, unsigned int b)\n{\n\tswap(((freelist_idx_t *)page->freelist)[a],\n\t\t((freelist_idx_t *)page->freelist)[b]);\n}"
  },
  {
    "function_name": "next_random_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2486-2491",
    "snippet": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\tif (state->pos >= state->count)\n\t\tstate->pos = 0;\n\treturn state->list[state->pos++];\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\n\nstatic freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\tif (state->pos >= state->count)\n\t\tstate->pos = 0;\n\treturn state->list[state->pos++];\n}"
  },
  {
    "function_name": "freelist_state_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2462-2483",
    "snippet": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\n\t/* Use best entropy available to define a random shift */\n\trand = get_random_int();\n\n\t/* Use a random state if the pre-computed list is not available */\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = rand % count;\n\t\tret = true;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prandom_seed_state",
          "args": [
            "&state->rnd_state",
            "rand"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\n\t/* Use best entropy available to define a random shift */\n\trand = get_random_int();\n\n\t/* Use a random state if the pre-computed list is not available */\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = rand % count;\n\t\tret = true;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cache_init_objs_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2404-2445",
    "snippet": "static void cache_init_objs_debug(struct kmem_cache *cachep, struct page *page)\n{\n#if DEBUG\n\tint i;\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tvoid *objp = index_to_obj(cachep, page, i);\n\n\t\tif (cachep->flags & SLAB_STORE_USER)\n\t\t\t*dbg_userword(cachep, objp) = NULL;\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t\t}\n\t\t/*\n\t\t * Constructors are not allowed to allocate memory from the same\n\t\t * cache which they are a constructor for.  Otherwise, deadlock.\n\t\t * They must also be threaded.\n\t\t */\n\t\tif (cachep->ctor && !(cachep->flags & SLAB_POISON)) {\n\t\t\tkasan_unpoison_object_data(cachep,\n\t\t\t\t\t\t   objp + obj_offset(cachep));\n\t\t\tcachep->ctor(objp + obj_offset(cachep));\n\t\t\tkasan_poison_object_data(\n\t\t\t\tcachep, objp + obj_offset(cachep));\n\t\t}\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\tif (*dbg_redzone2(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the end of an object\");\n\t\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the start of an object\");\n\t\t}\n\t\t/* need to poison the objs? */\n\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\t\tslab_kernel_map(cachep, objp, 0, 0);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_kernel_map",
          "args": [
            "cachep",
            "objp",
            "0",
            "0"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "slab_kernel_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1526-1527",
          "snippet": "static inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}"
        }
      },
      {
        "call_info": {
          "callee": "poison_obj",
          "args": [
            "cachep",
            "objp",
            "POISON_FREE"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "poison_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1531-1538",
          "snippet": "static void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_error",
          "args": [
            "cachep",
            "\"constructor overwrote the start of an object\""
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_redzone1",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "332-337",
          "snippet": "static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_error",
          "args": [
            "cachep",
            "\"constructor overwrote the end of an object\""
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_redzone2",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "339-348",
          "snippet": "static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_poison_object_data",
          "args": [
            "cachep",
            "objp + obj_offset(cachep)"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_poison_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "409-414",
          "snippet": "void kasan_poison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_poison_shadow(object,\n\t\t\tround_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_poison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_poison_shadow(object,\n\t\t\tround_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachep->ctor",
          "args": [
            "objp + obj_offset(cachep)"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_object_data",
          "args": [
            "cachep",
            "objp + obj_offset(cachep)"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_unpoison_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "404-407",
          "snippet": "void kasan_unpoison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_unpoison_shadow(object, cache->object_size);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_unpoison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_unpoison_shadow(object, cache->object_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_userword",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_userword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "350-354",
          "snippet": "static void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tBYTES_PER_WORD\t\tsizeof(void *)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n\nstatic noinline struct;\n\nstatic void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "i"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic noinline struct;\n\nstatic void cache_init_objs_debug(struct kmem_cache *cachep, struct page *page)\n{\n#if DEBUG\n\tint i;\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tvoid *objp = index_to_obj(cachep, page, i);\n\n\t\tif (cachep->flags & SLAB_STORE_USER)\n\t\t\t*dbg_userword(cachep, objp) = NULL;\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\t*dbg_redzone1(cachep, objp) = RED_INACTIVE;\n\t\t\t*dbg_redzone2(cachep, objp) = RED_INACTIVE;\n\t\t}\n\t\t/*\n\t\t * Constructors are not allowed to allocate memory from the same\n\t\t * cache which they are a constructor for.  Otherwise, deadlock.\n\t\t * They must also be threaded.\n\t\t */\n\t\tif (cachep->ctor && !(cachep->flags & SLAB_POISON)) {\n\t\t\tkasan_unpoison_object_data(cachep,\n\t\t\t\t\t\t   objp + obj_offset(cachep));\n\t\t\tcachep->ctor(objp + obj_offset(cachep));\n\t\t\tkasan_poison_object_data(\n\t\t\t\tcachep, objp + obj_offset(cachep));\n\t\t}\n\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\tif (*dbg_redzone2(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the end of an object\");\n\t\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"constructor overwrote the start of an object\");\n\t\t}\n\t\t/* need to poison the objs? */\n\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t\t\tslab_kernel_map(cachep, objp, 0, 0);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "set_free_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2398-2402",
    "snippet": "static inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_free_obj(struct page *page,\n\t\t\t\t\tunsigned int idx, freelist_idx_t val)\n{\n\t((freelist_idx_t *)(page->freelist))[idx] = val;\n}"
  },
  {
    "function_name": "get_free_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2393-2396",
    "snippet": "static inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)\n{\n\treturn ((freelist_idx_t *)page->freelist)[idx];\n}"
  },
  {
    "function_name": "alloc_slabmgmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2366-2391",
    "snippet": "static void *alloc_slabmgmt(struct kmem_cache *cachep,\n\t\t\t\t   struct page *page, int colour_off,\n\t\t\t\t   gfp_t local_flags, int nodeid)\n{\n\tvoid *freelist;\n\tvoid *addr = page_address(page);\n\n\tpage->s_mem = addr + colour_off;\n\tpage->active = 0;\n\n\tif (OBJFREELIST_SLAB(cachep))\n\t\tfreelist = NULL;\n\telse if (OFF_SLAB(cachep)) {\n\t\t/* Slab management obj is off-slab. */\n\t\tfreelist = kmem_cache_alloc_node(cachep->freelist_cache,\n\t\t\t\t\t      local_flags, nodeid);\n\t\tif (!freelist)\n\t\t\treturn NULL;\n\t} else {\n\t\t/* We will use last bytes at the slab for freelist */\n\t\tfreelist = addr + (PAGE_SIZE << cachep->gfporder) -\n\t\t\t\tcachep->freelist_size;\n\t}\n\n\treturn freelist;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc_node",
          "args": [
            "cachep->freelist_cache",
            "local_flags",
            "nodeid"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3640-3650",
          "snippet": "void *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid)\n{\n\tvoid *ret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    cachep->object_size, cachep->size,\n\t\t\t\t    flags, nodeid);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid)\n{\n\tvoid *ret = slab_alloc_node(cachep, flags, nodeid, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    cachep->object_size, cachep->size,\n\t\t\t\t    flags, nodeid);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFF_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJFREELIST_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void *alloc_slabmgmt(struct kmem_cache *cachep,\n\t\t\t\t   struct page *page, int colour_off,\n\t\t\t\t   gfp_t local_flags, int nodeid)\n{\n\tvoid *freelist;\n\tvoid *addr = page_address(page);\n\n\tpage->s_mem = addr + colour_off;\n\tpage->active = 0;\n\n\tif (OBJFREELIST_SLAB(cachep))\n\t\tfreelist = NULL;\n\telse if (OFF_SLAB(cachep)) {\n\t\t/* Slab management obj is off-slab. */\n\t\tfreelist = kmem_cache_alloc_node(cachep->freelist_cache,\n\t\t\t\t\t      local_flags, nodeid);\n\t\tif (!freelist)\n\t\t\treturn NULL;\n\t} else {\n\t\t/* We will use last bytes at the slab for freelist */\n\t\tfreelist = addr + (PAGE_SIZE << cachep->gfporder) -\n\t\t\t\tcachep->freelist_size;\n\t}\n\n\treturn freelist;\n}"
  },
  {
    "function_name": "__kmem_cache_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2334-2350",
    "snippet": "void __kmem_cache_release(struct kmem_cache *cachep)\n{\n\tint i;\n\tstruct kmem_cache_node *n;\n\n\tcache_random_seq_destroy(cachep);\n\n\tfree_percpu(cachep->cpu_cache);\n\n\t/* NUMA: free the node structures */\n\tfor_each_kmem_cache_node(cachep, i, n) {\n\t\tkfree(n->shared);\n\t\tfree_alien_cache(n->alien);\n\t\tkfree(n);\n\t\tcachep->node[i] = NULL;\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3802-3819",
          "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_alien_cache",
          "args": [
            "n->alien"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "free_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "713-722",
          "snippet": "static void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "cachep",
            "i",
            "n"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cachep->cpu_cache"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_random_seq_destroy",
          "args": [
            "cachep"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "cache_random_seq_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "528-528",
          "snippet": "static inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid __kmem_cache_release(struct kmem_cache *cachep)\n{\n\tint i;\n\tstruct kmem_cache_node *n;\n\n\tcache_random_seq_destroy(cachep);\n\n\tfree_percpu(cachep->cpu_cache);\n\n\t/* NUMA: free the node structures */\n\tfor_each_kmem_cache_node(cachep, i, n) {\n\t\tkfree(n->shared);\n\t\tfree_alien_cache(n->alien);\n\t\tkfree(n);\n\t\tcachep->node[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "__kmem_cache_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2329-2332",
    "snippet": "int __kmem_cache_shutdown(struct kmem_cache *cachep)\n{\n\treturn __kmem_cache_shrink(cachep);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_shrink",
          "args": [
            "cachep"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2304-2320",
          "snippet": "int __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nint __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nint __kmem_cache_shutdown(struct kmem_cache *cachep)\n{\n\treturn __kmem_cache_shrink(cachep);\n}"
  },
  {
    "function_name": "__kmemcg_cache_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2323-2326",
    "snippet": "void __kmemcg_cache_deactivate(struct kmem_cache *cachep)\n{\n\t__kmem_cache_shrink(cachep);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_shrink",
          "args": [
            "cachep"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2304-2320",
          "snippet": "int __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nint __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid __kmemcg_cache_deactivate(struct kmem_cache *cachep)\n{\n\t__kmem_cache_shrink(cachep);\n}"
  },
  {
    "function_name": "__kmem_cache_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2304-2320",
    "snippet": "int __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&n->slabs_partial"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_freelist",
          "args": [
            "cachep",
            "n",
            "INT_MAX"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "drain_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2258-2290",
          "snippet": "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic noinline struct;\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "n"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_on",
          "args": [],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2162-2165",
          "snippet": "static void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_cpu_caches",
          "args": [
            "cachep"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "drain_cpu_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2231-2250",
          "snippet": "static void drain_cpu_caches(struct kmem_cache *cachep)\n{\n\tstruct kmem_cache_node *n;\n\tint node;\n\tLIST_HEAD(list);\n\n\ton_each_cpu(do_drain, cachep, 1);\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n)\n\t\tif (n->alien)\n\t\t\tdrain_alien_cache(cachep, n->alien);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tdrain_array_locked(cachep, n->shared, node, true, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tslabs_destroy(cachep, &list);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_cpu_caches(struct kmem_cache *cachep)\n{\n\tstruct kmem_cache_node *n;\n\tint node;\n\tLIST_HEAD(list);\n\n\ton_each_cpu(do_drain, cachep, 1);\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n)\n\t\tif (n->alien)\n\t\t\tdrain_alien_cache(cachep, n->alien);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tdrain_array_locked(cachep, n->shared, node, true, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tslabs_destroy(cachep, &list);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nint __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}"
  },
  {
    "function_name": "__kmem_cache_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2292-2302",
    "snippet": "bool __kmem_cache_empty(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (!list_empty(&n->slabs_full) ||\n\t\t    !list_empty(&n->slabs_partial))\n\t\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&n->slabs_partial"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nbool __kmem_cache_empty(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (!list_empty(&n->slabs_full) ||\n\t\t    !list_empty(&n->slabs_partial))\n\t\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "drain_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2258-2290",
    "snippet": "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_destroy",
          "args": [
            "cache",
            "page"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "slab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1701-1718",
          "snippet": "static void slab_destroy(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *freelist;\n\n\tfreelist = page->freelist;\n\tslab_destroy_debugcheck(cachep, page);\n\tif (unlikely(cachep->flags & SLAB_TYPESAFE_BY_RCU))\n\t\tcall_rcu(&page->rcu_head, kmem_rcu_free);\n\telse\n\t\tkmem_freepages(cachep, page);\n\n\t/*\n\t * From now on, we don't use freelist\n\t * although actual page can be freed in rcu context\n\t */\n\tif (OFF_SLAB(cachep))\n\t\tkmem_cache_free(cachep->freelist_cache, freelist);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_destroy(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *freelist;\n\n\tfreelist = page->freelist;\n\tslab_destroy_debugcheck(cachep, page);\n\tif (unlikely(cachep->flags & SLAB_TYPESAFE_BY_RCU))\n\t\tcall_rcu(&page->rcu_head, kmem_rcu_free);\n\telse\n\t\tkmem_freepages(cachep, page);\n\n\t/*\n\t * From now on, we don't use freelist\n\t * although actual page can be freed in rcu context\n\t */\n\tif (OFF_SLAB(cachep))\n\t\tkmem_cache_free(cachep->freelist_cache, freelist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structpage",
            "lru"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&n->slabs_free"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic noinline struct;\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}"
  },
  {
    "function_name": "drain_cpu_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2231-2250",
    "snippet": "static void drain_cpu_caches(struct kmem_cache *cachep)\n{\n\tstruct kmem_cache_node *n;\n\tint node;\n\tLIST_HEAD(list);\n\n\ton_each_cpu(do_drain, cachep, 1);\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n)\n\t\tif (n->alien)\n\t\t\tdrain_alien_cache(cachep, n->alien);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tdrain_array_locked(cachep, n->shared, node, true, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tslabs_destroy(cachep, &list);\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_array_locked",
          "args": [
            "cachep",
            "n->shared",
            "node",
            "true",
            "&list"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "drain_array_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2196-2211",
          "snippet": "static void drain_array_locked(struct kmem_cache *cachep, struct array_cache *ac,\n\t\t\t\tint node, bool free_all, struct list_head *list)\n{\n\tint tofree;\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\ttofree = free_all ? ac->avail : (ac->limit + 4) / 5;\n\tif (tofree > ac->avail)\n\t\ttofree = (ac->avail + 1) / 2;\n\n\tfree_block(cachep, ac->entry, tofree, node, list);\n\tac->avail -= tofree;\n\tmemmove(ac->entry, &(ac->entry[tofree]), sizeof(void *) * ac->avail);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_array_locked(struct kmem_cache *cachep, struct array_cache *ac,\n\t\t\t\tint node, bool free_all, struct list_head *list)\n{\n\tint tofree;\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\ttofree = free_all ? ac->avail : (ac->limit + 4) / 5;\n\tif (tofree > ac->avail)\n\t\ttofree = (ac->avail + 1) / 2;\n\n\tfree_block(cachep, ac->entry, tofree, node, list);\n\tac->avail -= tofree;\n\tmemmove(ac->entry, &(ac->entry[tofree]), sizeof(void *) * ac->avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "n"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_alien_cache",
          "args": [
            "cachep",
            "n->alien"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "drain_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "770-790",
          "snippet": "static void drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct alien_cache **alien)\n{\n\tint i = 0;\n\tstruct alien_cache *alc;\n\tstruct array_cache *ac;\n\tunsigned long flags;\n\n\tfor_each_online_node(i) {\n\t\talc = alien[i];\n\t\tif (alc) {\n\t\t\tLIST_HEAD(list);\n\n\t\t\tac = &alc->ac;\n\t\t\tspin_lock_irqsave(&alc->lock, flags);\n\t\t\t__drain_alien_cache(cachep, ac, i, &list);\n\t\t\tspin_unlock_irqrestore(&alc->lock, flags);\n\t\t\tslabs_destroy(cachep, &list);\n\t\t}\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct alien_cache **alien)\n{\n\tint i = 0;\n\tstruct alien_cache *alc;\n\tstruct array_cache *ac;\n\tunsigned long flags;\n\n\tfor_each_online_node(i) {\n\t\talc = alien[i];\n\t\tif (alc) {\n\t\t\tLIST_HEAD(list);\n\n\t\t\tac = &alc->ac;\n\t\t\tspin_lock_irqsave(&alc->lock, flags);\n\t\t\t__drain_alien_cache(cachep, ac, i, &list);\n\t\t\tspin_unlock_irqrestore(&alc->lock, flags);\n\t\t\tslabs_destroy(cachep, &list);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "n"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_on",
          "args": [],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2162-2165",
          "snippet": "static void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "do_drain",
            "cachep",
            "1"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_cpu_caches(struct kmem_cache *cachep)\n{\n\tstruct kmem_cache_node *n;\n\tint node;\n\tLIST_HEAD(list);\n\n\ton_each_cpu(do_drain, cachep, 1);\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n)\n\t\tif (n->alien)\n\t\t\tdrain_alien_cache(cachep, n->alien);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tdrain_array_locked(cachep, n->shared, node, true, &list);\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tslabs_destroy(cachep, &list);\n\t}\n}"
  },
  {
    "function_name": "do_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2213-2229",
    "snippet": "static void do_drain(void *arg)\n{\n\tstruct kmem_cache *cachep = arg;\n\tstruct array_cache *ac;\n\tint node = numa_mem_id();\n\tstruct kmem_cache_node *n;\n\tLIST_HEAD(list);\n\n\tcheck_irq_off();\n\tac = cpu_cache_get(cachep);\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tfree_block(cachep, ac->entry, ac->avail, node, &list);\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail = 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "ac->entry",
            "ac->avail",
            "node",
            "&list"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_cache_get",
          "args": [
            "cachep"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "434-437",
          "snippet": "static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void do_drain(void *arg)\n{\n\tstruct kmem_cache *cachep = arg;\n\tstruct array_cache *ac;\n\tint node = numa_mem_id();\n\tstruct kmem_cache_node *n;\n\tLIST_HEAD(list);\n\n\tcheck_irq_off();\n\tac = cpu_cache_get(cachep);\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tfree_block(cachep, ac->entry, ac->avail, node, &list);\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail = 0;\n}"
  },
  {
    "function_name": "drain_array_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2196-2211",
    "snippet": "static void drain_array_locked(struct kmem_cache *cachep, struct array_cache *ac,\n\t\t\t\tint node, bool free_all, struct list_head *list)\n{\n\tint tofree;\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\ttofree = free_all ? ac->avail : (ac->limit + 4) / 5;\n\tif (tofree > ac->avail)\n\t\ttofree = (ac->avail + 1) / 2;\n\n\tfree_block(cachep, ac->entry, tofree, node, list);\n\tac->avail -= tofree;\n\tmemmove(ac->entry, &(ac->entry[tofree]), sizeof(void *) * ac->avail);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ac->entry",
            "&(ac->entry[tofree])",
            "sizeof(void *) * ac->avail"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "ac->entry",
            "tofree",
            "node",
            "list"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_array_locked(struct kmem_cache *cachep, struct array_cache *ac,\n\t\t\t\tint node, bool free_all, struct list_head *list)\n{\n\tint tofree;\n\n\tif (!ac || !ac->avail)\n\t\treturn;\n\n\ttofree = free_all ? ac->avail : (ac->limit + 4) / 5;\n\tif (tofree > ac->avail)\n\t\ttofree = (ac->avail + 1) / 2;\n\n\tfree_block(cachep, ac->entry, tofree, node, list);\n\tac->avail -= tofree;\n\tmemmove(ac->entry, &(ac->entry[tofree]), sizeof(void *) * ac->avail);\n}"
  },
  {
    "function_name": "check_spinlock_acquired_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2180-2186",
    "snippet": "static void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, node)->list_lock);\n#endif\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&get_node(cachep, node)->list_lock"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, node)->list_lock);\n#endif\n}"
  },
  {
    "function_name": "check_spinlock_acquired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2172-2178",
    "snippet": "static void check_spinlock_acquired(struct kmem_cache *cachep)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, numa_mem_id())->list_lock);\n#endif\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&get_node(cachep, numa_mem_id())->list_lock"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "numa_mem_id()"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_off",
          "args": [],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2157-2160",
          "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_spinlock_acquired(struct kmem_cache *cachep)\n{\n#ifdef CONFIG_SMP\n\tcheck_irq_off();\n\tassert_spin_locked(&get_node(cachep, numa_mem_id())->list_lock);\n#endif\n}"
  },
  {
    "function_name": "check_mutex_acquired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2167-2170",
    "snippet": "static void check_mutex_acquired(void)\n{\n\tBUG_ON(!mutex_is_locked(&slab_mutex));\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&slab_mutex)"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&slab_mutex"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_mutex_acquired(void)\n{\n\tBUG_ON(!mutex_is_locked(&slab_mutex));\n}"
  },
  {
    "function_name": "check_irq_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2162-2165",
    "snippet": "static void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irqs_disabled()"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_on(void)\n{\n\tBUG_ON(irqs_disabled());\n}"
  },
  {
    "function_name": "check_irq_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "2157-2160",
    "snippet": "static void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void check_irq_off(void)\n{\n\tBUG_ON(!irqs_disabled());\n}"
  },
  {
    "function_name": "__kmem_cache_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1990-2154",
    "snippet": "int __kmem_cache_create(struct kmem_cache *cachep, slab_flags_t flags)\n{\n\tsize_t ralign = BYTES_PER_WORD;\n\tgfp_t gfp;\n\tint err;\n\tunsigned int size = cachep->size;\n\n#if DEBUG\n#if FORCED_DEBUG\n\t/*\n\t * Enable redzoning and last user accounting, except for caches with\n\t * large objects, if the increased size would increase the object size\n\t * above the next power of two: caches with object sizes just above a\n\t * power of two have a significant amount of internal fragmentation.\n\t */\n\tif (size < 4096 || fls(size - 1) == fls(size-1 + REDZONE_ALIGN +\n\t\t\t\t\t\t2 * sizeof(unsigned long long)))\n\t\tflags |= SLAB_RED_ZONE | SLAB_STORE_USER;\n\tif (!(flags & SLAB_TYPESAFE_BY_RCU))\n\t\tflags |= SLAB_POISON;\n#endif\n#endif\n\n\t/*\n\t * Check that size is in terms of words.  This is needed to avoid\n\t * unaligned accesses for some archs when redzoning is used, and makes\n\t * sure any on-slab bufctl's are also correctly aligned.\n\t */\n\tsize = ALIGN(size, BYTES_PER_WORD);\n\n\tif (flags & SLAB_RED_ZONE) {\n\t\tralign = REDZONE_ALIGN;\n\t\t/* If redzoning, ensure that the second redzone is suitably\n\t\t * aligned, by adjusting the object size accordingly. */\n\t\tsize = ALIGN(size, REDZONE_ALIGN);\n\t}\n\n\t/* 3) caller mandated alignment */\n\tif (ralign < cachep->align) {\n\t\tralign = cachep->align;\n\t}\n\t/* disable debug if necessary */\n\tif (ralign > __alignof__(unsigned long long))\n\t\tflags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n\t/*\n\t * 4) Store it.\n\t */\n\tcachep->align = ralign;\n\tcachep->colour_off = cache_line_size();\n\t/* Offset must be a multiple of the alignment. */\n\tif (cachep->colour_off < cachep->align)\n\t\tcachep->colour_off = cachep->align;\n\n\tif (slab_is_available())\n\t\tgfp = GFP_KERNEL;\n\telse\n\t\tgfp = GFP_NOWAIT;\n\n#if DEBUG\n\n\t/*\n\t * Both debugging options require word-alignment which is calculated\n\t * into align above.\n\t */\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/* add space for red zone words */\n\t\tcachep->obj_offset += sizeof(unsigned long long);\n\t\tsize += 2 * sizeof(unsigned long long);\n\t}\n\tif (flags & SLAB_STORE_USER) {\n\t\t/* user store requires one word storage behind the end of\n\t\t * the real object. But if the second red zone needs to be\n\t\t * aligned to 64 bits, we must allow that much space.\n\t\t */\n\t\tif (flags & SLAB_RED_ZONE)\n\t\t\tsize += REDZONE_ALIGN;\n\t\telse\n\t\t\tsize += BYTES_PER_WORD;\n\t}\n#endif\n\n\tkasan_cache_create(cachep, &size, &flags);\n\n\tsize = ALIGN(size, cachep->align);\n\t/*\n\t * We should restrict the number of objects in a slab to implement\n\t * byte sized index. Refer comment on SLAB_OBJ_MIN_SIZE definition.\n\t */\n\tif (FREELIST_BYTE_INDEX && size < SLAB_OBJ_MIN_SIZE)\n\t\tsize = ALIGN(SLAB_OBJ_MIN_SIZE, cachep->align);\n\n#if DEBUG\n\t/*\n\t * To activate debug pagealloc, off-slab management is necessary\n\t * requirement. In early phase of initialization, small sized slab\n\t * doesn't get initialized so it would not be possible. So, we need\n\t * to check size >= 256. It guarantees that all necessary small\n\t * sized slab is initialized in current slab initialization sequence.\n\t */\n\tif (debug_pagealloc_enabled() && (flags & SLAB_POISON) &&\n\t\tsize >= 256 && cachep->object_size > cache_line_size()) {\n\t\tif (size < PAGE_SIZE || size % PAGE_SIZE == 0) {\n\t\t\tsize_t tmp_size = ALIGN(size, PAGE_SIZE);\n\n\t\t\tif (set_off_slab_cache(cachep, tmp_size, flags)) {\n\t\t\t\tflags |= CFLGS_OFF_SLAB;\n\t\t\t\tcachep->obj_offset += tmp_size - size;\n\t\t\t\tsize = tmp_size;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (set_objfreelist_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OBJFREELIST_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_off_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OFF_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_on_slab_cache(cachep, size, flags))\n\t\tgoto done;\n\n\treturn -E2BIG;\n\ndone:\n\tcachep->freelist_size = cachep->num * sizeof(freelist_idx_t);\n\tcachep->flags = flags;\n\tcachep->allocflags = __GFP_COMP;\n\tif (flags & SLAB_CACHE_DMA)\n\t\tcachep->allocflags |= GFP_DMA;\n\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\tcachep->allocflags |= __GFP_RECLAIMABLE;\n\tcachep->size = size;\n\tcachep->reciprocal_buffer_size = reciprocal_value(size);\n\n#if DEBUG\n\t/*\n\t * If we're going to use the generic kernel_map_pages()\n\t * poisoning, then it's going to smash the contents of\n\t * the redzone and userword anyhow, so switch them off.\n\t */\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING) &&\n\t\t(cachep->flags & SLAB_POISON) &&\n\t\tis_debug_pagealloc_cache(cachep))\n\t\tcachep->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n#endif\n\n\tif (OFF_SLAB(cachep)) {\n\t\tcachep->freelist_cache =\n\t\t\tkmalloc_slab(cachep->freelist_size, 0u);\n\t}\n\n\terr = setup_cpu_cache(cachep, gfp);\n\tif (err) {\n\t\t__kmem_cache_release(cachep);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
      "#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)",
      "#define FREELIST_BYTE_INDEX (((PAGE_SIZE >> BITS_PER_BYTE) \\\n\t\t\t\t<= SLAB_OBJ_MIN_SIZE) ? 1 : 0)",
      "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))",
      "#define\tBYTES_PER_WORD\t\tsizeof(void *)",
      "#define\tFORCED_DEBUG\t0",
      "#define\tDEBUG\t\t0",
      "#define\tFORCED_DEBUG\t1",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_release",
          "args": [
            "cachep"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2334-2350",
          "snippet": "void __kmem_cache_release(struct kmem_cache *cachep)\n{\n\tint i;\n\tstruct kmem_cache_node *n;\n\n\tcache_random_seq_destroy(cachep);\n\n\tfree_percpu(cachep->cpu_cache);\n\n\t/* NUMA: free the node structures */\n\tfor_each_kmem_cache_node(cachep, i, n) {\n\t\tkfree(n->shared);\n\t\tfree_alien_cache(n->alien);\n\t\tkfree(n);\n\t\tcachep->node[i] = NULL;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid __kmem_cache_release(struct kmem_cache *cachep)\n{\n\tint i;\n\tstruct kmem_cache_node *n;\n\n\tcache_random_seq_destroy(cachep);\n\n\tfree_percpu(cachep->cpu_cache);\n\n\t/* NUMA: free the node structures */\n\tfor_each_kmem_cache_node(cachep, i, n) {\n\t\tkfree(n->shared);\n\t\tfree_alien_cache(n->alien);\n\t\tkfree(n);\n\t\tcachep->node[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_cpu_cache",
          "args": [
            "cachep",
            "gfp"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cpu_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1831-1868",
          "snippet": "static int __ref setup_cpu_cache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tif (slab_state >= FULL)\n\t\treturn enable_cpucache(cachep, gfp);\n\n\tcachep->cpu_cache = alloc_kmem_cache_cpus(cachep, 1, 1);\n\tif (!cachep->cpu_cache)\n\t\treturn 1;\n\n\tif (slab_state == DOWN) {\n\t\t/* Creation of first cache (kmem_cache). */\n\t\tset_up_node(kmem_cache, CACHE_CACHE);\n\t} else if (slab_state == PARTIAL) {\n\t\t/* For kmem_cache_node */\n\t\tset_up_node(cachep, SIZE_NODE);\n\t} else {\n\t\tint node;\n\n\t\tfor_each_online_node(node) {\n\t\t\tcachep->node[node] = kmalloc_node(\n\t\t\t\tsizeof(struct kmem_cache_node), gfp, node);\n\t\t\tBUG_ON(!cachep->node[node]);\n\t\t\tkmem_cache_node_init(cachep->node[node]);\n\t\t}\n\t}\n\n\tcachep->node[numa_mem_id()]->next_reap =\n\t\t\tjiffies + REAPTIMEOUT_NODE +\n\t\t\t((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tcpu_cache_get(cachep)->avail = 0;\n\tcpu_cache_get(cachep)->limit = BOOT_CPUCACHE_ENTRIES;\n\tcpu_cache_get(cachep)->batchcount = 1;\n\tcpu_cache_get(cachep)->touched = 0;\n\tcachep->batchcount = 1;\n\tcachep->limit = BOOT_CPUCACHE_ENTRIES;\n\treturn 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define BOOT_CPUCACHE_ENTRIES\t1",
            "#define REAPTIMEOUT_NODE\t(4*HZ)",
            "#define\tSIZE_NODE (MAX_NUMNODES)",
            "#define\tCACHE_CACHE 0"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define BOOT_CPUCACHE_ENTRIES\t1\n#define REAPTIMEOUT_NODE\t(4*HZ)\n#define\tSIZE_NODE (MAX_NUMNODES)\n#define\tCACHE_CACHE 0\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int __ref setup_cpu_cache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tif (slab_state >= FULL)\n\t\treturn enable_cpucache(cachep, gfp);\n\n\tcachep->cpu_cache = alloc_kmem_cache_cpus(cachep, 1, 1);\n\tif (!cachep->cpu_cache)\n\t\treturn 1;\n\n\tif (slab_state == DOWN) {\n\t\t/* Creation of first cache (kmem_cache). */\n\t\tset_up_node(kmem_cache, CACHE_CACHE);\n\t} else if (slab_state == PARTIAL) {\n\t\t/* For kmem_cache_node */\n\t\tset_up_node(cachep, SIZE_NODE);\n\t} else {\n\t\tint node;\n\n\t\tfor_each_online_node(node) {\n\t\t\tcachep->node[node] = kmalloc_node(\n\t\t\t\tsizeof(struct kmem_cache_node), gfp, node);\n\t\t\tBUG_ON(!cachep->node[node]);\n\t\t\tkmem_cache_node_init(cachep->node[node]);\n\t\t}\n\t}\n\n\tcachep->node[numa_mem_id()]->next_reap =\n\t\t\tjiffies + REAPTIMEOUT_NODE +\n\t\t\t((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tcpu_cache_get(cachep)->avail = 0;\n\tcpu_cache_get(cachep)->limit = BOOT_CPUCACHE_ENTRIES;\n\tcpu_cache_get(cachep)->batchcount = 1;\n\tcpu_cache_get(cachep)->touched = 0;\n\tcachep->batchcount = 1;\n\tcachep->limit = BOOT_CPUCACHE_ENTRIES;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "cachep->freelist_size",
            "0u"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFF_SLAB",
          "args": [
            "cachep"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_debug_pagealloc_cache",
          "args": [
            "cachep"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "is_debug_pagealloc_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1471-1478",
          "snippet": "static bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PAGE_POISONING"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reciprocal_value",
          "args": [
            "size"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_on_slab_cache",
          "args": [
            "cachep",
            "size",
            "flags"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "set_on_slab_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1953-1967",
          "snippet": "static bool set_on_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tleft = calculate_slab_order(cachep, size, flags);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic bool set_on_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tleft = calculate_slab_order(cachep, size, flags);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_off_slab_cache",
          "args": [
            "cachep",
            "size",
            "flags"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "set_off_slab_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1919-1951",
          "snippet": "static bool set_off_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\t/*\n\t * Always use on-slab management when SLAB_NOLEAKTRACE\n\t * to avoid recursive calls into kmemleak.\n\t */\n\tif (flags & SLAB_NOLEAKTRACE)\n\t\treturn false;\n\n\t/*\n\t * Size is large, assume best to place the slab management obj\n\t * off-slab (should allow better packing of objs).\n\t */\n\tleft = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\t/*\n\t * If the slab has been placed off-slab, and we have enough space then\n\t * move it on-slab. This is at the expense of any extra colouring.\n\t */\n\tif (left >= cachep->num * sizeof(freelist_idx_t))\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n\nstatic noinline struct;\n\nstatic bool set_off_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\t/*\n\t * Always use on-slab management when SLAB_NOLEAKTRACE\n\t * to avoid recursive calls into kmemleak.\n\t */\n\tif (flags & SLAB_NOLEAKTRACE)\n\t\treturn false;\n\n\t/*\n\t * Size is large, assume best to place the slab management obj\n\t * off-slab (should allow better packing of objs).\n\t */\n\tleft = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\t/*\n\t * If the slab has been placed off-slab, and we have enough space then\n\t * move it on-slab. This is at the expense of any extra colouring.\n\t */\n\tif (left >= cachep->num * sizeof(freelist_idx_t))\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_objfreelist_slab_cache",
          "args": [
            "cachep",
            "size",
            "flags"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "set_objfreelist_slab_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1896-1917",
          "snippet": "static bool set_objfreelist_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tif (cachep->ctor || flags & SLAB_TYPESAFE_BY_RCU)\n\t\treturn false;\n\n\tleft = calculate_slab_order(cachep, size,\n\t\t\tflags | CFLGS_OBJFREELIST_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tif (cachep->num * sizeof(freelist_idx_t) > cachep->object_size)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)\n\nstatic noinline struct;\n\nstatic bool set_objfreelist_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tif (cachep->ctor || flags & SLAB_TYPESAFE_BY_RCU)\n\t\treturn false;\n\n\tleft = calculate_slab_order(cachep, size,\n\t\t\tflags | CFLGS_OBJFREELIST_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tif (cachep->num * sizeof(freelist_idx_t) > cachep->object_size)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "SLAB_OBJ_MIN_SIZE",
            "cachep->align"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "cachep->align"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_cache_create",
          "args": [
            "cachep",
            "&size",
            "&flags"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "338-376",
          "snippet": "void kasan_cache_create(struct kmem_cache *cache, unsigned int *size,\n\t\t\tslab_flags_t *flags)\n{\n\tunsigned int orig_size = *size;\n\tint redzone_adjust;\n\n\t/* Add alloc meta. */\n\tcache->kasan_info.alloc_meta_offset = *size;\n\t*size += sizeof(struct kasan_alloc_meta);\n\n\t/* Add free meta. */\n\tif (cache->flags & SLAB_TYPESAFE_BY_RCU || cache->ctor ||\n\t    cache->object_size < sizeof(struct kasan_free_meta)) {\n\t\tcache->kasan_info.free_meta_offset = *size;\n\t\t*size += sizeof(struct kasan_free_meta);\n\t}\n\tredzone_adjust = optimal_redzone(cache->object_size) -\n\t\t(*size - cache->object_size);\n\n\tif (redzone_adjust > 0)\n\t\t*size += redzone_adjust;\n\n\t*size = min_t(unsigned int, KMALLOC_MAX_SIZE,\n\t\t\tmax(*size, cache->object_size +\n\t\t\t\t\toptimal_redzone(cache->object_size)));\n\n\t/*\n\t * If the metadata doesn't fit, don't enable KASAN at all.\n\t */\n\tif (*size <= cache->kasan_info.alloc_meta_offset ||\n\t\t\t*size <= cache->kasan_info.free_meta_offset) {\n\t\tcache->kasan_info.alloc_meta_offset = 0;\n\t\tcache->kasan_info.free_meta_offset = 0;\n\t\t*size = orig_size;\n\t\treturn;\n\t}\n\n\t*flags |= SLAB_KASAN;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_cache_create(struct kmem_cache *cache, unsigned int *size,\n\t\t\tslab_flags_t *flags)\n{\n\tunsigned int orig_size = *size;\n\tint redzone_adjust;\n\n\t/* Add alloc meta. */\n\tcache->kasan_info.alloc_meta_offset = *size;\n\t*size += sizeof(struct kasan_alloc_meta);\n\n\t/* Add free meta. */\n\tif (cache->flags & SLAB_TYPESAFE_BY_RCU || cache->ctor ||\n\t    cache->object_size < sizeof(struct kasan_free_meta)) {\n\t\tcache->kasan_info.free_meta_offset = *size;\n\t\t*size += sizeof(struct kasan_free_meta);\n\t}\n\tredzone_adjust = optimal_redzone(cache->object_size) -\n\t\t(*size - cache->object_size);\n\n\tif (redzone_adjust > 0)\n\t\t*size += redzone_adjust;\n\n\t*size = min_t(unsigned int, KMALLOC_MAX_SIZE,\n\t\t\tmax(*size, cache->object_size +\n\t\t\t\t\toptimal_redzone(cache->object_size)));\n\n\t/*\n\t * If the metadata doesn't fit, don't enable KASAN at all.\n\t */\n\tif (*size <= cache->kasan_info.alloc_meta_offset ||\n\t\t\t*size <= cache->kasan_info.free_meta_offset) {\n\t\tcache->kasan_info.alloc_meta_offset = 0;\n\t\tcache->kasan_info.free_meta_offset = 0;\n\t\t*size = orig_size;\n\t\treturn;\n\t}\n\n\t*flags |= SLAB_KASAN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "slab_is_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "930-933",
          "snippet": "bool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum slab_state slab_state;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\n\nbool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "REDZONE_ALIGN"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "BYTES_PER_WORD"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "size-1 + REDZONE_ALIGN +\n\t\t\t\t\t\t2 * sizeof(unsigned long long)"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "size - 1"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)\n#define FREELIST_BYTE_INDEX (((PAGE_SIZE >> BITS_PER_BYTE) \\\n\t\t\t\t<= SLAB_OBJ_MIN_SIZE) ? 1 : 0)\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n#define\tFORCED_DEBUG\t0\n#define\tDEBUG\t\t0\n#define\tFORCED_DEBUG\t1\n#define\tDEBUG\t\t1\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nint __kmem_cache_create(struct kmem_cache *cachep, slab_flags_t flags)\n{\n\tsize_t ralign = BYTES_PER_WORD;\n\tgfp_t gfp;\n\tint err;\n\tunsigned int size = cachep->size;\n\n#if DEBUG\n#if FORCED_DEBUG\n\t/*\n\t * Enable redzoning and last user accounting, except for caches with\n\t * large objects, if the increased size would increase the object size\n\t * above the next power of two: caches with object sizes just above a\n\t * power of two have a significant amount of internal fragmentation.\n\t */\n\tif (size < 4096 || fls(size - 1) == fls(size-1 + REDZONE_ALIGN +\n\t\t\t\t\t\t2 * sizeof(unsigned long long)))\n\t\tflags |= SLAB_RED_ZONE | SLAB_STORE_USER;\n\tif (!(flags & SLAB_TYPESAFE_BY_RCU))\n\t\tflags |= SLAB_POISON;\n#endif\n#endif\n\n\t/*\n\t * Check that size is in terms of words.  This is needed to avoid\n\t * unaligned accesses for some archs when redzoning is used, and makes\n\t * sure any on-slab bufctl's are also correctly aligned.\n\t */\n\tsize = ALIGN(size, BYTES_PER_WORD);\n\n\tif (flags & SLAB_RED_ZONE) {\n\t\tralign = REDZONE_ALIGN;\n\t\t/* If redzoning, ensure that the second redzone is suitably\n\t\t * aligned, by adjusting the object size accordingly. */\n\t\tsize = ALIGN(size, REDZONE_ALIGN);\n\t}\n\n\t/* 3) caller mandated alignment */\n\tif (ralign < cachep->align) {\n\t\tralign = cachep->align;\n\t}\n\t/* disable debug if necessary */\n\tif (ralign > __alignof__(unsigned long long))\n\t\tflags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n\t/*\n\t * 4) Store it.\n\t */\n\tcachep->align = ralign;\n\tcachep->colour_off = cache_line_size();\n\t/* Offset must be a multiple of the alignment. */\n\tif (cachep->colour_off < cachep->align)\n\t\tcachep->colour_off = cachep->align;\n\n\tif (slab_is_available())\n\t\tgfp = GFP_KERNEL;\n\telse\n\t\tgfp = GFP_NOWAIT;\n\n#if DEBUG\n\n\t/*\n\t * Both debugging options require word-alignment which is calculated\n\t * into align above.\n\t */\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/* add space for red zone words */\n\t\tcachep->obj_offset += sizeof(unsigned long long);\n\t\tsize += 2 * sizeof(unsigned long long);\n\t}\n\tif (flags & SLAB_STORE_USER) {\n\t\t/* user store requires one word storage behind the end of\n\t\t * the real object. But if the second red zone needs to be\n\t\t * aligned to 64 bits, we must allow that much space.\n\t\t */\n\t\tif (flags & SLAB_RED_ZONE)\n\t\t\tsize += REDZONE_ALIGN;\n\t\telse\n\t\t\tsize += BYTES_PER_WORD;\n\t}\n#endif\n\n\tkasan_cache_create(cachep, &size, &flags);\n\n\tsize = ALIGN(size, cachep->align);\n\t/*\n\t * We should restrict the number of objects in a slab to implement\n\t * byte sized index. Refer comment on SLAB_OBJ_MIN_SIZE definition.\n\t */\n\tif (FREELIST_BYTE_INDEX && size < SLAB_OBJ_MIN_SIZE)\n\t\tsize = ALIGN(SLAB_OBJ_MIN_SIZE, cachep->align);\n\n#if DEBUG\n\t/*\n\t * To activate debug pagealloc, off-slab management is necessary\n\t * requirement. In early phase of initialization, small sized slab\n\t * doesn't get initialized so it would not be possible. So, we need\n\t * to check size >= 256. It guarantees that all necessary small\n\t * sized slab is initialized in current slab initialization sequence.\n\t */\n\tif (debug_pagealloc_enabled() && (flags & SLAB_POISON) &&\n\t\tsize >= 256 && cachep->object_size > cache_line_size()) {\n\t\tif (size < PAGE_SIZE || size % PAGE_SIZE == 0) {\n\t\t\tsize_t tmp_size = ALIGN(size, PAGE_SIZE);\n\n\t\t\tif (set_off_slab_cache(cachep, tmp_size, flags)) {\n\t\t\t\tflags |= CFLGS_OFF_SLAB;\n\t\t\t\tcachep->obj_offset += tmp_size - size;\n\t\t\t\tsize = tmp_size;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (set_objfreelist_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OBJFREELIST_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_off_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OFF_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_on_slab_cache(cachep, size, flags))\n\t\tgoto done;\n\n\treturn -E2BIG;\n\ndone:\n\tcachep->freelist_size = cachep->num * sizeof(freelist_idx_t);\n\tcachep->flags = flags;\n\tcachep->allocflags = __GFP_COMP;\n\tif (flags & SLAB_CACHE_DMA)\n\t\tcachep->allocflags |= GFP_DMA;\n\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\tcachep->allocflags |= __GFP_RECLAIMABLE;\n\tcachep->size = size;\n\tcachep->reciprocal_buffer_size = reciprocal_value(size);\n\n#if DEBUG\n\t/*\n\t * If we're going to use the generic kernel_map_pages()\n\t * poisoning, then it's going to smash the contents of\n\t * the redzone and userword anyhow, so switch them off.\n\t */\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING) &&\n\t\t(cachep->flags & SLAB_POISON) &&\n\t\tis_debug_pagealloc_cache(cachep))\n\t\tcachep->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n#endif\n\n\tif (OFF_SLAB(cachep)) {\n\t\tcachep->freelist_cache =\n\t\t\tkmalloc_slab(cachep->freelist_size, 0u);\n\t}\n\n\terr = setup_cpu_cache(cachep, gfp);\n\tif (err) {\n\t\t__kmem_cache_release(cachep);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_on_slab_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1953-1967",
    "snippet": "static bool set_on_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tleft = calculate_slab_order(cachep, size, flags);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_slab_order",
          "args": [
            "cachep",
            "size",
            "flags"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_slab_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1742-1808",
          "snippet": "static size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
            "#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static int slab_max_order = SLAB_MAX_ORDER_LO;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic int slab_max_order = SLAB_MAX_ORDER_LO;\nstatic noinline struct;\n\nstatic size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic bool set_on_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tleft = calculate_slab_order(cachep, size, flags);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}"
  },
  {
    "function_name": "set_off_slab_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1919-1951",
    "snippet": "static bool set_off_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\t/*\n\t * Always use on-slab management when SLAB_NOLEAKTRACE\n\t * to avoid recursive calls into kmemleak.\n\t */\n\tif (flags & SLAB_NOLEAKTRACE)\n\t\treturn false;\n\n\t/*\n\t * Size is large, assume best to place the slab management obj\n\t * off-slab (should allow better packing of objs).\n\t */\n\tleft = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\t/*\n\t * If the slab has been placed off-slab, and we have enough space then\n\t * move it on-slab. This is at the expense of any extra colouring.\n\t */\n\tif (left >= cachep->num * sizeof(freelist_idx_t))\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_slab_order",
          "args": [
            "cachep",
            "size",
            "flags | CFLGS_OFF_SLAB"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_slab_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1742-1808",
          "snippet": "static size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
            "#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static int slab_max_order = SLAB_MAX_ORDER_LO;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic int slab_max_order = SLAB_MAX_ORDER_LO;\nstatic noinline struct;\n\nstatic size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n\nstatic noinline struct;\n\nstatic bool set_off_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\t/*\n\t * Always use on-slab management when SLAB_NOLEAKTRACE\n\t * to avoid recursive calls into kmemleak.\n\t */\n\tif (flags & SLAB_NOLEAKTRACE)\n\t\treturn false;\n\n\t/*\n\t * Size is large, assume best to place the slab management obj\n\t * off-slab (should allow better packing of objs).\n\t */\n\tleft = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\t/*\n\t * If the slab has been placed off-slab, and we have enough space then\n\t * move it on-slab. This is at the expense of any extra colouring.\n\t */\n\tif (left >= cachep->num * sizeof(freelist_idx_t))\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}"
  },
  {
    "function_name": "set_objfreelist_slab_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1896-1917",
    "snippet": "static bool set_objfreelist_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tif (cachep->ctor || flags & SLAB_TYPESAFE_BY_RCU)\n\t\treturn false;\n\n\tleft = calculate_slab_order(cachep, size,\n\t\t\tflags | CFLGS_OBJFREELIST_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tif (cachep->num * sizeof(freelist_idx_t) > cachep->object_size)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_slab_order",
          "args": [
            "cachep",
            "size",
            "flags | CFLGS_OBJFREELIST_SLAB"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_slab_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1742-1808",
          "snippet": "static size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
            "#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static int slab_max_order = SLAB_MAX_ORDER_LO;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic int slab_max_order = SLAB_MAX_ORDER_LO;\nstatic noinline struct;\n\nstatic size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)\n\nstatic noinline struct;\n\nstatic bool set_objfreelist_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\tif (cachep->ctor || flags & SLAB_TYPESAFE_BY_RCU)\n\t\treturn false;\n\n\tleft = calculate_slab_order(cachep, size,\n\t\t\tflags | CFLGS_OBJFREELIST_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\tif (cachep->num * sizeof(freelist_idx_t) > cachep->object_size)\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__kmem_cache_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1877-1894",
    "snippet": "struct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{\n\tstruct kmem_cache *cachep;\n\n\tcachep = find_mergeable(size, align, flags, name, ctor);\n\tif (cachep) {\n\t\tcachep->refcount++;\n\n\t\t/*\n\t\t * Adjust the object sizes so that we clear\n\t\t * the complete object on kzalloc.\n\t\t */\n\t\tcachep->object_size = max_t(int, cachep->object_size, size);\n\t}\n\treturn cachep;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "cachep->object_size",
            "size"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_mergeable",
          "args": [
            "size",
            "align",
            "flags",
            "name",
            "ctor"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "find_mergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "316-361",
          "snippet": "struct kmem_cache *find_mergeable(unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, const char *name, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s;\n\n\tif (slab_nomerge)\n\t\treturn NULL;\n\n\tif (ctor)\n\t\treturn NULL;\n\n\tsize = ALIGN(size, sizeof(void *));\n\talign = calculate_alignment(flags, align, size);\n\tsize = ALIGN(size, align);\n\tflags = kmem_cache_flags(size, flags, name, NULL);\n\n\tif (flags & SLAB_NEVER_MERGE)\n\t\treturn NULL;\n\n\tlist_for_each_entry_reverse(s, &slab_root_caches, root_caches_node) {\n\t\tif (slab_unmergeable(s))\n\t\t\tcontinue;\n\n\t\tif (size > s->size)\n\t\t\tcontinue;\n\n\t\tif ((flags & SLAB_MERGE_SAME) != (s->flags & SLAB_MERGE_SAME))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check if alignment is compatible.\n\t\t * Courtesy of Adrian Drzewiecki\n\t\t */\n\t\tif ((s->size & ~(align - 1)) != s->size)\n\t\t\tcontinue;\n\n\t\tif (s->size - size >= sizeof(void *))\n\t\t\tcontinue;\n\n\t\tif (IS_ENABLED(CONFIG_SLAB) && align &&\n\t\t\t(align > s->align || s->align % align))\n\t\t\tcontinue;\n\n\t\treturn s;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SLAB_MERGE_SAME (SLAB_RECLAIM_ACCOUNT | SLAB_CACHE_DMA | \\\n\t\t\t SLAB_ACCOUNT)",
            "#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)"
          ],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#define SLAB_MERGE_SAME (SLAB_RECLAIM_ACCOUNT | SLAB_CACHE_DMA | \\\n\t\t\t SLAB_ACCOUNT)\n#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)\n\nstruct kmem_cache *kmem_cache;\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);\n\nstruct kmem_cache *find_mergeable(unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, const char *name, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s;\n\n\tif (slab_nomerge)\n\t\treturn NULL;\n\n\tif (ctor)\n\t\treturn NULL;\n\n\tsize = ALIGN(size, sizeof(void *));\n\talign = calculate_alignment(flags, align, size);\n\tsize = ALIGN(size, align);\n\tflags = kmem_cache_flags(size, flags, name, NULL);\n\n\tif (flags & SLAB_NEVER_MERGE)\n\t\treturn NULL;\n\n\tlist_for_each_entry_reverse(s, &slab_root_caches, root_caches_node) {\n\t\tif (slab_unmergeable(s))\n\t\t\tcontinue;\n\n\t\tif (size > s->size)\n\t\t\tcontinue;\n\n\t\tif ((flags & SLAB_MERGE_SAME) != (s->flags & SLAB_MERGE_SAME))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check if alignment is compatible.\n\t\t * Courtesy of Adrian Drzewiecki\n\t\t */\n\t\tif ((s->size & ~(align - 1)) != s->size)\n\t\t\tcontinue;\n\n\t\tif (s->size - size >= sizeof(void *))\n\t\t\tcontinue;\n\n\t\tif (IS_ENABLED(CONFIG_SLAB) && align &&\n\t\t\t(align > s->align || s->align % align))\n\t\t\tcontinue;\n\n\t\treturn s;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstruct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{\n\tstruct kmem_cache *cachep;\n\n\tcachep = find_mergeable(size, align, flags, name, ctor);\n\tif (cachep) {\n\t\tcachep->refcount++;\n\n\t\t/*\n\t\t * Adjust the object sizes so that we clear\n\t\t * the complete object on kzalloc.\n\t\t */\n\t\tcachep->object_size = max_t(int, cachep->object_size, size);\n\t}\n\treturn cachep;\n}"
  },
  {
    "function_name": "kmem_cache_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1870-1875",
    "snippet": "slab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nslab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}"
  },
  {
    "function_name": "setup_cpu_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1831-1868",
    "snippet": "static int __ref setup_cpu_cache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tif (slab_state >= FULL)\n\t\treturn enable_cpucache(cachep, gfp);\n\n\tcachep->cpu_cache = alloc_kmem_cache_cpus(cachep, 1, 1);\n\tif (!cachep->cpu_cache)\n\t\treturn 1;\n\n\tif (slab_state == DOWN) {\n\t\t/* Creation of first cache (kmem_cache). */\n\t\tset_up_node(kmem_cache, CACHE_CACHE);\n\t} else if (slab_state == PARTIAL) {\n\t\t/* For kmem_cache_node */\n\t\tset_up_node(cachep, SIZE_NODE);\n\t} else {\n\t\tint node;\n\n\t\tfor_each_online_node(node) {\n\t\t\tcachep->node[node] = kmalloc_node(\n\t\t\t\tsizeof(struct kmem_cache_node), gfp, node);\n\t\t\tBUG_ON(!cachep->node[node]);\n\t\t\tkmem_cache_node_init(cachep->node[node]);\n\t\t}\n\t}\n\n\tcachep->node[numa_mem_id()]->next_reap =\n\t\t\tjiffies + REAPTIMEOUT_NODE +\n\t\t\t((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tcpu_cache_get(cachep)->avail = 0;\n\tcpu_cache_get(cachep)->limit = BOOT_CPUCACHE_ENTRIES;\n\tcpu_cache_get(cachep)->batchcount = 1;\n\tcpu_cache_get(cachep)->touched = 0;\n\tcachep->batchcount = 1;\n\tcachep->limit = BOOT_CPUCACHE_ENTRIES;\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define BOOT_CPUCACHE_ENTRIES\t1",
      "#define REAPTIMEOUT_NODE\t(4*HZ)",
      "#define\tSIZE_NODE (MAX_NUMNODES)",
      "#define\tCACHE_CACHE 0"
    ],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_cache_get",
          "args": [
            "cachep"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "434-437",
          "snippet": "static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_node_init",
          "args": [
            "cachep->node[node]"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_node_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "226-239",
          "snippet": "static void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cachep->node[node]"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct kmem_cache_node)",
            "gfp",
            "node"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_up_node",
          "args": [
            "cachep",
            "SIZE_NODE"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "set_up_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1218-1228",
          "snippet": "static void __init set_up_node(struct kmem_cache *cachep, int index)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tcachep->node[node] = &init_kmem_cache_node[index + node];\n\t\tcachep->node[node]->next_reap = jiffies +\n\t\t    REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define REAPTIMEOUT_NODE\t(4*HZ)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define REAPTIMEOUT_NODE\t(4*HZ)\n\nstatic noinline struct;\n\nstatic void __init set_up_node(struct kmem_cache *cachep, int index)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tcachep->node[node] = &init_kmem_cache_node[index + node];\n\t\tcachep->node[node]->next_reap = jiffies +\n\t\t    REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_kmem_cache_cpus",
          "args": [
            "cachep",
            "1",
            "1"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_kmem_cache_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1810-1829",
          "snippet": "static struct array_cache __percpu *alloc_kmem_cache_cpus(\n\t\tstruct kmem_cache *cachep, int entries, int batchcount)\n{\n\tint cpu;\n\tsize_t size;\n\tstruct array_cache __percpu *cpu_cache;\n\n\tsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tcpu_cache = __alloc_percpu(size, sizeof(void *));\n\n\tif (!cpu_cache)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinit_arraycache(per_cpu_ptr(cpu_cache, cpu),\n\t\t\t\tentries, batchcount);\n\t}\n\n\treturn cpu_cache;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct array_cache __percpu *alloc_kmem_cache_cpus(\n\t\tstruct kmem_cache *cachep, int entries, int batchcount)\n{\n\tint cpu;\n\tsize_t size;\n\tstruct array_cache __percpu *cpu_cache;\n\n\tsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tcpu_cache = __alloc_percpu(size, sizeof(void *));\n\n\tif (!cpu_cache)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinit_arraycache(per_cpu_ptr(cpu_cache, cpu),\n\t\t\t\tentries, batchcount);\n\t}\n\n\treturn cpu_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_cpucache",
          "args": [
            "cachep",
            "gfp"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "enable_cpucache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3929-3998",
          "snippet": "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define BOOT_CPUCACHE_ENTRIES\t1\n#define REAPTIMEOUT_NODE\t(4*HZ)\n#define\tSIZE_NODE (MAX_NUMNODES)\n#define\tCACHE_CACHE 0\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int __ref setup_cpu_cache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tif (slab_state >= FULL)\n\t\treturn enable_cpucache(cachep, gfp);\n\n\tcachep->cpu_cache = alloc_kmem_cache_cpus(cachep, 1, 1);\n\tif (!cachep->cpu_cache)\n\t\treturn 1;\n\n\tif (slab_state == DOWN) {\n\t\t/* Creation of first cache (kmem_cache). */\n\t\tset_up_node(kmem_cache, CACHE_CACHE);\n\t} else if (slab_state == PARTIAL) {\n\t\t/* For kmem_cache_node */\n\t\tset_up_node(cachep, SIZE_NODE);\n\t} else {\n\t\tint node;\n\n\t\tfor_each_online_node(node) {\n\t\t\tcachep->node[node] = kmalloc_node(\n\t\t\t\tsizeof(struct kmem_cache_node), gfp, node);\n\t\t\tBUG_ON(!cachep->node[node]);\n\t\t\tkmem_cache_node_init(cachep->node[node]);\n\t\t}\n\t}\n\n\tcachep->node[numa_mem_id()]->next_reap =\n\t\t\tjiffies + REAPTIMEOUT_NODE +\n\t\t\t((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tcpu_cache_get(cachep)->avail = 0;\n\tcpu_cache_get(cachep)->limit = BOOT_CPUCACHE_ENTRIES;\n\tcpu_cache_get(cachep)->batchcount = 1;\n\tcpu_cache_get(cachep)->touched = 0;\n\tcachep->batchcount = 1;\n\tcachep->limit = BOOT_CPUCACHE_ENTRIES;\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_kmem_cache_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1810-1829",
    "snippet": "static struct array_cache __percpu *alloc_kmem_cache_cpus(\n\t\tstruct kmem_cache *cachep, int entries, int batchcount)\n{\n\tint cpu;\n\tsize_t size;\n\tstruct array_cache __percpu *cpu_cache;\n\n\tsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tcpu_cache = __alloc_percpu(size, sizeof(void *));\n\n\tif (!cpu_cache)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinit_arraycache(per_cpu_ptr(cpu_cache, cpu),\n\t\t\t\tentries, batchcount);\n\t}\n\n\treturn cpu_cache;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_arraycache",
          "args": [
            "per_cpu_ptr(cpu_cache, cpu)",
            "entries",
            "batchcount"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "init_arraycache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "564-580",
          "snippet": "static void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cpu_cache",
            "cpu"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "size",
            "sizeof(void *)"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1557-1560",
          "snippet": "void __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct array_cache __percpu *alloc_kmem_cache_cpus(\n\t\tstruct kmem_cache *cachep, int entries, int batchcount)\n{\n\tint cpu;\n\tsize_t size;\n\tstruct array_cache __percpu *cpu_cache;\n\n\tsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tcpu_cache = __alloc_percpu(size, sizeof(void *));\n\n\tif (!cpu_cache)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinit_arraycache(per_cpu_ptr(cpu_cache, cpu),\n\t\t\t\tentries, batchcount);\n\t}\n\n\treturn cpu_cache;\n}"
  },
  {
    "function_name": "calculate_slab_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1742-1808",
    "snippet": "static size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
      "#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)"
    ],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static int slab_max_order = SLAB_MAX_ORDER_LO;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OFF_SLAB",
          "args": [
            "freelist_cache"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "freelist_size",
            "0u"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_estimate",
          "args": [
            "gfporder",
            "size",
            "flags",
            "&remainder"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "cache_estimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "442-475",
          "snippet": "static unsigned int cache_estimate(unsigned long gfporder, size_t buffer_size,\n\t\tslab_flags_t flags, size_t *left_over)\n{\n\tunsigned int num;\n\tsize_t slab_size = PAGE_SIZE << gfporder;\n\n\t/*\n\t * The slab management structure can be either off the slab or\n\t * on it. For the latter case, the memory allocated for a\n\t * slab is used for:\n\t *\n\t * - @buffer_size bytes for each object\n\t * - One freelist_idx_t for each object\n\t *\n\t * We don't need to consider alignment of freelist because\n\t * freelist will be at the end of slab page. The objects will be\n\t * at the correct alignment.\n\t *\n\t * If the slab management structure is off the slab, then the\n\t * alignment will already be calculated into the size. Because\n\t * the slabs are all pages aligned, the objects will be at the\n\t * correct alignment when allocated.\n\t */\n\tif (flags & (CFLGS_OBJFREELIST_SLAB | CFLGS_OFF_SLAB)) {\n\t\tnum = slab_size / buffer_size;\n\t\t*left_over = slab_size % buffer_size;\n\t} else {\n\t\tnum = slab_size / (buffer_size + sizeof(freelist_idx_t));\n\t\t*left_over = slab_size %\n\t\t\t(buffer_size + sizeof(freelist_idx_t));\n\t}\n\n\treturn num;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
            "#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)\n\nstatic unsigned int cache_estimate(unsigned long gfporder, size_t buffer_size,\n\t\tslab_flags_t flags, size_t *left_over)\n{\n\tunsigned int num;\n\tsize_t slab_size = PAGE_SIZE << gfporder;\n\n\t/*\n\t * The slab management structure can be either off the slab or\n\t * on it. For the latter case, the memory allocated for a\n\t * slab is used for:\n\t *\n\t * - @buffer_size bytes for each object\n\t * - One freelist_idx_t for each object\n\t *\n\t * We don't need to consider alignment of freelist because\n\t * freelist will be at the end of slab page. The objects will be\n\t * at the correct alignment.\n\t *\n\t * If the slab management structure is off the slab, then the\n\t * alignment will already be calculated into the size. Because\n\t * the slabs are all pages aligned, the objects will be at the\n\t * correct alignment when allocated.\n\t */\n\tif (flags & (CFLGS_OBJFREELIST_SLAB | CFLGS_OFF_SLAB)) {\n\t\tnum = slab_size / buffer_size;\n\t\t*left_over = slab_size % buffer_size;\n\t} else {\n\t\tnum = slab_size / (buffer_size + sizeof(freelist_idx_t));\n\t\t*left_over = slab_size %\n\t\t\t(buffer_size + sizeof(freelist_idx_t));\n\t}\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define SLAB_OBJ_MAX_NUM ((1 << sizeof(freelist_idx_t) * BITS_PER_BYTE) - 1)\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic int slab_max_order = SLAB_MAX_ORDER_LO;\nstatic noinline struct;\n\nstatic size_t calculate_slab_order(struct kmem_cache *cachep,\n\t\t\t\tsize_t size, slab_flags_t flags)\n{\n\tsize_t left_over = 0;\n\tint gfporder;\n\n\tfor (gfporder = 0; gfporder <= KMALLOC_MAX_ORDER; gfporder++) {\n\t\tunsigned int num;\n\t\tsize_t remainder;\n\n\t\tnum = cache_estimate(gfporder, size, flags, &remainder);\n\t\tif (!num)\n\t\t\tcontinue;\n\n\t\t/* Can't handle number of objects more than SLAB_OBJ_MAX_NUM */\n\t\tif (num > SLAB_OBJ_MAX_NUM)\n\t\t\tbreak;\n\n\t\tif (flags & CFLGS_OFF_SLAB) {\n\t\t\tstruct kmem_cache *freelist_cache;\n\t\t\tsize_t freelist_size;\n\n\t\t\tfreelist_size = num * sizeof(freelist_idx_t);\n\t\t\tfreelist_cache = kmalloc_slab(freelist_size, 0u);\n\t\t\tif (!freelist_cache)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Needed to avoid possible looping condition\n\t\t\t * in cache_grow_begin()\n\t\t\t */\n\t\t\tif (OFF_SLAB(freelist_cache))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if off slab has enough benefit */\n\t\t\tif (freelist_cache->size > cachep->size / 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Found something acceptable - save it away */\n\t\tcachep->num = num;\n\t\tcachep->gfporder = gfporder;\n\t\tleft_over = remainder;\n\n\t\t/*\n\t\t * A VFS-reclaimable slab tends to have most allocations\n\t\t * as GFP_NOFS and we really don't want to have to be allocating\n\t\t * higher-order pages when we are unable to shrink dcache.\n\t\t */\n\t\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Large number of objects is good, but very large slabs are\n\t\t * currently bad for the gfp()s.\n\t\t */\n\t\tif (gfporder >= slab_max_order)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Acceptable internal fragmentation?\n\t\t */\n\t\tif (left_over * 8 <= (PAGE_SIZE << gfporder))\n\t\t\tbreak;\n\t}\n\treturn left_over;\n}"
  },
  {
    "function_name": "slabs_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1720-1728",
    "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_destroy",
          "args": [
            "cachep",
            "page"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "slab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1701-1718",
          "snippet": "static void slab_destroy(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *freelist;\n\n\tfreelist = page->freelist;\n\tslab_destroy_debugcheck(cachep, page);\n\tif (unlikely(cachep->flags & SLAB_TYPESAFE_BY_RCU))\n\t\tcall_rcu(&page->rcu_head, kmem_rcu_free);\n\telse\n\t\tkmem_freepages(cachep, page);\n\n\t/*\n\t * From now on, we don't use freelist\n\t * although actual page can be freed in rcu context\n\t */\n\tif (OFF_SLAB(cachep))\n\t\tkmem_cache_free(cachep->freelist_cache, freelist);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_destroy(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *freelist;\n\n\tfreelist = page->freelist;\n\tslab_destroy_debugcheck(cachep, page);\n\tif (unlikely(cachep->flags & SLAB_TYPESAFE_BY_RCU))\n\t\tcall_rcu(&page->rcu_head, kmem_rcu_free);\n\telse\n\t\tkmem_freepages(cachep, page);\n\n\t/*\n\t * From now on, we don't use freelist\n\t * although actual page can be freed in rcu context\n\t */\n\tif (OFF_SLAB(cachep))\n\t\tkmem_cache_free(cachep->freelist_cache, freelist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "n",
            "list",
            "lru"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
  },
  {
    "function_name": "slab_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1701-1718",
    "snippet": "static void slab_destroy(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *freelist;\n\n\tfreelist = page->freelist;\n\tslab_destroy_debugcheck(cachep, page);\n\tif (unlikely(cachep->flags & SLAB_TYPESAFE_BY_RCU))\n\t\tcall_rcu(&page->rcu_head, kmem_rcu_free);\n\telse\n\t\tkmem_freepages(cachep, page);\n\n\t/*\n\t * From now on, we don't use freelist\n\t * although actual page can be freed in rcu context\n\t */\n\tif (OFF_SLAB(cachep))\n\t\tkmem_cache_free(cachep->freelist_cache, freelist);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cachep->freelist_cache",
            "freelist"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFF_SLAB",
          "args": [
            "cachep"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_freepages",
          "args": [
            "cachep",
            "page"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1437-1457",
          "snippet": "static void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&page->rcu_head",
            "kmem_rcu_free"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cachep->flags & SLAB_TYPESAFE_BY_RCU"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_destroy_debugcheck",
          "args": [
            "cachep",
            "page"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "slab_destroy_debugcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1686-1689",
          "snippet": "static void slab_destroy_debugcheck(struct kmem_cache *cachep,\n\t\t\t\t\t\tstruct page *page)\n{\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_destroy_debugcheck(struct kmem_cache *cachep,\n\t\t\t\t\t\tstruct page *page)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_destroy(struct kmem_cache *cachep, struct page *page)\n{\n\tvoid *freelist;\n\n\tfreelist = page->freelist;\n\tslab_destroy_debugcheck(cachep, page);\n\tif (unlikely(cachep->flags & SLAB_TYPESAFE_BY_RCU))\n\t\tcall_rcu(&page->rcu_head, kmem_rcu_free);\n\telse\n\t\tkmem_freepages(cachep, page);\n\n\t/*\n\t * From now on, we don't use freelist\n\t * although actual page can be freed in rcu context\n\t */\n\tif (OFF_SLAB(cachep))\n\t\tkmem_cache_free(cachep->freelist_cache, freelist);\n}"
  },
  {
    "function_name": "slab_destroy_debugcheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1686-1689",
    "snippet": "static void slab_destroy_debugcheck(struct kmem_cache *cachep,\n\t\t\t\t\t\tstruct page *page)\n{\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_destroy_debugcheck(struct kmem_cache *cachep,\n\t\t\t\t\t\tstruct page *page)\n{\n}"
  },
  {
    "function_name": "slab_destroy_debugcheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1660-1684",
    "snippet": "static void slab_destroy_debugcheck(struct kmem_cache *cachep,\n\t\t\t\t\t\tstruct page *page)\n{\n\tint i;\n\n\tif (OBJFREELIST_SLAB(cachep) && cachep->flags & SLAB_POISON) {\n\t\tpoison_obj(cachep, page->freelist - obj_offset(cachep),\n\t\t\tPOISON_FREE);\n\t}\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tvoid *objp = index_to_obj(cachep, page, i);\n\n\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\tcheck_poison_obj(cachep, objp);\n\t\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\t}\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"start of a freed object was overwritten\");\n\t\t\tif (*dbg_redzone2(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"end of a freed object was overwritten\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_error",
          "args": [
            "cachep",
            "\"end of a freed object was overwritten\""
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_redzone2",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "339-348",
          "snippet": "static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_error",
          "args": [
            "cachep",
            "\"start of a freed object was overwritten\""
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_redzone1",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "332-337",
          "snippet": "static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_kernel_map",
          "args": [
            "cachep",
            "objp",
            "1",
            "0"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "slab_kernel_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1526-1527",
          "snippet": "static inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}"
        }
      },
      {
        "call_info": {
          "callee": "check_poison_obj",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "check_poison_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1596-1656",
          "snippet": "static void check_poison_obj(struct kmem_cache *cachep, void *objp)\n{\n\tchar *realobj;\n\tint size, i;\n\tint lines = 0;\n\n\tif (is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\n\tfor (i = 0; i < size; i++) {\n\t\tchar exp = POISON_FREE;\n\t\tif (i == size - 1)\n\t\t\texp = POISON_END;\n\t\tif (realobj[i] != exp) {\n\t\t\tint limit;\n\t\t\t/* Mismatch ! */\n\t\t\t/* Print header */\n\t\t\tif (lines == 0) {\n\t\t\t\tpr_err(\"Slab corruption (%s): %s start=%px, len=%d\\n\",\n\t\t\t\t       print_tainted(), cachep->name,\n\t\t\t\t       realobj, size);\n\t\t\t\tprint_objinfo(cachep, objp, 0);\n\t\t\t}\n\t\t\t/* Hexdump the affected line */\n\t\t\ti = (i / 16) * 16;\n\t\t\tlimit = 16;\n\t\t\tif (i + limit > size)\n\t\t\t\tlimit = size - i;\n\t\t\tdump_line(realobj, i, limit);\n\t\t\ti += 16;\n\t\t\tlines++;\n\t\t\t/* Limit to 5 lines */\n\t\t\tif (lines > 5)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (lines != 0) {\n\t\t/* Print some data about the neighboring objects, if they\n\t\t * exist:\n\t\t */\n\t\tstruct page *page = virt_to_head_page(objp);\n\t\tunsigned int objnr;\n\n\t\tobjnr = obj_to_index(cachep, page, objp);\n\t\tif (objnr) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr - 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Prev obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t\tif (objnr + 1 < cachep->num) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr + 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Next obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_poison_obj(struct kmem_cache *cachep, void *objp)\n{\n\tchar *realobj;\n\tint size, i;\n\tint lines = 0;\n\n\tif (is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\n\tfor (i = 0; i < size; i++) {\n\t\tchar exp = POISON_FREE;\n\t\tif (i == size - 1)\n\t\t\texp = POISON_END;\n\t\tif (realobj[i] != exp) {\n\t\t\tint limit;\n\t\t\t/* Mismatch ! */\n\t\t\t/* Print header */\n\t\t\tif (lines == 0) {\n\t\t\t\tpr_err(\"Slab corruption (%s): %s start=%px, len=%d\\n\",\n\t\t\t\t       print_tainted(), cachep->name,\n\t\t\t\t       realobj, size);\n\t\t\t\tprint_objinfo(cachep, objp, 0);\n\t\t\t}\n\t\t\t/* Hexdump the affected line */\n\t\t\ti = (i / 16) * 16;\n\t\t\tlimit = 16;\n\t\t\tif (i + limit > size)\n\t\t\t\tlimit = size - i;\n\t\t\tdump_line(realobj, i, limit);\n\t\t\ti += 16;\n\t\t\tlines++;\n\t\t\t/* Limit to 5 lines */\n\t\t\tif (lines > 5)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (lines != 0) {\n\t\t/* Print some data about the neighboring objects, if they\n\t\t * exist:\n\t\t */\n\t\tstruct page *page = virt_to_head_page(objp);\n\t\tunsigned int objnr;\n\n\t\tobjnr = obj_to_index(cachep, page, objp);\n\t\tif (objnr) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr - 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Prev obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t\tif (objnr + 1 < cachep->num) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr + 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Next obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "i"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poison_obj",
          "args": [
            "cachep",
            "page->freelist - obj_offset(cachep)",
            "POISON_FREE"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "poison_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1531-1538",
          "snippet": "static void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OBJFREELIST_SLAB",
          "args": [
            "cachep"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_destroy_debugcheck(struct kmem_cache *cachep,\n\t\t\t\t\t\tstruct page *page)\n{\n\tint i;\n\n\tif (OBJFREELIST_SLAB(cachep) && cachep->flags & SLAB_POISON) {\n\t\tpoison_obj(cachep, page->freelist - obj_offset(cachep),\n\t\t\tPOISON_FREE);\n\t}\n\n\tfor (i = 0; i < cachep->num; i++) {\n\t\tvoid *objp = index_to_obj(cachep, page, i);\n\n\t\tif (cachep->flags & SLAB_POISON) {\n\t\t\tcheck_poison_obj(cachep, objp);\n\t\t\tslab_kernel_map(cachep, objp, 1, 0);\n\t\t}\n\t\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\t\tif (*dbg_redzone1(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"start of a freed object was overwritten\");\n\t\t\tif (*dbg_redzone2(cachep, objp) != RED_INACTIVE)\n\t\t\t\tslab_error(cachep, \"end of a freed object was overwritten\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_poison_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1596-1656",
    "snippet": "static void check_poison_obj(struct kmem_cache *cachep, void *objp)\n{\n\tchar *realobj;\n\tint size, i;\n\tint lines = 0;\n\n\tif (is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\n\tfor (i = 0; i < size; i++) {\n\t\tchar exp = POISON_FREE;\n\t\tif (i == size - 1)\n\t\t\texp = POISON_END;\n\t\tif (realobj[i] != exp) {\n\t\t\tint limit;\n\t\t\t/* Mismatch ! */\n\t\t\t/* Print header */\n\t\t\tif (lines == 0) {\n\t\t\t\tpr_err(\"Slab corruption (%s): %s start=%px, len=%d\\n\",\n\t\t\t\t       print_tainted(), cachep->name,\n\t\t\t\t       realobj, size);\n\t\t\t\tprint_objinfo(cachep, objp, 0);\n\t\t\t}\n\t\t\t/* Hexdump the affected line */\n\t\t\ti = (i / 16) * 16;\n\t\t\tlimit = 16;\n\t\t\tif (i + limit > size)\n\t\t\t\tlimit = size - i;\n\t\t\tdump_line(realobj, i, limit);\n\t\t\ti += 16;\n\t\t\tlines++;\n\t\t\t/* Limit to 5 lines */\n\t\t\tif (lines > 5)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (lines != 0) {\n\t\t/* Print some data about the neighboring objects, if they\n\t\t * exist:\n\t\t */\n\t\tstruct page *page = virt_to_head_page(objp);\n\t\tunsigned int objnr;\n\n\t\tobjnr = obj_to_index(cachep, page, objp);\n\t\tif (objnr) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr - 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Prev obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t\tif (objnr + 1 < cachep->num) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr + 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Next obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_objinfo",
          "args": [
            "cachep",
            "objp",
            "2"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "print_objinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1572-1594",
          "snippet": "static void print_objinfo(struct kmem_cache *cachep, void *objp, int lines)\n{\n\tint i, size;\n\tchar *realobj;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tpr_err(\"Redzone: 0x%llx/0x%llx\\n\",\n\t\t       *dbg_redzone1(cachep, objp),\n\t\t       *dbg_redzone2(cachep, objp));\n\t}\n\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tpr_err(\"Last user: (%pSR)\\n\", *dbg_userword(cachep, objp));\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\tfor (i = 0; i < size && lines; i += 16, lines--) {\n\t\tint limit;\n\t\tlimit = 16;\n\t\tif (i + limit > size)\n\t\t\tlimit = size - i;\n\t\tdump_line(realobj, i, limit);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void print_objinfo(struct kmem_cache *cachep, void *objp, int lines)\n{\n\tint i, size;\n\tchar *realobj;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tpr_err(\"Redzone: 0x%llx/0x%llx\\n\",\n\t\t       *dbg_redzone1(cachep, objp),\n\t\t       *dbg_redzone2(cachep, objp));\n\t}\n\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tpr_err(\"Last user: (%pSR)\\n\", *dbg_userword(cachep, objp));\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\tfor (i = 0; i < size && lines; i += 16, lines--) {\n\t\tint limit;\n\t\tlimit = 16;\n\t\tif (i + limit > size)\n\t\t\tlimit = size - i;\n\t\tdump_line(realobj, i, limit);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Next obj: start=%px, len=%d\\n\"",
            "realobj",
            "size"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_to_obj",
          "args": [
            "cachep",
            "page",
            "objnr + 1"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "index_to_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "403-407",
          "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Prev obj: start=%px, len=%d\\n\"",
            "realobj",
            "size"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_to_index",
          "args": [
            "cachep",
            "page",
            "objp"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "obj_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "415-420",
          "snippet": "static inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "objp"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_line",
          "args": [
            "realobj",
            "i",
            "limit"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "dump_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1540-1567",
          "snippet": "static void dump_line(char *data, int offset, int limit)\n{\n\tint i;\n\tunsigned char error = 0;\n\tint bad_count = 0;\n\n\tpr_err(\"%03x: \", offset);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (data[offset + i] != POISON_FREE) {\n\t\t\terror = data[offset + i];\n\t\t\tbad_count++;\n\t\t}\n\t}\n\tprint_hex_dump(KERN_CONT, \"\", 0, 16, 1,\n\t\t\t&data[offset], limit, 1);\n\n\tif (bad_count == 1) {\n\t\terror ^= POISON_FREE;\n\t\tif (!(error & (error - 1))) {\n\t\t\tpr_err(\"Single bit error detected. Probably bad RAM.\\n\");\n#ifdef CONFIG_X86\n\t\t\tpr_err(\"Run memtest86+ or a similar memory test tool.\\n\");\n#else\n\t\t\tpr_err(\"Run a memory test tool.\\n\");\n#endif\n\t\t}\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void dump_line(char *data, int offset, int limit)\n{\n\tint i;\n\tunsigned char error = 0;\n\tint bad_count = 0;\n\n\tpr_err(\"%03x: \", offset);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (data[offset + i] != POISON_FREE) {\n\t\t\terror = data[offset + i];\n\t\t\tbad_count++;\n\t\t}\n\t}\n\tprint_hex_dump(KERN_CONT, \"\", 0, 16, 1,\n\t\t\t&data[offset], limit, 1);\n\n\tif (bad_count == 1) {\n\t\terror ^= POISON_FREE;\n\t\tif (!(error & (error - 1))) {\n\t\t\tpr_err(\"Single bit error detected. Probably bad RAM.\\n\");\n#ifdef CONFIG_X86\n\t\t\tpr_err(\"Run memtest86+ or a similar memory test tool.\\n\");\n#else\n\t\t\tpr_err(\"Run a memory test tool.\\n\");\n#endif\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Slab corruption (%s): %s start=%px, len=%d\\n\"",
            "print_tainted()",
            "cachep->name",
            "realobj",
            "size"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_debug_pagealloc_cache",
          "args": [
            "cachep"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "is_debug_pagealloc_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1471-1478",
          "snippet": "static bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void check_poison_obj(struct kmem_cache *cachep, void *objp)\n{\n\tchar *realobj;\n\tint size, i;\n\tint lines = 0;\n\n\tif (is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\n\tfor (i = 0; i < size; i++) {\n\t\tchar exp = POISON_FREE;\n\t\tif (i == size - 1)\n\t\t\texp = POISON_END;\n\t\tif (realobj[i] != exp) {\n\t\t\tint limit;\n\t\t\t/* Mismatch ! */\n\t\t\t/* Print header */\n\t\t\tif (lines == 0) {\n\t\t\t\tpr_err(\"Slab corruption (%s): %s start=%px, len=%d\\n\",\n\t\t\t\t       print_tainted(), cachep->name,\n\t\t\t\t       realobj, size);\n\t\t\t\tprint_objinfo(cachep, objp, 0);\n\t\t\t}\n\t\t\t/* Hexdump the affected line */\n\t\t\ti = (i / 16) * 16;\n\t\t\tlimit = 16;\n\t\t\tif (i + limit > size)\n\t\t\t\tlimit = size - i;\n\t\t\tdump_line(realobj, i, limit);\n\t\t\ti += 16;\n\t\t\tlines++;\n\t\t\t/* Limit to 5 lines */\n\t\t\tif (lines > 5)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (lines != 0) {\n\t\t/* Print some data about the neighboring objects, if they\n\t\t * exist:\n\t\t */\n\t\tstruct page *page = virt_to_head_page(objp);\n\t\tunsigned int objnr;\n\n\t\tobjnr = obj_to_index(cachep, page, objp);\n\t\tif (objnr) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr - 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Prev obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t\tif (objnr + 1 < cachep->num) {\n\t\t\tobjp = index_to_obj(cachep, page, objnr + 1);\n\t\t\trealobj = (char *)objp + obj_offset(cachep);\n\t\t\tpr_err(\"Next obj: start=%px, len=%d\\n\", realobj, size);\n\t\t\tprint_objinfo(cachep, objp, 2);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "print_objinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1572-1594",
    "snippet": "static void print_objinfo(struct kmem_cache *cachep, void *objp, int lines)\n{\n\tint i, size;\n\tchar *realobj;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tpr_err(\"Redzone: 0x%llx/0x%llx\\n\",\n\t\t       *dbg_redzone1(cachep, objp),\n\t\t       *dbg_redzone2(cachep, objp));\n\t}\n\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tpr_err(\"Last user: (%pSR)\\n\", *dbg_userword(cachep, objp));\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\tfor (i = 0; i < size && lines; i += 16, lines--) {\n\t\tint limit;\n\t\tlimit = 16;\n\t\tif (i + limit > size)\n\t\t\tlimit = size - i;\n\t\tdump_line(realobj, i, limit);\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_line",
          "args": [
            "realobj",
            "i",
            "limit"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "dump_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1540-1567",
          "snippet": "static void dump_line(char *data, int offset, int limit)\n{\n\tint i;\n\tunsigned char error = 0;\n\tint bad_count = 0;\n\n\tpr_err(\"%03x: \", offset);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (data[offset + i] != POISON_FREE) {\n\t\t\terror = data[offset + i];\n\t\t\tbad_count++;\n\t\t}\n\t}\n\tprint_hex_dump(KERN_CONT, \"\", 0, 16, 1,\n\t\t\t&data[offset], limit, 1);\n\n\tif (bad_count == 1) {\n\t\terror ^= POISON_FREE;\n\t\tif (!(error & (error - 1))) {\n\t\t\tpr_err(\"Single bit error detected. Probably bad RAM.\\n\");\n#ifdef CONFIG_X86\n\t\t\tpr_err(\"Run memtest86+ or a similar memory test tool.\\n\");\n#else\n\t\t\tpr_err(\"Run a memory test tool.\\n\");\n#endif\n\t\t}\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void dump_line(char *data, int offset, int limit)\n{\n\tint i;\n\tunsigned char error = 0;\n\tint bad_count = 0;\n\n\tpr_err(\"%03x: \", offset);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (data[offset + i] != POISON_FREE) {\n\t\t\terror = data[offset + i];\n\t\t\tbad_count++;\n\t\t}\n\t}\n\tprint_hex_dump(KERN_CONT, \"\", 0, 16, 1,\n\t\t\t&data[offset], limit, 1);\n\n\tif (bad_count == 1) {\n\t\terror ^= POISON_FREE;\n\t\tif (!(error & (error - 1))) {\n\t\t\tpr_err(\"Single bit error detected. Probably bad RAM.\\n\");\n#ifdef CONFIG_X86\n\t\t\tpr_err(\"Run memtest86+ or a similar memory test tool.\\n\");\n#else\n\t\t\tpr_err(\"Run a memory test tool.\\n\");\n#endif\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Last user: (%pSR)\\n\"",
            "*dbg_userword(cachep, objp)"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_userword",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_userword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "350-354",
          "snippet": "static void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tBYTES_PER_WORD\t\tsizeof(void *)"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n\nstatic noinline struct;\n\nstatic void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Redzone: 0x%llx/0x%llx\\n\"",
            "*dbg_redzone1(cachep, objp)",
            "*dbg_redzone2(cachep, objp)"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_redzone2",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "339-348",
          "snippet": "static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_redzone1",
          "args": [
            "cachep",
            "objp"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_redzone1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "332-337",
          "snippet": "static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void print_objinfo(struct kmem_cache *cachep, void *objp, int lines)\n{\n\tint i, size;\n\tchar *realobj;\n\n\tif (cachep->flags & SLAB_RED_ZONE) {\n\t\tpr_err(\"Redzone: 0x%llx/0x%llx\\n\",\n\t\t       *dbg_redzone1(cachep, objp),\n\t\t       *dbg_redzone2(cachep, objp));\n\t}\n\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\tpr_err(\"Last user: (%pSR)\\n\", *dbg_userword(cachep, objp));\n\trealobj = (char *)objp + obj_offset(cachep);\n\tsize = cachep->object_size;\n\tfor (i = 0; i < size && lines; i += 16, lines--) {\n\t\tint limit;\n\t\tlimit = 16;\n\t\tif (i + limit > size)\n\t\t\tlimit = size - i;\n\t\tdump_line(realobj, i, limit);\n\t}\n}"
  },
  {
    "function_name": "dump_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1540-1567",
    "snippet": "static void dump_line(char *data, int offset, int limit)\n{\n\tint i;\n\tunsigned char error = 0;\n\tint bad_count = 0;\n\n\tpr_err(\"%03x: \", offset);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (data[offset + i] != POISON_FREE) {\n\t\t\terror = data[offset + i];\n\t\t\tbad_count++;\n\t\t}\n\t}\n\tprint_hex_dump(KERN_CONT, \"\", 0, 16, 1,\n\t\t\t&data[offset], limit, 1);\n\n\tif (bad_count == 1) {\n\t\terror ^= POISON_FREE;\n\t\tif (!(error & (error - 1))) {\n\t\t\tpr_err(\"Single bit error detected. Probably bad RAM.\\n\");\n#ifdef CONFIG_X86\n\t\t\tpr_err(\"Run memtest86+ or a similar memory test tool.\\n\");\n#else\n\t\t\tpr_err(\"Run a memory test tool.\\n\");\n#endif\n\t\t}\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Run a memory test tool.\\n\""
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Run memtest86+ or a similar memory test tool.\\n\""
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Single bit error detected. Probably bad RAM.\\n\""
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_CONT",
            "\"\"",
            "0",
            "16",
            "1",
            "&data[offset]",
            "limit",
            "1"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%03x: \"",
            "offset"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void dump_line(char *data, int offset, int limit)\n{\n\tint i;\n\tunsigned char error = 0;\n\tint bad_count = 0;\n\n\tpr_err(\"%03x: \", offset);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (data[offset + i] != POISON_FREE) {\n\t\t\terror = data[offset + i];\n\t\t\tbad_count++;\n\t\t}\n\t}\n\tprint_hex_dump(KERN_CONT, \"\", 0, 16, 1,\n\t\t\t&data[offset], limit, 1);\n\n\tif (bad_count == 1) {\n\t\terror ^= POISON_FREE;\n\t\tif (!(error & (error - 1))) {\n\t\t\tpr_err(\"Single bit error detected. Probably bad RAM.\\n\");\n#ifdef CONFIG_X86\n\t\t\tpr_err(\"Run memtest86+ or a similar memory test tool.\\n\");\n#else\n\t\t\tpr_err(\"Run a memory test tool.\\n\");\n#endif\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "poison_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1531-1538",
    "snippet": "static void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr",
            "val",
            "size"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)\n{\n\tint size = cachep->object_size;\n\taddr = &((char *)addr)[obj_offset(cachep)];\n\n\tmemset(addr, val, size);\n\t*(unsigned char *)(addr + size - 1) = POISON_END;\n}"
  },
  {
    "function_name": "slab_kernel_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1526-1527",
    "snippet": "static inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller) {}"
  },
  {
    "function_name": "slab_kernel_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1513-1523",
    "snippet": "static void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller)\n{\n\tif (!is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\tif (caller)\n\t\tstore_stackinfo(cachep, objp, caller);\n\n\tkernel_map_pages(virt_to_page(objp), cachep->size / PAGE_SIZE, map);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_map_pages",
          "args": [
            "virt_to_page(objp)",
            "cachep->size / PAGE_SIZE",
            "map"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "126-129",
          "snippet": "void __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "objp"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_stackinfo",
          "args": [
            "cachep",
            "objp",
            "caller"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "store_stackinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1481-1511",
          "snippet": "static void store_stackinfo(struct kmem_cache *cachep, unsigned long *addr,\n\t\t\t    unsigned long caller)\n{\n\tint size = cachep->object_size;\n\n\taddr = (unsigned long *)&((char *)addr)[obj_offset(cachep)];\n\n\tif (size < 5 * sizeof(unsigned long))\n\t\treturn;\n\n\t*addr++ = 0x12345678;\n\t*addr++ = caller;\n\t*addr++ = smp_processor_id();\n\tsize -= 3 * sizeof(unsigned long);\n\t{\n\t\tunsigned long *sptr = &caller;\n\t\tunsigned long svalue;\n\n\t\twhile (!kstack_end(sptr)) {\n\t\t\tsvalue = *sptr++;\n\t\t\tif (kernel_text_address(svalue)) {\n\t\t\t\t*addr++ = svalue;\n\t\t\t\tsize -= sizeof(unsigned long);\n\t\t\t\tif (size <= sizeof(unsigned long))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\t*addr++ = 0x87654321;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void store_stackinfo(struct kmem_cache *cachep, unsigned long *addr,\n\t\t\t    unsigned long caller)\n{\n\tint size = cachep->object_size;\n\n\taddr = (unsigned long *)&((char *)addr)[obj_offset(cachep)];\n\n\tif (size < 5 * sizeof(unsigned long))\n\t\treturn;\n\n\t*addr++ = 0x12345678;\n\t*addr++ = caller;\n\t*addr++ = smp_processor_id();\n\tsize -= 3 * sizeof(unsigned long);\n\t{\n\t\tunsigned long *sptr = &caller;\n\t\tunsigned long svalue;\n\n\t\twhile (!kstack_end(sptr)) {\n\t\t\tsvalue = *sptr++;\n\t\t\tif (kernel_text_address(svalue)) {\n\t\t\t\t*addr++ = svalue;\n\t\t\t\tsize -= sizeof(unsigned long);\n\t\t\t\tif (size <= sizeof(unsigned long))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\t*addr++ = 0x87654321;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_debug_pagealloc_cache",
          "args": [
            "cachep"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "is_debug_pagealloc_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1471-1478",
          "snippet": "static bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void slab_kernel_map(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint map, unsigned long caller)\n{\n\tif (!is_debug_pagealloc_cache(cachep))\n\t\treturn;\n\n\tif (caller)\n\t\tstore_stackinfo(cachep, objp, caller);\n\n\tkernel_map_pages(virt_to_page(objp), cachep->size / PAGE_SIZE, map);\n}"
  },
  {
    "function_name": "store_stackinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1481-1511",
    "snippet": "static void store_stackinfo(struct kmem_cache *cachep, unsigned long *addr,\n\t\t\t    unsigned long caller)\n{\n\tint size = cachep->object_size;\n\n\taddr = (unsigned long *)&((char *)addr)[obj_offset(cachep)];\n\n\tif (size < 5 * sizeof(unsigned long))\n\t\treturn;\n\n\t*addr++ = 0x12345678;\n\t*addr++ = caller;\n\t*addr++ = smp_processor_id();\n\tsize -= 3 * sizeof(unsigned long);\n\t{\n\t\tunsigned long *sptr = &caller;\n\t\tunsigned long svalue;\n\n\t\twhile (!kstack_end(sptr)) {\n\t\t\tsvalue = *sptr++;\n\t\t\tif (kernel_text_address(svalue)) {\n\t\t\t\t*addr++ = svalue;\n\t\t\t\tsize -= sizeof(unsigned long);\n\t\t\t\tif (size <= sizeof(unsigned long))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\t*addr++ = 0x87654321;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "svalue"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstack_end",
          "args": [
            "sptr"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void store_stackinfo(struct kmem_cache *cachep, unsigned long *addr,\n\t\t\t    unsigned long caller)\n{\n\tint size = cachep->object_size;\n\n\taddr = (unsigned long *)&((char *)addr)[obj_offset(cachep)];\n\n\tif (size < 5 * sizeof(unsigned long))\n\t\treturn;\n\n\t*addr++ = 0x12345678;\n\t*addr++ = caller;\n\t*addr++ = smp_processor_id();\n\tsize -= 3 * sizeof(unsigned long);\n\t{\n\t\tunsigned long *sptr = &caller;\n\t\tunsigned long svalue;\n\n\t\twhile (!kstack_end(sptr)) {\n\t\t\tsvalue = *sptr++;\n\t\t\tif (kernel_text_address(svalue)) {\n\t\t\t\t*addr++ = svalue;\n\t\t\t\tsize -= sizeof(unsigned long);\n\t\t\t\tif (size <= sizeof(unsigned long))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\t*addr++ = 0x87654321;\n}"
  },
  {
    "function_name": "is_debug_pagealloc_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1471-1478",
    "snippet": "static bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OFF_SLAB",
          "args": [
            "cachep"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic bool is_debug_pagealloc_cache(struct kmem_cache *cachep)\n{\n\tif (debug_pagealloc_enabled() && OFF_SLAB(cachep) &&\n\t\t(cachep->size % PAGE_SIZE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "kmem_rcu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1459-1468",
    "snippet": "static void kmem_rcu_free(struct rcu_head *head)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\tpage = container_of(head, struct page, rcu_head);\n\tcachep = page->slab_cache;\n\n\tkmem_freepages(cachep, page);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_freepages",
          "args": [
            "cachep",
            "page"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1437-1457",
          "snippet": "static void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structpage",
            "rcu_head"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_rcu_free(struct rcu_head *head)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\tpage = container_of(head, struct page, rcu_head);\n\tcachep = page->slab_cache;\n\n\tkmem_freepages(cachep, page);\n}"
  },
  {
    "function_name": "kmem_freepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1437-1457",
    "snippet": "static void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_uncharge_slab",
          "args": [
            "page",
            "order",
            "cachep"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_uncharge_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "341-344",
          "snippet": "static inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t       struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t       struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount_reset",
          "args": [
            "page"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageSlab",
          "args": [
            "page"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageSlab(page)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_lruvec_page_state",
          "args": [
            "page",
            "NR_SLAB_UNRECLAIMABLE",
            "-nr_freed"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_lruvec_page_state",
          "args": [
            "page",
            "NR_SLAB_RECLAIMABLE",
            "-nr_freed"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_freepages(struct kmem_cache *cachep, struct page *page)\n{\n\tint order = cachep->gfporder;\n\tunsigned long nr_freed = (1 << order);\n\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, -nr_freed);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, -nr_freed);\n\n\tBUG_ON(!PageSlab(page));\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage_mapcount_reset(page);\n\tpage->mapping = NULL;\n\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += nr_freed;\n\tmemcg_uncharge_slab(page, order, cachep);\n\t__free_pages(page, order);\n}"
  },
  {
    "function_name": "kmem_getpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1401-1432",
    "snippet": "static struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\t\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tint nr_pages;\n\n\tflags |= cachep->allocflags;\n\n\tpage = __alloc_pages_node(nodeid, flags, cachep->gfporder);\n\tif (!page) {\n\t\tslab_out_of_memory(cachep, flags, nodeid);\n\t\treturn NULL;\n\t}\n\n\tif (memcg_charge_slab(page, flags, cachep->gfporder, cachep)) {\n\t\t__free_pages(page, cachep->gfporder);\n\t\treturn NULL;\n\t}\n\n\tnr_pages = (1 << cachep->gfporder);\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, nr_pages);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, nr_pages);\n\n\t__SetPageSlab(page);\n\t/* Record if ALLOC_NO_WATERMARKS was set when allocating the slab */\n\tif (sk_memalloc_socks() && page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\treturn page;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_pfmemalloc",
          "args": [
            "page"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_memalloc_socks",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSlab",
          "args": [
            "page"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_lruvec_page_state",
          "args": [
            "page",
            "NR_SLAB_UNRECLAIMABLE",
            "nr_pages"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_lruvec_page_state",
          "args": [
            "page",
            "NR_SLAB_RECLAIMABLE",
            "nr_pages"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "cachep->gfporder"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_charge_slab",
          "args": [
            "page",
            "flags",
            "cachep->gfporder",
            "cachep"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_charge_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "335-339",
          "snippet": "static inline int memcg_charge_slab(struct page *page, gfp_t gfp, int order,\n\t\t\t\t    struct kmem_cache *s)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline int memcg_charge_slab(struct page *page, gfp_t gfp, int order,\n\t\t\t\t    struct kmem_cache *s)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_out_of_memory",
          "args": [
            "cachep",
            "flags",
            "nodeid"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "slab_out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1358-1391",
          "snippet": "static noinline void\nslab_out_of_memory(struct kmem_cache *cachep, gfp_t gfpflags, int nodeid)\n{\n#if DEBUG\n\tstruct kmem_cache_node *n;\n\tunsigned long flags;\n\tint node;\n\tstatic DEFINE_RATELIMIT_STATE(slab_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slab_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLAB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnodeid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %d, order: %d\\n\",\n\t\tcachep->name, cachep->size, cachep->gfporder);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tunsigned long total_slabs, free_slabs, free_objs;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\ttotal_slabs = n->total_slabs;\n\t\tfree_slabs = n->free_slabs;\n\t\tfree_objs = n->free_objects;\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\tpr_warn(\"  node %d: slabs: %ld/%ld, objs: %ld/%ld\\n\",\n\t\t\tnode, total_slabs - free_slabs, total_slabs,\n\t\t\t(total_slabs * cachep->num) - free_objs,\n\t\t\ttotal_slabs * cachep->num);\n\t}\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic noinline void\nslab_out_of_memory(struct kmem_cache *cachep, gfp_t gfpflags, int nodeid)\n{\n#if DEBUG\n\tstruct kmem_cache_node *n;\n\tunsigned long flags;\n\tint node;\n\tstatic DEFINE_RATELIMIT_STATE(slab_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slab_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLAB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnodeid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %d, order: %d\\n\",\n\t\tcachep->name, cachep->size, cachep->gfporder);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tunsigned long total_slabs, free_slabs, free_objs;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\ttotal_slabs = n->total_slabs;\n\t\tfree_slabs = n->free_slabs;\n\t\tfree_objs = n->free_objects;\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\tpr_warn(\"  node %d: slabs: %ld/%ld, objs: %ld/%ld\\n\",\n\t\t\tnode, total_slabs - free_slabs, total_slabs,\n\t\t\t(total_slabs * cachep->num) - free_objs,\n\t\t\ttotal_slabs * cachep->num);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "nodeid",
            "flags",
            "cachep->gfporder"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,\n\t\t\t\t\t\t\t\tint nodeid)\n{\n\tstruct page *page;\n\tint nr_pages;\n\n\tflags |= cachep->allocflags;\n\n\tpage = __alloc_pages_node(nodeid, flags, cachep->gfporder);\n\tif (!page) {\n\t\tslab_out_of_memory(cachep, flags, nodeid);\n\t\treturn NULL;\n\t}\n\n\tif (memcg_charge_slab(page, flags, cachep->gfporder, cachep)) {\n\t\t__free_pages(page, cachep->gfporder);\n\t\treturn NULL;\n\t}\n\n\tnr_pages = (1 << cachep->gfporder);\n\tif (cachep->flags & SLAB_RECLAIM_ACCOUNT)\n\t\tmod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, nr_pages);\n\telse\n\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, nr_pages);\n\n\t__SetPageSlab(page);\n\t/* Record if ALLOC_NO_WATERMARKS was set when allocating the slab */\n\tif (sk_memalloc_socks() && page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\treturn page;\n}"
  },
  {
    "function_name": "slab_out_of_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1358-1391",
    "snippet": "static noinline void\nslab_out_of_memory(struct kmem_cache *cachep, gfp_t gfpflags, int nodeid)\n{\n#if DEBUG\n\tstruct kmem_cache_node *n;\n\tunsigned long flags;\n\tint node;\n\tstatic DEFINE_RATELIMIT_STATE(slab_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slab_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLAB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnodeid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %d, order: %d\\n\",\n\t\tcachep->name, cachep->size, cachep->gfporder);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tunsigned long total_slabs, free_slabs, free_objs;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\ttotal_slabs = n->total_slabs;\n\t\tfree_slabs = n->free_slabs;\n\t\tfree_objs = n->free_objects;\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\tpr_warn(\"  node %d: slabs: %ld/%ld, objs: %ld/%ld\\n\",\n\t\t\tnode, total_slabs - free_slabs, total_slabs,\n\t\t\t(total_slabs * cachep->num) - free_objs,\n\t\t\ttotal_slabs * cachep->num);\n\t}\n#endif\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tDEBUG\t\t0",
      "#define\tDEBUG\t\t1"
    ],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  node %d: slabs: %ld/%ld, objs: %ld/%ld\\n\"",
            "node",
            "total_slabs - free_slabs",
            "total_slabs",
            "(total_slabs * cachep->num) - free_objs",
            "total_slabs * cachep->num"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "n"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  cache: %s, object size: %d, order: %d\\n\"",
            "cachep->name",
            "cachep->size",
            "cachep->gfporder"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"SLAB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\"",
            "nodeid",
            "gfpflags",
            "&gfpflags"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&slab_oom_rs"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic noinline void\nslab_out_of_memory(struct kmem_cache *cachep, gfp_t gfpflags, int nodeid)\n{\n#if DEBUG\n\tstruct kmem_cache_node *n;\n\tunsigned long flags;\n\tint node;\n\tstatic DEFINE_RATELIMIT_STATE(slab_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slab_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLAB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnodeid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %d, order: %d\\n\",\n\t\tcachep->name, cachep->size, cachep->gfporder);\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tunsigned long total_slabs, free_slabs, free_objs;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\ttotal_slabs = n->total_slabs;\n\t\tfree_slabs = n->free_slabs;\n\t\tfree_objs = n->free_objects;\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\tpr_warn(\"  node %d: slabs: %ld/%ld, objs: %ld/%ld\\n\",\n\t\t\tnode, total_slabs - free_slabs, total_slabs,\n\t\t\t(total_slabs * cachep->num) - free_objs,\n\t\t\ttotal_slabs * cachep->num);\n\t}\n#endif\n}"
  },
  {
    "function_name": "cpucache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1343-1355",
    "snippet": "static int __init cpucache_init(void)\n{\n\tint ret;\n\n\t/*\n\t * Register the timers that return unneeded pages to the page allocator\n\t */\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"SLAB online\",\n\t\t\t\tslab_online_cpu, slab_offline_cpu);\n\tWARN_ON(ret < 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"SLAB online\"",
            "slab_online_cpu",
            "slab_offline_cpu"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int __init cpucache_init(void)\n{\n\tint ret;\n\n\t/*\n\t * Register the timers that return unneeded pages to the page allocator\n\t */\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"SLAB online\",\n\t\t\t\tslab_online_cpu, slab_offline_cpu);\n\tWARN_ON(ret < 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kmem_cache_init_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1315-1341",
    "snippet": "void __init kmem_cache_init_late(void)\n{\n\tstruct kmem_cache *cachep;\n\n\t/* 6) resize the head arrays to their final sizes */\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(cachep, &slab_caches, list)\n\t\tif (enable_cpucache(cachep, GFP_NOWAIT))\n\t\t\tBUG();\n\tmutex_unlock(&slab_mutex);\n\n\t/* Done! */\n\tslab_state = FULL;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Register a memory hotplug callback that initializes and frees\n\t * node.\n\t */\n\thotplug_memory_notifier(slab_memory_callback, SLAB_CALLBACK_PRI);\n#endif\n\n\t/*\n\t * The reap timers are started later, with a module init call: That part\n\t * of the kernel is not yet operational.\n\t */\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hotplug_memory_notifier",
          "args": [
            "slab_memory_callback",
            "SLAB_CALLBACK_PRI"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_cpucache",
          "args": [
            "cachep",
            "GFP_NOWAIT"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "enable_cpucache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3929-3998",
          "snippet": "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tDEBUG\t\t0",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tDEBUG\t\t0\n#define\tDEBUG\t\t1\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cachep",
            "&slab_caches",
            "list"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nvoid __init kmem_cache_init_late(void)\n{\n\tstruct kmem_cache *cachep;\n\n\t/* 6) resize the head arrays to their final sizes */\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(cachep, &slab_caches, list)\n\t\tif (enable_cpucache(cachep, GFP_NOWAIT))\n\t\t\tBUG();\n\tmutex_unlock(&slab_mutex);\n\n\t/* Done! */\n\tslab_state = FULL;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Register a memory hotplug callback that initializes and frees\n\t * node.\n\t */\n\thotplug_memory_notifier(slab_memory_callback, SLAB_CALLBACK_PRI);\n#endif\n\n\t/*\n\t * The reap timers are started later, with a module init call: That part\n\t * of the kernel is not yet operational.\n\t */\n}"
  },
  {
    "function_name": "kmem_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1234-1313",
    "snippet": "void __init kmem_cache_init(void)\n{\n\tint i;\n\n\tkmem_cache = &kmem_cache_boot;\n\n\tif (!IS_ENABLED(CONFIG_NUMA) || num_possible_nodes() == 1)\n\t\tuse_alien_caches = 0;\n\n\tfor (i = 0; i < NUM_INIT_LISTS; i++)\n\t\tkmem_cache_node_init(&init_kmem_cache_node[i]);\n\n\t/*\n\t * Fragmentation resistance on low memory - only use bigger\n\t * page orders on machines with more than 32MB of memory if\n\t * not overridden on the command line.\n\t */\n\tif (!slab_max_order_set && totalram_pages > (32 << 20) >> PAGE_SHIFT)\n\t\tslab_max_order = SLAB_MAX_ORDER_HI;\n\n\t/* Bootstrap is tricky, because several objects are allocated\n\t * from caches that do not exist yet:\n\t * 1) initialize the kmem_cache cache: it contains the struct\n\t *    kmem_cache structures of all caches, except kmem_cache itself:\n\t *    kmem_cache is statically allocated.\n\t *    Initially an __init data area is used for the head array and the\n\t *    kmem_cache_node structures, it's replaced with a kmalloc allocated\n\t *    array at the end of the bootstrap.\n\t * 2) Create the first kmalloc cache.\n\t *    The struct kmem_cache for the new cache is allocated normally.\n\t *    An __init data area is used for the head array.\n\t * 3) Create the remaining kmalloc caches, with minimally sized\n\t *    head arrays.\n\t * 4) Replace the __init data head arrays for kmem_cache and the first\n\t *    kmalloc cache with kmalloc allocated arrays.\n\t * 5) Replace the __init data for kmem_cache_node for kmem_cache and\n\t *    the other cache's with kmalloc allocated memory.\n\t * 6) Resize the head arrays of the kmalloc caches to their final sizes.\n\t */\n\n\t/* 1) create the kmem_cache */\n\n\t/*\n\t * struct kmem_cache size depends on nr_node_ids & nr_cpu_ids\n\t */\n\tcreate_boot_cache(kmem_cache, \"kmem_cache\",\n\t\toffsetof(struct kmem_cache, node) +\n\t\t\t\t  nr_node_ids * sizeof(struct kmem_cache_node *),\n\t\t\t\t  SLAB_HWCACHE_ALIGN, 0, 0);\n\tlist_add(&kmem_cache->list, &slab_caches);\n\tmemcg_link_cache(kmem_cache);\n\tslab_state = PARTIAL;\n\n\t/*\n\t * Initialize the caches that provide memory for the  kmem_cache_node\n\t * structures first.  Without this, further allocations will bug.\n\t */\n\tkmalloc_caches[KMALLOC_NORMAL][INDEX_NODE] = create_kmalloc_cache(\n\t\t\t\tkmalloc_info[INDEX_NODE].name,\n\t\t\t\tkmalloc_size(INDEX_NODE), ARCH_KMALLOC_FLAGS,\n\t\t\t\t0, kmalloc_size(INDEX_NODE));\n\tslab_state = PARTIAL_NODE;\n\tsetup_kmalloc_cache_index_table();\n\n\tslab_early_init = 0;\n\n\t/* 5) Replace the bootstrap kmem_cache_node */\n\t{\n\t\tint nid;\n\n\t\tfor_each_online_node(nid) {\n\t\t\tinit_list(kmem_cache, &init_kmem_cache_node[CACHE_CACHE + nid], nid);\n\n\t\t\tinit_list(kmalloc_caches[KMALLOC_NORMAL][INDEX_NODE],\n\t\t\t\t\t  &init_kmem_cache_node[SIZE_NODE + nid], nid);\n\t\t}\n\t}\n\n\tcreate_kmalloc_caches(ARCH_KMALLOC_FLAGS);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tSLAB_MAX_ORDER_HI\t1",
      "#define INDEX_NODE kmalloc_index(sizeof(struct kmem_cache_node))",
      "#define\tSIZE_NODE (MAX_NUMNODES)",
      "#define\tCACHE_CACHE 0",
      "#define NUM_INIT_LISTS (2 * MAX_NUMNODES)",
      "#define ARCH_KMALLOC_FLAGS SLAB_HWCACHE_ALIGN"
    ],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static int slab_early_init = 1;",
      "static int slab_max_order = SLAB_MAX_ORDER_LO;",
      "static bool slab_max_order_set",
      "static struct kmem_cache kmem_cache_boot = {\n\t.batchcount = 1,\n\t.limit = BOOT_CPUCACHE_ENTRIES,\n\t.shared = 1,\n\t.size = sizeof(struct kmem_cache),\n\t.name = \"kmem_cache\",\n};",
      "static int use_alien_caches",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_kmalloc_caches",
          "args": [
            "ARCH_KMALLOC_FLAGS"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "create_kmalloc_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1150-1190",
          "snippet": "void __init create_kmalloc_caches(slab_flags_t flags)\n{\n\tint i, type;\n\n\tfor (type = KMALLOC_NORMAL; type <= KMALLOC_RECLAIM; type++) {\n\t\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\t\tif (!kmalloc_caches[type][i])\n\t\t\t\tnew_kmalloc_cache(i, type, flags);\n\n\t\t\t/*\n\t\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t\t * These have to be created immediately after the\n\t\t\t * earlier power of two caches\n\t\t\t */\n\t\t\tif (KMALLOC_MIN_SIZE <= 32 && i == 6 &&\n\t\t\t\t\t!kmalloc_caches[type][1])\n\t\t\t\tnew_kmalloc_cache(1, type, flags);\n\t\t\tif (KMALLOC_MIN_SIZE <= 64 && i == 7 &&\n\t\t\t\t\t!kmalloc_caches[type][2])\n\t\t\t\tnew_kmalloc_cache(2, type, flags);\n\t\t}\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n\n#ifdef CONFIG_ZONE_DMA\n\tfor (i = 0; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tstruct kmem_cache *s = kmalloc_caches[KMALLOC_NORMAL][i];\n\n\t\tif (s) {\n\t\t\tunsigned int size = kmalloc_size(i);\n\t\t\tconst char *n = kmalloc_cache_name(\"dma-kmalloc\", size);\n\n\t\t\tBUG_ON(!n);\n\t\t\tkmalloc_caches[KMALLOC_DMA][i] = create_kmalloc_cache(\n\t\t\t\tn, size, SLAB_CACHE_DMA | flags, 0, 0);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum slab_state slab_state;",
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\nstruct kmem_cache *kmem_cache;\n\nvoid __init create_kmalloc_caches(slab_flags_t flags)\n{\n\tint i, type;\n\n\tfor (type = KMALLOC_NORMAL; type <= KMALLOC_RECLAIM; type++) {\n\t\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\t\tif (!kmalloc_caches[type][i])\n\t\t\t\tnew_kmalloc_cache(i, type, flags);\n\n\t\t\t/*\n\t\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t\t * These have to be created immediately after the\n\t\t\t * earlier power of two caches\n\t\t\t */\n\t\t\tif (KMALLOC_MIN_SIZE <= 32 && i == 6 &&\n\t\t\t\t\t!kmalloc_caches[type][1])\n\t\t\t\tnew_kmalloc_cache(1, type, flags);\n\t\t\tif (KMALLOC_MIN_SIZE <= 64 && i == 7 &&\n\t\t\t\t\t!kmalloc_caches[type][2])\n\t\t\t\tnew_kmalloc_cache(2, type, flags);\n\t\t}\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n\n#ifdef CONFIG_ZONE_DMA\n\tfor (i = 0; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tstruct kmem_cache *s = kmalloc_caches[KMALLOC_NORMAL][i];\n\n\t\tif (s) {\n\t\t\tunsigned int size = kmalloc_size(i);\n\t\t\tconst char *n = kmalloc_cache_name(\"dma-kmalloc\", size);\n\n\t\t\tBUG_ON(!n);\n\t\t\tkmalloc_caches[KMALLOC_DMA][i] = create_kmalloc_cache(\n\t\t\t\tn, size, SLAB_CACHE_DMA | flags, 0, 0);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_list",
          "args": [
            "kmalloc_caches[KMALLOC_NORMAL][INDEX_NODE]",
            "&init_kmem_cache_node[SIZE_NODE + nid]",
            "nid"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "init_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1196-1212",
          "snippet": "static void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *list,\n\t\t\t\tint nodeid)\n{\n\tstruct kmem_cache_node *ptr;\n\n\tptr = kmalloc_node(sizeof(struct kmem_cache_node), GFP_NOWAIT, nodeid);\n\tBUG_ON(!ptr);\n\n\tmemcpy(ptr, list, sizeof(struct kmem_cache_node));\n\t/*\n\t * Do not assume that spinlocks can be initialized via memcpy:\n\t */\n\tspin_lock_init(&ptr->list_lock);\n\n\tMAKE_ALL_LISTS(cachep, ptr, nodeid);\n\tcachep->node[nodeid] = ptr;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *list,\n\t\t\t\tint nodeid)\n{\n\tstruct kmem_cache_node *ptr;\n\n\tptr = kmalloc_node(sizeof(struct kmem_cache_node), GFP_NOWAIT, nodeid);\n\tBUG_ON(!ptr);\n\n\tmemcpy(ptr, list, sizeof(struct kmem_cache_node));\n\t/*\n\t * Do not assume that spinlocks can be initialized via memcpy:\n\t */\n\tspin_lock_init(&ptr->list_lock);\n\n\tMAKE_ALL_LISTS(cachep, ptr, nodeid);\n\tcachep->node[nodeid] = ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_kmalloc_cache_index_table",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "setup_kmalloc_cache_index_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1075-1109",
          "snippet": "void __init setup_kmalloc_cache_index_table(void)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));\n\n\tfor (i = 8; i < KMALLOC_MIN_SIZE; i += 8) {\n\t\tunsigned int elem = size_index_elem(i);\n\n\t\tif (elem >= ARRAY_SIZE(size_index))\n\t\t\tbreak;\n\t\tsize_index[elem] = KMALLOC_SHIFT_LOW;\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 64) {\n\t\t/*\n\t\t * The 96 byte size cache is not used if the alignment\n\t\t * is 64 byte.\n\t\t */\n\t\tfor (i = 64 + 8; i <= 96; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 7;\n\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 128) {\n\t\t/*\n\t\t * The 192 byte sized cache is not used if the alignment\n\t\t * is 128 byte. Redirect kmalloc to use the 256 byte cache\n\t\t * instead.\n\t\t */\n\t\tfor (i = 128 + 8; i <= 192; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 8;\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid __init setup_kmalloc_cache_index_table(void)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));\n\n\tfor (i = 8; i < KMALLOC_MIN_SIZE; i += 8) {\n\t\tunsigned int elem = size_index_elem(i);\n\n\t\tif (elem >= ARRAY_SIZE(size_index))\n\t\t\tbreak;\n\t\tsize_index[elem] = KMALLOC_SHIFT_LOW;\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 64) {\n\t\t/*\n\t\t * The 96 byte size cache is not used if the alignment\n\t\t * is 64 byte.\n\t\t */\n\t\tfor (i = 64 + 8; i <= 96; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 7;\n\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 128) {\n\t\t/*\n\t\t * The 192 byte sized cache is not used if the alignment\n\t\t * is 128 byte. Redirect kmalloc to use the 256 byte cache\n\t\t * instead.\n\t\t */\n\t\tfor (i = 128 + 8; i <= 192; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 8;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_kmalloc_cache",
          "args": [
            "kmalloc_info[INDEX_NODE].name",
            "kmalloc_size(INDEX_NODE)",
            "ARCH_KMALLOC_FLAGS",
            "0",
            "kmalloc_size(INDEX_NODE)"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "create_kmalloc_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "960-974",
          "snippet": "struct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_size",
          "args": [
            "INDEX_NODE"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_size",
          "args": [
            "INDEX_NODE"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_link_cache",
          "args": [
            "kmem_cache"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_link_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "350-352",
          "snippet": "static inline void memcg_link_cache(struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void memcg_link_cache(struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&kmem_cache->list",
            "&slab_caches"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_boot_cache",
          "args": [
            "kmem_cache",
            "\"kmem_cache\"",
            "offsetof(struct kmem_cache, node) +\n\t\t\t\t  nr_node_ids * sizeof(struct kmem_cache_node *)",
            "SLAB_HWCACHE_ALIGN",
            "0",
            "0"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "create_boot_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "937-958",
          "snippet": "void __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_node_init",
          "args": [
            "&init_kmem_cache_node[i]"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_node_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "226-239",
          "snippet": "static void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_nodes",
          "args": [],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NUMA"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tSLAB_MAX_ORDER_HI\t1\n#define INDEX_NODE kmalloc_index(sizeof(struct kmem_cache_node))\n#define\tSIZE_NODE (MAX_NUMNODES)\n#define\tCACHE_CACHE 0\n#define NUM_INIT_LISTS (2 * MAX_NUMNODES)\n#define ARCH_KMALLOC_FLAGS SLAB_HWCACHE_ALIGN\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic int slab_early_init = 1;\nstatic int slab_max_order = SLAB_MAX_ORDER_LO;\nstatic bool slab_max_order_set;\nstatic struct kmem_cache kmem_cache_boot = {\n\t.batchcount = 1,\n\t.limit = BOOT_CPUCACHE_ENTRIES,\n\t.shared = 1,\n\t.size = sizeof(struct kmem_cache),\n\t.name = \"kmem_cache\",\n};\nstatic int use_alien_caches;\nstatic noinline struct;\n\nvoid __init kmem_cache_init(void)\n{\n\tint i;\n\n\tkmem_cache = &kmem_cache_boot;\n\n\tif (!IS_ENABLED(CONFIG_NUMA) || num_possible_nodes() == 1)\n\t\tuse_alien_caches = 0;\n\n\tfor (i = 0; i < NUM_INIT_LISTS; i++)\n\t\tkmem_cache_node_init(&init_kmem_cache_node[i]);\n\n\t/*\n\t * Fragmentation resistance on low memory - only use bigger\n\t * page orders on machines with more than 32MB of memory if\n\t * not overridden on the command line.\n\t */\n\tif (!slab_max_order_set && totalram_pages > (32 << 20) >> PAGE_SHIFT)\n\t\tslab_max_order = SLAB_MAX_ORDER_HI;\n\n\t/* Bootstrap is tricky, because several objects are allocated\n\t * from caches that do not exist yet:\n\t * 1) initialize the kmem_cache cache: it contains the struct\n\t *    kmem_cache structures of all caches, except kmem_cache itself:\n\t *    kmem_cache is statically allocated.\n\t *    Initially an __init data area is used for the head array and the\n\t *    kmem_cache_node structures, it's replaced with a kmalloc allocated\n\t *    array at the end of the bootstrap.\n\t * 2) Create the first kmalloc cache.\n\t *    The struct kmem_cache for the new cache is allocated normally.\n\t *    An __init data area is used for the head array.\n\t * 3) Create the remaining kmalloc caches, with minimally sized\n\t *    head arrays.\n\t * 4) Replace the __init data head arrays for kmem_cache and the first\n\t *    kmalloc cache with kmalloc allocated arrays.\n\t * 5) Replace the __init data for kmem_cache_node for kmem_cache and\n\t *    the other cache's with kmalloc allocated memory.\n\t * 6) Resize the head arrays of the kmalloc caches to their final sizes.\n\t */\n\n\t/* 1) create the kmem_cache */\n\n\t/*\n\t * struct kmem_cache size depends on nr_node_ids & nr_cpu_ids\n\t */\n\tcreate_boot_cache(kmem_cache, \"kmem_cache\",\n\t\toffsetof(struct kmem_cache, node) +\n\t\t\t\t  nr_node_ids * sizeof(struct kmem_cache_node *),\n\t\t\t\t  SLAB_HWCACHE_ALIGN, 0, 0);\n\tlist_add(&kmem_cache->list, &slab_caches);\n\tmemcg_link_cache(kmem_cache);\n\tslab_state = PARTIAL;\n\n\t/*\n\t * Initialize the caches that provide memory for the  kmem_cache_node\n\t * structures first.  Without this, further allocations will bug.\n\t */\n\tkmalloc_caches[KMALLOC_NORMAL][INDEX_NODE] = create_kmalloc_cache(\n\t\t\t\tkmalloc_info[INDEX_NODE].name,\n\t\t\t\tkmalloc_size(INDEX_NODE), ARCH_KMALLOC_FLAGS,\n\t\t\t\t0, kmalloc_size(INDEX_NODE));\n\tslab_state = PARTIAL_NODE;\n\tsetup_kmalloc_cache_index_table();\n\n\tslab_early_init = 0;\n\n\t/* 5) Replace the bootstrap kmem_cache_node */\n\t{\n\t\tint nid;\n\n\t\tfor_each_online_node(nid) {\n\t\t\tinit_list(kmem_cache, &init_kmem_cache_node[CACHE_CACHE + nid], nid);\n\n\t\t\tinit_list(kmalloc_caches[KMALLOC_NORMAL][INDEX_NODE],\n\t\t\t\t\t  &init_kmem_cache_node[SIZE_NODE + nid], nid);\n\t\t}\n\t}\n\n\tcreate_kmalloc_caches(ARCH_KMALLOC_FLAGS);\n}"
  },
  {
    "function_name": "set_up_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1218-1228",
    "snippet": "static void __init set_up_node(struct kmem_cache *cachep, int index)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tcachep->node[node] = &init_kmem_cache_node[index + node];\n\t\tcachep->node[node]->next_reap = jiffies +\n\t\t    REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define REAPTIMEOUT_NODE\t(4*HZ)"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define REAPTIMEOUT_NODE\t(4*HZ)\n\nstatic noinline struct;\n\nstatic void __init set_up_node(struct kmem_cache *cachep, int index)\n{\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tcachep->node[node] = &init_kmem_cache_node[index + node];\n\t\tcachep->node[node]->next_reap = jiffies +\n\t\t    REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\t}\n}"
  },
  {
    "function_name": "init_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1196-1212",
    "snippet": "static void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *list,\n\t\t\t\tint nodeid)\n{\n\tstruct kmem_cache_node *ptr;\n\n\tptr = kmalloc_node(sizeof(struct kmem_cache_node), GFP_NOWAIT, nodeid);\n\tBUG_ON(!ptr);\n\n\tmemcpy(ptr, list, sizeof(struct kmem_cache_node));\n\t/*\n\t * Do not assume that spinlocks can be initialized via memcpy:\n\t */\n\tspin_lock_init(&ptr->list_lock);\n\n\tMAKE_ALL_LISTS(cachep, ptr, nodeid);\n\tcachep->node[nodeid] = ptr;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAKE_ALL_LISTS",
          "args": [
            "cachep",
            "ptr",
            "nodeid"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ptr->list_lock"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "list",
            "sizeof(struct kmem_cache_node)"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ptr"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct kmem_cache_node)",
            "GFP_NOWAIT",
            "nodeid"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *list,\n\t\t\t\tint nodeid)\n{\n\tstruct kmem_cache_node *ptr;\n\n\tptr = kmalloc_node(sizeof(struct kmem_cache_node), GFP_NOWAIT, nodeid);\n\tBUG_ON(!ptr);\n\n\tmemcpy(ptr, list, sizeof(struct kmem_cache_node));\n\t/*\n\t * Do not assume that spinlocks can be initialized via memcpy:\n\t */\n\tspin_lock_init(&ptr->list_lock);\n\n\tMAKE_ALL_LISTS(cachep, ptr, nodeid);\n\tcachep->node[nodeid] = ptr;\n}"
  },
  {
    "function_name": "slab_memory_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1160-1190",
    "snippet": "static int __meminit slab_memory_callback(struct notifier_block *self,\n\t\t\t\t\tunsigned long action, void *arg)\n{\n\tstruct memory_notify *mnb = arg;\n\tint ret = 0;\n\tint nid;\n\n\tnid = mnb->status_change_nid;\n\tif (nid < 0)\n\t\tgoto out;\n\n\tswitch (action) {\n\tcase MEM_GOING_ONLINE:\n\t\tmutex_lock(&slab_mutex);\n\t\tret = init_cache_node_node(nid);\n\t\tmutex_unlock(&slab_mutex);\n\t\tbreak;\n\tcase MEM_GOING_OFFLINE:\n\t\tmutex_lock(&slab_mutex);\n\t\tret = drain_cache_node_node(nid);\n\t\tmutex_unlock(&slab_mutex);\n\t\tbreak;\n\tcase MEM_ONLINE:\n\tcase MEM_OFFLINE:\n\tcase MEM_CANCEL_ONLINE:\n\tcase MEM_CANCEL_OFFLINE:\n\t\tbreak;\n\t}\nout:\n\treturn notifier_from_errno(ret);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_from_errno",
          "args": [
            "ret"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_cache_node_node",
          "args": [
            "nid"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "drain_cache_node_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1137-1158",
          "snippet": "static int __meminit drain_cache_node_node(int node)\n{\n\tstruct kmem_cache *cachep;\n\tint ret = 0;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tif (!list_empty(&n->slabs_full) ||\n\t\t    !list_empty(&n->slabs_partial)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int __meminit drain_cache_node_node(int node)\n{\n\tstruct kmem_cache *cachep;\n\tint ret = 0;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tif (!list_empty(&n->slabs_full) ||\n\t\t    !list_empty(&n->slabs_partial)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cache_node_node",
          "args": [
            "nid"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "init_cache_node_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "897-909",
          "snippet": "static int init_cache_node_node(int node)\n{\n\tint ret;\n\tstruct kmem_cache *cachep;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tret = init_cache_node(cachep, node, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int init_cache_node_node(int node)\n{\n\tint ret;\n\tstruct kmem_cache *cachep;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tret = init_cache_node(cachep, node, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int __meminit slab_memory_callback(struct notifier_block *self,\n\t\t\t\t\tunsigned long action, void *arg)\n{\n\tstruct memory_notify *mnb = arg;\n\tint ret = 0;\n\tint nid;\n\n\tnid = mnb->status_change_nid;\n\tif (nid < 0)\n\t\tgoto out;\n\n\tswitch (action) {\n\tcase MEM_GOING_ONLINE:\n\t\tmutex_lock(&slab_mutex);\n\t\tret = init_cache_node_node(nid);\n\t\tmutex_unlock(&slab_mutex);\n\t\tbreak;\n\tcase MEM_GOING_OFFLINE:\n\t\tmutex_lock(&slab_mutex);\n\t\tret = drain_cache_node_node(nid);\n\t\tmutex_unlock(&slab_mutex);\n\t\tbreak;\n\tcase MEM_ONLINE:\n\tcase MEM_OFFLINE:\n\tcase MEM_CANCEL_ONLINE:\n\tcase MEM_CANCEL_OFFLINE:\n\t\tbreak;\n\t}\nout:\n\treturn notifier_from_errno(ret);\n}"
  },
  {
    "function_name": "drain_cache_node_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1137-1158",
    "snippet": "static int __meminit drain_cache_node_node(int node)\n{\n\tstruct kmem_cache *cachep;\n\tint ret = 0;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tif (!list_empty(&n->slabs_full) ||\n\t\t    !list_empty(&n->slabs_partial)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&n->slabs_partial"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_freelist",
          "args": [
            "cachep",
            "n",
            "INT_MAX"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "drain_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2258-2290",
          "snippet": "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic noinline struct;\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cachep",
            "&slab_caches",
            "list"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int __meminit drain_cache_node_node(int node)\n{\n\tstruct kmem_cache *cachep;\n\tint ret = 0;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tif (!list_empty(&n->slabs_full) ||\n\t\t    !list_empty(&n->slabs_partial)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "slab_offline_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1115-1127",
    "snippet": "static int slab_offline_cpu(unsigned int cpu)\n{\n\t/*\n\t * Shutdown cache reaper. Note that the slab_mutex is held so\n\t * that if cache_reap() is invoked it cannot do anything\n\t * expensive but will only modify reap_work and reschedule the\n\t * timer.\n\t */\n\tcancel_delayed_work_sync(&per_cpu(slab_reap_work, cpu));\n\t/* Now the cache_reaper is guaranteed to be not running. */\n\tper_cpu(slab_reap_work, cpu).work.func = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct delayed_work, slab_reap_work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "slab_reap_work",
            "cpu"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&per_cpu(slab_reap_work, cpu)"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "slab_reap_work",
            "cpu"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic DEFINE_PER_CPU(struct delayed_work, slab_reap_work);\n\nstatic int slab_offline_cpu(unsigned int cpu)\n{\n\t/*\n\t * Shutdown cache reaper. Note that the slab_mutex is held so\n\t * that if cache_reap() is invoked it cannot do anything\n\t * expensive but will only modify reap_work and reschedule the\n\t * timer.\n\t */\n\tcancel_delayed_work_sync(&per_cpu(slab_reap_work, cpu));\n\t/* Now the cache_reaper is guaranteed to be not running. */\n\tper_cpu(slab_reap_work, cpu).work.func = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "slab_online_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1109-1113",
    "snippet": "static int slab_online_cpu(unsigned int cpu)\n{\n\tstart_cpu_timer(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_cpu_timer",
          "args": [
            "cpu"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "start_cpu_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "552-562",
          "snippet": "static void start_cpu_timer(int cpu)\n{\n\tstruct delayed_work *reap_work = &per_cpu(slab_reap_work, cpu);\n\n\tif (reap_work->work.func == NULL) {\n\t\tinit_reap_node(cpu);\n\t\tINIT_DEFERRABLE_WORK(reap_work, cache_reap);\n\t\tschedule_delayed_work_on(cpu, reap_work,\n\t\t\t\t\t__round_jiffies_relative(HZ, cpu));\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct delayed_work, slab_reap_work);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic DEFINE_PER_CPU(struct delayed_work, slab_reap_work);\nstatic noinline struct;\n\nstatic void start_cpu_timer(int cpu)\n{\n\tstruct delayed_work *reap_work = &per_cpu(slab_reap_work, cpu);\n\n\tif (reap_work->work.func == NULL) {\n\t\tinit_reap_node(cpu);\n\t\tINIT_DEFERRABLE_WORK(reap_work, cache_reap);\n\t\tschedule_delayed_work_on(cpu, reap_work,\n\t\t\t\t\t__round_jiffies_relative(HZ, cpu));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int slab_online_cpu(unsigned int cpu)\n{\n\tstart_cpu_timer(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "slab_dead_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1100-1106",
    "snippet": "int slab_dead_cpu(unsigned int cpu)\n{\n\tmutex_lock(&slab_mutex);\n\tcpuup_canceled(cpu);\n\tmutex_unlock(&slab_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuup_canceled",
          "args": [
            "cpu"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "cpuup_canceled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "980-1046",
          "snippet": "static void cpuup_canceled(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tstruct kmem_cache_node *n = NULL;\n\tint node = cpu_to_mem(cpu);\n\tconst struct cpumask *mask = cpumask_of_node(node);\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct array_cache *nc;\n\t\tstruct array_cache *shared;\n\t\tstruct alien_cache **alien;\n\t\tLIST_HEAD(list);\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\t/* Free limit for this kmem_cache_node */\n\t\tn->free_limit -= cachep->batchcount;\n\n\t\t/* cpu is dead; no one can alloc from it. */\n\t\tnc = per_cpu_ptr(cachep->cpu_cache, cpu);\n\t\tif (nc) {\n\t\t\tfree_block(cachep, nc->entry, nc->avail, node, &list);\n\t\t\tnc->avail = 0;\n\t\t}\n\n\t\tif (!cpumask_empty(mask)) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto free_slab;\n\t\t}\n\n\t\tshared = n->shared;\n\t\tif (shared) {\n\t\t\tfree_block(cachep, shared->entry,\n\t\t\t\t   shared->avail, node, &list);\n\t\t\tn->shared = NULL;\n\t\t}\n\n\t\talien = n->alien;\n\t\tn->alien = NULL;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tkfree(shared);\n\t\tif (alien) {\n\t\t\tdrain_alien_cache(cachep, alien);\n\t\t\tfree_alien_cache(alien);\n\t\t}\n\nfree_slab:\n\t\tslabs_destroy(cachep, &list);\n\t}\n\t/*\n\t * In the previous loop, all the objects were freed to\n\t * the respective cache's slabs,  now we can go ahead and\n\t * shrink each nodelist to its limit.\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cpuup_canceled(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tstruct kmem_cache_node *n = NULL;\n\tint node = cpu_to_mem(cpu);\n\tconst struct cpumask *mask = cpumask_of_node(node);\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct array_cache *nc;\n\t\tstruct array_cache *shared;\n\t\tstruct alien_cache **alien;\n\t\tLIST_HEAD(list);\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\t/* Free limit for this kmem_cache_node */\n\t\tn->free_limit -= cachep->batchcount;\n\n\t\t/* cpu is dead; no one can alloc from it. */\n\t\tnc = per_cpu_ptr(cachep->cpu_cache, cpu);\n\t\tif (nc) {\n\t\t\tfree_block(cachep, nc->entry, nc->avail, node, &list);\n\t\t\tnc->avail = 0;\n\t\t}\n\n\t\tif (!cpumask_empty(mask)) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto free_slab;\n\t\t}\n\n\t\tshared = n->shared;\n\t\tif (shared) {\n\t\t\tfree_block(cachep, shared->entry,\n\t\t\t\t   shared->avail, node, &list);\n\t\t\tn->shared = NULL;\n\t\t}\n\n\t\talien = n->alien;\n\t\tn->alien = NULL;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tkfree(shared);\n\t\tif (alien) {\n\t\t\tdrain_alien_cache(cachep, alien);\n\t\t\tfree_alien_cache(alien);\n\t\t}\n\nfree_slab:\n\t\tslabs_destroy(cachep, &list);\n\t}\n\t/*\n\t * In the previous loop, all the objects were freed to\n\t * the respective cache's slabs,  now we can go ahead and\n\t * shrink each nodelist to its limit.\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nint slab_dead_cpu(unsigned int cpu)\n{\n\tmutex_lock(&slab_mutex);\n\tcpuup_canceled(cpu);\n\tmutex_unlock(&slab_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "slab_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1080-1088",
    "snippet": "int slab_prepare_cpu(unsigned int cpu)\n{\n\tint err;\n\n\tmutex_lock(&slab_mutex);\n\terr = cpuup_prepare(cpu);\n\tmutex_unlock(&slab_mutex);\n\treturn err;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuup_prepare",
          "args": [
            "cpu"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "cpuup_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1048-1078",
          "snippet": "static int cpuup_prepare(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tint node = cpu_to_mem(cpu);\n\tint err;\n\n\t/*\n\t * We need to do this right in the beginning since\n\t * alloc_arraycache's are going to use this list.\n\t * kmalloc_node allows us to add the slab to the right\n\t * kmem_cache_node and not this cpu's kmem_cache_node\n\t */\n\terr = init_cache_node_node(node);\n\tif (err < 0)\n\t\tgoto bad;\n\n\t/*\n\t * Now we can go ahead with allocating the shared arrays and\n\t * array caches\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\terr = setup_kmem_cache_node(cachep, node, GFP_KERNEL, false);\n\t\tif (err)\n\t\t\tgoto bad;\n\t}\n\n\treturn 0;\nbad:\n\tcpuup_canceled(cpu);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int cpuup_prepare(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tint node = cpu_to_mem(cpu);\n\tint err;\n\n\t/*\n\t * We need to do this right in the beginning since\n\t * alloc_arraycache's are going to use this list.\n\t * kmalloc_node allows us to add the slab to the right\n\t * kmem_cache_node and not this cpu's kmem_cache_node\n\t */\n\terr = init_cache_node_node(node);\n\tif (err < 0)\n\t\tgoto bad;\n\n\t/*\n\t * Now we can go ahead with allocating the shared arrays and\n\t * array caches\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\terr = setup_kmem_cache_node(cachep, node, GFP_KERNEL, false);\n\t\tif (err)\n\t\t\tgoto bad;\n\t}\n\n\treturn 0;\nbad:\n\tcpuup_canceled(cpu);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nint slab_prepare_cpu(unsigned int cpu)\n{\n\tint err;\n\n\tmutex_lock(&slab_mutex);\n\terr = cpuup_prepare(cpu);\n\tmutex_unlock(&slab_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "cpuup_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "1048-1078",
    "snippet": "static int cpuup_prepare(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tint node = cpu_to_mem(cpu);\n\tint err;\n\n\t/*\n\t * We need to do this right in the beginning since\n\t * alloc_arraycache's are going to use this list.\n\t * kmalloc_node allows us to add the slab to the right\n\t * kmem_cache_node and not this cpu's kmem_cache_node\n\t */\n\terr = init_cache_node_node(node);\n\tif (err < 0)\n\t\tgoto bad;\n\n\t/*\n\t * Now we can go ahead with allocating the shared arrays and\n\t * array caches\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\terr = setup_kmem_cache_node(cachep, node, GFP_KERNEL, false);\n\t\tif (err)\n\t\t\tgoto bad;\n\t}\n\n\treturn 0;\nbad:\n\tcpuup_canceled(cpu);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuup_canceled",
          "args": [
            "cpu"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "cpuup_canceled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "980-1046",
          "snippet": "static void cpuup_canceled(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tstruct kmem_cache_node *n = NULL;\n\tint node = cpu_to_mem(cpu);\n\tconst struct cpumask *mask = cpumask_of_node(node);\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct array_cache *nc;\n\t\tstruct array_cache *shared;\n\t\tstruct alien_cache **alien;\n\t\tLIST_HEAD(list);\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\t/* Free limit for this kmem_cache_node */\n\t\tn->free_limit -= cachep->batchcount;\n\n\t\t/* cpu is dead; no one can alloc from it. */\n\t\tnc = per_cpu_ptr(cachep->cpu_cache, cpu);\n\t\tif (nc) {\n\t\t\tfree_block(cachep, nc->entry, nc->avail, node, &list);\n\t\t\tnc->avail = 0;\n\t\t}\n\n\t\tif (!cpumask_empty(mask)) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto free_slab;\n\t\t}\n\n\t\tshared = n->shared;\n\t\tif (shared) {\n\t\t\tfree_block(cachep, shared->entry,\n\t\t\t\t   shared->avail, node, &list);\n\t\t\tn->shared = NULL;\n\t\t}\n\n\t\talien = n->alien;\n\t\tn->alien = NULL;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tkfree(shared);\n\t\tif (alien) {\n\t\t\tdrain_alien_cache(cachep, alien);\n\t\t\tfree_alien_cache(alien);\n\t\t}\n\nfree_slab:\n\t\tslabs_destroy(cachep, &list);\n\t}\n\t/*\n\t * In the previous loop, all the objects were freed to\n\t * the respective cache's slabs,  now we can go ahead and\n\t * shrink each nodelist to its limit.\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cpuup_canceled(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tstruct kmem_cache_node *n = NULL;\n\tint node = cpu_to_mem(cpu);\n\tconst struct cpumask *mask = cpumask_of_node(node);\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct array_cache *nc;\n\t\tstruct array_cache *shared;\n\t\tstruct alien_cache **alien;\n\t\tLIST_HEAD(list);\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\t/* Free limit for this kmem_cache_node */\n\t\tn->free_limit -= cachep->batchcount;\n\n\t\t/* cpu is dead; no one can alloc from it. */\n\t\tnc = per_cpu_ptr(cachep->cpu_cache, cpu);\n\t\tif (nc) {\n\t\t\tfree_block(cachep, nc->entry, nc->avail, node, &list);\n\t\t\tnc->avail = 0;\n\t\t}\n\n\t\tif (!cpumask_empty(mask)) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto free_slab;\n\t\t}\n\n\t\tshared = n->shared;\n\t\tif (shared) {\n\t\t\tfree_block(cachep, shared->entry,\n\t\t\t\t   shared->avail, node, &list);\n\t\t\tn->shared = NULL;\n\t\t}\n\n\t\talien = n->alien;\n\t\tn->alien = NULL;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tkfree(shared);\n\t\tif (alien) {\n\t\t\tdrain_alien_cache(cachep, alien);\n\t\t\tfree_alien_cache(alien);\n\t\t}\n\nfree_slab:\n\t\tslabs_destroy(cachep, &list);\n\t}\n\t/*\n\t * In the previous loop, all the objects were freed to\n\t * the respective cache's slabs,  now we can go ahead and\n\t * shrink each nodelist to its limit.\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_kmem_cache_node",
          "args": [
            "cachep",
            "node",
            "GFP_KERNEL",
            "false"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "setup_kmem_cache_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "912-976",
          "snippet": "static int setup_kmem_cache_node(struct kmem_cache *cachep,\n\t\t\t\tint node, gfp_t gfp, bool force_change)\n{\n\tint ret = -ENOMEM;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *old_shared = NULL;\n\tstruct array_cache *new_shared = NULL;\n\tstruct alien_cache **new_alien = NULL;\n\tLIST_HEAD(list);\n\n\tif (use_alien_caches) {\n\t\tnew_alien = alloc_alien_cache(node, cachep->limit, gfp);\n\t\tif (!new_alien)\n\t\t\tgoto fail;\n\t}\n\n\tif (cachep->shared) {\n\t\tnew_shared = alloc_arraycache(node,\n\t\t\tcachep->shared * cachep->batchcount, 0xbaadf00d, gfp);\n\t\tif (!new_shared)\n\t\t\tgoto fail;\n\t}\n\n\tret = init_cache_node(cachep, node, gfp);\n\tif (ret)\n\t\tgoto fail;\n\n\tn = get_node(cachep, node);\n\tspin_lock_irq(&n->list_lock);\n\tif (n->shared && force_change) {\n\t\tfree_block(cachep, n->shared->entry,\n\t\t\t\tn->shared->avail, node, &list);\n\t\tn->shared->avail = 0;\n\t}\n\n\tif (!n->shared || force_change) {\n\t\told_shared = n->shared;\n\t\tn->shared = new_shared;\n\t\tnew_shared = NULL;\n\t}\n\n\tif (!n->alien) {\n\t\tn->alien = new_alien;\n\t\tnew_alien = NULL;\n\t}\n\n\tspin_unlock_irq(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\n\t/*\n\t * To protect lockless access to n->shared during irq disabled context.\n\t * If n->shared isn't NULL in irq disabled context, accessing to it is\n\t * guaranteed to be valid until irq is re-enabled, because it will be\n\t * freed after synchronize_sched().\n\t */\n\tif (old_shared && force_change)\n\t\tsynchronize_sched();\n\nfail:\n\tkfree(old_shared);\n\tkfree(new_shared);\n\tfree_alien_cache(new_alien);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static int use_alien_caches",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic int use_alien_caches;\nstatic noinline struct;\n\nstatic int setup_kmem_cache_node(struct kmem_cache *cachep,\n\t\t\t\tint node, gfp_t gfp, bool force_change)\n{\n\tint ret = -ENOMEM;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *old_shared = NULL;\n\tstruct array_cache *new_shared = NULL;\n\tstruct alien_cache **new_alien = NULL;\n\tLIST_HEAD(list);\n\n\tif (use_alien_caches) {\n\t\tnew_alien = alloc_alien_cache(node, cachep->limit, gfp);\n\t\tif (!new_alien)\n\t\t\tgoto fail;\n\t}\n\n\tif (cachep->shared) {\n\t\tnew_shared = alloc_arraycache(node,\n\t\t\tcachep->shared * cachep->batchcount, 0xbaadf00d, gfp);\n\t\tif (!new_shared)\n\t\t\tgoto fail;\n\t}\n\n\tret = init_cache_node(cachep, node, gfp);\n\tif (ret)\n\t\tgoto fail;\n\n\tn = get_node(cachep, node);\n\tspin_lock_irq(&n->list_lock);\n\tif (n->shared && force_change) {\n\t\tfree_block(cachep, n->shared->entry,\n\t\t\t\tn->shared->avail, node, &list);\n\t\tn->shared->avail = 0;\n\t}\n\n\tif (!n->shared || force_change) {\n\t\told_shared = n->shared;\n\t\tn->shared = new_shared;\n\t\tnew_shared = NULL;\n\t}\n\n\tif (!n->alien) {\n\t\tn->alien = new_alien;\n\t\tnew_alien = NULL;\n\t}\n\n\tspin_unlock_irq(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\n\t/*\n\t * To protect lockless access to n->shared during irq disabled context.\n\t * If n->shared isn't NULL in irq disabled context, accessing to it is\n\t * guaranteed to be valid until irq is re-enabled, because it will be\n\t * freed after synchronize_sched().\n\t */\n\tif (old_shared && force_change)\n\t\tsynchronize_sched();\n\nfail:\n\tkfree(old_shared);\n\tkfree(new_shared);\n\tfree_alien_cache(new_alien);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cachep",
            "&slab_caches",
            "list"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cache_node_node",
          "args": [
            "node"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "init_cache_node_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "897-909",
          "snippet": "static int init_cache_node_node(int node)\n{\n\tint ret;\n\tstruct kmem_cache *cachep;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tret = init_cache_node(cachep, node, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int init_cache_node_node(int node)\n{\n\tint ret;\n\tstruct kmem_cache *cachep;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tret = init_cache_node(cachep, node, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_mem",
          "args": [
            "cpu"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int cpuup_prepare(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tint node = cpu_to_mem(cpu);\n\tint err;\n\n\t/*\n\t * We need to do this right in the beginning since\n\t * alloc_arraycache's are going to use this list.\n\t * kmalloc_node allows us to add the slab to the right\n\t * kmem_cache_node and not this cpu's kmem_cache_node\n\t */\n\terr = init_cache_node_node(node);\n\tif (err < 0)\n\t\tgoto bad;\n\n\t/*\n\t * Now we can go ahead with allocating the shared arrays and\n\t * array caches\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\terr = setup_kmem_cache_node(cachep, node, GFP_KERNEL, false);\n\t\tif (err)\n\t\t\tgoto bad;\n\t}\n\n\treturn 0;\nbad:\n\tcpuup_canceled(cpu);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "cpuup_canceled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "980-1046",
    "snippet": "static void cpuup_canceled(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tstruct kmem_cache_node *n = NULL;\n\tint node = cpu_to_mem(cpu);\n\tconst struct cpumask *mask = cpumask_of_node(node);\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct array_cache *nc;\n\t\tstruct array_cache *shared;\n\t\tstruct alien_cache **alien;\n\t\tLIST_HEAD(list);\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\t/* Free limit for this kmem_cache_node */\n\t\tn->free_limit -= cachep->batchcount;\n\n\t\t/* cpu is dead; no one can alloc from it. */\n\t\tnc = per_cpu_ptr(cachep->cpu_cache, cpu);\n\t\tif (nc) {\n\t\t\tfree_block(cachep, nc->entry, nc->avail, node, &list);\n\t\t\tnc->avail = 0;\n\t\t}\n\n\t\tif (!cpumask_empty(mask)) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto free_slab;\n\t\t}\n\n\t\tshared = n->shared;\n\t\tif (shared) {\n\t\t\tfree_block(cachep, shared->entry,\n\t\t\t\t   shared->avail, node, &list);\n\t\t\tn->shared = NULL;\n\t\t}\n\n\t\talien = n->alien;\n\t\tn->alien = NULL;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tkfree(shared);\n\t\tif (alien) {\n\t\t\tdrain_alien_cache(cachep, alien);\n\t\t\tfree_alien_cache(alien);\n\t\t}\n\nfree_slab:\n\t\tslabs_destroy(cachep, &list);\n\t}\n\t/*\n\t * In the previous loop, all the objects were freed to\n\t * the respective cache's slabs,  now we can go ahead and\n\t * shrink each nodelist to its limit.\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drain_freelist",
          "args": [
            "cachep",
            "n",
            "INT_MAX"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "drain_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2258-2290",
          "snippet": "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree);\nstatic noinline struct;\n\nstatic int drain_freelist(struct kmem_cache *cache,\n\t\t\tstruct kmem_cache_node *n, int tofree)\n{\n\tstruct list_head *p;\n\tint nr_freed;\n\tstruct page *page;\n\n\tnr_freed = 0;\n\twhile (nr_freed < tofree && !list_empty(&n->slabs_free)) {\n\n\t\tspin_lock_irq(&n->list_lock);\n\t\tp = n->slabs_free.prev;\n\t\tif (p == &n->slabs_free) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = list_entry(p, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t\t/*\n\t\t * Safe to drop the lock. The slab is no longer linked\n\t\t * to the cache.\n\t\t */\n\t\tn->free_objects -= cache->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\t\tslab_destroy(cache, page);\n\t\tnr_freed++;\n\t}\nout:\n\treturn nr_freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cachep",
            "&slab_caches",
            "list"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_alien_cache",
          "args": [
            "alien"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "free_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "713-722",
          "snippet": "static void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_alien_cache",
          "args": [
            "cachep",
            "alien"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "drain_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "770-790",
          "snippet": "static void drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct alien_cache **alien)\n{\n\tint i = 0;\n\tstruct alien_cache *alc;\n\tstruct array_cache *ac;\n\tunsigned long flags;\n\n\tfor_each_online_node(i) {\n\t\talc = alien[i];\n\t\tif (alc) {\n\t\t\tLIST_HEAD(list);\n\n\t\t\tac = &alc->ac;\n\t\t\tspin_lock_irqsave(&alc->lock, flags);\n\t\t\t__drain_alien_cache(cachep, ac, i, &list);\n\t\t\tspin_unlock_irqrestore(&alc->lock, flags);\n\t\t\tslabs_destroy(cachep, &list);\n\t\t}\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct alien_cache **alien)\n{\n\tint i = 0;\n\tstruct alien_cache *alc;\n\tstruct array_cache *ac;\n\tunsigned long flags;\n\n\tfor_each_online_node(i) {\n\t\talc = alien[i];\n\t\tif (alc) {\n\t\t\tLIST_HEAD(list);\n\n\t\t\tac = &alc->ac;\n\t\t\tspin_lock_irqsave(&alc->lock, flags);\n\t\t\t__drain_alien_cache(cachep, ac, i, &list);\n\t\t\tspin_unlock_irqrestore(&alc->lock, flags);\n\t\t\tslabs_destroy(cachep, &list);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "shared"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3802-3819",
          "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "shared->entry",
            "shared->avail",
            "node",
            "&list"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "mask"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cachep->cpu_cache",
            "cpu"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cachep",
            "&slab_caches",
            "list"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_mem",
          "args": [
            "cpu"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void cpuup_canceled(long cpu)\n{\n\tstruct kmem_cache *cachep;\n\tstruct kmem_cache_node *n = NULL;\n\tint node = cpu_to_mem(cpu);\n\tconst struct cpumask *mask = cpumask_of_node(node);\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tstruct array_cache *nc;\n\t\tstruct array_cache *shared;\n\t\tstruct alien_cache **alien;\n\t\tLIST_HEAD(list);\n\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\t/* Free limit for this kmem_cache_node */\n\t\tn->free_limit -= cachep->batchcount;\n\n\t\t/* cpu is dead; no one can alloc from it. */\n\t\tnc = per_cpu_ptr(cachep->cpu_cache, cpu);\n\t\tif (nc) {\n\t\t\tfree_block(cachep, nc->entry, nc->avail, node, &list);\n\t\t\tnc->avail = 0;\n\t\t}\n\n\t\tif (!cpumask_empty(mask)) {\n\t\t\tspin_unlock_irq(&n->list_lock);\n\t\t\tgoto free_slab;\n\t\t}\n\n\t\tshared = n->shared;\n\t\tif (shared) {\n\t\t\tfree_block(cachep, shared->entry,\n\t\t\t\t   shared->avail, node, &list);\n\t\t\tn->shared = NULL;\n\t\t}\n\n\t\talien = n->alien;\n\t\tn->alien = NULL;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\tkfree(shared);\n\t\tif (alien) {\n\t\t\tdrain_alien_cache(cachep, alien);\n\t\t\tfree_alien_cache(alien);\n\t\t}\n\nfree_slab:\n\t\tslabs_destroy(cachep, &list);\n\t}\n\t/*\n\t * In the previous loop, all the objects were freed to\n\t * the respective cache's slabs,  now we can go ahead and\n\t * shrink each nodelist to its limit.\n\t */\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tn = get_node(cachep, node);\n\t\tif (!n)\n\t\t\tcontinue;\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\t}\n}"
  },
  {
    "function_name": "setup_kmem_cache_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "912-976",
    "snippet": "static int setup_kmem_cache_node(struct kmem_cache *cachep,\n\t\t\t\tint node, gfp_t gfp, bool force_change)\n{\n\tint ret = -ENOMEM;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *old_shared = NULL;\n\tstruct array_cache *new_shared = NULL;\n\tstruct alien_cache **new_alien = NULL;\n\tLIST_HEAD(list);\n\n\tif (use_alien_caches) {\n\t\tnew_alien = alloc_alien_cache(node, cachep->limit, gfp);\n\t\tif (!new_alien)\n\t\t\tgoto fail;\n\t}\n\n\tif (cachep->shared) {\n\t\tnew_shared = alloc_arraycache(node,\n\t\t\tcachep->shared * cachep->batchcount, 0xbaadf00d, gfp);\n\t\tif (!new_shared)\n\t\t\tgoto fail;\n\t}\n\n\tret = init_cache_node(cachep, node, gfp);\n\tif (ret)\n\t\tgoto fail;\n\n\tn = get_node(cachep, node);\n\tspin_lock_irq(&n->list_lock);\n\tif (n->shared && force_change) {\n\t\tfree_block(cachep, n->shared->entry,\n\t\t\t\tn->shared->avail, node, &list);\n\t\tn->shared->avail = 0;\n\t}\n\n\tif (!n->shared || force_change) {\n\t\told_shared = n->shared;\n\t\tn->shared = new_shared;\n\t\tnew_shared = NULL;\n\t}\n\n\tif (!n->alien) {\n\t\tn->alien = new_alien;\n\t\tnew_alien = NULL;\n\t}\n\n\tspin_unlock_irq(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\n\t/*\n\t * To protect lockless access to n->shared during irq disabled context.\n\t * If n->shared isn't NULL in irq disabled context, accessing to it is\n\t * guaranteed to be valid until irq is re-enabled, because it will be\n\t * freed after synchronize_sched().\n\t */\n\tif (old_shared && force_change)\n\t\tsynchronize_sched();\n\nfail:\n\tkfree(old_shared);\n\tkfree(new_shared);\n\tfree_alien_cache(new_alien);\n\n\treturn ret;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static int use_alien_caches",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_alien_cache",
          "args": [
            "new_alien"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "free_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "713-722",
          "snippet": "static void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_shared"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3802-3819",
          "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "n->shared->entry",
            "n->shared->avail",
            "node",
            "&list"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_cache_node",
          "args": [
            "cachep",
            "node",
            "gfp"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "init_cache_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "847-885",
          "snippet": "static int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)\n{\n\tstruct kmem_cache_node *n;\n\n\t/*\n\t * Set up the kmem_cache_node for cpu before we can\n\t * begin anything. Make sure some other cpu on this\n\t * node has not already allocated this\n\t */\n\tn = get_node(cachep, node);\n\tif (n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tn->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +\n\t\t\t\tcachep->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\treturn 0;\n\t}\n\n\tn = kmalloc_node(sizeof(struct kmem_cache_node), gfp, node);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tkmem_cache_node_init(n);\n\tn->next_reap = jiffies + REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tn->free_limit =\n\t\t(1 + nr_cpus_node(node)) * cachep->batchcount + cachep->num;\n\n\t/*\n\t * The kmem_cache_nodes don't come and go as CPUs\n\t * come and go.  slab_mutex is sufficient\n\t * protection here.\n\t */\n\tcachep->node[node] = n;\n\n\treturn 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define REAPTIMEOUT_NODE\t(4*HZ)"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define REAPTIMEOUT_NODE\t(4*HZ)\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)\n{\n\tstruct kmem_cache_node *n;\n\n\t/*\n\t * Set up the kmem_cache_node for cpu before we can\n\t * begin anything. Make sure some other cpu on this\n\t * node has not already allocated this\n\t */\n\tn = get_node(cachep, node);\n\tif (n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tn->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +\n\t\t\t\tcachep->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\treturn 0;\n\t}\n\n\tn = kmalloc_node(sizeof(struct kmem_cache_node), gfp, node);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tkmem_cache_node_init(n);\n\tn->next_reap = jiffies + REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tn->free_limit =\n\t\t(1 + nr_cpus_node(node)) * cachep->batchcount + cachep->num;\n\n\t/*\n\t * The kmem_cache_nodes don't come and go as CPUs\n\t * come and go.  slab_mutex is sufficient\n\t * protection here.\n\t */\n\tcachep->node[node] = n;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_arraycache",
          "args": [
            "node",
            "cachep->shared * cachep->batchcount",
            "0xbaadf00d",
            "gfp"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_arraycache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "582-591",
          "snippet": "static struct array_cache *alloc_arraycache(int node, int entries,\n\t\t\t\t\t    int batchcount, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tstruct array_cache *ac = NULL;\n\n\tac = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(ac, entries, batchcount);\n\treturn ac;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct array_cache *alloc_arraycache(int node, int entries,\n\t\t\t\t\t    int batchcount, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tstruct array_cache *ac = NULL;\n\n\tac = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(ac, entries, batchcount);\n\treturn ac;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_alien_cache",
          "args": [
            "node",
            "cachep->limit",
            "gfp"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "687-711",
          "snippet": "static struct alien_cache **alloc_alien_cache(int node, int limit, gfp_t gfp)\n{\n\tstruct alien_cache **alc_ptr;\n\tsize_t memsize = sizeof(void *) * nr_node_ids;\n\tint i;\n\n\tif (limit > 1)\n\t\tlimit = 12;\n\talc_ptr = kzalloc_node(memsize, gfp, node);\n\tif (!alc_ptr)\n\t\treturn NULL;\n\n\tfor_each_node(i) {\n\t\tif (i == node || !node_online(i))\n\t\t\tcontinue;\n\t\talc_ptr[i] = __alloc_alien_cache(node, limit, 0xbaadf00d, gfp);\n\t\tif (!alc_ptr[i]) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tkfree(alc_ptr[i]);\n\t\t\tkfree(alc_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn alc_ptr;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct alien_cache **alloc_alien_cache(int node, int limit, gfp_t gfp)\n{\n\tstruct alien_cache **alc_ptr;\n\tsize_t memsize = sizeof(void *) * nr_node_ids;\n\tint i;\n\n\tif (limit > 1)\n\t\tlimit = 12;\n\talc_ptr = kzalloc_node(memsize, gfp, node);\n\tif (!alc_ptr)\n\t\treturn NULL;\n\n\tfor_each_node(i) {\n\t\tif (i == node || !node_online(i))\n\t\t\tcontinue;\n\t\talc_ptr[i] = __alloc_alien_cache(node, limit, 0xbaadf00d, gfp);\n\t\tif (!alc_ptr[i]) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tkfree(alc_ptr[i]);\n\t\t\tkfree(alc_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn alc_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic int use_alien_caches;\nstatic noinline struct;\n\nstatic int setup_kmem_cache_node(struct kmem_cache *cachep,\n\t\t\t\tint node, gfp_t gfp, bool force_change)\n{\n\tint ret = -ENOMEM;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *old_shared = NULL;\n\tstruct array_cache *new_shared = NULL;\n\tstruct alien_cache **new_alien = NULL;\n\tLIST_HEAD(list);\n\n\tif (use_alien_caches) {\n\t\tnew_alien = alloc_alien_cache(node, cachep->limit, gfp);\n\t\tif (!new_alien)\n\t\t\tgoto fail;\n\t}\n\n\tif (cachep->shared) {\n\t\tnew_shared = alloc_arraycache(node,\n\t\t\tcachep->shared * cachep->batchcount, 0xbaadf00d, gfp);\n\t\tif (!new_shared)\n\t\t\tgoto fail;\n\t}\n\n\tret = init_cache_node(cachep, node, gfp);\n\tif (ret)\n\t\tgoto fail;\n\n\tn = get_node(cachep, node);\n\tspin_lock_irq(&n->list_lock);\n\tif (n->shared && force_change) {\n\t\tfree_block(cachep, n->shared->entry,\n\t\t\t\tn->shared->avail, node, &list);\n\t\tn->shared->avail = 0;\n\t}\n\n\tif (!n->shared || force_change) {\n\t\told_shared = n->shared;\n\t\tn->shared = new_shared;\n\t\tnew_shared = NULL;\n\t}\n\n\tif (!n->alien) {\n\t\tn->alien = new_alien;\n\t\tnew_alien = NULL;\n\t}\n\n\tspin_unlock_irq(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\n\t/*\n\t * To protect lockless access to n->shared during irq disabled context.\n\t * If n->shared isn't NULL in irq disabled context, accessing to it is\n\t * guaranteed to be valid until irq is re-enabled, because it will be\n\t * freed after synchronize_sched().\n\t */\n\tif (old_shared && force_change)\n\t\tsynchronize_sched();\n\nfail:\n\tkfree(old_shared);\n\tkfree(new_shared);\n\tfree_alien_cache(new_alien);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_cache_node_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "897-909",
    "snippet": "static int init_cache_node_node(int node)\n{\n\tint ret;\n\tstruct kmem_cache *cachep;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tret = init_cache_node(cachep, node, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_cache_node",
          "args": [
            "cachep",
            "node",
            "GFP_KERNEL"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "init_cache_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "847-885",
          "snippet": "static int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)\n{\n\tstruct kmem_cache_node *n;\n\n\t/*\n\t * Set up the kmem_cache_node for cpu before we can\n\t * begin anything. Make sure some other cpu on this\n\t * node has not already allocated this\n\t */\n\tn = get_node(cachep, node);\n\tif (n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tn->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +\n\t\t\t\tcachep->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\treturn 0;\n\t}\n\n\tn = kmalloc_node(sizeof(struct kmem_cache_node), gfp, node);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tkmem_cache_node_init(n);\n\tn->next_reap = jiffies + REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tn->free_limit =\n\t\t(1 + nr_cpus_node(node)) * cachep->batchcount + cachep->num;\n\n\t/*\n\t * The kmem_cache_nodes don't come and go as CPUs\n\t * come and go.  slab_mutex is sufficient\n\t * protection here.\n\t */\n\tcachep->node[node] = n;\n\n\treturn 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define REAPTIMEOUT_NODE\t(4*HZ)"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define REAPTIMEOUT_NODE\t(4*HZ)\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)\n{\n\tstruct kmem_cache_node *n;\n\n\t/*\n\t * Set up the kmem_cache_node for cpu before we can\n\t * begin anything. Make sure some other cpu on this\n\t * node has not already allocated this\n\t */\n\tn = get_node(cachep, node);\n\tif (n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tn->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +\n\t\t\t\tcachep->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\treturn 0;\n\t}\n\n\tn = kmalloc_node(sizeof(struct kmem_cache_node), gfp, node);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tkmem_cache_node_init(n);\n\tn->next_reap = jiffies + REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tn->free_limit =\n\t\t(1 + nr_cpus_node(node)) * cachep->batchcount + cachep->num;\n\n\t/*\n\t * The kmem_cache_nodes don't come and go as CPUs\n\t * come and go.  slab_mutex is sufficient\n\t * protection here.\n\t */\n\tcachep->node[node] = n;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cachep",
            "&slab_caches",
            "list"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int init_cache_node_node(int node)\n{\n\tint ret;\n\tstruct kmem_cache *cachep;\n\n\tlist_for_each_entry(cachep, &slab_caches, list) {\n\t\tret = init_cache_node(cachep, node, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_cache_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "847-885",
    "snippet": "static int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)\n{\n\tstruct kmem_cache_node *n;\n\n\t/*\n\t * Set up the kmem_cache_node for cpu before we can\n\t * begin anything. Make sure some other cpu on this\n\t * node has not already allocated this\n\t */\n\tn = get_node(cachep, node);\n\tif (n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tn->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +\n\t\t\t\tcachep->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\treturn 0;\n\t}\n\n\tn = kmalloc_node(sizeof(struct kmem_cache_node), gfp, node);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tkmem_cache_node_init(n);\n\tn->next_reap = jiffies + REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tn->free_limit =\n\t\t(1 + nr_cpus_node(node)) * cachep->batchcount + cachep->num;\n\n\t/*\n\t * The kmem_cache_nodes don't come and go as CPUs\n\t * come and go.  slab_mutex is sufficient\n\t * protection here.\n\t */\n\tcachep->node[node] = n;\n\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define REAPTIMEOUT_NODE\t(4*HZ)"
    ],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_cpus_node",
          "args": [
            "node"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_node_init",
          "args": [
            "n"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_node_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "226-239",
          "snippet": "static void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct kmem_cache_node)",
            "gfp",
            "node"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_cpus_node",
          "args": [
            "node"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define REAPTIMEOUT_NODE\t(4*HZ)\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)\n{\n\tstruct kmem_cache_node *n;\n\n\t/*\n\t * Set up the kmem_cache_node for cpu before we can\n\t * begin anything. Make sure some other cpu on this\n\t * node has not already allocated this\n\t */\n\tn = get_node(cachep, node);\n\tif (n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tn->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +\n\t\t\t\tcachep->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\treturn 0;\n\t}\n\n\tn = kmalloc_node(sizeof(struct kmem_cache_node), gfp, node);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tkmem_cache_node_init(n);\n\tn->next_reap = jiffies + REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tn->free_limit =\n\t\t(1 + nr_cpus_node(node)) * cachep->batchcount + cachep->num;\n\n\t/*\n\t * The kmem_cache_nodes don't come and go as CPUs\n\t * come and go.  slab_mutex is sufficient\n\t * protection here.\n\t */\n\tcachep->node[node] = n;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfp_exact_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "841-844",
    "snippet": "static inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn (flags | __GFP_THISNODE | __GFP_NOWARN) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n}"
  },
  {
    "function_name": "cache_free_alien",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "823-835",
    "snippet": "static inline int cache_free_alien(struct kmem_cache *cachep, void *objp)\n{\n\tint page_node = page_to_nid(virt_to_page(objp));\n\tint node = numa_mem_id();\n\t/*\n\t * Make sure we are not freeing a object from another node to the array\n\t * cache on this cpu.\n\t */\n\tif (likely(node == page_node))\n\t\treturn 0;\n\n\treturn __cache_free_alien(cachep, objp, node, page_node);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cache_free_alien",
          "args": [
            "cachep",
            "objp",
            "node",
            "page_node"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "__cache_free_alien",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "792-821",
          "snippet": "static int __cache_free_alien(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint node, int page_node)\n{\n\tstruct kmem_cache_node *n;\n\tstruct alien_cache *alien = NULL;\n\tstruct array_cache *ac;\n\tLIST_HEAD(list);\n\n\tn = get_node(cachep, node);\n\tSTATS_INC_NODEFREES(cachep);\n\tif (n->alien && n->alien[page_node]) {\n\t\talien = n->alien[page_node];\n\t\tac = &alien->ac;\n\t\tspin_lock(&alien->lock);\n\t\tif (unlikely(ac->avail == ac->limit)) {\n\t\t\tSTATS_INC_ACOVERFLOW(cachep);\n\t\t\t__drain_alien_cache(cachep, ac, page_node, &list);\n\t\t}\n\t\tac->entry[ac->avail++] = objp;\n\t\tspin_unlock(&alien->lock);\n\t\tslabs_destroy(cachep, &list);\n\t} else {\n\t\tn = get_node(cachep, page_node);\n\t\tspin_lock(&n->list_lock);\n\t\tfree_block(cachep, &objp, 1, page_node, &list);\n\t\tspin_unlock(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int __cache_free_alien(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint node, int page_node)\n{\n\tstruct kmem_cache_node *n;\n\tstruct alien_cache *alien = NULL;\n\tstruct array_cache *ac;\n\tLIST_HEAD(list);\n\n\tn = get_node(cachep, node);\n\tSTATS_INC_NODEFREES(cachep);\n\tif (n->alien && n->alien[page_node]) {\n\t\talien = n->alien[page_node];\n\t\tac = &alien->ac;\n\t\tspin_lock(&alien->lock);\n\t\tif (unlikely(ac->avail == ac->limit)) {\n\t\t\tSTATS_INC_ACOVERFLOW(cachep);\n\t\t\t__drain_alien_cache(cachep, ac, page_node, &list);\n\t\t}\n\t\tac->entry[ac->avail++] = objp;\n\t\tspin_unlock(&alien->lock);\n\t\tslabs_destroy(cachep, &list);\n\t} else {\n\t\tn = get_node(cachep, page_node);\n\t\tspin_lock(&n->list_lock);\n\t\tfree_block(cachep, &objp, 1, page_node, &list);\n\t\tspin_unlock(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "node == page_node"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "virt_to_page(objp)"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "objp"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline int cache_free_alien(struct kmem_cache *cachep, void *objp)\n{\n\tint page_node = page_to_nid(virt_to_page(objp));\n\tint node = numa_mem_id();\n\t/*\n\t * Make sure we are not freeing a object from another node to the array\n\t * cache on this cpu.\n\t */\n\tif (likely(node == page_node))\n\t\treturn 0;\n\n\treturn __cache_free_alien(cachep, objp, node, page_node);\n}"
  },
  {
    "function_name": "__cache_free_alien",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "792-821",
    "snippet": "static int __cache_free_alien(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint node, int page_node)\n{\n\tstruct kmem_cache_node *n;\n\tstruct alien_cache *alien = NULL;\n\tstruct array_cache *ac;\n\tLIST_HEAD(list);\n\n\tn = get_node(cachep, node);\n\tSTATS_INC_NODEFREES(cachep);\n\tif (n->alien && n->alien[page_node]) {\n\t\talien = n->alien[page_node];\n\t\tac = &alien->ac;\n\t\tspin_lock(&alien->lock);\n\t\tif (unlikely(ac->avail == ac->limit)) {\n\t\t\tSTATS_INC_ACOVERFLOW(cachep);\n\t\t\t__drain_alien_cache(cachep, ac, page_node, &list);\n\t\t}\n\t\tac->entry[ac->avail++] = objp;\n\t\tspin_unlock(&alien->lock);\n\t\tslabs_destroy(cachep, &list);\n\t} else {\n\t\tn = get_node(cachep, page_node);\n\t\tspin_lock(&n->list_lock);\n\t\tfree_block(cachep, &objp, 1, page_node, &list);\n\t\tspin_unlock(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "&objp",
            "1",
            "page_node",
            "&list"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "page_node"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&alien->lock"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__drain_alien_cache",
          "args": [
            "cachep",
            "ac",
            "page_node",
            "&list"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "__drain_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "724-744",
          "snippet": "static void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATS_INC_ACOVERFLOW",
          "args": [
            "cachep"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ac->avail == ac->limit"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&alien->lock"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATS_INC_NODEFREES",
          "args": [
            "cachep"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic int __cache_free_alien(struct kmem_cache *cachep, void *objp,\n\t\t\t\tint node, int page_node)\n{\n\tstruct kmem_cache_node *n;\n\tstruct alien_cache *alien = NULL;\n\tstruct array_cache *ac;\n\tLIST_HEAD(list);\n\n\tn = get_node(cachep, node);\n\tSTATS_INC_NODEFREES(cachep);\n\tif (n->alien && n->alien[page_node]) {\n\t\talien = n->alien[page_node];\n\t\tac = &alien->ac;\n\t\tspin_lock(&alien->lock);\n\t\tif (unlikely(ac->avail == ac->limit)) {\n\t\t\tSTATS_INC_ACOVERFLOW(cachep);\n\t\t\t__drain_alien_cache(cachep, ac, page_node, &list);\n\t\t}\n\t\tac->entry[ac->avail++] = objp;\n\t\tspin_unlock(&alien->lock);\n\t\tslabs_destroy(cachep, &list);\n\t} else {\n\t\tn = get_node(cachep, page_node);\n\t\tspin_lock(&n->list_lock);\n\t\tfree_block(cachep, &objp, 1, page_node, &list);\n\t\tspin_unlock(&n->list_lock);\n\t\tslabs_destroy(cachep, &list);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "drain_alien_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "770-790",
    "snippet": "static void drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct alien_cache **alien)\n{\n\tint i = 0;\n\tstruct alien_cache *alc;\n\tstruct array_cache *ac;\n\tunsigned long flags;\n\n\tfor_each_online_node(i) {\n\t\talc = alien[i];\n\t\tif (alc) {\n\t\t\tLIST_HEAD(list);\n\n\t\t\tac = &alc->ac;\n\t\t\tspin_lock_irqsave(&alc->lock, flags);\n\t\t\t__drain_alien_cache(cachep, ac, i, &list);\n\t\t\tspin_unlock_irqrestore(&alc->lock, flags);\n\t\t\tslabs_destroy(cachep, &list);\n\t\t}\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&alc->lock",
            "flags"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__drain_alien_cache",
          "args": [
            "cachep",
            "ac",
            "i",
            "&list"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "__drain_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "724-744",
          "snippet": "static void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&alc->lock",
            "flags"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct alien_cache **alien)\n{\n\tint i = 0;\n\tstruct alien_cache *alc;\n\tstruct array_cache *ac;\n\tunsigned long flags;\n\n\tfor_each_online_node(i) {\n\t\talc = alien[i];\n\t\tif (alc) {\n\t\t\tLIST_HEAD(list);\n\n\t\t\tac = &alc->ac;\n\t\t\tspin_lock_irqsave(&alc->lock, flags);\n\t\t\t__drain_alien_cache(cachep, ac, i, &list);\n\t\t\tspin_unlock_irqrestore(&alc->lock, flags);\n\t\t\tslabs_destroy(cachep, &list);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "reap_alien",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "749-768",
    "snippet": "static void reap_alien(struct kmem_cache *cachep, struct kmem_cache_node *n)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tif (n->alien) {\n\t\tstruct alien_cache *alc = n->alien[node];\n\t\tstruct array_cache *ac;\n\n\t\tif (alc) {\n\t\t\tac = &alc->ac;\n\t\t\tif (ac->avail && spin_trylock_irq(&alc->lock)) {\n\t\t\t\tLIST_HEAD(list);\n\n\t\t\t\t__drain_alien_cache(cachep, ac, node, &list);\n\t\t\t\tspin_unlock_irq(&alc->lock);\n\t\t\t\tslabs_destroy(cachep, &list);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&alc->lock"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__drain_alien_cache",
          "args": [
            "cachep",
            "ac",
            "node",
            "&list"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__drain_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "724-744",
          "snippet": "static void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_irq",
          "args": [
            "&alc->lock"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "slab_reap_node"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void reap_alien(struct kmem_cache *cachep, struct kmem_cache_node *n)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tif (n->alien) {\n\t\tstruct alien_cache *alc = n->alien[node];\n\t\tstruct array_cache *ac;\n\n\t\tif (alc) {\n\t\t\tac = &alc->ac;\n\t\t\tif (ac->avail && spin_trylock_irq(&alc->lock)) {\n\t\t\t\tLIST_HEAD(list);\n\n\t\t\t\t__drain_alien_cache(cachep, ac, node, &list);\n\t\t\t\tspin_unlock_irq(&alc->lock);\n\t\t\t\tslabs_destroy(cachep, &list);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__drain_alien_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "724-744",
    "snippet": "static void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "ac->entry",
            "ac->avail",
            "node",
            "list"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "transfer_objects",
          "args": [
            "n->shared",
            "ac",
            "ac->limit"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "transfer_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "616-631",
          "snippet": "static int transfer_objects(struct array_cache *to,\n\t\tstruct array_cache *from, unsigned int max)\n{\n\t/* Figure out how many entries to transfer */\n\tint nr = min3(from->avail, max, to->limit - to->avail);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tmemcpy(to->entry + to->avail, from->entry + from->avail -nr,\n\t\t\tsizeof(void *) *nr);\n\n\tfrom->avail -= nr;\n\tto->avail += nr;\n\treturn nr;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int transfer_objects(struct array_cache *to,\n\t\tstruct array_cache *from, unsigned int max)\n{\n\t/* Figure out how many entries to transfer */\n\tint nr = min3(from->avail, max, to->limit - to->avail);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tmemcpy(to->entry + to->avail, from->entry + from->avail -nr,\n\t\t\tsizeof(void *) *nr);\n\n\tfrom->avail -= nr;\n\tto->avail += nr;\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "node"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void __drain_alien_cache(struct kmem_cache *cachep,\n\t\t\t\tstruct array_cache *ac, int node,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\n\tif (ac->avail) {\n\t\tspin_lock(&n->list_lock);\n\t\t/*\n\t\t * Stuff objects into the remote nodes shared array first.\n\t\t * That way we could avoid the overhead of putting the objects\n\t\t * into the free lists and getting them back later.\n\t\t */\n\t\tif (n->shared)\n\t\t\ttransfer_objects(n->shared, ac, ac->limit);\n\n\t\tfree_block(cachep, ac->entry, ac->avail, node, list);\n\t\tac->avail = 0;\n\t\tspin_unlock(&n->list_lock);\n\t}\n}"
  },
  {
    "function_name": "free_alien_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "713-722",
    "snippet": "static void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "alc_ptr"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3802-3819",
          "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void free_alien_cache(struct alien_cache **alc_ptr)\n{\n\tint i;\n\n\tif (!alc_ptr)\n\t\treturn;\n\tfor_each_node(i)\n\t    kfree(alc_ptr[i]);\n\tkfree(alc_ptr);\n}"
  },
  {
    "function_name": "alloc_alien_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "687-711",
    "snippet": "static struct alien_cache **alloc_alien_cache(int node, int limit, gfp_t gfp)\n{\n\tstruct alien_cache **alc_ptr;\n\tsize_t memsize = sizeof(void *) * nr_node_ids;\n\tint i;\n\n\tif (limit > 1)\n\t\tlimit = 12;\n\talc_ptr = kzalloc_node(memsize, gfp, node);\n\tif (!alc_ptr)\n\t\treturn NULL;\n\n\tfor_each_node(i) {\n\t\tif (i == node || !node_online(i))\n\t\t\tcontinue;\n\t\talc_ptr[i] = __alloc_alien_cache(node, limit, 0xbaadf00d, gfp);\n\t\tif (!alc_ptr[i]) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tkfree(alc_ptr[i]);\n\t\t\tkfree(alc_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn alc_ptr;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "alc_ptr"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3802-3819",
          "snippet": "void kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kfree(const void *objp)\n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, c->object_size);\n\n\tdebug_check_no_obj_freed(objp, c->object_size);\n\t__cache_free(c, (void *)objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_alien_cache",
          "args": [
            "node",
            "limit",
            "0xbaadf00d",
            "gfp"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_alien_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "675-685",
          "snippet": "static struct alien_cache *__alloc_alien_cache(int node, int entries,\n\t\t\t\t\t\tint batch, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct alien_cache);\n\tstruct alien_cache *alc = NULL;\n\n\talc = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(&alc->ac, entries, batch);\n\tspin_lock_init(&alc->lock);\n\treturn alc;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct alien_cache *__alloc_alien_cache(int node, int entries,\n\t\t\t\t\t\tint batch, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct alien_cache);\n\tstruct alien_cache *alc = NULL;\n\n\talc = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(&alc->ac, entries, batch);\n\tspin_lock_init(&alc->lock);\n\treturn alc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "i"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "memsize",
            "gfp",
            "node"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct alien_cache **alloc_alien_cache(int node, int limit, gfp_t gfp)\n{\n\tstruct alien_cache **alc_ptr;\n\tsize_t memsize = sizeof(void *) * nr_node_ids;\n\tint i;\n\n\tif (limit > 1)\n\t\tlimit = 12;\n\talc_ptr = kzalloc_node(memsize, gfp, node);\n\tif (!alc_ptr)\n\t\treturn NULL;\n\n\tfor_each_node(i) {\n\t\tif (i == node || !node_online(i))\n\t\t\tcontinue;\n\t\talc_ptr[i] = __alloc_alien_cache(node, limit, 0xbaadf00d, gfp);\n\t\tif (!alc_ptr[i]) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tkfree(alc_ptr[i]);\n\t\t\tkfree(alc_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn alc_ptr;\n}"
  },
  {
    "function_name": "__alloc_alien_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "675-685",
    "snippet": "static struct alien_cache *__alloc_alien_cache(int node, int entries,\n\t\t\t\t\t\tint batch, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct alien_cache);\n\tstruct alien_cache *alc = NULL;\n\n\talc = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(&alc->ac, entries, batch);\n\tspin_lock_init(&alc->lock);\n\treturn alc;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&alc->lock"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_arraycache",
          "args": [
            "&alc->ac",
            "entries",
            "batch"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "init_arraycache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "564-580",
          "snippet": "static void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "memsize",
            "gfp",
            "node"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct alien_cache *__alloc_alien_cache(int node, int entries,\n\t\t\t\t\t\tint batch, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct alien_cache);\n\tstruct alien_cache *alc = NULL;\n\n\talc = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(&alc->ac, entries, batch);\n\tspin_lock_init(&alc->lock);\n\treturn alc;\n}"
  },
  {
    "function_name": "gfp_exact_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "665-668",
    "snippet": "static inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn flags & ~__GFP_NOFAIL;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic inline gfp_t gfp_exact_node(gfp_t flags)\n{\n\treturn flags & ~__GFP_NOFAIL;\n}"
  },
  {
    "function_name": "____cache_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "659-663",
    "snippet": "static inline void *____cache_alloc_node(struct kmem_cache *cachep,\n\t\t gfp_t flags, int nodeid)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *____cache_alloc_node(struct kmem_cache *cachep,\n\t\t gfp_t flags, int nodeid)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "alternate_node_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "653-657",
    "snippet": "static inline void *alternate_node_alloc(struct kmem_cache *cachep,\n\t\tgfp_t flags)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *alternate_node_alloc(struct kmem_cache *cachep,\n\t\tgfp_t flags)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "cache_free_alien",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "648-651",
    "snippet": "static inline int cache_free_alien(struct kmem_cache *cachep, void *objp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline int cache_free_alien(struct kmem_cache *cachep, void *objp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "free_alien_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "644-646",
    "snippet": "static inline void free_alien_cache(struct alien_cache **ac_ptr)\n{\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void free_alien_cache(struct alien_cache **ac_ptr)\n{\n}"
  },
  {
    "function_name": "alloc_alien_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "638-642",
    "snippet": "static inline struct alien_cache **alloc_alien_cache(int node,\n\t\t\t\t\t\tint limit, gfp_t gfp)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic inline struct alien_cache **alloc_alien_cache(int node,\n\t\t\t\t\t\tint limit, gfp_t gfp)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "transfer_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "616-631",
    "snippet": "static int transfer_objects(struct array_cache *to,\n\t\tstruct array_cache *from, unsigned int max)\n{\n\t/* Figure out how many entries to transfer */\n\tint nr = min3(from->avail, max, to->limit - to->avail);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tmemcpy(to->entry + to->avail, from->entry + from->avail -nr,\n\t\t\tsizeof(void *) *nr);\n\n\tfrom->avail -= nr;\n\tto->avail += nr;\n\treturn nr;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to->entry + to->avail",
            "from->entry + from->avail -nr",
            "sizeof(void *) *nr"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min3",
          "args": [
            "from->avail",
            "max",
            "to->limit - to->avail"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int transfer_objects(struct array_cache *to,\n\t\tstruct array_cache *from, unsigned int max)\n{\n\t/* Figure out how many entries to transfer */\n\tint nr = min3(from->avail, max, to->limit - to->avail);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tmemcpy(to->entry + to->avail, from->entry + from->avail -nr,\n\t\t\tsizeof(void *) *nr);\n\n\tfrom->avail -= nr;\n\tto->avail += nr;\n\treturn nr;\n}"
  },
  {
    "function_name": "cache_free_pfmemalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "593-608",
    "snippet": "static noinline void cache_free_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\t\tstruct page *page, void *objp)\n{\n\tstruct kmem_cache_node *n;\n\tint page_node;\n\tLIST_HEAD(list);\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\tspin_lock(&n->list_lock);\n\tfree_block(cachep, &objp, 1, page_node, &list);\n\tspin_unlock(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
      "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
      "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
      "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_destroy",
          "args": [
            "cachep",
            "&list"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1720-1728",
          "snippet": "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list)\n{\n\tstruct page *page, *n;\n\n\tlist_for_each_entry_safe(page, n, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tslab_destroy(cachep, page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_block",
          "args": [
            "cachep",
            "&objp",
            "1",
            "page_node",
            "&list"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3400-3442",
          "snippet": "static void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);",
            "static void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);",
            "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);",
            "static inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp,\n\t\t\tint nr_objects, int node, struct list_head *list)\n{\n\tint i;\n\tstruct kmem_cache_node *n = get_node(cachep, node);\n\tstruct page *page;\n\n\tn->free_objects += nr_objects;\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tvoid *objp;\n\t\tstruct page *page;\n\n\t\tobjp = objpp[i];\n\n\t\tpage = virt_to_head_page(objp);\n\t\tlist_del(&page->lru);\n\t\tcheck_spinlock_acquired_node(cachep, node);\n\t\tslab_put_obj(cachep, page, objp);\n\t\tSTATS_DEC_ACTIVE(cachep);\n\n\t\t/* fixup slab chains */\n\t\tif (page->active == 0) {\n\t\t\tlist_add(&page->lru, &n->slabs_free);\n\t\t\tn->free_slabs++;\n\t\t} else {\n\t\t\t/* Unconditionally move a slab to the end of the\n\t\t\t * partial list on free - maximum time for the\n\t\t\t * other objects to be freed, too.\n\t\t\t */\n\t\t\tlist_add_tail(&page->lru, &n->slabs_partial);\n\t\t}\n\t}\n\n\twhile (n->free_objects > n->free_limit && !list_empty(&n->slabs_free)) {\n\t\tn->free_objects -= cachep->num;\n\n\t\tpage = list_last_entry(&n->slabs_free, struct page, lru);\n\t\tlist_move(&page->lru, list);\n\t\tn->free_slabs--;\n\t\tn->total_slabs--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "cachep",
            "page_node"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void free_block(struct kmem_cache *cachep, void **objpp, int len,\n\t\t\tint node, struct list_head *list);\nstatic void slabs_destroy(struct kmem_cache *cachep, struct list_head *list);\nstatic inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list);\nstatic inline void fixup_slab_list(struct kmem_cache *cachep,\n\t\t\t\tstruct kmem_cache_node *n, struct page *page,\n\t\t\t\tvoid **list);\nstatic noinline struct;\n\nstatic noinline void cache_free_pfmemalloc(struct kmem_cache *cachep,\n\t\t\t\t\tstruct page *page, void *objp)\n{\n\tstruct kmem_cache_node *n;\n\tint page_node;\n\tLIST_HEAD(list);\n\n\tpage_node = page_to_nid(page);\n\tn = get_node(cachep, page_node);\n\n\tspin_lock(&n->list_lock);\n\tfree_block(cachep, &objp, 1, page_node, &list);\n\tspin_unlock(&n->list_lock);\n\n\tslabs_destroy(cachep, &list);\n}"
  },
  {
    "function_name": "alloc_arraycache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "582-591",
    "snippet": "static struct array_cache *alloc_arraycache(int node, int entries,\n\t\t\t\t\t    int batchcount, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tstruct array_cache *ac = NULL;\n\n\tac = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(ac, entries, batchcount);\n\treturn ac;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_arraycache",
          "args": [
            "ac",
            "entries",
            "batchcount"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "init_arraycache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "564-580",
          "snippet": "static void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "memsize",
            "gfp",
            "node"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nstatic struct array_cache *alloc_arraycache(int node, int entries,\n\t\t\t\t\t    int batchcount, gfp_t gfp)\n{\n\tsize_t memsize = sizeof(void *) * entries + sizeof(struct array_cache);\n\tstruct array_cache *ac = NULL;\n\n\tac = kmalloc_node(memsize, gfp, node);\n\tinit_arraycache(ac, entries, batchcount);\n\treturn ac;\n}"
  },
  {
    "function_name": "init_arraycache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "564-580",
    "snippet": "static void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_no_scan",
          "args": [
            "ac"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_no_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1200-1208",
          "snippet": "void __ref kmemleak_no_scan(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tobject_no_scan((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NO_SCAN, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_no_scan(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tobject_no_scan((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NO_SCAN, ptr, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void init_arraycache(struct array_cache *ac, int limit, int batch)\n{\n\t/*\n\t * The array_cache structures contain pointers to free object.\n\t * However, when such objects are allocated or transferred to another\n\t * cache the pointers are not cleared and they could be counted as\n\t * valid references during a kmemleak scan. Therefore, kmemleak must\n\t * not scan such objects.\n\t */\n\tkmemleak_no_scan(ac);\n\tif (ac) {\n\t\tac->avail = 0;\n\t\tac->limit = limit;\n\t\tac->batchcount = batch;\n\t\tac->touched = 0;\n\t}\n}"
  },
  {
    "function_name": "start_cpu_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "552-562",
    "snippet": "static void start_cpu_timer(int cpu)\n{\n\tstruct delayed_work *reap_work = &per_cpu(slab_reap_work, cpu);\n\n\tif (reap_work->work.func == NULL) {\n\t\tinit_reap_node(cpu);\n\t\tINIT_DEFERRABLE_WORK(reap_work, cache_reap);\n\t\tschedule_delayed_work_on(cpu, reap_work,\n\t\t\t\t\t__round_jiffies_relative(HZ, cpu));\n\t}\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct delayed_work, slab_reap_work);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work_on",
          "args": [
            "cpu",
            "reap_work",
            "__round_jiffies_relative(HZ, cpu)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__round_jiffies_relative",
          "args": [
            "HZ",
            "cpu"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DEFERRABLE_WORK",
          "args": [
            "reap_work",
            "cache_reap"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_reap_node",
          "args": [
            "cpu"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "init_reap_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "526-530",
          "snippet": "static void init_reap_node(int cpu)\n{\n\tper_cpu(slab_reap_node, cpu) = next_node_in(cpu_to_mem(cpu),\n\t\t\t\t\t\t    node_online_map);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void init_reap_node(int cpu)\n{\n\tper_cpu(slab_reap_node, cpu) = next_node_in(cpu_to_mem(cpu),\n\t\t\t\t\t\t    node_online_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "slab_reap_work",
            "cpu"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic DEFINE_PER_CPU(struct delayed_work, slab_reap_work);\nstatic noinline struct;\n\nstatic void start_cpu_timer(int cpu)\n{\n\tstruct delayed_work *reap_work = &per_cpu(slab_reap_work, cpu);\n\n\tif (reap_work->work.func == NULL) {\n\t\tinit_reap_node(cpu);\n\t\tINIT_DEFERRABLE_WORK(reap_work, cache_reap);\n\t\tschedule_delayed_work_on(cpu, reap_work,\n\t\t\t\t\t__round_jiffies_relative(HZ, cpu));\n\t}\n}"
  },
  {
    "function_name": "next_reap_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "532-538",
    "snippet": "static void next_reap_node(void)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tnode = next_node_in(node, node_online_map);\n\t__this_cpu_write(slab_reap_node, node);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "slab_reap_node",
            "node"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_node_in",
          "args": [
            "node",
            "node_online_map"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "slab_reap_node"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void next_reap_node(void)\n{\n\tint node = __this_cpu_read(slab_reap_node);\n\n\tnode = next_node_in(node, node_online_map);\n\t__this_cpu_write(slab_reap_node, node);\n}"
  },
  {
    "function_name": "init_reap_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "526-530",
    "snippet": "static void init_reap_node(int cpu)\n{\n\tper_cpu(slab_reap_node, cpu) = next_node_in(cpu_to_mem(cpu),\n\t\t\t\t\t\t    node_online_map);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_node_in",
          "args": [
            "cpu_to_mem(cpu)",
            "node_online_map"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_mem",
          "args": [
            "cpu"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "slab_reap_node",
            "cpu"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic void init_reap_node(int cpu)\n{\n\tper_cpu(slab_reap_node, cpu) = next_node_in(cpu_to_mem(cpu),\n\t\t\t\t\t\t    node_online_map);\n}"
  },
  {
    "function_name": "slab_max_order_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "506-514",
    "snippet": "static int __init slab_max_order_setup(char *str)\n{\n\tget_option(&str, &slab_max_order);\n\tslab_max_order = slab_max_order < 0 ? 0 :\n\t\t\t\tmin(slab_max_order, MAX_ORDER - 1);\n\tslab_max_order_set = true;\n\n\treturn 1;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int slab_max_order = SLAB_MAX_ORDER_LO;",
      "static bool slab_max_order_set"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "slab_max_order",
            "MAX_ORDER - 1"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&slab_max_order"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int slab_max_order = SLAB_MAX_ORDER_LO;\nstatic bool slab_max_order_set;\n\nstatic int __init slab_max_order_setup(char *str)\n{\n\tget_option(&str, &slab_max_order);\n\tslab_max_order = slab_max_order < 0 ? 0 :\n\t\t\t\tmin(slab_max_order, MAX_ORDER - 1);\n\tslab_max_order_set = true;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "noaliencache_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "499-503",
    "snippet": "static int __init noaliencache_setup(char *s)\n{\n\tuse_alien_caches = 0;\n\treturn 1;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int use_alien_caches"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic int use_alien_caches;\n\nstatic int __init noaliencache_setup(char *s)\n{\n\tuse_alien_caches = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__slab_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "480-487",
    "snippet": "static void __slab_error(const char *function, struct kmem_cache *cachep,\n\t\t\tchar *msg)\n{\n\tpr_err(\"slab error in %s(): cache `%s': %s\\n\",\n\t       function, cachep->name, msg);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_BAD_PAGE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"slab error in %s(): cache `%s': %s\\n\"",
            "function",
            "cachep->name",
            "msg"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void __slab_error(const char *function, struct kmem_cache *cachep,\n\t\t\tchar *msg)\n{\n\tpr_err(\"slab error in %s(): cache `%s': %s\\n\",\n\t       function, cachep->name, msg);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
  },
  {
    "function_name": "cache_estimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "442-475",
    "snippet": "static unsigned int cache_estimate(unsigned long gfporder, size_t buffer_size,\n\t\tslab_flags_t flags, size_t *left_over)\n{\n\tunsigned int num;\n\tsize_t slab_size = PAGE_SIZE << gfporder;\n\n\t/*\n\t * The slab management structure can be either off the slab or\n\t * on it. For the latter case, the memory allocated for a\n\t * slab is used for:\n\t *\n\t * - @buffer_size bytes for each object\n\t * - One freelist_idx_t for each object\n\t *\n\t * We don't need to consider alignment of freelist because\n\t * freelist will be at the end of slab page. The objects will be\n\t * at the correct alignment.\n\t *\n\t * If the slab management structure is off the slab, then the\n\t * alignment will already be calculated into the size. Because\n\t * the slabs are all pages aligned, the objects will be at the\n\t * correct alignment when allocated.\n\t */\n\tif (flags & (CFLGS_OBJFREELIST_SLAB | CFLGS_OFF_SLAB)) {\n\t\tnum = slab_size / buffer_size;\n\t\t*left_over = slab_size % buffer_size;\n\t} else {\n\t\tnum = slab_size / (buffer_size + sizeof(freelist_idx_t));\n\t\t*left_over = slab_size %\n\t\t\t(buffer_size + sizeof(freelist_idx_t));\n\t}\n\n\treturn num;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
      "#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)\n\nstatic unsigned int cache_estimate(unsigned long gfporder, size_t buffer_size,\n\t\tslab_flags_t flags, size_t *left_over)\n{\n\tunsigned int num;\n\tsize_t slab_size = PAGE_SIZE << gfporder;\n\n\t/*\n\t * The slab management structure can be either off the slab or\n\t * on it. For the latter case, the memory allocated for a\n\t * slab is used for:\n\t *\n\t * - @buffer_size bytes for each object\n\t * - One freelist_idx_t for each object\n\t *\n\t * We don't need to consider alignment of freelist because\n\t * freelist will be at the end of slab page. The objects will be\n\t * at the correct alignment.\n\t *\n\t * If the slab management structure is off the slab, then the\n\t * alignment will already be calculated into the size. Because\n\t * the slabs are all pages aligned, the objects will be at the\n\t * correct alignment when allocated.\n\t */\n\tif (flags & (CFLGS_OBJFREELIST_SLAB | CFLGS_OFF_SLAB)) {\n\t\tnum = slab_size / buffer_size;\n\t\t*left_over = slab_size % buffer_size;\n\t} else {\n\t\tnum = slab_size / (buffer_size + sizeof(freelist_idx_t));\n\t\t*left_over = slab_size %\n\t\t\t(buffer_size + sizeof(freelist_idx_t));\n\t}\n\n\treturn num;\n}"
  },
  {
    "function_name": "cpu_cache_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "434-437",
    "snippet": "static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "cachep->cpu_cache"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)\n{\n\treturn this_cpu_ptr(cachep->cpu_cache);\n}"
  },
  {
    "function_name": "obj_to_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "415-420",
    "snippet": "static inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reciprocal_divide",
          "args": [
            "offset",
            "cache->reciprocal_buffer_size"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int obj_to_index(const struct kmem_cache *cache,\n\t\t\t\t\tconst struct page *page, void *obj)\n{\n\tu32 offset = (obj - page->s_mem);\n\treturn reciprocal_divide(offset, cache->reciprocal_buffer_size);\n}"
  },
  {
    "function_name": "index_to_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "403-407",
    "snippet": "static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void *index_to_obj(struct kmem_cache *cache, struct page *page,\n\t\t\t\t unsigned int idx)\n{\n\treturn page->s_mem + cache->size * idx;\n}"
  },
  {
    "function_name": "virt_to_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "397-401",
    "snippet": "static inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "obj"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline struct kmem_cache *virt_to_cache(const void *obj)\n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page->slab_cache;\n}"
  },
  {
    "function_name": "set_store_user_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "384-384",
    "snippet": "static inline void set_store_user_dirty(struct kmem_cache *cachep) {}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_store_user_dirty(struct kmem_cache *cachep) {}"
  },
  {
    "function_name": "set_store_user_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "377-381",
    "snippet": "static inline void set_store_user_dirty(struct kmem_cache *cachep)\n{\n\tif (is_store_user_clean(cachep))\n\t\tatomic_set(&cachep->store_user_clean, 0);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cachep->store_user_clean",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_store_user_clean",
          "args": [
            "cachep"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "is_store_user_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "367-370",
          "snippet": "static inline bool is_store_user_clean(struct kmem_cache *cachep)\n{\n\treturn atomic_read(&cachep->store_user_clean) == 1;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline bool is_store_user_clean(struct kmem_cache *cachep)\n{\n\treturn atomic_read(&cachep->store_user_clean) == 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_store_user_dirty(struct kmem_cache *cachep)\n{\n\tif (is_store_user_clean(cachep))\n\t\tatomic_set(&cachep->store_user_clean, 0);\n}"
  },
  {
    "function_name": "set_store_user_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "372-375",
    "snippet": "static inline void set_store_user_clean(struct kmem_cache *cachep)\n{\n\tatomic_set(&cachep->store_user_clean, 1);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cachep->store_user_clean",
            "1"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline void set_store_user_clean(struct kmem_cache *cachep)\n{\n\tatomic_set(&cachep->store_user_clean, 1);\n}"
  },
  {
    "function_name": "is_store_user_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "367-370",
    "snippet": "static inline bool is_store_user_clean(struct kmem_cache *cachep)\n{\n\treturn atomic_read(&cachep->store_user_clean) == 1;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cachep->store_user_clean"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic inline bool is_store_user_clean(struct kmem_cache *cachep)\n{\n\treturn atomic_read(&cachep->store_user_clean) == 1;\n}"
  },
  {
    "function_name": "dbg_userword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "350-354",
    "snippet": "static void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tBYTES_PER_WORD\t\tsizeof(void *)"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(cachep->flags & SLAB_STORE_USER)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n\nstatic noinline struct;\n\nstatic void **dbg_userword(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_STORE_USER));\n\treturn (void **)(objp + cachep->size - BYTES_PER_WORD);\n}"
  },
  {
    "function_name": "dbg_redzone2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "339-348",
    "snippet": "static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [
      "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))"
    ],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(cachep->flags & SLAB_RED_ZONE)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\tif (cachep->flags & SLAB_STORE_USER)\n\t\treturn (unsigned long long *)(objp + cachep->size -\n\t\t\t\t\t      sizeof(unsigned long long) -\n\t\t\t\t\t      REDZONE_ALIGN);\n\treturn (unsigned long long *) (objp + cachep->size -\n\t\t\t\t       sizeof(unsigned long long));\n}"
  },
  {
    "function_name": "dbg_redzone1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "332-337",
    "snippet": "static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj_offset",
          "args": [
            "cachep"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "obj_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "327-330",
          "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(cachep->flags & SLAB_RED_ZONE)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)\n{\n\tBUG_ON(!(cachep->flags & SLAB_RED_ZONE));\n\treturn (unsigned long long*) (objp + obj_offset(cachep) -\n\t\t\t\t      sizeof(unsigned long long));\n}"
  },
  {
    "function_name": "obj_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "327-330",
    "snippet": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}"
  },
  {
    "function_name": "kmem_cache_node_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
    "lines": "226-239",
    "snippet": "static void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}",
    "includes": [
      "#include\t\"slab.h\"",
      "#include\t\"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include\t<asm/page.h>",
      "#include\t<asm/tlbflush.h>",
      "#include\t<asm/cacheflush.h>",
      "#include\t<net/sock.h>",
      "#include\t<linux/sched/task_stack.h>",
      "#include\t<linux/prefetch.h>",
      "#include\t<linux/memory.h>",
      "#include\t<linux/debugobjects.h>",
      "#include\t<linux/reciprocal_div.h>",
      "#include\t<linux/rtmutex.h>",
      "#include\t<linux/fault-inject.h>",
      "#include\t<linux/mutex.h>",
      "#include\t<linux/mempolicy.h>",
      "#include\t<linux/kmemleak.h>",
      "#include\t<linux/nodemask.h>",
      "#include\t<linux/uaccess.h>",
      "#include\t<linux/string.h>",
      "#include\t<linux/rcupdate.h>",
      "#include\t<linux/module.h>",
      "#include\t<linux/sysctl.h>",
      "#include\t<linux/cpu.h>",
      "#include\t<linux/kallsyms.h>",
      "#include\t<linux/notifier.h>",
      "#include\t<linux/seq_file.h>",
      "#include\t<linux/proc_fs.h>",
      "#include\t<linux/cpuset.h>",
      "#include\t<linux/compiler.h>",
      "#include\t<linux/init.h>",
      "#include\t<linux/interrupt.h>",
      "#include\t<linux/cache.h>",
      "#include\t<linux/swap.h>",
      "#include\t<linux/poison.h>",
      "#include\t<linux/mm.h>",
      "#include\t<linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&parent->list_lock"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&parent->slabs_free"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&parent->slabs_partial"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&parent->slabs_full"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void kmem_cache_node_init(struct kmem_cache_node *parent)\n{\n\tINIT_LIST_HEAD(&parent->slabs_full);\n\tINIT_LIST_HEAD(&parent->slabs_partial);\n\tINIT_LIST_HEAD(&parent->slabs_free);\n\tparent->total_slabs = 0;\n\tparent->free_slabs = 0;\n\tparent->shared = NULL;\n\tparent->alien = NULL;\n\tparent->colour_next = 0;\n\tspin_lock_init(&parent->list_lock);\n\tparent->free_objects = 0;\n\tparent->free_touched = 0;\n}"
  }
]