[
  {
    "function_name": "kmemleak_late_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "2122-2151",
    "snippet": "static int __init kmemleak_late_init(void)\n{\n\tstruct dentry *dentry;\n\n\tkmemleak_initialized = 1;\n\n\tdentry = debugfs_create_file(\"kmemleak\", 0644, NULL, NULL,\n\t\t\t\t     &kmemleak_fops);\n\tif (!dentry)\n\t\tpr_warn(\"Failed to create the debugfs kmemleak file\\n\");\n\n\tif (kmemleak_error) {\n\t\t/*\n\t\t * Some error occurred and kmemleak was disabled. There is a\n\t\t * small chance that kmemleak_disable() was called immediately\n\t\t * after setting kmemleak_initialized and we may end up with\n\t\t * two clean-up threads but serialized by scan_mutex.\n\t\t */\n\t\tschedule_work(&cleanup_work);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&scan_mutex);\n\tstart_scan_thread();\n\tmutex_unlock(&scan_mutex);\n\n\tpr_info(\"Kernel memory leak detector initialized\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_initialized;",
      "static int kmemleak_error;",
      "static DEFINE_MUTEX(scan_mutex);",
      "static void kmemleak_disable(void);",
      "static const struct file_operations kmemleak_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= kmemleak_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= kmemleak_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Kernel memory leak detector initialized\\n\""
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&scan_mutex"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_scan_thread",
          "args": [],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "start_scan_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1686-1695",
          "snippet": "static void start_scan_thread(void)\n{\n\tif (scan_thread)\n\t\treturn;\n\tscan_thread = kthread_run(kmemleak_scan_thread, NULL, \"kmemleak\");\n\tif (IS_ERR(scan_thread)) {\n\t\tpr_warn(\"Failed to create the scan thread\\n\");\n\t\tscan_thread = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *scan_thread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct task_struct *scan_thread;\n\nstatic void start_scan_thread(void)\n{\n\tif (scan_thread)\n\t\treturn;\n\tscan_thread = kthread_run(kmemleak_scan_thread, NULL, \"kmemleak\");\n\tif (IS_ERR(scan_thread)) {\n\t\tpr_warn(\"Failed to create the scan thread\\n\");\n\t\tscan_thread = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&scan_mutex"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&cleanup_work"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to create the debugfs kmemleak file\\n\""
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"kmemleak\"",
            "0644",
            "NULL",
            "NULL",
            "&kmemleak_fops"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_initialized;\nstatic int kmemleak_error;\nstatic DEFINE_MUTEX(scan_mutex);\nstatic void kmemleak_disable(void);\nstatic const struct file_operations kmemleak_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= kmemleak_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= kmemleak_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int __init kmemleak_late_init(void)\n{\n\tstruct dentry *dentry;\n\n\tkmemleak_initialized = 1;\n\n\tdentry = debugfs_create_file(\"kmemleak\", 0644, NULL, NULL,\n\t\t\t\t     &kmemleak_fops);\n\tif (!dentry)\n\t\tpr_warn(\"Failed to create the debugfs kmemleak file\\n\");\n\n\tif (kmemleak_error) {\n\t\t/*\n\t\t * Some error occurred and kmemleak was disabled. There is a\n\t\t * small chance that kmemleak_disable() was called immediately\n\t\t * after setting kmemleak_initialized and we may end up with\n\t\t * two clean-up threads but serialized by scan_mutex.\n\t\t */\n\t\tschedule_work(&cleanup_work);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&scan_mutex);\n\tstart_scan_thread();\n\tmutex_unlock(&scan_mutex);\n\n\tpr_info(\"Kernel memory leak detector initialized\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kmemleak_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "2032-2117",
    "snippet": "void __init kmemleak_init(void)\n{\n\tint i;\n\tunsigned long flags;\n\n#ifdef CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF\n\tif (!kmemleak_skip_disable) {\n\t\tkmemleak_early_log = 0;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n#endif\n\n\tjiffies_min_age = msecs_to_jiffies(MSECS_MIN_AGE);\n\tjiffies_scan_wait = msecs_to_jiffies(SECS_SCAN_WAIT * 1000);\n\n\tobject_cache = KMEM_CACHE(kmemleak_object, SLAB_NOLEAKTRACE);\n\tscan_area_cache = KMEM_CACHE(kmemleak_scan_area, SLAB_NOLEAKTRACE);\n\n\tif (crt_early_log > ARRAY_SIZE(early_log))\n\t\tpr_warn(\"Early log buffer exceeded (%d), please increase DEBUG_KMEMLEAK_EARLY_LOG_SIZE\\n\",\n\t\t\tcrt_early_log);\n\n\t/* the kernel is still in UP mode, so disabling the IRQs is enough */\n\tlocal_irq_save(flags);\n\tkmemleak_early_log = 0;\n\tif (kmemleak_error) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t} else {\n\t\tkmemleak_enabled = 1;\n\t\tkmemleak_free_enabled = 1;\n\t}\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This is the point where tracking allocations is safe. Automatic\n\t * scanning is started during the late initcall. Add the early logged\n\t * callbacks to the kmemleak infrastructure.\n\t */\n\tfor (i = 0; i < crt_early_log; i++) {\n\t\tstruct early_log *log = &early_log[i];\n\n\t\tswitch (log->op_type) {\n\t\tcase KMEMLEAK_ALLOC:\n\t\t\tearly_alloc(log);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_ALLOC_PERCPU:\n\t\t\tearly_alloc_percpu(log);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_FREE:\n\t\t\tkmemleak_free(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_FREE_PART:\n\t\t\tkmemleak_free_part(log->ptr, log->size);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_FREE_PERCPU:\n\t\t\tkmemleak_free_percpu(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_NOT_LEAK:\n\t\t\tkmemleak_not_leak(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_IGNORE:\n\t\t\tkmemleak_ignore(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_SCAN_AREA:\n\t\t\tkmemleak_scan_area(log->ptr, log->size, GFP_KERNEL);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_NO_SCAN:\n\t\t\tkmemleak_no_scan(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_SET_EXCESS_REF:\n\t\t\tobject_set_excess_ref((unsigned long)log->ptr,\n\t\t\t\t\t      log->excess_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkmemleak_warn(\"Unknown early log operation: %d\\n\",\n\t\t\t\t      log->op_type);\n\t\t}\n\n\t\tif (kmemleak_warning) {\n\t\t\tprint_log_trace(log);\n\t\t\tkmemleak_warning = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SECS_SCAN_WAIT\t\t600\t/* subsequent auto scanning delay */",
      "#define MSECS_MIN_AGE\t\t5000\t/* minimum object age for reporting */"
    ],
    "globals_used": [
      "static struct kmem_cache *object_cache;",
      "static struct kmem_cache *scan_area_cache;",
      "static int kmemleak_enabled;",
      "static int kmemleak_free_enabled;",
      "static int kmemleak_early_log = 1;",
      "static int kmemleak_warning;",
      "static int kmemleak_error;",
      "static unsigned long jiffies_min_age;",
      "static signed long jiffies_scan_wait;",
      "static int kmemleak_skip_disable;",
      "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
      "static int crt_early_log",
      "static void kmemleak_disable(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_log_trace",
          "args": [
            "log"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "print_log_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "2018-2027",
          "snippet": "static void __init print_log_trace(struct early_log *log)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = log->trace_len;\n\ttrace.entries = log->trace;\n\n\tpr_notice(\"Early log backtrace:\\n\");\n\tprint_stack_trace(&trace, 2);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void __init print_log_trace(struct early_log *log)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = log->trace_len;\n\ttrace.entries = log->trace;\n\n\tpr_notice(\"Early log backtrace:\\n\");\n\tprint_stack_trace(&trace, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Unknown early log operation: %d\\n\"",
            "log->op_type"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_set_excess_ref",
          "args": [
            "(unsigned long)log->ptr",
            "log->excess_ref"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "object_set_excess_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "832-848",
          "snippet": "static void object_set_excess_ref(unsigned long ptr, unsigned long excess_ref)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Setting excess_ref on unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->excess_ref = excess_ref;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void object_set_excess_ref(unsigned long ptr, unsigned long excess_ref)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Setting excess_ref on unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->excess_ref = excess_ref;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_no_scan",
          "args": [
            "log->ptr"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_no_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1200-1208",
          "snippet": "void __ref kmemleak_no_scan(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tobject_no_scan((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NO_SCAN, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_no_scan(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tobject_no_scan((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NO_SCAN, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_scan_area",
          "args": [
            "log->ptr",
            "log->size",
            "GFP_KERNEL"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_scan_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1180-1188",
          "snippet": "void __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && size && !IS_ERR(ptr))\n\t\tadd_scan_area((unsigned long)ptr, size, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_SCAN_AREA, ptr, size, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && size && !IS_ERR(ptr))\n\t\tadd_scan_area((unsigned long)ptr, size, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_SCAN_AREA, ptr, size, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_ignore",
          "args": [
            "log->ptr"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_ignore_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1259-1263",
          "snippet": "void __ref kmemleak_ignore_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_ignore(__va(phys));\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_ignore_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_ignore(__va(phys));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_not_leak",
          "args": [
            "log->ptr"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_not_leak_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1247-1251",
          "snippet": "void __ref kmemleak_not_leak_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_not_leak(__va(phys));\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_not_leak_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_not_leak(__va(phys));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free_percpu",
          "args": [
            "log->ptr"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free_part",
          "args": [
            "log->ptr",
            "log->size"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_part_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1235-1239",
          "snippet": "void __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_alloc_percpu",
          "args": [
            "log"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "early_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "941-950",
          "snippet": "static void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Early log buffer exceeded (%d), please increase DEBUG_KMEMLEAK_EARLY_LOG_SIZE\\n\"",
            "crt_early_log"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "early_log"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "kmemleak_scan_area",
            "SLAB_NOLEAKTRACE"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "kmemleak_object",
            "SLAB_NOLEAKTRACE"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "SECS_SCAN_WAIT * 1000"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "MSECS_MIN_AGE"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_disable",
          "args": [],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1983-1999",
          "snippet": "static void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_free_enabled;",
            "static int kmemleak_initialized;",
            "static int kmemleak_error;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_initialized;\nstatic int kmemleak_error;\nstatic void kmemleak_disable(void);\n\nstatic void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define SECS_SCAN_WAIT\t\t600\t/* subsequent auto scanning delay */\n#define MSECS_MIN_AGE\t\t5000\t/* minimum object age for reporting */\n\nstatic struct kmem_cache *object_cache;\nstatic struct kmem_cache *scan_area_cache;\nstatic int kmemleak_enabled;\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\nstatic int kmemleak_warning;\nstatic int kmemleak_error;\nstatic unsigned long jiffies_min_age;\nstatic signed long jiffies_scan_wait;\nstatic int kmemleak_skip_disable;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nvoid __init kmemleak_init(void)\n{\n\tint i;\n\tunsigned long flags;\n\n#ifdef CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF\n\tif (!kmemleak_skip_disable) {\n\t\tkmemleak_early_log = 0;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n#endif\n\n\tjiffies_min_age = msecs_to_jiffies(MSECS_MIN_AGE);\n\tjiffies_scan_wait = msecs_to_jiffies(SECS_SCAN_WAIT * 1000);\n\n\tobject_cache = KMEM_CACHE(kmemleak_object, SLAB_NOLEAKTRACE);\n\tscan_area_cache = KMEM_CACHE(kmemleak_scan_area, SLAB_NOLEAKTRACE);\n\n\tif (crt_early_log > ARRAY_SIZE(early_log))\n\t\tpr_warn(\"Early log buffer exceeded (%d), please increase DEBUG_KMEMLEAK_EARLY_LOG_SIZE\\n\",\n\t\t\tcrt_early_log);\n\n\t/* the kernel is still in UP mode, so disabling the IRQs is enough */\n\tlocal_irq_save(flags);\n\tkmemleak_early_log = 0;\n\tif (kmemleak_error) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t} else {\n\t\tkmemleak_enabled = 1;\n\t\tkmemleak_free_enabled = 1;\n\t}\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This is the point where tracking allocations is safe. Automatic\n\t * scanning is started during the late initcall. Add the early logged\n\t * callbacks to the kmemleak infrastructure.\n\t */\n\tfor (i = 0; i < crt_early_log; i++) {\n\t\tstruct early_log *log = &early_log[i];\n\n\t\tswitch (log->op_type) {\n\t\tcase KMEMLEAK_ALLOC:\n\t\t\tearly_alloc(log);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_ALLOC_PERCPU:\n\t\t\tearly_alloc_percpu(log);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_FREE:\n\t\t\tkmemleak_free(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_FREE_PART:\n\t\t\tkmemleak_free_part(log->ptr, log->size);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_FREE_PERCPU:\n\t\t\tkmemleak_free_percpu(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_NOT_LEAK:\n\t\t\tkmemleak_not_leak(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_IGNORE:\n\t\t\tkmemleak_ignore(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_SCAN_AREA:\n\t\t\tkmemleak_scan_area(log->ptr, log->size, GFP_KERNEL);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_NO_SCAN:\n\t\t\tkmemleak_no_scan(log->ptr);\n\t\t\tbreak;\n\t\tcase KMEMLEAK_SET_EXCESS_REF:\n\t\t\tobject_set_excess_ref((unsigned long)log->ptr,\n\t\t\t\t\t      log->excess_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkmemleak_warn(\"Unknown early log operation: %d\\n\",\n\t\t\t\t      log->op_type);\n\t\t}\n\n\t\tif (kmemleak_warning) {\n\t\t\tprint_log_trace(log);\n\t\t\tkmemleak_warning = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "print_log_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "2018-2027",
    "snippet": "static void __init print_log_trace(struct early_log *log)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = log->trace_len;\n\ttrace.entries = log->trace;\n\n\tpr_notice(\"Early log backtrace:\\n\");\n\tprint_stack_trace(&trace, 2);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "&trace",
            "2"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Early log backtrace:\\n\""
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void __init print_log_trace(struct early_log *log)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = log->trace_len;\n\ttrace.entries = log->trace;\n\n\tpr_notice(\"Early log backtrace:\\n\");\n\tprint_stack_trace(&trace, 2);\n}"
  },
  {
    "function_name": "kmemleak_boot_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "2004-2015",
    "snippet": "static int __init kmemleak_boot_config(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\tif (strcmp(str, \"off\") == 0)\n\t\tkmemleak_disable();\n\telse if (strcmp(str, \"on\") == 0)\n\t\tkmemleak_skip_disable = 1;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_skip_disable;",
      "static void kmemleak_disable(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"on\""
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_disable",
          "args": [],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1983-1999",
          "snippet": "static void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_free_enabled;",
            "static int kmemleak_initialized;",
            "static int kmemleak_error;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_initialized;\nstatic int kmemleak_error;\nstatic void kmemleak_disable(void);\n\nstatic void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"off\""
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_skip_disable;\nstatic void kmemleak_disable(void);\n\nstatic int __init kmemleak_boot_config(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\tif (strcmp(str, \"off\") == 0)\n\t\tkmemleak_disable();\n\telse if (strcmp(str, \"on\") == 0)\n\t\tkmemleak_skip_disable = 1;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "kmemleak_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1983-1999",
    "snippet": "static void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_free_enabled;",
      "static int kmemleak_initialized;",
      "static int kmemleak_error;",
      "static void kmemleak_disable(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Kernel memory leak detector disabled\\n\""
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&cleanup_work"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&kmemleak_error",
            "0",
            "1"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_initialized;\nstatic int kmemleak_error;\nstatic void kmemleak_disable(void);\n\nstatic void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}"
  },
  {
    "function_name": "kmemleak_do_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1957-1975",
    "snippet": "static void kmemleak_do_cleanup(struct work_struct *work)\n{\n\tstop_scan_thread();\n\n\tmutex_lock(&scan_mutex);\n\t/*\n\t * Once it is made sure that kmemleak_scan has stopped, it is safe to no\n\t * longer track object freeing. Ordering of the scan thread stopping and\n\t * the memory accesses below is guaranteed by the kthread_stop()\n\t * function.\n\t */\n\tkmemleak_free_enabled = 0;\n\tmutex_unlock(&scan_mutex);\n\n\tif (!kmemleak_found_leaks)\n\t\t__kmemleak_do_cleanup();\n\telse\n\t\tpr_info(\"Kmemleak disabled without freeing internal data. Reclaim the memory with \\\"echo clear > /sys/kernel/debug/kmemleak\\\".\\n\");\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_free_enabled;",
      "static DEFINE_MUTEX(scan_mutex);",
      "static bool kmemleak_found_leaks;",
      "static void __kmemleak_do_cleanup(void);",
      "static DECLARE_WORK(cleanup_work, kmemleak_do_cleanup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Kmemleak disabled without freeing internal data. Reclaim the memory with \\\"echo clear > /sys/kernel/debug/kmemleak\\\".\\n\""
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmemleak_do_cleanup",
          "args": [],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "__kmemleak_do_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1942-1950",
          "snippet": "static void __kmemleak_do_cleanup(void)\n{\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list)\n\t\tdelete_object_full(object->pointer);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static void __kmemleak_do_cleanup(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\nstatic void __kmemleak_do_cleanup(void);\n\nstatic void __kmemleak_do_cleanup(void)\n{\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list)\n\t\tdelete_object_full(object->pointer);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&scan_mutex"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&scan_mutex"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_scan_thread",
          "args": [],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "stop_scan_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1700-1706",
          "snippet": "static void stop_scan_thread(void)\n{\n\tif (scan_thread) {\n\t\tkthread_stop(scan_thread);\n\t\tscan_thread = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *scan_thread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct task_struct *scan_thread;\n\nstatic void stop_scan_thread(void)\n{\n\tif (scan_thread) {\n\t\tkthread_stop(scan_thread);\n\t\tscan_thread = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic DEFINE_MUTEX(scan_mutex);\nstatic bool kmemleak_found_leaks;\nstatic void __kmemleak_do_cleanup(void);\nstatic DECLARE_WORK(cleanup_work, kmemleak_do_cleanup);\n\nstatic void kmemleak_do_cleanup(struct work_struct *work)\n{\n\tstop_scan_thread();\n\n\tmutex_lock(&scan_mutex);\n\t/*\n\t * Once it is made sure that kmemleak_scan has stopped, it is safe to no\n\t * longer track object freeing. Ordering of the scan thread stopping and\n\t * the memory accesses below is guaranteed by the kthread_stop()\n\t * function.\n\t */\n\tkmemleak_free_enabled = 0;\n\tmutex_unlock(&scan_mutex);\n\n\tif (!kmemleak_found_leaks)\n\t\t__kmemleak_do_cleanup();\n\telse\n\t\tpr_info(\"Kmemleak disabled without freeing internal data. Reclaim the memory with \\\"echo clear > /sys/kernel/debug/kmemleak\\\".\\n\");\n}"
  },
  {
    "function_name": "__kmemleak_do_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1942-1950",
    "snippet": "static void __kmemleak_do_cleanup(void)\n{\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list)\n\t\tdelete_object_full(object->pointer);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(object_list);",
      "static void __kmemleak_do_cleanup(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_object_full",
          "args": [
            "object->pointer"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "delete_object_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "679-692",
          "snippet": "static void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "object",
            "&object_list",
            "object_list"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\nstatic void __kmemleak_do_cleanup(void);\n\nstatic void __kmemleak_do_cleanup(void)\n{\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list)\n\t\tdelete_object_full(object->pointer);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "kmemleak_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1866-1931",
    "snippet": "static ssize_t kmemleak_write(struct file *file, const char __user *user_buf,\n\t\t\t      size_t size, loff_t *ppos)\n{\n\tchar buf[64];\n\tint buf_size;\n\tint ret;\n\n\tbuf_size = min(size, (sizeof(buf) - 1));\n\tif (strncpy_from_user(buf, user_buf, buf_size) < 0)\n\t\treturn -EFAULT;\n\tbuf[buf_size] = 0;\n\n\tret = mutex_lock_interruptible(&scan_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (strncmp(buf, \"clear\", 5) == 0) {\n\t\tif (kmemleak_enabled)\n\t\t\tkmemleak_clear();\n\t\telse\n\t\t\t__kmemleak_do_cleanup();\n\t\tgoto out;\n\t}\n\n\tif (!kmemleak_enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (strncmp(buf, \"off\", 3) == 0)\n\t\tkmemleak_disable();\n\telse if (strncmp(buf, \"stack=on\", 8) == 0)\n\t\tkmemleak_stack_scan = 1;\n\telse if (strncmp(buf, \"stack=off\", 9) == 0)\n\t\tkmemleak_stack_scan = 0;\n\telse if (strncmp(buf, \"scan=on\", 7) == 0)\n\t\tstart_scan_thread();\n\telse if (strncmp(buf, \"scan=off\", 8) == 0)\n\t\tstop_scan_thread();\n\telse if (strncmp(buf, \"scan=\", 5) == 0) {\n\t\tunsigned long secs;\n\n\t\tret = kstrtoul(buf + 5, 0, &secs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tstop_scan_thread();\n\t\tif (secs) {\n\t\t\tjiffies_scan_wait = msecs_to_jiffies(secs * 1000);\n\t\t\tstart_scan_thread();\n\t\t}\n\t} else if (strncmp(buf, \"scan\", 4) == 0)\n\t\tkmemleak_scan();\n\telse if (strncmp(buf, \"dump=\", 5) == 0)\n\t\tret = dump_str_object_info(buf + 5);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\tmutex_unlock(&scan_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* ignore the rest of the buffer, only one command at a time */\n\t*ppos += size;\n\treturn size;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static signed long jiffies_scan_wait;",
      "static int kmemleak_stack_scan = 1;",
      "static DEFINE_MUTEX(scan_mutex);",
      "static void kmemleak_disable(void);",
      "static void __kmemleak_do_cleanup(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&scan_mutex"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_str_object_info",
          "args": [
            "buf + 5"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "dump_str_object_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1802-1822",
          "snippet": "static int dump_str_object_info(const char *str)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tunsigned long addr;\n\n\tif (kstrtoul(str, 0, &addr))\n\t\treturn -EINVAL;\n\tobject = find_and_get_object(addr, 0);\n\tif (!object) {\n\t\tpr_info(\"Unknown object at 0x%08lx\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tdump_object_info(object);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int dump_str_object_info(const char *str)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tunsigned long addr;\n\n\tif (kstrtoul(str, 0, &addr))\n\t\treturn -EINVAL;\n\tobject = find_and_get_object(addr, 0);\n\tif (!object) {\n\t\tpr_info(\"Unknown object at 0x%08lx\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tdump_object_info(object);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"dump=\"",
            "5"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_scan",
          "args": [],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1495-1642",
          "snippet": "static void kmemleak_scan(void)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tint i;\n\tint new_leaks = 0;\n\n\tjiffies_last_scan = jiffies;\n\n\t/* prepare the kmemleak_object's */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n#ifdef DEBUG\n\t\t/*\n\t\t * With a few exceptions there should be a maximum of\n\t\t * 1 reference to any object at this point.\n\t\t */\n\t\tif (atomic_read(&object->use_count) > 1) {\n\t\t\tpr_debug(\"object->use_count = %d\\n\",\n\t\t\t\t atomic_read(&object->use_count));\n\t\t\tdump_object_info(object);\n\t\t}\n#endif\n\t\t/* reset the reference count (whiten the object) */\n\t\tobject->count = 0;\n\t\tif (color_gray(object) && get_object(object))\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/* data/bss scanning */\n\tscan_large_block(_sdata, _edata);\n\tscan_large_block(__bss_start, __bss_stop);\n\tscan_large_block(__start_ro_after_init, __end_ro_after_init);\n\n#ifdef CONFIG_SMP\n\t/* per-cpu sections scanning */\n\tfor_each_possible_cpu(i)\n\t\tscan_large_block(__per_cpu_start + per_cpu_offset(i),\n\t\t\t\t __per_cpu_end + per_cpu_offset(i));\n#endif\n\n\t/*\n\t * Struct page scanning for each node.\n\t */\n\tget_online_mems();\n\tfor_each_online_node(i) {\n\t\tunsigned long start_pfn = node_start_pfn(i);\n\t\tunsigned long end_pfn = node_end_pfn(i);\n\t\tunsigned long pfn;\n\n\t\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\t/* only scan if page is in use */\n\t\t\tif (page_count(page) == 0)\n\t\t\t\tcontinue;\n\t\t\tscan_block(page, page + 1, NULL);\n\t\t\tif (!(pfn & 63))\n\t\t\t\tcond_resched();\n\t\t}\n\t}\n\tput_online_mems();\n\n\t/*\n\t * Scanning the task stacks (may introduce false negatives).\n\t */\n\tif (kmemleak_stack_scan) {\n\t\tstruct task_struct *p, *g;\n\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_thread(g, p) {\n\t\t\tvoid *stack = try_get_task_stack(p);\n\t\t\tif (stack) {\n\t\t\t\tscan_block(stack, stack + THREAD_SIZE, NULL);\n\t\t\t\tput_task_stack(p);\n\t\t\t}\n\t\t} while_each_thread(g, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * Scan the objects already referenced from the sections scanned\n\t * above.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * Check for new or unreferenced objects modified since the previous\n\t * scan and color them gray until the next scan.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (color_white(object) && (object->flags & OBJECT_ALLOCATED)\n\t\t    && update_checksum(object) && get_object(object)) {\n\t\t\t/* color it gray temporarily */\n\t\t\tobject->count = object->min_count;\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Re-scan the gray list for modified unreferenced objects.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * If scanning was stopped do not report any new unreferenced objects.\n\t */\n\tif (scan_should_stop())\n\t\treturn;\n\n\t/*\n\t * Scanning result reporting.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (unreferenced_object(object) &&\n\t\t    !(object->flags & OBJECT_REPORTED)) {\n\t\t\tobject->flags |= OBJECT_REPORTED;\n\n\t\t\tif (kmemleak_verbose)\n\t\t\t\tprint_unreferenced(NULL, object);\n\n\t\t\tnew_leaks++;\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tif (new_leaks) {\n\t\tkmemleak_found_leaks = true;\n\n\t\tpr_info(\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\",\n\t\t\tnew_leaks);\n\t}\n\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_REPORTED\t\t(1 << 1)",
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static LIST_HEAD(gray_list);",
            "static unsigned long jiffies_last_scan;",
            "static int kmemleak_stack_scan = 1;",
            "static bool kmemleak_found_leaks;",
            "static bool kmemleak_verbose;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_REPORTED\t\t(1 << 1)\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic unsigned long jiffies_last_scan;\nstatic int kmemleak_stack_scan = 1;\nstatic bool kmemleak_found_leaks;\nstatic bool kmemleak_verbose;\n\nstatic void kmemleak_scan(void)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tint i;\n\tint new_leaks = 0;\n\n\tjiffies_last_scan = jiffies;\n\n\t/* prepare the kmemleak_object's */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n#ifdef DEBUG\n\t\t/*\n\t\t * With a few exceptions there should be a maximum of\n\t\t * 1 reference to any object at this point.\n\t\t */\n\t\tif (atomic_read(&object->use_count) > 1) {\n\t\t\tpr_debug(\"object->use_count = %d\\n\",\n\t\t\t\t atomic_read(&object->use_count));\n\t\t\tdump_object_info(object);\n\t\t}\n#endif\n\t\t/* reset the reference count (whiten the object) */\n\t\tobject->count = 0;\n\t\tif (color_gray(object) && get_object(object))\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/* data/bss scanning */\n\tscan_large_block(_sdata, _edata);\n\tscan_large_block(__bss_start, __bss_stop);\n\tscan_large_block(__start_ro_after_init, __end_ro_after_init);\n\n#ifdef CONFIG_SMP\n\t/* per-cpu sections scanning */\n\tfor_each_possible_cpu(i)\n\t\tscan_large_block(__per_cpu_start + per_cpu_offset(i),\n\t\t\t\t __per_cpu_end + per_cpu_offset(i));\n#endif\n\n\t/*\n\t * Struct page scanning for each node.\n\t */\n\tget_online_mems();\n\tfor_each_online_node(i) {\n\t\tunsigned long start_pfn = node_start_pfn(i);\n\t\tunsigned long end_pfn = node_end_pfn(i);\n\t\tunsigned long pfn;\n\n\t\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\t/* only scan if page is in use */\n\t\t\tif (page_count(page) == 0)\n\t\t\t\tcontinue;\n\t\t\tscan_block(page, page + 1, NULL);\n\t\t\tif (!(pfn & 63))\n\t\t\t\tcond_resched();\n\t\t}\n\t}\n\tput_online_mems();\n\n\t/*\n\t * Scanning the task stacks (may introduce false negatives).\n\t */\n\tif (kmemleak_stack_scan) {\n\t\tstruct task_struct *p, *g;\n\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_thread(g, p) {\n\t\t\tvoid *stack = try_get_task_stack(p);\n\t\t\tif (stack) {\n\t\t\t\tscan_block(stack, stack + THREAD_SIZE, NULL);\n\t\t\t\tput_task_stack(p);\n\t\t\t}\n\t\t} while_each_thread(g, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * Scan the objects already referenced from the sections scanned\n\t * above.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * Check for new or unreferenced objects modified since the previous\n\t * scan and color them gray until the next scan.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (color_white(object) && (object->flags & OBJECT_ALLOCATED)\n\t\t    && update_checksum(object) && get_object(object)) {\n\t\t\t/* color it gray temporarily */\n\t\t\tobject->count = object->min_count;\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Re-scan the gray list for modified unreferenced objects.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * If scanning was stopped do not report any new unreferenced objects.\n\t */\n\tif (scan_should_stop())\n\t\treturn;\n\n\t/*\n\t * Scanning result reporting.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (unreferenced_object(object) &&\n\t\t    !(object->flags & OBJECT_REPORTED)) {\n\t\t\tobject->flags |= OBJECT_REPORTED;\n\n\t\t\tif (kmemleak_verbose)\n\t\t\t\tprint_unreferenced(NULL, object);\n\n\t\t\tnew_leaks++;\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tif (new_leaks) {\n\t\tkmemleak_found_leaks = true;\n\n\t\tpr_info(\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\",\n\t\t\tnew_leaks);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"scan\"",
            "4"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_scan_thread",
          "args": [],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "start_scan_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1686-1695",
          "snippet": "static void start_scan_thread(void)\n{\n\tif (scan_thread)\n\t\treturn;\n\tscan_thread = kthread_run(kmemleak_scan_thread, NULL, \"kmemleak\");\n\tif (IS_ERR(scan_thread)) {\n\t\tpr_warn(\"Failed to create the scan thread\\n\");\n\t\tscan_thread = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *scan_thread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct task_struct *scan_thread;\n\nstatic void start_scan_thread(void)\n{\n\tif (scan_thread)\n\t\treturn;\n\tscan_thread = kthread_run(kmemleak_scan_thread, NULL, \"kmemleak\");\n\tif (IS_ERR(scan_thread)) {\n\t\tpr_warn(\"Failed to create the scan thread\\n\");\n\t\tscan_thread = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "secs * 1000"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_scan_thread",
          "args": [],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "stop_scan_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1700-1706",
          "snippet": "static void stop_scan_thread(void)\n{\n\tif (scan_thread) {\n\t\tkthread_stop(scan_thread);\n\t\tscan_thread = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *scan_thread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct task_struct *scan_thread;\n\nstatic void stop_scan_thread(void)\n{\n\tif (scan_thread) {\n\t\tkthread_stop(scan_thread);\n\t\tscan_thread = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf + 5",
            "0",
            "&secs"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"scan=\"",
            "5"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"scan=off\"",
            "8"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"scan=on\"",
            "7"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"stack=off\"",
            "9"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"stack=on\"",
            "8"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_disable",
          "args": [],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1983-1999",
          "snippet": "static void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_free_enabled;",
            "static int kmemleak_initialized;",
            "static int kmemleak_error;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_initialized;\nstatic int kmemleak_error;\nstatic void kmemleak_disable(void);\n\nstatic void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"off\"",
            "3"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmemleak_do_cleanup",
          "args": [],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "__kmemleak_do_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1942-1950",
          "snippet": "static void __kmemleak_do_cleanup(void)\n{\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list)\n\t\tdelete_object_full(object->pointer);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static void __kmemleak_do_cleanup(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\nstatic void __kmemleak_do_cleanup(void);\n\nstatic void __kmemleak_do_cleanup(void)\n{\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list)\n\t\tdelete_object_full(object->pointer);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_clear",
          "args": [],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1830-1846",
          "snippet": "static void kmemleak_clear(void)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif ((object->flags & OBJECT_REPORTED) &&\n\t\t    unreferenced_object(object))\n\t\t\t__paint_it(object, KMEMLEAK_GREY);\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tkmemleak_found_leaks = false;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_REPORTED\t\t(1 << 1)",
            "#define KMEMLEAK_GREY\t0"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static bool kmemleak_found_leaks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_REPORTED\t\t(1 << 1)\n#define KMEMLEAK_GREY\t0\n\nstatic LIST_HEAD(object_list);\nstatic bool kmemleak_found_leaks;\n\nstatic void kmemleak_clear(void)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif ((object->flags & OBJECT_REPORTED) &&\n\t\t    unreferenced_object(object))\n\t\t\t__paint_it(object, KMEMLEAK_GREY);\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tkmemleak_found_leaks = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"clear\"",
            "5"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&scan_mutex"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "buf",
            "user_buf",
            "buf_size"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "(sizeof(buf) - 1)"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic signed long jiffies_scan_wait;\nstatic int kmemleak_stack_scan = 1;\nstatic DEFINE_MUTEX(scan_mutex);\nstatic void kmemleak_disable(void);\nstatic void __kmemleak_do_cleanup(void);\n\nstatic ssize_t kmemleak_write(struct file *file, const char __user *user_buf,\n\t\t\t      size_t size, loff_t *ppos)\n{\n\tchar buf[64];\n\tint buf_size;\n\tint ret;\n\n\tbuf_size = min(size, (sizeof(buf) - 1));\n\tif (strncpy_from_user(buf, user_buf, buf_size) < 0)\n\t\treturn -EFAULT;\n\tbuf[buf_size] = 0;\n\n\tret = mutex_lock_interruptible(&scan_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (strncmp(buf, \"clear\", 5) == 0) {\n\t\tif (kmemleak_enabled)\n\t\t\tkmemleak_clear();\n\t\telse\n\t\t\t__kmemleak_do_cleanup();\n\t\tgoto out;\n\t}\n\n\tif (!kmemleak_enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (strncmp(buf, \"off\", 3) == 0)\n\t\tkmemleak_disable();\n\telse if (strncmp(buf, \"stack=on\", 8) == 0)\n\t\tkmemleak_stack_scan = 1;\n\telse if (strncmp(buf, \"stack=off\", 9) == 0)\n\t\tkmemleak_stack_scan = 0;\n\telse if (strncmp(buf, \"scan=on\", 7) == 0)\n\t\tstart_scan_thread();\n\telse if (strncmp(buf, \"scan=off\", 8) == 0)\n\t\tstop_scan_thread();\n\telse if (strncmp(buf, \"scan=\", 5) == 0) {\n\t\tunsigned long secs;\n\n\t\tret = kstrtoul(buf + 5, 0, &secs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tstop_scan_thread();\n\t\tif (secs) {\n\t\t\tjiffies_scan_wait = msecs_to_jiffies(secs * 1000);\n\t\t\tstart_scan_thread();\n\t\t}\n\t} else if (strncmp(buf, \"scan\", 4) == 0)\n\t\tkmemleak_scan();\n\telse if (strncmp(buf, \"dump=\", 5) == 0)\n\t\tret = dump_str_object_info(buf + 5);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\tmutex_unlock(&scan_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* ignore the rest of the buffer, only one command at a time */\n\t*ppos += size;\n\treturn size;\n}"
  },
  {
    "function_name": "kmemleak_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1830-1846",
    "snippet": "static void kmemleak_clear(void)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif ((object->flags & OBJECT_REPORTED) &&\n\t\t    unreferenced_object(object))\n\t\t\t__paint_it(object, KMEMLEAK_GREY);\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tkmemleak_found_leaks = false;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_REPORTED\t\t(1 << 1)",
      "#define KMEMLEAK_GREY\t0"
    ],
    "globals_used": [
      "static LIST_HEAD(object_list);",
      "static bool kmemleak_found_leaks;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__paint_it",
          "args": [
            "object",
            "KMEMLEAK_GREY"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "__paint_it",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "732-737",
          "snippet": "static void __paint_it(struct kmemleak_object *object, int color)\n{\n\tobject->min_count = color;\n\tif (color == KMEMLEAK_BLACK)\n\t\tobject->flags |= OBJECT_NO_SCAN;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_NO_SCAN\t\t(1 << 2)",
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_NO_SCAN\t\t(1 << 2)\n#define KMEMLEAK_BLACK\t-1\n\nstatic void __paint_it(struct kmemleak_object *object, int color)\n{\n\tobject->min_count = color;\n\tif (color == KMEMLEAK_BLACK)\n\t\tobject->flags |= OBJECT_NO_SCAN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreferenced_object",
          "args": [
            "object"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "unreferenced_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "375-380",
          "snippet": "static bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static unsigned long jiffies_min_age;",
            "static unsigned long jiffies_last_scan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic unsigned long jiffies_min_age;\nstatic unsigned long jiffies_last_scan;\n\nstatic bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "object",
            "&object_list",
            "object_list"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_REPORTED\t\t(1 << 1)\n#define KMEMLEAK_GREY\t0\n\nstatic LIST_HEAD(object_list);\nstatic bool kmemleak_found_leaks;\n\nstatic void kmemleak_clear(void)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif ((object->flags & OBJECT_REPORTED) &&\n\t\t    unreferenced_object(object))\n\t\t\t__paint_it(object, KMEMLEAK_GREY);\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tkmemleak_found_leaks = false;\n}"
  },
  {
    "function_name": "dump_str_object_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1802-1822",
    "snippet": "static int dump_str_object_info(const char *str)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tunsigned long addr;\n\n\tif (kstrtoul(str, 0, &addr))\n\t\treturn -EINVAL;\n\tobject = find_and_get_object(addr, 0);\n\tif (!object) {\n\t\tpr_info(\"Unknown object at 0x%08lx\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tdump_object_info(object);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_object_info",
          "args": [
            "object"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "dump_object_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "411-428",
          "snippet": "static void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unknown object at 0x%08lx\\n\"",
            "addr"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_get_object",
          "args": [
            "addr",
            "0"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "512-528",
          "snippet": "static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "&addr"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int dump_str_object_info(const char *str)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tunsigned long addr;\n\n\tif (kstrtoul(str, 0, &addr))\n\t\treturn -EINVAL;\n\tobject = find_and_get_object(addr, 0);\n\tif (!object) {\n\t\tpr_info(\"Unknown object at 0x%08lx\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tdump_object_info(object);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n\treturn 0;\n}"
  },
  {
    "function_name": "kmemleak_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1797-1800",
    "snippet": "static int kmemleak_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &kmemleak_seq_ops);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations kmemleak_seq_ops = {\n\t.start = kmemleak_seq_start,\n\t.next  = kmemleak_seq_next,\n\t.stop  = kmemleak_seq_stop,\n\t.show  = kmemleak_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&kmemleak_seq_ops"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct seq_operations kmemleak_seq_ops = {\n\t.start = kmemleak_seq_start,\n\t.next  = kmemleak_seq_next,\n\t.stop  = kmemleak_seq_stop,\n\t.show  = kmemleak_seq_show,\n};\n\nstatic int kmemleak_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &kmemleak_seq_ops);\n}"
  },
  {
    "function_name": "kmemleak_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1778-1788",
    "snippet": "static int kmemleak_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct kmemleak_object *object = v;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tif ((object->flags & OBJECT_REPORTED) && unreferenced_object(object))\n\t\tprint_unreferenced(seq, object);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_REPORTED\t\t(1 << 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_unreferenced",
          "args": [
            "seq",
            "object"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "print_unreferenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "386-404",
          "snippet": "static void print_unreferenced(struct seq_file *seq,\n\t\t\t       struct kmemleak_object *object)\n{\n\tint i;\n\tunsigned int msecs_age = jiffies_to_msecs(jiffies - object->jiffies);\n\n\twarn_or_seq_printf(seq, \"unreferenced object 0x%08lx (size %zu):\\n\",\n\t\t   object->pointer, object->size);\n\twarn_or_seq_printf(seq, \"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\",\n\t\t   object->comm, object->pid, object->jiffies,\n\t\t   msecs_age / 1000, msecs_age % 1000);\n\thex_dump_object(seq, object);\n\twarn_or_seq_printf(seq, \"  backtrace:\\n\");\n\n\tfor (i = 0; i < object->trace_len; i++) {\n\t\tvoid *ptr = (void *)object->trace[i];\n\t\twarn_or_seq_printf(seq, \"    [<%p>] %pS\\n\", ptr, ptr);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void print_unreferenced(struct seq_file *seq,\n\t\t\t       struct kmemleak_object *object)\n{\n\tint i;\n\tunsigned int msecs_age = jiffies_to_msecs(jiffies - object->jiffies);\n\n\twarn_or_seq_printf(seq, \"unreferenced object 0x%08lx (size %zu):\\n\",\n\t\t   object->pointer, object->size);\n\twarn_or_seq_printf(seq, \"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\",\n\t\t   object->comm, object->pid, object->jiffies,\n\t\t   msecs_age / 1000, msecs_age % 1000);\n\thex_dump_object(seq, object);\n\twarn_or_seq_printf(seq, \"  backtrace:\\n\");\n\n\tfor (i = 0; i < object->trace_len; i++) {\n\t\tvoid *ptr = (void *)object->trace[i];\n\t\twarn_or_seq_printf(seq, \"    [<%p>] %pS\\n\", ptr, ptr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreferenced_object",
          "args": [
            "object"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "unreferenced_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "375-380",
          "snippet": "static bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static unsigned long jiffies_min_age;",
            "static unsigned long jiffies_last_scan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic unsigned long jiffies_min_age;\nstatic unsigned long jiffies_last_scan;\n\nstatic bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_REPORTED\t\t(1 << 1)\n\nstatic int kmemleak_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct kmemleak_object *object = v;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tif ((object->flags & OBJECT_REPORTED) && unreferenced_object(object))\n\t\tprint_unreferenced(seq, object);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "kmemleak_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1761-1773",
    "snippet": "static void kmemleak_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!IS_ERR(v)) {\n\t\t/*\n\t\t * kmemleak_seq_start may return ERR_PTR if the scan_mutex\n\t\t * waiting was interrupted, so only release it if !IS_ERR.\n\t\t */\n\t\trcu_read_unlock();\n\t\tmutex_unlock(&scan_mutex);\n\t\tif (v)\n\t\t\tput_object(v);\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(scan_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "v"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&scan_mutex"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "v"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(scan_mutex);\n\nstatic void kmemleak_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!IS_ERR(v)) {\n\t\t/*\n\t\t * kmemleak_seq_start may return ERR_PTR if the scan_mutex\n\t\t * waiting was interrupted, so only release it if !IS_ERR.\n\t\t */\n\t\trcu_read_unlock();\n\t\tmutex_unlock(&scan_mutex);\n\t\tif (v)\n\t\t\tput_object(v);\n\t}\n}"
  },
  {
    "function_name": "kmemleak_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1739-1756",
    "snippet": "static void *kmemleak_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct kmemleak_object *prev_obj = v;\n\tstruct kmemleak_object *next_obj = NULL;\n\tstruct kmemleak_object *obj = prev_obj;\n\n\t++(*pos);\n\n\tlist_for_each_entry_continue_rcu(obj, &object_list, object_list) {\n\t\tif (get_object(obj)) {\n\t\t\tnext_obj = obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_object(prev_obj);\n\treturn next_obj;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(object_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "prev_obj"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_object",
          "args": [
            "obj"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "465-468",
          "snippet": "static int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_rcu",
          "args": [
            "obj",
            "&object_list",
            "object_list"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\n\nstatic void *kmemleak_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct kmemleak_object *prev_obj = v;\n\tstruct kmemleak_object *next_obj = NULL;\n\tstruct kmemleak_object *obj = prev_obj;\n\n\t++(*pos);\n\n\tlist_for_each_entry_continue_rcu(obj, &object_list, object_list) {\n\t\tif (get_object(obj)) {\n\t\t\tnext_obj = obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_object(prev_obj);\n\treturn next_obj;\n}"
  },
  {
    "function_name": "kmemleak_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1713-1733",
    "snippet": "static void *kmemleak_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct kmemleak_object *object;\n\tloff_t n = *pos;\n\tint err;\n\n\terr = mutex_lock_interruptible(&scan_mutex);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tif (n-- > 0)\n\t\t\tcontinue;\n\t\tif (get_object(object))\n\t\t\tgoto out;\n\t}\n\tobject = NULL;\nout:\n\treturn object;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(object_list);",
      "static DEFINE_MUTEX(scan_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_object",
          "args": [
            "object"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "465-468",
          "snippet": "static int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "object",
            "&object_list",
            "object_list"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&scan_mutex"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\nstatic DEFINE_MUTEX(scan_mutex);\n\nstatic void *kmemleak_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct kmemleak_object *object;\n\tloff_t n = *pos;\n\tint err;\n\n\terr = mutex_lock_interruptible(&scan_mutex);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tif (n-- > 0)\n\t\t\tcontinue;\n\t\tif (get_object(object))\n\t\t\tgoto out;\n\t}\n\tobject = NULL;\nout:\n\treturn object;\n}"
  },
  {
    "function_name": "stop_scan_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1700-1706",
    "snippet": "static void stop_scan_thread(void)\n{\n\tif (scan_thread) {\n\t\tkthread_stop(scan_thread);\n\t\tscan_thread = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *scan_thread;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "scan_thread"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct task_struct *scan_thread;\n\nstatic void stop_scan_thread(void)\n{\n\tif (scan_thread) {\n\t\tkthread_stop(scan_thread);\n\t\tscan_thread = NULL;\n\t}\n}"
  },
  {
    "function_name": "start_scan_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1686-1695",
    "snippet": "static void start_scan_thread(void)\n{\n\tif (scan_thread)\n\t\treturn;\n\tscan_thread = kthread_run(kmemleak_scan_thread, NULL, \"kmemleak\");\n\tif (IS_ERR(scan_thread)) {\n\t\tpr_warn(\"Failed to create the scan thread\\n\");\n\t\tscan_thread = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *scan_thread;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to create the scan thread\\n\""
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "scan_thread"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kmemleak_scan_thread",
            "NULL",
            "\"kmemleak\""
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct task_struct *scan_thread;\n\nstatic void start_scan_thread(void)\n{\n\tif (scan_thread)\n\t\treturn;\n\tscan_thread = kthread_run(kmemleak_scan_thread, NULL, \"kmemleak\");\n\tif (IS_ERR(scan_thread)) {\n\t\tpr_warn(\"Failed to create the scan thread\\n\");\n\t\tscan_thread = NULL;\n\t}\n}"
  },
  {
    "function_name": "kmemleak_scan_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1648-1680",
    "snippet": "static int kmemleak_scan_thread(void *arg)\n{\n\tstatic int first_run = 1;\n\n\tpr_info(\"Automatic memory scanning thread started\\n\");\n\tset_user_nice(current, 10);\n\n\t/*\n\t * Wait before the first scan to allow the system to fully initialize.\n\t */\n\tif (first_run) {\n\t\tsigned long timeout = msecs_to_jiffies(SECS_FIRST_SCAN * 1000);\n\t\tfirst_run = 0;\n\t\twhile (timeout && !kthread_should_stop())\n\t\t\ttimeout = schedule_timeout_interruptible(timeout);\n\t}\n\n\twhile (!kthread_should_stop()) {\n\t\tsigned long timeout = jiffies_scan_wait;\n\n\t\tmutex_lock(&scan_mutex);\n\t\tkmemleak_scan();\n\t\tmutex_unlock(&scan_mutex);\n\n\t\t/* wait before the next scan */\n\t\twhile (timeout && !kthread_should_stop())\n\t\t\ttimeout = schedule_timeout_interruptible(timeout);\n\t}\n\n\tpr_info(\"Automatic memory scanning thread ended\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SECS_FIRST_SCAN\t\t60\t/* delay before the first scan */"
    ],
    "globals_used": [
      "static signed long jiffies_scan_wait;",
      "static DEFINE_MUTEX(scan_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Automatic memory scanning thread ended\\n\""
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "timeout"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&scan_mutex"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_scan",
          "args": [],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1495-1642",
          "snippet": "static void kmemleak_scan(void)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tint i;\n\tint new_leaks = 0;\n\n\tjiffies_last_scan = jiffies;\n\n\t/* prepare the kmemleak_object's */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n#ifdef DEBUG\n\t\t/*\n\t\t * With a few exceptions there should be a maximum of\n\t\t * 1 reference to any object at this point.\n\t\t */\n\t\tif (atomic_read(&object->use_count) > 1) {\n\t\t\tpr_debug(\"object->use_count = %d\\n\",\n\t\t\t\t atomic_read(&object->use_count));\n\t\t\tdump_object_info(object);\n\t\t}\n#endif\n\t\t/* reset the reference count (whiten the object) */\n\t\tobject->count = 0;\n\t\tif (color_gray(object) && get_object(object))\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/* data/bss scanning */\n\tscan_large_block(_sdata, _edata);\n\tscan_large_block(__bss_start, __bss_stop);\n\tscan_large_block(__start_ro_after_init, __end_ro_after_init);\n\n#ifdef CONFIG_SMP\n\t/* per-cpu sections scanning */\n\tfor_each_possible_cpu(i)\n\t\tscan_large_block(__per_cpu_start + per_cpu_offset(i),\n\t\t\t\t __per_cpu_end + per_cpu_offset(i));\n#endif\n\n\t/*\n\t * Struct page scanning for each node.\n\t */\n\tget_online_mems();\n\tfor_each_online_node(i) {\n\t\tunsigned long start_pfn = node_start_pfn(i);\n\t\tunsigned long end_pfn = node_end_pfn(i);\n\t\tunsigned long pfn;\n\n\t\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\t/* only scan if page is in use */\n\t\t\tif (page_count(page) == 0)\n\t\t\t\tcontinue;\n\t\t\tscan_block(page, page + 1, NULL);\n\t\t\tif (!(pfn & 63))\n\t\t\t\tcond_resched();\n\t\t}\n\t}\n\tput_online_mems();\n\n\t/*\n\t * Scanning the task stacks (may introduce false negatives).\n\t */\n\tif (kmemleak_stack_scan) {\n\t\tstruct task_struct *p, *g;\n\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_thread(g, p) {\n\t\t\tvoid *stack = try_get_task_stack(p);\n\t\t\tif (stack) {\n\t\t\t\tscan_block(stack, stack + THREAD_SIZE, NULL);\n\t\t\t\tput_task_stack(p);\n\t\t\t}\n\t\t} while_each_thread(g, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * Scan the objects already referenced from the sections scanned\n\t * above.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * Check for new or unreferenced objects modified since the previous\n\t * scan and color them gray until the next scan.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (color_white(object) && (object->flags & OBJECT_ALLOCATED)\n\t\t    && update_checksum(object) && get_object(object)) {\n\t\t\t/* color it gray temporarily */\n\t\t\tobject->count = object->min_count;\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Re-scan the gray list for modified unreferenced objects.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * If scanning was stopped do not report any new unreferenced objects.\n\t */\n\tif (scan_should_stop())\n\t\treturn;\n\n\t/*\n\t * Scanning result reporting.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (unreferenced_object(object) &&\n\t\t    !(object->flags & OBJECT_REPORTED)) {\n\t\t\tobject->flags |= OBJECT_REPORTED;\n\n\t\t\tif (kmemleak_verbose)\n\t\t\t\tprint_unreferenced(NULL, object);\n\n\t\t\tnew_leaks++;\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tif (new_leaks) {\n\t\tkmemleak_found_leaks = true;\n\n\t\tpr_info(\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\",\n\t\t\tnew_leaks);\n\t}\n\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_REPORTED\t\t(1 << 1)",
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static LIST_HEAD(gray_list);",
            "static unsigned long jiffies_last_scan;",
            "static int kmemleak_stack_scan = 1;",
            "static bool kmemleak_found_leaks;",
            "static bool kmemleak_verbose;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_REPORTED\t\t(1 << 1)\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic unsigned long jiffies_last_scan;\nstatic int kmemleak_stack_scan = 1;\nstatic bool kmemleak_found_leaks;\nstatic bool kmemleak_verbose;\n\nstatic void kmemleak_scan(void)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tint i;\n\tint new_leaks = 0;\n\n\tjiffies_last_scan = jiffies;\n\n\t/* prepare the kmemleak_object's */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n#ifdef DEBUG\n\t\t/*\n\t\t * With a few exceptions there should be a maximum of\n\t\t * 1 reference to any object at this point.\n\t\t */\n\t\tif (atomic_read(&object->use_count) > 1) {\n\t\t\tpr_debug(\"object->use_count = %d\\n\",\n\t\t\t\t atomic_read(&object->use_count));\n\t\t\tdump_object_info(object);\n\t\t}\n#endif\n\t\t/* reset the reference count (whiten the object) */\n\t\tobject->count = 0;\n\t\tif (color_gray(object) && get_object(object))\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/* data/bss scanning */\n\tscan_large_block(_sdata, _edata);\n\tscan_large_block(__bss_start, __bss_stop);\n\tscan_large_block(__start_ro_after_init, __end_ro_after_init);\n\n#ifdef CONFIG_SMP\n\t/* per-cpu sections scanning */\n\tfor_each_possible_cpu(i)\n\t\tscan_large_block(__per_cpu_start + per_cpu_offset(i),\n\t\t\t\t __per_cpu_end + per_cpu_offset(i));\n#endif\n\n\t/*\n\t * Struct page scanning for each node.\n\t */\n\tget_online_mems();\n\tfor_each_online_node(i) {\n\t\tunsigned long start_pfn = node_start_pfn(i);\n\t\tunsigned long end_pfn = node_end_pfn(i);\n\t\tunsigned long pfn;\n\n\t\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\t/* only scan if page is in use */\n\t\t\tif (page_count(page) == 0)\n\t\t\t\tcontinue;\n\t\t\tscan_block(page, page + 1, NULL);\n\t\t\tif (!(pfn & 63))\n\t\t\t\tcond_resched();\n\t\t}\n\t}\n\tput_online_mems();\n\n\t/*\n\t * Scanning the task stacks (may introduce false negatives).\n\t */\n\tif (kmemleak_stack_scan) {\n\t\tstruct task_struct *p, *g;\n\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_thread(g, p) {\n\t\t\tvoid *stack = try_get_task_stack(p);\n\t\t\tif (stack) {\n\t\t\t\tscan_block(stack, stack + THREAD_SIZE, NULL);\n\t\t\t\tput_task_stack(p);\n\t\t\t}\n\t\t} while_each_thread(g, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * Scan the objects already referenced from the sections scanned\n\t * above.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * Check for new or unreferenced objects modified since the previous\n\t * scan and color them gray until the next scan.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (color_white(object) && (object->flags & OBJECT_ALLOCATED)\n\t\t    && update_checksum(object) && get_object(object)) {\n\t\t\t/* color it gray temporarily */\n\t\t\tobject->count = object->min_count;\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Re-scan the gray list for modified unreferenced objects.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * If scanning was stopped do not report any new unreferenced objects.\n\t */\n\tif (scan_should_stop())\n\t\treturn;\n\n\t/*\n\t * Scanning result reporting.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (unreferenced_object(object) &&\n\t\t    !(object->flags & OBJECT_REPORTED)) {\n\t\t\tobject->flags |= OBJECT_REPORTED;\n\n\t\t\tif (kmemleak_verbose)\n\t\t\t\tprint_unreferenced(NULL, object);\n\n\t\t\tnew_leaks++;\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tif (new_leaks) {\n\t\tkmemleak_found_leaks = true;\n\n\t\tpr_info(\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\",\n\t\t\tnew_leaks);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&scan_mutex"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "timeout"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "SECS_FIRST_SCAN * 1000"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "10"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Automatic memory scanning thread started\\n\""
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define SECS_FIRST_SCAN\t\t60\t/* delay before the first scan */\n\nstatic signed long jiffies_scan_wait;\nstatic DEFINE_MUTEX(scan_mutex);\n\nstatic int kmemleak_scan_thread(void *arg)\n{\n\tstatic int first_run = 1;\n\n\tpr_info(\"Automatic memory scanning thread started\\n\");\n\tset_user_nice(current, 10);\n\n\t/*\n\t * Wait before the first scan to allow the system to fully initialize.\n\t */\n\tif (first_run) {\n\t\tsigned long timeout = msecs_to_jiffies(SECS_FIRST_SCAN * 1000);\n\t\tfirst_run = 0;\n\t\twhile (timeout && !kthread_should_stop())\n\t\t\ttimeout = schedule_timeout_interruptible(timeout);\n\t}\n\n\twhile (!kthread_should_stop()) {\n\t\tsigned long timeout = jiffies_scan_wait;\n\n\t\tmutex_lock(&scan_mutex);\n\t\tkmemleak_scan();\n\t\tmutex_unlock(&scan_mutex);\n\n\t\t/* wait before the next scan */\n\t\twhile (timeout && !kthread_should_stop())\n\t\t\ttimeout = schedule_timeout_interruptible(timeout);\n\t}\n\n\tpr_info(\"Automatic memory scanning thread ended\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kmemleak_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1495-1642",
    "snippet": "static void kmemleak_scan(void)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tint i;\n\tint new_leaks = 0;\n\n\tjiffies_last_scan = jiffies;\n\n\t/* prepare the kmemleak_object's */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n#ifdef DEBUG\n\t\t/*\n\t\t * With a few exceptions there should be a maximum of\n\t\t * 1 reference to any object at this point.\n\t\t */\n\t\tif (atomic_read(&object->use_count) > 1) {\n\t\t\tpr_debug(\"object->use_count = %d\\n\",\n\t\t\t\t atomic_read(&object->use_count));\n\t\t\tdump_object_info(object);\n\t\t}\n#endif\n\t\t/* reset the reference count (whiten the object) */\n\t\tobject->count = 0;\n\t\tif (color_gray(object) && get_object(object))\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/* data/bss scanning */\n\tscan_large_block(_sdata, _edata);\n\tscan_large_block(__bss_start, __bss_stop);\n\tscan_large_block(__start_ro_after_init, __end_ro_after_init);\n\n#ifdef CONFIG_SMP\n\t/* per-cpu sections scanning */\n\tfor_each_possible_cpu(i)\n\t\tscan_large_block(__per_cpu_start + per_cpu_offset(i),\n\t\t\t\t __per_cpu_end + per_cpu_offset(i));\n#endif\n\n\t/*\n\t * Struct page scanning for each node.\n\t */\n\tget_online_mems();\n\tfor_each_online_node(i) {\n\t\tunsigned long start_pfn = node_start_pfn(i);\n\t\tunsigned long end_pfn = node_end_pfn(i);\n\t\tunsigned long pfn;\n\n\t\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\t/* only scan if page is in use */\n\t\t\tif (page_count(page) == 0)\n\t\t\t\tcontinue;\n\t\t\tscan_block(page, page + 1, NULL);\n\t\t\tif (!(pfn & 63))\n\t\t\t\tcond_resched();\n\t\t}\n\t}\n\tput_online_mems();\n\n\t/*\n\t * Scanning the task stacks (may introduce false negatives).\n\t */\n\tif (kmemleak_stack_scan) {\n\t\tstruct task_struct *p, *g;\n\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_thread(g, p) {\n\t\t\tvoid *stack = try_get_task_stack(p);\n\t\t\tif (stack) {\n\t\t\t\tscan_block(stack, stack + THREAD_SIZE, NULL);\n\t\t\t\tput_task_stack(p);\n\t\t\t}\n\t\t} while_each_thread(g, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * Scan the objects already referenced from the sections scanned\n\t * above.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * Check for new or unreferenced objects modified since the previous\n\t * scan and color them gray until the next scan.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (color_white(object) && (object->flags & OBJECT_ALLOCATED)\n\t\t    && update_checksum(object) && get_object(object)) {\n\t\t\t/* color it gray temporarily */\n\t\t\tobject->count = object->min_count;\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Re-scan the gray list for modified unreferenced objects.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * If scanning was stopped do not report any new unreferenced objects.\n\t */\n\tif (scan_should_stop())\n\t\treturn;\n\n\t/*\n\t * Scanning result reporting.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (unreferenced_object(object) &&\n\t\t    !(object->flags & OBJECT_REPORTED)) {\n\t\t\tobject->flags |= OBJECT_REPORTED;\n\n\t\t\tif (kmemleak_verbose)\n\t\t\t\tprint_unreferenced(NULL, object);\n\n\t\t\tnew_leaks++;\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tif (new_leaks) {\n\t\tkmemleak_found_leaks = true;\n\n\t\tpr_info(\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\",\n\t\t\tnew_leaks);\n\t}\n\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_REPORTED\t\t(1 << 1)",
      "#define OBJECT_ALLOCATED\t(1 << 0)"
    ],
    "globals_used": [
      "static LIST_HEAD(object_list);",
      "static LIST_HEAD(gray_list);",
      "static unsigned long jiffies_last_scan;",
      "static int kmemleak_stack_scan = 1;",
      "static bool kmemleak_found_leaks;",
      "static bool kmemleak_verbose;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\"",
            "new_leaks"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_unreferenced",
          "args": [
            "NULL",
            "object"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "print_unreferenced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "386-404",
          "snippet": "static void print_unreferenced(struct seq_file *seq,\n\t\t\t       struct kmemleak_object *object)\n{\n\tint i;\n\tunsigned int msecs_age = jiffies_to_msecs(jiffies - object->jiffies);\n\n\twarn_or_seq_printf(seq, \"unreferenced object 0x%08lx (size %zu):\\n\",\n\t\t   object->pointer, object->size);\n\twarn_or_seq_printf(seq, \"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\",\n\t\t   object->comm, object->pid, object->jiffies,\n\t\t   msecs_age / 1000, msecs_age % 1000);\n\thex_dump_object(seq, object);\n\twarn_or_seq_printf(seq, \"  backtrace:\\n\");\n\n\tfor (i = 0; i < object->trace_len; i++) {\n\t\tvoid *ptr = (void *)object->trace[i];\n\t\twarn_or_seq_printf(seq, \"    [<%p>] %pS\\n\", ptr, ptr);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void print_unreferenced(struct seq_file *seq,\n\t\t\t       struct kmemleak_object *object)\n{\n\tint i;\n\tunsigned int msecs_age = jiffies_to_msecs(jiffies - object->jiffies);\n\n\twarn_or_seq_printf(seq, \"unreferenced object 0x%08lx (size %zu):\\n\",\n\t\t   object->pointer, object->size);\n\twarn_or_seq_printf(seq, \"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\",\n\t\t   object->comm, object->pid, object->jiffies,\n\t\t   msecs_age / 1000, msecs_age % 1000);\n\thex_dump_object(seq, object);\n\twarn_or_seq_printf(seq, \"  backtrace:\\n\");\n\n\tfor (i = 0; i < object->trace_len; i++) {\n\t\tvoid *ptr = (void *)object->trace[i];\n\t\twarn_or_seq_printf(seq, \"    [<%p>] %pS\\n\", ptr, ptr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreferenced_object",
          "args": [
            "object"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "unreferenced_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "375-380",
          "snippet": "static bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static unsigned long jiffies_min_age;",
            "static unsigned long jiffies_last_scan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic unsigned long jiffies_min_age;\nstatic unsigned long jiffies_last_scan;\n\nstatic bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "object",
            "&object_list",
            "object_list"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_should_stop",
          "args": [],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "scan_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1308-1323",
          "snippet": "static int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\n\nstatic int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_gray_list",
          "args": [],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "scan_gray_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1461-1488",
          "snippet": "static void scan_gray_list(void)\n{\n\tstruct kmemleak_object *object, *tmp;\n\n\t/*\n\t * The list traversal is safe for both tail additions and removals\n\t * from inside the loop. The kmemleak objects cannot be freed from\n\t * outside the loop because their use_count was incremented.\n\t */\n\tobject = list_entry(gray_list.next, typeof(*object), gray_list);\n\twhile (&object->gray_list != &gray_list) {\n\t\tcond_resched();\n\n\t\t/* may add new objects to the list */\n\t\tif (!scan_should_stop())\n\t\t\tscan_object(object);\n\n\t\ttmp = list_entry(object->gray_list.next, typeof(*object),\n\t\t\t\t gray_list);\n\n\t\t/* remove the object from the list and release it */\n\t\tlist_del(&object->gray_list);\n\t\tput_object(object);\n\n\t\tobject = tmp;\n\t}\n\tWARN_ON(!list_empty(&gray_list));\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(gray_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(gray_list);\n\nstatic void scan_gray_list(void)\n{\n\tstruct kmemleak_object *object, *tmp;\n\n\t/*\n\t * The list traversal is safe for both tail additions and removals\n\t * from inside the loop. The kmemleak objects cannot be freed from\n\t * outside the loop because their use_count was incremented.\n\t */\n\tobject = list_entry(gray_list.next, typeof(*object), gray_list);\n\twhile (&object->gray_list != &gray_list) {\n\t\tcond_resched();\n\n\t\t/* may add new objects to the list */\n\t\tif (!scan_should_stop())\n\t\t\tscan_object(object);\n\n\t\ttmp = list_entry(object->gray_list.next, typeof(*object),\n\t\t\t\t gray_list);\n\n\t\t/* remove the object from the list and release it */\n\t\tlist_del(&object->gray_list);\n\t\tput_object(object);\n\n\t\tobject = tmp;\n\t}\n\tWARN_ON(!list_empty(&gray_list));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&object->gray_list",
            "&gray_list"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_object",
          "args": [
            "object"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "465-468",
          "snippet": "static int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_checksum",
          "args": [
            "object"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "update_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1269-1278",
          "snippet": "static bool update_checksum(struct kmemleak_object *object)\n{\n\tu32 old_csum = object->checksum;\n\n\tkasan_disable_current();\n\tobject->checksum = crc32(0, (void *)object->pointer, object->size);\n\tkasan_enable_current();\n\n\treturn object->checksum != old_csum;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic bool update_checksum(struct kmemleak_object *object)\n{\n\tu32 old_csum = object->checksum;\n\n\tkasan_disable_current();\n\tobject->checksum = crc32(0, (void *)object->pointer, object->size);\n\tkasan_enable_current();\n\n\treturn object->checksum != old_csum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "color_white",
          "args": [
            "object"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "color_white",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "358-362",
          "snippet": "static bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "object",
            "&object_list",
            "object_list"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1859-1862",
          "snippet": "static void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_stack",
          "args": [
            "p"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_block",
          "args": [
            "stack",
            "stack + THREAD_SIZE",
            "NULL"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "scan_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1329-1395",
          "snippet": "static void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define BYTES_PER_POINTER\tsizeof(void *)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static DEFINE_MUTEX(scan_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define BYTES_PER_POINTER\tsizeof(void *)\n\nstatic LIST_HEAD(object_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic DEFINE_MUTEX(scan_mutex);\n\nstatic void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_get_task_stack",
          "args": [
            "p"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1854-1857",
          "snippet": "static void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_end_pfn",
          "args": [
            "i"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_start_pfn",
          "args": [
            "i"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_large_block",
          "args": [
            "__start_ro_after_init",
            "__end_ro_after_init"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "scan_large_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1400-1410",
          "snippet": "static void scan_large_block(void *start, void *end)\n{\n\tvoid *next;\n\n\twhile (start < end) {\n\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\tscan_block(start, next, NULL);\n\t\tstart = next;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */\n\nstatic void scan_large_block(void *start, void *end)\n{\n\tvoid *next;\n\n\twhile (start < end) {\n\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\tscan_block(start, next, NULL);\n\t\tstart = next;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&object->gray_list",
            "&gray_list"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "color_gray",
          "args": [
            "object"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "color_gray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "364-368",
          "snippet": "static bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_object_info",
          "args": [
            "object"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "dump_object_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "411-428",
          "snippet": "static void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"object->use_count = %d\\n\"",
            "atomic_read(&object->use_count)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->use_count"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->use_count"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "object",
            "&object_list",
            "object_list"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_REPORTED\t\t(1 << 1)\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic unsigned long jiffies_last_scan;\nstatic int kmemleak_stack_scan = 1;\nstatic bool kmemleak_found_leaks;\nstatic bool kmemleak_verbose;\n\nstatic void kmemleak_scan(void)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tint i;\n\tint new_leaks = 0;\n\n\tjiffies_last_scan = jiffies;\n\n\t/* prepare the kmemleak_object's */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n#ifdef DEBUG\n\t\t/*\n\t\t * With a few exceptions there should be a maximum of\n\t\t * 1 reference to any object at this point.\n\t\t */\n\t\tif (atomic_read(&object->use_count) > 1) {\n\t\t\tpr_debug(\"object->use_count = %d\\n\",\n\t\t\t\t atomic_read(&object->use_count));\n\t\t\tdump_object_info(object);\n\t\t}\n#endif\n\t\t/* reset the reference count (whiten the object) */\n\t\tobject->count = 0;\n\t\tif (color_gray(object) && get_object(object))\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/* data/bss scanning */\n\tscan_large_block(_sdata, _edata);\n\tscan_large_block(__bss_start, __bss_stop);\n\tscan_large_block(__start_ro_after_init, __end_ro_after_init);\n\n#ifdef CONFIG_SMP\n\t/* per-cpu sections scanning */\n\tfor_each_possible_cpu(i)\n\t\tscan_large_block(__per_cpu_start + per_cpu_offset(i),\n\t\t\t\t __per_cpu_end + per_cpu_offset(i));\n#endif\n\n\t/*\n\t * Struct page scanning for each node.\n\t */\n\tget_online_mems();\n\tfor_each_online_node(i) {\n\t\tunsigned long start_pfn = node_start_pfn(i);\n\t\tunsigned long end_pfn = node_end_pfn(i);\n\t\tunsigned long pfn;\n\n\t\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\t/* only scan if page is in use */\n\t\t\tif (page_count(page) == 0)\n\t\t\t\tcontinue;\n\t\t\tscan_block(page, page + 1, NULL);\n\t\t\tif (!(pfn & 63))\n\t\t\t\tcond_resched();\n\t\t}\n\t}\n\tput_online_mems();\n\n\t/*\n\t * Scanning the task stacks (may introduce false negatives).\n\t */\n\tif (kmemleak_stack_scan) {\n\t\tstruct task_struct *p, *g;\n\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_thread(g, p) {\n\t\t\tvoid *stack = try_get_task_stack(p);\n\t\t\tif (stack) {\n\t\t\t\tscan_block(stack, stack + THREAD_SIZE, NULL);\n\t\t\t\tput_task_stack(p);\n\t\t\t}\n\t\t} while_each_thread(g, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * Scan the objects already referenced from the sections scanned\n\t * above.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * Check for new or unreferenced objects modified since the previous\n\t * scan and color them gray until the next scan.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (color_white(object) && (object->flags & OBJECT_ALLOCATED)\n\t\t    && update_checksum(object) && get_object(object)) {\n\t\t\t/* color it gray temporarily */\n\t\t\tobject->count = object->min_count;\n\t\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Re-scan the gray list for modified unreferenced objects.\n\t */\n\tscan_gray_list();\n\n\t/*\n\t * If scanning was stopped do not report any new unreferenced objects.\n\t */\n\tif (scan_should_stop())\n\t\treturn;\n\n\t/*\n\t * Scanning result reporting.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(object, &object_list, object_list) {\n\t\tspin_lock_irqsave(&object->lock, flags);\n\t\tif (unreferenced_object(object) &&\n\t\t    !(object->flags & OBJECT_REPORTED)) {\n\t\t\tobject->flags |= OBJECT_REPORTED;\n\n\t\t\tif (kmemleak_verbose)\n\t\t\t\tprint_unreferenced(NULL, object);\n\n\t\t\tnew_leaks++;\n\t\t}\n\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\tif (new_leaks) {\n\t\tkmemleak_found_leaks = true;\n\n\t\tpr_info(\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\",\n\t\t\tnew_leaks);\n\t}\n\n}"
  },
  {
    "function_name": "scan_gray_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1461-1488",
    "snippet": "static void scan_gray_list(void)\n{\n\tstruct kmemleak_object *object, *tmp;\n\n\t/*\n\t * The list traversal is safe for both tail additions and removals\n\t * from inside the loop. The kmemleak objects cannot be freed from\n\t * outside the loop because their use_count was incremented.\n\t */\n\tobject = list_entry(gray_list.next, typeof(*object), gray_list);\n\twhile (&object->gray_list != &gray_list) {\n\t\tcond_resched();\n\n\t\t/* may add new objects to the list */\n\t\tif (!scan_should_stop())\n\t\t\tscan_object(object);\n\n\t\ttmp = list_entry(object->gray_list.next, typeof(*object),\n\t\t\t\t gray_list);\n\n\t\t/* remove the object from the list and release it */\n\t\tlist_del(&object->gray_list);\n\t\tput_object(object);\n\n\t\tobject = tmp;\n\t}\n\tWARN_ON(!list_empty(&gray_list));\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(gray_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&gray_list)"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&gray_list"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&object->gray_list"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "object->gray_list.next",
            "typeof(*object)",
            "gray_list"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*object"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_object",
          "args": [
            "object"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "scan_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1416-1455",
          "snippet": "static void scan_object(struct kmemleak_object *object)\n{\n\tstruct kmemleak_scan_area *area;\n\tunsigned long flags;\n\n\t/*\n\t * Once the object->lock is acquired, the corresponding memory block\n\t * cannot be freed (the same lock is acquired in delete_object).\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (object->flags & OBJECT_NO_SCAN)\n\t\tgoto out;\n\tif (!(object->flags & OBJECT_ALLOCATED))\n\t\t/* already freed object */\n\t\tgoto out;\n\tif (hlist_empty(&object->area_list)) {\n\t\tvoid *start = (void *)object->pointer;\n\t\tvoid *end = (void *)(object->pointer + object->size);\n\t\tvoid *next;\n\n\t\tdo {\n\t\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\t\tscan_block(start, next, object);\n\n\t\t\tstart = next;\n\t\t\tif (start >= end)\n\t\t\t\tbreak;\n\n\t\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t\t\tcond_resched();\n\t\t\tspin_lock_irqsave(&object->lock, flags);\n\t\t} while (object->flags & OBJECT_ALLOCATED);\n\t} else\n\t\thlist_for_each_entry(area, &object->area_list, node)\n\t\t\tscan_block((void *)area->start,\n\t\t\t\t   (void *)(area->start + area->size),\n\t\t\t\t   object);\nout:\n\tspin_unlock_irqrestore(&object->lock, flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_NO_SCAN\t\t(1 << 2)",
            "#define OBJECT_ALLOCATED\t(1 << 0)",
            "#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_NO_SCAN\t\t(1 << 2)\n#define OBJECT_ALLOCATED\t(1 << 0)\n#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */\n\nstatic void scan_object(struct kmemleak_object *object)\n{\n\tstruct kmemleak_scan_area *area;\n\tunsigned long flags;\n\n\t/*\n\t * Once the object->lock is acquired, the corresponding memory block\n\t * cannot be freed (the same lock is acquired in delete_object).\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (object->flags & OBJECT_NO_SCAN)\n\t\tgoto out;\n\tif (!(object->flags & OBJECT_ALLOCATED))\n\t\t/* already freed object */\n\t\tgoto out;\n\tif (hlist_empty(&object->area_list)) {\n\t\tvoid *start = (void *)object->pointer;\n\t\tvoid *end = (void *)(object->pointer + object->size);\n\t\tvoid *next;\n\n\t\tdo {\n\t\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\t\tscan_block(start, next, object);\n\n\t\t\tstart = next;\n\t\t\tif (start >= end)\n\t\t\t\tbreak;\n\n\t\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t\t\tcond_resched();\n\t\t\tspin_lock_irqsave(&object->lock, flags);\n\t\t} while (object->flags & OBJECT_ALLOCATED);\n\t} else\n\t\thlist_for_each_entry(area, &object->area_list, node)\n\t\t\tscan_block((void *)area->start,\n\t\t\t\t   (void *)(area->start + area->size),\n\t\t\t\t   object);\nout:\n\tspin_unlock_irqrestore(&object->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_should_stop",
          "args": [],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "scan_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1308-1323",
          "snippet": "static int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\n\nstatic int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "gray_list.next",
            "typeof(*object)",
            "gray_list"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*object"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(gray_list);\n\nstatic void scan_gray_list(void)\n{\n\tstruct kmemleak_object *object, *tmp;\n\n\t/*\n\t * The list traversal is safe for both tail additions and removals\n\t * from inside the loop. The kmemleak objects cannot be freed from\n\t * outside the loop because their use_count was incremented.\n\t */\n\tobject = list_entry(gray_list.next, typeof(*object), gray_list);\n\twhile (&object->gray_list != &gray_list) {\n\t\tcond_resched();\n\n\t\t/* may add new objects to the list */\n\t\tif (!scan_should_stop())\n\t\t\tscan_object(object);\n\n\t\ttmp = list_entry(object->gray_list.next, typeof(*object),\n\t\t\t\t gray_list);\n\n\t\t/* remove the object from the list and release it */\n\t\tlist_del(&object->gray_list);\n\t\tput_object(object);\n\n\t\tobject = tmp;\n\t}\n\tWARN_ON(!list_empty(&gray_list));\n}"
  },
  {
    "function_name": "scan_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1416-1455",
    "snippet": "static void scan_object(struct kmemleak_object *object)\n{\n\tstruct kmemleak_scan_area *area;\n\tunsigned long flags;\n\n\t/*\n\t * Once the object->lock is acquired, the corresponding memory block\n\t * cannot be freed (the same lock is acquired in delete_object).\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (object->flags & OBJECT_NO_SCAN)\n\t\tgoto out;\n\tif (!(object->flags & OBJECT_ALLOCATED))\n\t\t/* already freed object */\n\t\tgoto out;\n\tif (hlist_empty(&object->area_list)) {\n\t\tvoid *start = (void *)object->pointer;\n\t\tvoid *end = (void *)(object->pointer + object->size);\n\t\tvoid *next;\n\n\t\tdo {\n\t\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\t\tscan_block(start, next, object);\n\n\t\t\tstart = next;\n\t\t\tif (start >= end)\n\t\t\t\tbreak;\n\n\t\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t\t\tcond_resched();\n\t\t\tspin_lock_irqsave(&object->lock, flags);\n\t\t} while (object->flags & OBJECT_ALLOCATED);\n\t} else\n\t\thlist_for_each_entry(area, &object->area_list, node)\n\t\t\tscan_block((void *)area->start,\n\t\t\t\t   (void *)(area->start + area->size),\n\t\t\t\t   object);\nout:\n\tspin_unlock_irqrestore(&object->lock, flags);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_NO_SCAN\t\t(1 << 2)",
      "#define OBJECT_ALLOCATED\t(1 << 0)",
      "#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_block",
          "args": [
            "(void *)area->start",
            "(void *)(area->start + area->size)",
            "object"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "scan_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1329-1395",
          "snippet": "static void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define BYTES_PER_POINTER\tsizeof(void *)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static DEFINE_MUTEX(scan_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define BYTES_PER_POINTER\tsizeof(void *)\n\nstatic LIST_HEAD(object_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic DEFINE_MUTEX(scan_mutex);\n\nstatic void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "area",
            "&object->area_list",
            "node"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "start + MAX_SCAN_SIZE",
            "end"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&object->area_list"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_NO_SCAN\t\t(1 << 2)\n#define OBJECT_ALLOCATED\t(1 << 0)\n#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */\n\nstatic void scan_object(struct kmemleak_object *object)\n{\n\tstruct kmemleak_scan_area *area;\n\tunsigned long flags;\n\n\t/*\n\t * Once the object->lock is acquired, the corresponding memory block\n\t * cannot be freed (the same lock is acquired in delete_object).\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (object->flags & OBJECT_NO_SCAN)\n\t\tgoto out;\n\tif (!(object->flags & OBJECT_ALLOCATED))\n\t\t/* already freed object */\n\t\tgoto out;\n\tif (hlist_empty(&object->area_list)) {\n\t\tvoid *start = (void *)object->pointer;\n\t\tvoid *end = (void *)(object->pointer + object->size);\n\t\tvoid *next;\n\n\t\tdo {\n\t\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\t\tscan_block(start, next, object);\n\n\t\t\tstart = next;\n\t\t\tif (start >= end)\n\t\t\t\tbreak;\n\n\t\t\tspin_unlock_irqrestore(&object->lock, flags);\n\t\t\tcond_resched();\n\t\t\tspin_lock_irqsave(&object->lock, flags);\n\t\t} while (object->flags & OBJECT_ALLOCATED);\n\t} else\n\t\thlist_for_each_entry(area, &object->area_list, node)\n\t\t\tscan_block((void *)area->start,\n\t\t\t\t   (void *)(area->start + area->size),\n\t\t\t\t   object);\nout:\n\tspin_unlock_irqrestore(&object->lock, flags);\n}"
  },
  {
    "function_name": "scan_large_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1400-1410",
    "snippet": "static void scan_large_block(void *start, void *end)\n{\n\tvoid *next;\n\n\twhile (start < end) {\n\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\tscan_block(start, next, NULL);\n\t\tstart = next;\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_block",
          "args": [
            "start",
            "next",
            "NULL"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "scan_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1329-1395",
          "snippet": "static void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define BYTES_PER_POINTER\tsizeof(void *)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static DEFINE_MUTEX(scan_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define BYTES_PER_POINTER\tsizeof(void *)\n\nstatic LIST_HEAD(object_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic DEFINE_MUTEX(scan_mutex);\n\nstatic void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "start + MAX_SCAN_SIZE",
            "end"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_SCAN_SIZE\t\t4096\t/* maximum size of a scanned block */\n\nstatic void scan_large_block(void *start, void *end)\n{\n\tvoid *next;\n\n\twhile (start < end) {\n\t\tnext = min(start + MAX_SCAN_SIZE, end);\n\t\tscan_block(start, next, NULL);\n\t\tstart = next;\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "scan_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1329-1395",
    "snippet": "static void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BYTES_PER_POINTER\tsizeof(void *)"
    ],
    "globals_used": [
      "static LIST_HEAD(object_list);",
      "static struct rb_root object_tree_root = RB_ROOT;",
      "static DEFINE_RWLOCK(kmemleak_lock);",
      "static unsigned long min_addr = ULONG_MAX;",
      "static unsigned long max_addr;",
      "static DEFINE_MUTEX(scan_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_refs",
          "args": [
            "object"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "update_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1283-1302",
          "snippet": "static void update_refs(struct kmemleak_object *object)\n{\n\tif (!color_white(object)) {\n\t\t/* non-orphan, ignored or new */\n\t\treturn;\n\t}\n\n\t/*\n\t * Increase the object's reference count (number of pointers to the\n\t * memory block). If this count reaches the required minimum, the\n\t * object's color will become gray and it will be added to the\n\t * gray_list.\n\t */\n\tobject->count++;\n\tif (color_gray(object)) {\n\t\t/* put_object() called when removing from gray_list */\n\t\tWARN_ON(!get_object(object));\n\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(gray_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(gray_list);\n\nstatic void update_refs(struct kmemleak_object *object)\n{\n\tif (!color_white(object)) {\n\t\t/* non-orphan, ignored or new */\n\t\treturn;\n\t}\n\n\t/*\n\t * Increase the object's reference count (number of pointers to the\n\t * memory block). If this count reaches the required minimum, the\n\t * object's color will become gray and it will be added to the\n\t * gray_list.\n\t */\n\tobject->count++;\n\tif (color_gray(object)) {\n\t\t/* put_object() called when removing from gray_list */\n\t\tWARN_ON(!get_object(object));\n\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&object->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_object",
          "args": [
            "excess_ref",
            "0"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "436-457",
          "snippet": "static struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root object_tree_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct rb_root object_tree_root = RB_ROOT;\n\nstatic struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "color_gray",
          "args": [
            "object"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "color_gray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "364-368",
          "snippet": "static bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&object->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_enable_current",
          "args": [],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_enable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "43-46",
          "snippet": "void kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_disable_current",
          "args": [],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_disable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "48-51",
          "snippet": "void kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_should_stop",
          "args": [],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "scan_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1308-1323",
          "snippet": "static int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\n\nstatic int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ALIGN",
          "args": [
            "_start",
            "BYTES_PER_POINTER"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define BYTES_PER_POINTER\tsizeof(void *)\n\nstatic LIST_HEAD(object_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic DEFINE_MUTEX(scan_mutex);\n\nstatic void scan_block(void *_start, void *_end,\n\t\t       struct kmemleak_object *scanned)\n{\n\tunsigned long *ptr;\n\tunsigned long *start = PTR_ALIGN(_start, BYTES_PER_POINTER);\n\tunsigned long *end = _end - (BYTES_PER_POINTER - 1);\n\tunsigned long flags;\n\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tstruct kmemleak_object *object;\n\t\tunsigned long pointer;\n\t\tunsigned long excess_ref;\n\n\t\tif (scan_should_stop())\n\t\t\tbreak;\n\n\t\tkasan_disable_current();\n\t\tpointer = *ptr;\n\t\tkasan_enable_current();\n\n\t\tif (pointer < min_addr || pointer >= max_addr)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need for get_object() here since we hold kmemleak_lock.\n\t\t * object->use_count cannot be dropped to 0 while the object\n\t\t * is still present in object_tree_root and object_list\n\t\t * (with updates protected by kmemleak_lock).\n\t\t */\n\t\tobject = lookup_object(pointer, 1);\n\t\tif (!object)\n\t\t\tcontinue;\n\t\tif (object == scanned)\n\t\t\t/* self referenced, ignore */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Avoid the lockdep recursive warning on object->lock being\n\t\t * previously acquired in scan_object(). These locks are\n\t\t * enclosed by scan_mutex.\n\t\t */\n\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t/* only pass surplus references (object already gray) */\n\t\tif (color_gray(object)) {\n\t\t\texcess_ref = object->excess_ref;\n\t\t\t/* no need for update_refs() if object already gray */\n\t\t} else {\n\t\t\texcess_ref = 0;\n\t\t\tupdate_refs(object);\n\t\t}\n\t\tspin_unlock(&object->lock);\n\n\t\tif (excess_ref) {\n\t\t\tobject = lookup_object(excess_ref, 0);\n\t\t\tif (!object)\n\t\t\t\tcontinue;\n\t\t\tif (object == scanned)\n\t\t\t\t/* circular reference, ignore */\n\t\t\t\tcontinue;\n\t\t\tspin_lock_nested(&object->lock, SINGLE_DEPTH_NESTING);\n\t\t\tupdate_refs(object);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n}"
  },
  {
    "function_name": "scan_should_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1308-1323",
    "snippet": "static int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\n\nstatic int scan_should_stop(void)\n{\n\tif (!kmemleak_enabled)\n\t\treturn 1;\n\n\t/*\n\t * This function may be called from either process or kthread context,\n\t * hence the need to check for both stop conditions.\n\t */\n\tif (current->mm)\n\t\treturn signal_pending(current);\n\telse\n\t\treturn kthread_should_stop();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1283-1302",
    "snippet": "static void update_refs(struct kmemleak_object *object)\n{\n\tif (!color_white(object)) {\n\t\t/* non-orphan, ignored or new */\n\t\treturn;\n\t}\n\n\t/*\n\t * Increase the object's reference count (number of pointers to the\n\t * memory block). If this count reaches the required minimum, the\n\t * object's color will become gray and it will be added to the\n\t * gray_list.\n\t */\n\tobject->count++;\n\tif (color_gray(object)) {\n\t\t/* put_object() called when removing from gray_list */\n\t\tWARN_ON(!get_object(object));\n\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(gray_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&object->gray_list",
            "&gray_list"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!get_object(object)"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_object",
          "args": [
            "object"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "465-468",
          "snippet": "static int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "color_gray",
          "args": [
            "object"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "color_gray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "364-368",
          "snippet": "static bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "color_white",
          "args": [
            "object"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "color_white",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "358-362",
          "snippet": "static bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(gray_list);\n\nstatic void update_refs(struct kmemleak_object *object)\n{\n\tif (!color_white(object)) {\n\t\t/* non-orphan, ignored or new */\n\t\treturn;\n\t}\n\n\t/*\n\t * Increase the object's reference count (number of pointers to the\n\t * memory block). If this count reaches the required minimum, the\n\t * object's color will become gray and it will be added to the\n\t * gray_list.\n\t */\n\tobject->count++;\n\tif (color_gray(object)) {\n\t\t/* put_object() called when removing from gray_list */\n\t\tWARN_ON(!get_object(object));\n\t\tlist_add_tail(&object->gray_list, &gray_list);\n\t}\n}"
  },
  {
    "function_name": "update_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1269-1278",
    "snippet": "static bool update_checksum(struct kmemleak_object *object)\n{\n\tu32 old_csum = object->checksum;\n\n\tkasan_disable_current();\n\tobject->checksum = crc32(0, (void *)object->pointer, object->size);\n\tkasan_enable_current();\n\n\treturn object->checksum != old_csum;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_enable_current",
          "args": [],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_enable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "43-46",
          "snippet": "void kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32",
          "args": [
            "0",
            "(void *)object->pointer",
            "object->size"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_disable_current",
          "args": [],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_disable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "48-51",
          "snippet": "void kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic bool update_checksum(struct kmemleak_object *object)\n{\n\tu32 old_csum = object->checksum;\n\n\tkasan_disable_current();\n\tobject->checksum = crc32(0, (void *)object->pointer, object->size);\n\tkasan_enable_current();\n\n\treturn object->checksum != old_csum;\n}"
  },
  {
    "function_name": "kmemleak_ignore_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1259-1263",
    "snippet": "void __ref kmemleak_ignore_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_ignore(__va(phys));\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_ignore",
          "args": [
            "__va(phys)"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_ignore_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1259-1263",
          "snippet": "void __ref kmemleak_ignore_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_ignore(__va(phys));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "phys"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "phys"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIGHMEM"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_ignore_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_ignore(__va(phys));\n}"
  },
  {
    "function_name": "kmemleak_not_leak_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1247-1251",
    "snippet": "void __ref kmemleak_not_leak_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_not_leak(__va(phys));\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_not_leak",
          "args": [
            "__va(phys)"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_not_leak_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1247-1251",
          "snippet": "void __ref kmemleak_not_leak_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_not_leak(__va(phys));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "phys"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "phys"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIGHMEM"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_not_leak_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_not_leak(__va(phys));\n}"
  },
  {
    "function_name": "kmemleak_free_part_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1235-1239",
    "snippet": "void __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_free_part",
          "args": [
            "__va(phys)",
            "size"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_part_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1235-1239",
          "snippet": "void __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "phys"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "phys"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIGHMEM"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_free_part_phys(phys_addr_t phys, size_t size)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_free_part(__va(phys), size);\n}"
  },
  {
    "function_name": "kmemleak_alloc_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1220-1225",
    "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "__va(phys)",
            "size",
            "min_count",
            "gfp"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "phys"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "phys"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIGHMEM"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
  },
  {
    "function_name": "kmemleak_no_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1200-1208",
    "snippet": "void __ref kmemleak_no_scan(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tobject_no_scan((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NO_SCAN, ptr, 0, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_NO_SCAN",
            "ptr",
            "0",
            "0"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_no_scan",
          "args": [
            "(unsigned long)ptr"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "object_no_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "855-870",
          "snippet": "static void object_no_scan(unsigned long ptr)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Not scanning unknown object at 0x%08lx\\n\", ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags |= OBJECT_NO_SCAN;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_NO_SCAN\t\t(1 << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_NO_SCAN\t\t(1 << 2)\n\nstatic void object_no_scan(unsigned long ptr)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Not scanning unknown object at 0x%08lx\\n\", ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags |= OBJECT_NO_SCAN;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_no_scan(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tobject_no_scan((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NO_SCAN, ptr, 0, 0);\n}"
  },
  {
    "function_name": "kmemleak_scan_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1180-1188",
    "snippet": "void __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && size && !IS_ERR(ptr))\n\t\tadd_scan_area((unsigned long)ptr, size, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_SCAN_AREA, ptr, size, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_SCAN_AREA",
            "ptr",
            "size",
            "0"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_scan_area",
          "args": [
            "(unsigned long)ptr",
            "size",
            "gfp"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "add_scan_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "786-824",
          "snippet": "static void add_scan_area(unsigned long ptr, size_t size, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tstruct kmemleak_scan_area *area;\n\n\tobject = find_and_get_object(ptr, 1);\n\tif (!object) {\n\t\tkmemleak_warn(\"Adding scan area to unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tarea = kmem_cache_alloc(scan_area_cache, gfp_kmemleak_mask(gfp));\n\tif (!area) {\n\t\tpr_warn(\"Cannot allocate a scan area\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (size == SIZE_MAX) {\n\t\tsize = object->pointer + object->size - ptr;\n\t} else if (ptr + size > object->pointer + object->size) {\n\t\tkmemleak_warn(\"Scan area larger than object 0x%08lx\\n\", ptr);\n\t\tdump_object_info(object);\n\t\tkmem_cache_free(scan_area_cache, area);\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_HLIST_NODE(&area->node);\n\tarea->start = ptr;\n\tarea->size = size;\n\n\thlist_add_head(&area->node, &object->area_list);\nout_unlock:\n\tspin_unlock_irqrestore(&object->lock, flags);\nout:\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *scan_area_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache *scan_area_cache;\n\nstatic void add_scan_area(unsigned long ptr, size_t size, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tstruct kmemleak_scan_area *area;\n\n\tobject = find_and_get_object(ptr, 1);\n\tif (!object) {\n\t\tkmemleak_warn(\"Adding scan area to unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tarea = kmem_cache_alloc(scan_area_cache, gfp_kmemleak_mask(gfp));\n\tif (!area) {\n\t\tpr_warn(\"Cannot allocate a scan area\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (size == SIZE_MAX) {\n\t\tsize = object->pointer + object->size - ptr;\n\t} else if (ptr + size > object->pointer + object->size) {\n\t\tkmemleak_warn(\"Scan area larger than object 0x%08lx\\n\", ptr);\n\t\tdump_object_info(object);\n\t\tkmem_cache_free(scan_area_cache, area);\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_HLIST_NODE(&area->node);\n\tarea->start = ptr;\n\tarea->size = size;\n\n\thlist_add_head(&area->node, &object->area_list);\nout_unlock:\n\tspin_unlock_irqrestore(&object->lock, flags);\nout:\n\tput_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && size && !IS_ERR(ptr))\n\t\tadd_scan_area((unsigned long)ptr, size, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_SCAN_AREA, ptr, size, 0);\n}"
  },
  {
    "function_name": "kmemleak_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1158-1166",
    "snippet": "void __ref kmemleak_ignore(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tmake_black_object((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_IGNORE, ptr, 0, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_IGNORE",
            "ptr",
            "0",
            "0"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_black_object",
          "args": [
            "(unsigned long)ptr"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "make_black_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "777-780",
          "snippet": "static void make_black_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_BLACK);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic void make_black_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_BLACK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_ignore(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tmake_black_object((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_IGNORE, ptr, 0, 0);\n}"
  },
  {
    "function_name": "kmemleak_not_leak",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1138-1146",
    "snippet": "void __ref kmemleak_not_leak(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tmake_gray_object((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NOT_LEAK, ptr, 0, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_NOT_LEAK",
            "ptr",
            "0",
            "0"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_gray_object",
          "args": [
            "(unsigned long)ptr"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "make_gray_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "768-771",
          "snippet": "static void make_gray_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_GREY);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_GREY\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_GREY\t0\n\nstatic void make_gray_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_GREY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_not_leak(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tmake_gray_object((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_NOT_LEAK, ptr, 0, 0);\n}"
  },
  {
    "function_name": "kmemleak_update_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1104-1128",
    "snippet": "void __ref kmemleak_update_trace(const void *ptr)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (!kmemleak_enabled || IS_ERR_OR_NULL(ptr))\n\t\treturn;\n\n\tobject = find_and_get_object((unsigned long)ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Updating stack trace for unknown object at %p\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->trace_len = __save_stack_trace(object->trace);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_stack_trace",
          "args": [
            "object->trace"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "__save_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "554-565",
          "snippet": "static int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_TRACE\t\t16\t/* stack trace length */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_TRACE\t\t16\t/* stack trace length */\n\nstatic int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Updating stack trace for unknown object at %p\\n\"",
            "ptr"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_get_object",
          "args": [
            "(unsigned long)ptr",
            "1"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "512-528",
          "snippet": "static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "ptr"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\n\nvoid __ref kmemleak_update_trace(const void *ptr)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (!kmemleak_enabled || IS_ERR_OR_NULL(ptr))\n\t\treturn;\n\n\tobject = find_and_get_object((unsigned long)ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Updating stack trace for unknown object at %p\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->trace_len = __save_stack_trace(object->trace);\n\tspin_unlock_irqrestore(&object->lock, flags);\n\n\tput_object(object);\n}"
  },
  {
    "function_name": "kmemleak_free_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1082-1094",
    "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_free_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_FREE_PERCPU",
            "ptr",
            "0",
            "0"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_object_full",
          "args": [
            "(unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu)"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "delete_object_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "679-692",
          "snippet": "static void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ptr",
            "cpu"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_possible_cpu",
          "args": [
            "cpu"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
  },
  {
    "function_name": "kmemleak_free_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1064-1072",
    "snippet": "void __ref kmemleak_free_part(const void *ptr, size_t size)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tdelete_object_part((unsigned long)ptr, size);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PART, ptr, size, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_FREE_PART",
            "ptr",
            "size",
            "0"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_object_part",
          "args": [
            "(unsigned long)ptr",
            "size"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "delete_object_part",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "699-730",
          "snippet": "static void delete_object_part(unsigned long ptr, size_t size)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long start, end;\n\n\tobject = find_and_remove_object(ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Partially freeing unknown object at 0x%08lx (size %zu)\\n\",\n\t\t\t      ptr, size);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Create one or two objects that may result from the memory block\n\t * split. Note that partial freeing is only done by free_bootmem() and\n\t * this happens before kmemleak_init() is called. The path below is\n\t * only executed during early log recording in kmemleak_init(), so\n\t * GFP_KERNEL is enough.\n\t */\n\tstart = object->pointer;\n\tend = object->pointer + object->size;\n\tif (ptr > start)\n\t\tcreate_object(start, ptr - start, object->min_count,\n\t\t\t      GFP_KERNEL);\n\tif (ptr + size < end)\n\t\tcreate_object(ptr + size, end - ptr - size, object->min_count,\n\t\t\t      GFP_KERNEL);\n\n\t__delete_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void delete_object_part(unsigned long ptr, size_t size)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long start, end;\n\n\tobject = find_and_remove_object(ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Partially freeing unknown object at 0x%08lx (size %zu)\\n\",\n\t\t\t      ptr, size);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Create one or two objects that may result from the memory block\n\t * split. Note that partial freeing is only done by free_bootmem() and\n\t * this happens before kmemleak_init() is called. The path below is\n\t * only executed during early log recording in kmemleak_init(), so\n\t * GFP_KERNEL is enough.\n\t */\n\tstart = object->pointer;\n\tend = object->pointer + object->size;\n\tif (ptr > start)\n\t\tcreate_object(start, ptr - start, object->min_count,\n\t\t\t      GFP_KERNEL);\n\tif (ptr + size < end)\n\t\tcreate_object(ptr + size, end - ptr - size, object->min_count,\n\t\t\t      GFP_KERNEL);\n\n\t__delete_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_part(const void *ptr, size_t size)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tdelete_object_part((unsigned long)ptr, size);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PART, ptr, size, 0);\n}"
  },
  {
    "function_name": "kmemleak_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1044-1052",
    "snippet": "void __ref kmemleak_free(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tdelete_object_full((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE, ptr, 0, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_free_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_FREE",
            "ptr",
            "0",
            "0"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_object_full",
          "args": [
            "(unsigned long)ptr"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "delete_object_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "679-692",
          "snippet": "static void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p)\\n\"",
            "__func__",
            "ptr"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free(const void *ptr)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tdelete_object_full((unsigned long)ptr);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE, ptr, 0, 0);\n}"
  },
  {
    "function_name": "kmemleak_vmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "1016-1034",
    "snippet": "void __ref kmemleak_vmalloc(const struct vm_struct *area, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, area, size);\n\n\t/*\n\t * A min_count = 2 is needed because vm_struct contains a reference to\n\t * the virtual address of the vmalloc'ed block.\n\t */\n\tif (kmemleak_enabled) {\n\t\tcreate_object((unsigned long)area->addr, size, 2, gfp);\n\t\tobject_set_excess_ref((unsigned long)area,\n\t\t\t\t      (unsigned long)area->addr);\n\t} else if (kmemleak_early_log) {\n\t\tlog_early(KMEMLEAK_ALLOC, area->addr, size, 2);\n\t\t/* reusing early_log.size for storing area->addr */\n\t\tlog_early(KMEMLEAK_SET_EXCESS_REF,\n\t\t\t  area, (unsigned long)area->addr, 0);\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;",
      "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_SET_EXCESS_REF",
            "area",
            "(unsigned long)area->addr",
            "0"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_set_excess_ref",
          "args": [
            "(unsigned long)area",
            "(unsigned long)area->addr"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "object_set_excess_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "832-848",
          "snippet": "static void object_set_excess_ref(unsigned long ptr, unsigned long excess_ref)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Setting excess_ref on unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->excess_ref = excess_ref;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void object_set_excess_ref(unsigned long ptr, unsigned long excess_ref)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Setting excess_ref on unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->excess_ref = excess_ref;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_object",
          "args": [
            "(unsigned long)area->addr",
            "size",
            "2",
            "gfp"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "571-653",
          "snippet": "static struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static LIST_HEAD(gray_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static struct kmem_cache *object_cache;",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic struct kmem_cache *object_cache;\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic void kmemleak_disable(void);\n\nstatic struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p, %zu)\\n\"",
            "__func__",
            "area",
            "size"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nvoid __ref kmemleak_vmalloc(const struct vm_struct *area, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, area, size);\n\n\t/*\n\t * A min_count = 2 is needed because vm_struct contains a reference to\n\t * the virtual address of the vmalloc'ed block.\n\t */\n\tif (kmemleak_enabled) {\n\t\tcreate_object((unsigned long)area->addr, size, 2, gfp);\n\t\tobject_set_excess_ref((unsigned long)area,\n\t\t\t\t      (unsigned long)area->addr);\n\t} else if (kmemleak_early_log) {\n\t\tlog_early(KMEMLEAK_ALLOC, area->addr, size, 2);\n\t\t/* reusing early_log.size for storing area->addr */\n\t\tlog_early(KMEMLEAK_SET_EXCESS_REF,\n\t\t\t  area, (unsigned long)area->addr, 0);\n\t}\n}"
  },
  {
    "function_name": "kmemleak_alloc_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "987-1004",
    "snippet": "void __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,\n\t\t\t\t gfp_t gfp)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, ptr, size);\n\n\t/*\n\t * Percpu allocations are only scanned and not reported as leaks\n\t * (min_count is set to 0).\n\t */\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tcreate_object((unsigned long)per_cpu_ptr(ptr, cpu),\n\t\t\t\t      size, 0, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_ALLOC_PERCPU, ptr, size, 0);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_ALLOC_PERCPU",
            "ptr",
            "size",
            "0"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_object",
          "args": [
            "(unsigned long)per_cpu_ptr(ptr, cpu)",
            "size",
            "0",
            "gfp"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "571-653",
          "snippet": "static struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static LIST_HEAD(gray_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static struct kmem_cache *object_cache;",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic struct kmem_cache *object_cache;\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic void kmemleak_disable(void);\n\nstatic struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ptr",
            "cpu"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_possible_cpu",
          "args": [
            "cpu"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p, %zu)\\n\"",
            "__func__",
            "ptr",
            "size"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,\n\t\t\t\t gfp_t gfp)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, ptr, size);\n\n\t/*\n\t * Percpu allocations are only scanned and not reported as leaks\n\t * (min_count is set to 0).\n\t */\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tcreate_object((unsigned long)per_cpu_ptr(ptr, cpu),\n\t\t\t\t      size, 0, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_ALLOC_PERCPU, ptr, size, 0);\n}"
  },
  {
    "function_name": "kmemleak_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "966-975",
    "snippet": "void __ref kmemleak_alloc(const void *ptr, size_t size, int min_count,\n\t\t\t  gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p, %zu, %d)\\n\", __func__, ptr, size, min_count);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tcreate_object((unsigned long)ptr, size, min_count, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_ALLOC, ptr, size, min_count);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static int kmemleak_early_log = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_early",
          "args": [
            "KMEMLEAK_ALLOC",
            "ptr",
            "size",
            "min_count"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "log_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "876-907",
          "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_error;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
            "static int crt_early_log",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_object",
          "args": [
            "(unsigned long)ptr",
            "size",
            "min_count",
            "gfp"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "571-653",
          "snippet": "static struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static LIST_HEAD(gray_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static struct kmem_cache *object_cache;",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic struct kmem_cache *object_cache;\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic void kmemleak_disable(void);\n\nstatic struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(0x%p, %zu, %d)\\n\"",
            "__func__",
            "ptr",
            "size",
            "min_count"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_alloc(const void *ptr, size_t size, int min_count,\n\t\t\t  gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p, %zu, %d)\\n\", __func__, ptr, size, min_count);\n\n\tif (kmemleak_enabled && ptr && !IS_ERR(ptr))\n\t\tcreate_object((unsigned long)ptr, size, min_count, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_ALLOC, ptr, size, min_count);\n}"
  },
  {
    "function_name": "early_alloc_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "941-950",
    "snippet": "static void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_alloc",
          "args": [
            "log"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "early_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "941-950",
          "snippet": "static void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ptr",
            "cpu"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}"
  },
  {
    "function_name": "early_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "912-936",
    "snippet": "static void early_alloc(struct early_log *log)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\tint i;\n\n\tif (!kmemleak_enabled || !log->ptr || IS_ERR(log->ptr))\n\t\treturn;\n\n\t/*\n\t * RCU locking needed to ensure object is not freed via put_object().\n\t */\n\trcu_read_lock();\n\tobject = create_object((unsigned long)log->ptr, log->size,\n\t\t\t       log->min_count, GFP_ATOMIC);\n\tif (!object)\n\t\tgoto out;\n\tspin_lock_irqsave(&object->lock, flags);\n\tfor (i = 0; i < log->trace_len; i++)\n\t\tobject->trace[i] = log->trace[i];\n\tobject->trace_len = log->trace_len;\n\tspin_unlock_irqrestore(&object->lock, flags);\nout:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_enabled;",
      "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_object",
          "args": [
            "(unsigned long)log->ptr",
            "log->size",
            "log->min_count",
            "GFP_ATOMIC"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "571-653",
          "snippet": "static struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static LIST_HEAD(gray_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static struct kmem_cache *object_cache;",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic struct kmem_cache *object_cache;\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic void kmemleak_disable(void);\n\nstatic struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "log->ptr"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void early_alloc(struct early_log *log)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long flags;\n\tint i;\n\n\tif (!kmemleak_enabled || !log->ptr || IS_ERR(log->ptr))\n\t\treturn;\n\n\t/*\n\t * RCU locking needed to ensure object is not freed via put_object().\n\t */\n\trcu_read_lock();\n\tobject = create_object((unsigned long)log->ptr, log->size,\n\t\t\t       log->min_count, GFP_ATOMIC);\n\tif (!object)\n\t\tgoto out;\n\tspin_lock_irqsave(&object->lock, flags);\n\tfor (i = 0; i < log->trace_len; i++)\n\t\tobject->trace[i] = log->trace[i];\n\tobject->trace_len = log->trace_len;\n\tspin_unlock_irqrestore(&object->lock, flags);\nout:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "log_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "876-907",
    "snippet": "static void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kmemleak_error;",
      "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]",
      "static int crt_early_log",
      "static void kmemleak_disable(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_stack_trace",
          "args": [
            "log->trace"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "__save_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "554-565",
          "snippet": "static int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_TRACE\t\t16\t/* stack trace length */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_TRACE\t\t16\t/* stack trace length */\n\nstatic int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_disable",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1983-1999",
          "snippet": "static void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_free_enabled;",
            "static int kmemleak_initialized;",
            "static int kmemleak_error;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_initialized;\nstatic int kmemleak_error;\nstatic void kmemleak_disable(void);\n\nstatic void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "early_log"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_error;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\nstatic int crt_early_log;\nstatic void kmemleak_disable(void);\n\nstatic void __init log_early(int op_type, const void *ptr, size_t size,\n\t\t\t     int min_count)\n{\n\tunsigned long flags;\n\tstruct early_log *log;\n\n\tif (kmemleak_error) {\n\t\t/* kmemleak stopped recording, just count the requests */\n\t\tcrt_early_log++;\n\t\treturn;\n\t}\n\n\tif (crt_early_log >= ARRAY_SIZE(early_log)) {\n\t\tcrt_early_log++;\n\t\tkmemleak_disable();\n\t\treturn;\n\t}\n\n\t/*\n\t * There is no need for locking since the kernel is still in UP mode\n\t * at this stage. Disabling the IRQs is enough.\n\t */\n\tlocal_irq_save(flags);\n\tlog = &early_log[crt_early_log];\n\tlog->op_type = op_type;\n\tlog->ptr = ptr;\n\tlog->size = size;\n\tlog->min_count = min_count;\n\tlog->trace_len = __save_stack_trace(log->trace);\n\tcrt_early_log++;\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "object_no_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "855-870",
    "snippet": "static void object_no_scan(unsigned long ptr)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Not scanning unknown object at 0x%08lx\\n\", ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags |= OBJECT_NO_SCAN;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_NO_SCAN\t\t(1 << 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Not scanning unknown object at 0x%08lx\\n\"",
            "ptr"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_get_object",
          "args": [
            "ptr",
            "0"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "512-528",
          "snippet": "static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_NO_SCAN\t\t(1 << 2)\n\nstatic void object_no_scan(unsigned long ptr)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Not scanning unknown object at 0x%08lx\\n\", ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags |= OBJECT_NO_SCAN;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
  },
  {
    "function_name": "object_set_excess_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "832-848",
    "snippet": "static void object_set_excess_ref(unsigned long ptr, unsigned long excess_ref)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Setting excess_ref on unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->excess_ref = excess_ref;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Setting excess_ref on unknown object at 0x%08lx\\n\"",
            "ptr"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_get_object",
          "args": [
            "ptr",
            "0"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "512-528",
          "snippet": "static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void object_set_excess_ref(unsigned long ptr, unsigned long excess_ref)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Setting excess_ref on unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->excess_ref = excess_ref;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
  },
  {
    "function_name": "add_scan_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "786-824",
    "snippet": "static void add_scan_area(unsigned long ptr, size_t size, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tstruct kmemleak_scan_area *area;\n\n\tobject = find_and_get_object(ptr, 1);\n\tif (!object) {\n\t\tkmemleak_warn(\"Adding scan area to unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tarea = kmem_cache_alloc(scan_area_cache, gfp_kmemleak_mask(gfp));\n\tif (!area) {\n\t\tpr_warn(\"Cannot allocate a scan area\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (size == SIZE_MAX) {\n\t\tsize = object->pointer + object->size - ptr;\n\t} else if (ptr + size > object->pointer + object->size) {\n\t\tkmemleak_warn(\"Scan area larger than object 0x%08lx\\n\", ptr);\n\t\tdump_object_info(object);\n\t\tkmem_cache_free(scan_area_cache, area);\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_HLIST_NODE(&area->node);\n\tarea->start = ptr;\n\tarea->size = size;\n\n\thlist_add_head(&area->node, &object->area_list);\nout_unlock:\n\tspin_unlock_irqrestore(&object->lock, flags);\nout:\n\tput_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *scan_area_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&area->node",
            "&object->area_list"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&area->node"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "scan_area_cache",
            "area"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_object_info",
          "args": [
            "object"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "dump_object_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "411-428",
          "snippet": "static void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Scan area larger than object 0x%08lx\\n\"",
            "ptr"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot allocate a scan area\\n\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "scan_area_cache",
            "gfp_kmemleak_mask(gfp)"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_kmemleak_mask",
          "args": [
            "gfp"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Adding scan area to unknown object at 0x%08lx\\n\"",
            "ptr"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_get_object",
          "args": [
            "ptr",
            "1"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "512-528",
          "snippet": "static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache *scan_area_cache;\n\nstatic void add_scan_area(unsigned long ptr, size_t size, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\tstruct kmemleak_scan_area *area;\n\n\tobject = find_and_get_object(ptr, 1);\n\tif (!object) {\n\t\tkmemleak_warn(\"Adding scan area to unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n\t\treturn;\n\t}\n\n\tarea = kmem_cache_alloc(scan_area_cache, gfp_kmemleak_mask(gfp));\n\tif (!area) {\n\t\tpr_warn(\"Cannot allocate a scan area\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&object->lock, flags);\n\tif (size == SIZE_MAX) {\n\t\tsize = object->pointer + object->size - ptr;\n\t} else if (ptr + size > object->pointer + object->size) {\n\t\tkmemleak_warn(\"Scan area larger than object 0x%08lx\\n\", ptr);\n\t\tdump_object_info(object);\n\t\tkmem_cache_free(scan_area_cache, area);\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_HLIST_NODE(&area->node);\n\tarea->start = ptr;\n\tarea->size = size;\n\n\thlist_add_head(&area->node, &object->area_list);\nout_unlock:\n\tspin_unlock_irqrestore(&object->lock, flags);\nout:\n\tput_object(object);\n}"
  },
  {
    "function_name": "make_black_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "777-780",
    "snippet": "static void make_black_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_BLACK);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define KMEMLEAK_BLACK\t-1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "paint_ptr",
          "args": [
            "ptr",
            "KMEMLEAK_BLACK"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "paint_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "748-762",
          "snippet": "static void paint_ptr(unsigned long ptr, int color)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Trying to color unknown object at 0x%08lx as %s\\n\",\n\t\t\t      ptr,\n\t\t\t      (color == KMEMLEAK_GREY) ? \"Grey\" :\n\t\t\t      (color == KMEMLEAK_BLACK) ? \"Black\" : \"Unknown\");\n\t\treturn;\n\t}\n\tpaint_it(object, color);\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1",
            "#define KMEMLEAK_GREY\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n#define KMEMLEAK_GREY\t0\n\nstatic void paint_ptr(unsigned long ptr, int color)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Trying to color unknown object at 0x%08lx as %s\\n\",\n\t\t\t      ptr,\n\t\t\t      (color == KMEMLEAK_GREY) ? \"Grey\" :\n\t\t\t      (color == KMEMLEAK_BLACK) ? \"Black\" : \"Unknown\");\n\t\treturn;\n\t}\n\tpaint_it(object, color);\n\tput_object(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic void make_black_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_BLACK);\n}"
  },
  {
    "function_name": "make_gray_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "768-771",
    "snippet": "static void make_gray_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_GREY);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define KMEMLEAK_GREY\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "paint_ptr",
          "args": [
            "ptr",
            "KMEMLEAK_GREY"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "paint_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "748-762",
          "snippet": "static void paint_ptr(unsigned long ptr, int color)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Trying to color unknown object at 0x%08lx as %s\\n\",\n\t\t\t      ptr,\n\t\t\t      (color == KMEMLEAK_GREY) ? \"Grey\" :\n\t\t\t      (color == KMEMLEAK_BLACK) ? \"Black\" : \"Unknown\");\n\t\treturn;\n\t}\n\tpaint_it(object, color);\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1",
            "#define KMEMLEAK_GREY\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n#define KMEMLEAK_GREY\t0\n\nstatic void paint_ptr(unsigned long ptr, int color)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Trying to color unknown object at 0x%08lx as %s\\n\",\n\t\t\t      ptr,\n\t\t\t      (color == KMEMLEAK_GREY) ? \"Grey\" :\n\t\t\t      (color == KMEMLEAK_BLACK) ? \"Black\" : \"Unknown\");\n\t\treturn;\n\t}\n\tpaint_it(object, color);\n\tput_object(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_GREY\t0\n\nstatic void make_gray_object(unsigned long ptr)\n{\n\tpaint_ptr(ptr, KMEMLEAK_GREY);\n}"
  },
  {
    "function_name": "paint_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "748-762",
    "snippet": "static void paint_ptr(unsigned long ptr, int color)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Trying to color unknown object at 0x%08lx as %s\\n\",\n\t\t\t      ptr,\n\t\t\t      (color == KMEMLEAK_GREY) ? \"Grey\" :\n\t\t\t      (color == KMEMLEAK_BLACK) ? \"Black\" : \"Unknown\");\n\t\treturn;\n\t}\n\tpaint_it(object, color);\n\tput_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define KMEMLEAK_BLACK\t-1",
      "#define KMEMLEAK_GREY\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "paint_it",
          "args": [
            "object",
            "color"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "paint_it",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "739-746",
          "snippet": "static void paint_it(struct kmemleak_object *object, int color)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&object->lock, flags);\n\t__paint_it(object, color);\n\tspin_unlock_irqrestore(&object->lock, flags);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void paint_it(struct kmemleak_object *object, int color)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&object->lock, flags);\n\t__paint_it(object, color);\n\tspin_unlock_irqrestore(&object->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Trying to color unknown object at 0x%08lx as %s\\n\"",
            "ptr",
            "(color == KMEMLEAK_GREY) ? \"Grey\" :\n\t\t\t      (color == KMEMLEAK_BLACK) ? \"Black\" : \"Unknown\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_get_object",
          "args": [
            "ptr",
            "0"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "512-528",
          "snippet": "static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n#define KMEMLEAK_GREY\t0\n\nstatic void paint_ptr(unsigned long ptr, int color)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_get_object(ptr, 0);\n\tif (!object) {\n\t\tkmemleak_warn(\"Trying to color unknown object at 0x%08lx as %s\\n\",\n\t\t\t      ptr,\n\t\t\t      (color == KMEMLEAK_GREY) ? \"Grey\" :\n\t\t\t      (color == KMEMLEAK_BLACK) ? \"Black\" : \"Unknown\");\n\t\treturn;\n\t}\n\tpaint_it(object, color);\n\tput_object(object);\n}"
  },
  {
    "function_name": "paint_it",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "739-746",
    "snippet": "static void paint_it(struct kmemleak_object *object, int color)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&object->lock, flags);\n\t__paint_it(object, color);\n\tspin_unlock_irqrestore(&object->lock, flags);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__paint_it",
          "args": [
            "object",
            "color"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__paint_it",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "732-737",
          "snippet": "static void __paint_it(struct kmemleak_object *object, int color)\n{\n\tobject->min_count = color;\n\tif (color == KMEMLEAK_BLACK)\n\t\tobject->flags |= OBJECT_NO_SCAN;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_NO_SCAN\t\t(1 << 2)",
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_NO_SCAN\t\t(1 << 2)\n#define KMEMLEAK_BLACK\t-1\n\nstatic void __paint_it(struct kmemleak_object *object, int color)\n{\n\tobject->min_count = color;\n\tif (color == KMEMLEAK_BLACK)\n\t\tobject->flags |= OBJECT_NO_SCAN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void paint_it(struct kmemleak_object *object, int color)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&object->lock, flags);\n\t__paint_it(object, color);\n\tspin_unlock_irqrestore(&object->lock, flags);\n}"
  },
  {
    "function_name": "__paint_it",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "732-737",
    "snippet": "static void __paint_it(struct kmemleak_object *object, int color)\n{\n\tobject->min_count = color;\n\tif (color == KMEMLEAK_BLACK)\n\t\tobject->flags |= OBJECT_NO_SCAN;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_NO_SCAN\t\t(1 << 2)",
      "#define KMEMLEAK_BLACK\t-1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_NO_SCAN\t\t(1 << 2)\n#define KMEMLEAK_BLACK\t-1\n\nstatic void __paint_it(struct kmemleak_object *object, int color)\n{\n\tobject->min_count = color;\n\tif (color == KMEMLEAK_BLACK)\n\t\tobject->flags |= OBJECT_NO_SCAN;\n}"
  },
  {
    "function_name": "delete_object_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "699-730",
    "snippet": "static void delete_object_part(unsigned long ptr, size_t size)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long start, end;\n\n\tobject = find_and_remove_object(ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Partially freeing unknown object at 0x%08lx (size %zu)\\n\",\n\t\t\t      ptr, size);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Create one or two objects that may result from the memory block\n\t * split. Note that partial freeing is only done by free_bootmem() and\n\t * this happens before kmemleak_init() is called. The path below is\n\t * only executed during early log recording in kmemleak_init(), so\n\t * GFP_KERNEL is enough.\n\t */\n\tstart = object->pointer;\n\tend = object->pointer + object->size;\n\tif (ptr > start)\n\t\tcreate_object(start, ptr - start, object->min_count,\n\t\t\t      GFP_KERNEL);\n\tif (ptr + size < end)\n\t\tcreate_object(ptr + size, end - ptr - size, object->min_count,\n\t\t\t      GFP_KERNEL);\n\n\t__delete_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__delete_object",
          "args": [
            "object"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "658-673",
          "snippet": "static void __delete_object(struct kmemleak_object *object)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!(object->flags & OBJECT_ALLOCATED));\n\tWARN_ON(atomic_read(&object->use_count) < 1);\n\n\t/*\n\t * Locking here also ensures that the corresponding memory block\n\t * cannot be freed when it is being scanned.\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags &= ~OBJECT_ALLOCATED;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void __delete_object(struct kmemleak_object *object)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!(object->flags & OBJECT_ALLOCATED));\n\tWARN_ON(atomic_read(&object->use_count) < 1);\n\n\t/*\n\t * Locking here also ensures that the corresponding memory block\n\t * cannot be freed when it is being scanned.\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags &= ~OBJECT_ALLOCATED;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_object",
          "args": [
            "ptr + size",
            "end - ptr - size",
            "object->min_count",
            "GFP_KERNEL"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "create_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "571-653",
          "snippet": "static struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static LIST_HEAD(gray_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);",
            "static struct kmem_cache *object_cache;",
            "static unsigned long min_addr = ULONG_MAX;",
            "static unsigned long max_addr;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic struct kmem_cache *object_cache;\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic void kmemleak_disable(void);\n\nstatic struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Partially freeing unknown object at 0x%08lx (size %zu)\\n\"",
            "ptr",
            "size"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_remove_object",
          "args": [
            "ptr",
            "1"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_remove_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "535-549",
          "snippet": "static struct kmemleak_object *find_and_remove_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tif (object) {\n\t\trb_erase(&object->rb_node, &object_tree_root);\n\t\tlist_del_rcu(&object->object_list);\n\t}\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_remove_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tif (object) {\n\t\trb_erase(&object->rb_node, &object_tree_root);\n\t\tlist_del_rcu(&object->object_list);\n\t}\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void delete_object_part(unsigned long ptr, size_t size)\n{\n\tstruct kmemleak_object *object;\n\tunsigned long start, end;\n\n\tobject = find_and_remove_object(ptr, 1);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Partially freeing unknown object at 0x%08lx (size %zu)\\n\",\n\t\t\t      ptr, size);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Create one or two objects that may result from the memory block\n\t * split. Note that partial freeing is only done by free_bootmem() and\n\t * this happens before kmemleak_init() is called. The path below is\n\t * only executed during early log recording in kmemleak_init(), so\n\t * GFP_KERNEL is enough.\n\t */\n\tstart = object->pointer;\n\tend = object->pointer + object->size;\n\tif (ptr > start)\n\t\tcreate_object(start, ptr - start, object->min_count,\n\t\t\t      GFP_KERNEL);\n\tif (ptr + size < end)\n\t\tcreate_object(ptr + size, end - ptr - size, object->min_count,\n\t\t\t      GFP_KERNEL);\n\n\t__delete_object(object);\n}"
  },
  {
    "function_name": "delete_object_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "679-692",
    "snippet": "static void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__delete_object",
          "args": [
            "object"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "658-673",
          "snippet": "static void __delete_object(struct kmemleak_object *object)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!(object->flags & OBJECT_ALLOCATED));\n\tWARN_ON(atomic_read(&object->use_count) < 1);\n\n\t/*\n\t * Locking here also ensures that the corresponding memory block\n\t * cannot be freed when it is being scanned.\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags &= ~OBJECT_ALLOCATED;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void __delete_object(struct kmemleak_object *object)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!(object->flags & OBJECT_ALLOCATED));\n\tWARN_ON(atomic_read(&object->use_count) < 1);\n\n\t/*\n\t * Locking here also ensures that the corresponding memory block\n\t * cannot be freed when it is being scanned.\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags &= ~OBJECT_ALLOCATED;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Freeing unknown object at 0x%08lx\\n\"",
            "ptr"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_remove_object",
          "args": [
            "ptr",
            "0"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_remove_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "535-549",
          "snippet": "static struct kmemleak_object *find_and_remove_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tif (object) {\n\t\trb_erase(&object->rb_node, &object_tree_root);\n\t\tlist_del_rcu(&object->object_list);\n\t}\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\n\treturn object;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(object_list);",
            "static struct rb_root object_tree_root = RB_ROOT;",
            "static DEFINE_RWLOCK(kmemleak_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_remove_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tif (object) {\n\t\trb_erase(&object->rb_node, &object_tree_root);\n\t\tlist_del_rcu(&object->object_list);\n\t}\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void delete_object_full(unsigned long ptr)\n{\n\tstruct kmemleak_object *object;\n\n\tobject = find_and_remove_object(ptr, 0);\n\tif (!object) {\n#ifdef DEBUG\n\t\tkmemleak_warn(\"Freeing unknown object at 0x%08lx\\n\",\n\t\t\t      ptr);\n#endif\n\t\treturn;\n\t}\n\t__delete_object(object);\n}"
  },
  {
    "function_name": "__delete_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "658-673",
    "snippet": "static void __delete_object(struct kmemleak_object *object)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!(object->flags & OBJECT_ALLOCATED));\n\tWARN_ON(atomic_read(&object->use_count) < 1);\n\n\t/*\n\t * Locking here also ensures that the corresponding memory block\n\t * cannot be freed when it is being scanned.\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags &= ~OBJECT_ALLOCATED;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_ALLOCATED\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_object",
          "args": [
            "object"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "put_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "498-507",
          "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define OBJECT_ALLOCATED\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&object->lock",
            "flags"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&object->use_count) < 1"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->use_count"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(object->flags & OBJECT_ALLOCATED)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void __delete_object(struct kmemleak_object *object)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!(object->flags & OBJECT_ALLOCATED));\n\tWARN_ON(atomic_read(&object->use_count) < 1);\n\n\t/*\n\t * Locking here also ensures that the corresponding memory block\n\t * cannot be freed when it is being scanned.\n\t */\n\tspin_lock_irqsave(&object->lock, flags);\n\tobject->flags &= ~OBJECT_ALLOCATED;\n\tspin_unlock_irqrestore(&object->lock, flags);\n\tput_object(object);\n}"
  },
  {
    "function_name": "create_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "571-653",
    "snippet": "static struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_ALLOCATED\t(1 << 0)"
    ],
    "globals_used": [
      "static LIST_HEAD(object_list);",
      "static LIST_HEAD(gray_list);",
      "static struct rb_root object_tree_root = RB_ROOT;",
      "static DEFINE_RWLOCK(kmemleak_lock);",
      "static struct kmem_cache *object_cache;",
      "static unsigned long min_addr = ULONG_MAX;",
      "static unsigned long max_addr;",
      "static void kmemleak_disable(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&object->object_list",
            "&object_list"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&object->rb_node",
            "&object_tree_root"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&object->rb_node",
            "rb_parent",
            "link"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "object_cache",
            "object"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_object_info",
          "args": [
            "parent"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "dump_object_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "411-428",
          "snippet": "static void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_stop",
          "args": [
            "\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\"",
            "ptr"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_parent",
            "structkmemleak_object",
            "rb_node"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_addr",
            "ptr + size"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "min_addr",
            "ptr"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_stack_trace",
          "args": [
            "object->trace"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__save_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "554-565",
          "snippet": "static int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_TRACE\t\t16\t/* stack trace length */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_TRACE\t\t16\t/* stack trace length */\n\nstatic int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "object->comm",
            "current->comm",
            "sizeof(object->comm)"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "strncpy_from_unsafe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/maccess.c",
          "lines": "90-113",
          "snippet": "long strncpy_from_unsafe(char *dst, const void *unsafe_addr, long count)\n{\n\tmm_segment_t old_fs = get_fs();\n\tconst void *src = unsafe_addr;\n\tlong ret;\n\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\tcurrent->kernel_uaccess_faults_ok++;\n\n\tdo {\n\t\tret = __get_user(*dst++, (const char __user __force *)src++);\n\t} while (dst[-1] && ret == 0 && src - unsafe_addr < count);\n\n\tcurrent->kernel_uaccess_faults_ok--;\n\tdst[-1] = '\\0';\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn ret ? -EFAULT : src - unsafe_addr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nlong strncpy_from_unsafe(char *dst, const void *unsafe_addr, long count)\n{\n\tmm_segment_t old_fs = get_fs();\n\tconst void *src = unsafe_addr;\n\tlong ret;\n\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\tcurrent->kernel_uaccess_faults_ok++;\n\n\tdo {\n\t\tret = __get_user(*dst++, (const char __user __force *)src++);\n\t} while (dst[-1] && ret == 0 && src - unsafe_addr < count);\n\n\tcurrent->kernel_uaccess_faults_ok--;\n\tdst[-1] = '\\0';\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn ret ? -EFAULT : src - unsafe_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_softirq",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&object->use_count",
            "1"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&object->lock"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&object->area_list"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&object->gray_list"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&object->object_list"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_disable",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1983-1999",
          "snippet": "static void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_free_enabled;",
            "static int kmemleak_initialized;",
            "static int kmemleak_error;",
            "static void kmemleak_disable(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_initialized;\nstatic int kmemleak_error;\nstatic void kmemleak_disable(void);\n\nstatic void kmemleak_disable(void)\n{\n\t/* atomically check whether it was already invoked */\n\tif (cmpxchg(&kmemleak_error, 0, 1))\n\t\treturn;\n\n\t/* stop any memory operation tracing */\n\tkmemleak_enabled = 0;\n\n\t/* check whether it is too early for a kernel thread */\n\tif (kmemleak_initialized)\n\t\tschedule_work(&cleanup_work);\n\telse\n\t\tkmemleak_free_enabled = 0;\n\n\tpr_info(\"Kernel memory leak detector disabled\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cannot allocate a kmemleak_object structure\\n\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "object_cache",
            "gfp_kmemleak_mask(gfp)"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_kmemleak_mask",
          "args": [
            "gfp"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic LIST_HEAD(object_list);\nstatic LIST_HEAD(gray_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\nstatic struct kmem_cache *object_cache;\nstatic unsigned long min_addr = ULONG_MAX;\nstatic unsigned long max_addr;\nstatic void kmemleak_disable(void);\n\nstatic struct kmemleak_object *create_object(unsigned long ptr, size_t size,\n\t\t\t\t\t     int min_count, gfp_t gfp)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object, *parent;\n\tstruct rb_node **link, *rb_parent;\n\n\tobject = kmem_cache_alloc(object_cache, gfp_kmemleak_mask(gfp));\n\tif (!object) {\n\t\tpr_warn(\"Cannot allocate a kmemleak_object structure\\n\");\n\t\tkmemleak_disable();\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&object->object_list);\n\tINIT_LIST_HEAD(&object->gray_list);\n\tINIT_HLIST_HEAD(&object->area_list);\n\tspin_lock_init(&object->lock);\n\tatomic_set(&object->use_count, 1);\n\tobject->flags = OBJECT_ALLOCATED;\n\tobject->pointer = ptr;\n\tobject->size = size;\n\tobject->excess_ref = 0;\n\tobject->min_count = min_count;\n\tobject->count = 0;\t\t\t/* white color initially */\n\tobject->jiffies = jiffies;\n\tobject->checksum = 0;\n\n\t/* task information */\n\tif (in_irq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"hardirq\", sizeof(object->comm));\n\t} else if (in_softirq()) {\n\t\tobject->pid = 0;\n\t\tstrncpy(object->comm, \"softirq\", sizeof(object->comm));\n\t} else {\n\t\tobject->pid = current->pid;\n\t\t/*\n\t\t * There is a small chance of a race with set_task_comm(),\n\t\t * however using get_task_comm() here may cause locking\n\t\t * dependency issues with current->alloc_lock. In the worst\n\t\t * case, the command line is not correct.\n\t\t */\n\t\tstrncpy(object->comm, current->comm, sizeof(object->comm));\n\t}\n\n\t/* kernel backtrace */\n\tobject->trace_len = __save_stack_trace(object->trace);\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\n\tmin_addr = min(min_addr, ptr);\n\tmax_addr = max(max_addr, ptr + size);\n\tlink = &object_tree_root.rb_node;\n\trb_parent = NULL;\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct kmemleak_object, rb_node);\n\t\tif (ptr + size <= parent->pointer)\n\t\t\tlink = &parent->rb_node.rb_left;\n\t\telse if (parent->pointer + parent->size <= ptr)\n\t\t\tlink = &parent->rb_node.rb_right;\n\t\telse {\n\t\t\tkmemleak_stop(\"Cannot insert 0x%lx into the object search tree (overlaps existing)\\n\",\n\t\t\t\t      ptr);\n\t\t\t/*\n\t\t\t * No need for parent->lock here since \"parent\" cannot\n\t\t\t * be freed while the kmemleak_lock is held.\n\t\t\t */\n\t\t\tdump_object_info(parent);\n\t\t\tkmem_cache_free(object_cache, object);\n\t\t\tobject = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trb_link_node(&object->rb_node, rb_parent, link);\n\trb_insert_color(&object->rb_node, &object_tree_root);\n\n\tlist_add_tail_rcu(&object->object_list, &object_list);\nout:\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\treturn object;\n}"
  },
  {
    "function_name": "__save_stack_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "554-565",
    "snippet": "static int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define MAX_TRACE\t\t16\t/* stack trace length */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_stack_trace",
          "args": [
            "&stack_trace"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "__save_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "554-565",
          "snippet": "static int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_TRACE\t\t16\t/* stack trace length */\n\nstatic int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}"
  },
  {
    "function_name": "find_and_remove_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "535-549",
    "snippet": "static struct kmemleak_object *find_and_remove_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tif (object) {\n\t\trb_erase(&object->rb_node, &object_tree_root);\n\t\tlist_del_rcu(&object->object_list);\n\t}\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\n\treturn object;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(object_list);",
      "static struct rb_root object_tree_root = RB_ROOT;",
      "static DEFINE_RWLOCK(kmemleak_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&object->object_list"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&object->rb_node",
            "&object_tree_root"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_object",
          "args": [
            "ptr",
            "alias"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "436-457",
          "snippet": "static struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root object_tree_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct rb_root object_tree_root = RB_ROOT;\n\nstatic struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(object_list);\nstatic struct rb_root object_tree_root = RB_ROOT;\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_remove_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\twrite_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tif (object) {\n\t\trb_erase(&object->rb_node, &object_tree_root);\n\t\tlist_del_rcu(&object->object_list);\n\t}\n\twrite_unlock_irqrestore(&kmemleak_lock, flags);\n\n\treturn object;\n}"
  },
  {
    "function_name": "find_and_get_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "512-528",
    "snippet": "static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(kmemleak_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_object",
          "args": [
            "object"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "get_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "465-468",
          "snippet": "static int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_object",
          "args": [
            "ptr",
            "alias"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "436-457",
          "snippet": "static struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root object_tree_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct rb_root object_tree_root = RB_ROOT;\n\nstatic struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&kmemleak_lock",
            "flags"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_RWLOCK(kmemleak_lock);\n\nstatic struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)\n{\n\tunsigned long flags;\n\tstruct kmemleak_object *object;\n\n\trcu_read_lock();\n\tread_lock_irqsave(&kmemleak_lock, flags);\n\tobject = lookup_object(ptr, alias);\n\tread_unlock_irqrestore(&kmemleak_lock, flags);\n\n\t/* check whether the object is still available */\n\tif (object && !get_object(object))\n\t\tobject = NULL;\n\trcu_read_unlock();\n\n\treturn object;\n}"
  },
  {
    "function_name": "put_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "498-507",
    "snippet": "static void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_ALLOCATED\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&object->rcu",
            "free_object_rcu"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "object->flags & OBJECT_ALLOCATED"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&object->use_count"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic void put_object(struct kmemleak_object *object)\n{\n\tif (!atomic_dec_and_test(&object->use_count))\n\t\treturn;\n\n\t/* should only get here after delete_object was called */\n\tWARN_ON(object->flags & OBJECT_ALLOCATED);\n\n\tcall_rcu(&object->rcu, free_object_rcu);\n}"
  },
  {
    "function_name": "free_object_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "473-489",
    "snippet": "static void free_object_rcu(struct rcu_head *rcu)\n{\n\tstruct hlist_node *tmp;\n\tstruct kmemleak_scan_area *area;\n\tstruct kmemleak_object *object =\n\t\tcontainer_of(rcu, struct kmemleak_object, rcu);\n\n\t/*\n\t * Once use_count is 0 (guaranteed by put_object), there is no other\n\t * code accessing this object, hence no need for locking.\n\t */\n\thlist_for_each_entry_safe(area, tmp, &object->area_list, node) {\n\t\thlist_del(&area->node);\n\t\tkmem_cache_free(scan_area_cache, area);\n\t}\n\tkmem_cache_free(object_cache, object);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *object_cache;",
      "static struct kmem_cache *scan_area_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "object_cache",
            "object"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&area->node"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "area",
            "tmp",
            "&object->area_list",
            "node"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structkmemleak_object",
            "rcu"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache *object_cache;\nstatic struct kmem_cache *scan_area_cache;\n\nstatic void free_object_rcu(struct rcu_head *rcu)\n{\n\tstruct hlist_node *tmp;\n\tstruct kmemleak_scan_area *area;\n\tstruct kmemleak_object *object =\n\t\tcontainer_of(rcu, struct kmemleak_object, rcu);\n\n\t/*\n\t * Once use_count is 0 (guaranteed by put_object), there is no other\n\t * code accessing this object, hence no need for locking.\n\t */\n\thlist_for_each_entry_safe(area, tmp, &object->area_list, node) {\n\t\thlist_del(&area->node);\n\t\tkmem_cache_free(scan_area_cache, area);\n\t}\n\tkmem_cache_free(object_cache, object);\n}"
  },
  {
    "function_name": "get_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "465-468",
    "snippet": "static int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&object->use_count"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int get_object(struct kmemleak_object *object)\n{\n\treturn atomic_inc_not_zero(&object->use_count);\n}"
  },
  {
    "function_name": "lookup_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "436-457",
    "snippet": "static struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root object_tree_root = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_object_info",
          "args": [
            "object"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "dump_object_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "411-428",
          "snippet": "static void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_warn",
          "args": [
            "\"Found object by alias at 0x%08lx\\n\"",
            "ptr"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb",
            "structkmemleak_object",
            "rb_node"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct rb_root object_tree_root = RB_ROOT;\n\nstatic struct kmemleak_object *lookup_object(unsigned long ptr, int alias)\n{\n\tstruct rb_node *rb = object_tree_root.rb_node;\n\n\twhile (rb) {\n\t\tstruct kmemleak_object *object =\n\t\t\trb_entry(rb, struct kmemleak_object, rb_node);\n\t\tif (ptr < object->pointer)\n\t\t\trb = object->rb_node.rb_left;\n\t\telse if (object->pointer + object->size <= ptr)\n\t\t\trb = object->rb_node.rb_right;\n\t\telse if (object->pointer == ptr || alias)\n\t\t\treturn object;\n\t\telse {\n\t\t\tkmemleak_warn(\"Found object by alias at 0x%08lx\\n\",\n\t\t\t\t      ptr);\n\t\t\tdump_object_info(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dump_object_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "411-428",
    "snippet": "static void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "&trace",
            "4"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"  backtrace:\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"  checksum = %u\\n\"",
            "object->checksum"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"  flags = 0x%x\\n\"",
            "object->flags"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"  count = %d\\n\"",
            "object->count"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"  min_count = %d\\n\"",
            "object->min_count"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\"",
            "object->comm",
            "object->pid",
            "object->jiffies"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Object 0x%08lx (size %zu):\\n\"",
            "object->pointer",
            "object->size"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void dump_object_info(struct kmemleak_object *object)\n{\n\tstruct stack_trace trace;\n\n\ttrace.nr_entries = object->trace_len;\n\ttrace.entries = object->trace;\n\n\tpr_notice(\"Object 0x%08lx (size %zu):\\n\",\n\t\t  object->pointer, object->size);\n\tpr_notice(\"  comm \\\"%s\\\", pid %d, jiffies %lu\\n\",\n\t\t  object->comm, object->pid, object->jiffies);\n\tpr_notice(\"  min_count = %d\\n\", object->min_count);\n\tpr_notice(\"  count = %d\\n\", object->count);\n\tpr_notice(\"  flags = 0x%x\\n\", object->flags);\n\tpr_notice(\"  checksum = %u\\n\", object->checksum);\n\tpr_notice(\"  backtrace:\\n\");\n\tprint_stack_trace(&trace, 4);\n}"
  },
  {
    "function_name": "print_unreferenced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "386-404",
    "snippet": "static void print_unreferenced(struct seq_file *seq,\n\t\t\t       struct kmemleak_object *object)\n{\n\tint i;\n\tunsigned int msecs_age = jiffies_to_msecs(jiffies - object->jiffies);\n\n\twarn_or_seq_printf(seq, \"unreferenced object 0x%08lx (size %zu):\\n\",\n\t\t   object->pointer, object->size);\n\twarn_or_seq_printf(seq, \"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\",\n\t\t   object->comm, object->pid, object->jiffies,\n\t\t   msecs_age / 1000, msecs_age % 1000);\n\thex_dump_object(seq, object);\n\twarn_or_seq_printf(seq, \"  backtrace:\\n\");\n\n\tfor (i = 0; i < object->trace_len; i++) {\n\t\tvoid *ptr = (void *)object->trace[i];\n\t\twarn_or_seq_printf(seq, \"    [<%p>] %pS\\n\", ptr, ptr);\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "warn_or_seq_printf",
          "args": [
            "seq",
            "\"    [<%p>] %pS\\n\"",
            "ptr",
            "ptr"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_or_seq_printf",
          "args": [
            "seq",
            "\"  backtrace:\\n\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_dump_object",
          "args": [
            "seq",
            "object"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "hex_dump_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "332-346",
          "snippet": "static void hex_dump_object(struct seq_file *seq,\n\t\t\t    struct kmemleak_object *object)\n{\n\tconst u8 *ptr = (const u8 *)object->pointer;\n\tsize_t len;\n\n\t/* limit the number of lines to HEX_MAX_LINES */\n\tlen = min_t(size_t, object->size, HEX_MAX_LINES * HEX_ROW_SIZE);\n\n\twarn_or_seq_printf(seq, \"  hex dump (first %zu bytes):\\n\", len);\n\tkasan_disable_current();\n\twarn_or_seq_hex_dump(seq, DUMP_PREFIX_NONE, HEX_ROW_SIZE,\n\t\t\t     HEX_GROUP_SIZE, ptr, len, HEX_ASCII);\n\tkasan_enable_current();\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define HEX_MAX_LINES\t\t2",
            "#define HEX_ASCII\t\t1",
            "#define HEX_GROUP_SIZE\t\t1",
            "#define HEX_ROW_SIZE\t\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define HEX_MAX_LINES\t\t2\n#define HEX_ASCII\t\t1\n#define HEX_GROUP_SIZE\t\t1\n#define HEX_ROW_SIZE\t\t16\n\nstatic void hex_dump_object(struct seq_file *seq,\n\t\t\t    struct kmemleak_object *object)\n{\n\tconst u8 *ptr = (const u8 *)object->pointer;\n\tsize_t len;\n\n\t/* limit the number of lines to HEX_MAX_LINES */\n\tlen = min_t(size_t, object->size, HEX_MAX_LINES * HEX_ROW_SIZE);\n\n\twarn_or_seq_printf(seq, \"  hex dump (first %zu bytes):\\n\", len);\n\tkasan_disable_current();\n\twarn_or_seq_hex_dump(seq, DUMP_PREFIX_NONE, HEX_ROW_SIZE,\n\t\t\t     HEX_GROUP_SIZE, ptr, len, HEX_ASCII);\n\tkasan_enable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_or_seq_printf",
          "args": [
            "seq",
            "\"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\"",
            "object->comm",
            "object->pid",
            "object->jiffies",
            "msecs_age / 1000",
            "msecs_age % 1000"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_or_seq_printf",
          "args": [
            "seq",
            "\"unreferenced object 0x%08lx (size %zu):\\n\"",
            "object->pointer",
            "object->size"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "jiffies - object->jiffies"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void print_unreferenced(struct seq_file *seq,\n\t\t\t       struct kmemleak_object *object)\n{\n\tint i;\n\tunsigned int msecs_age = jiffies_to_msecs(jiffies - object->jiffies);\n\n\twarn_or_seq_printf(seq, \"unreferenced object 0x%08lx (size %zu):\\n\",\n\t\t   object->pointer, object->size);\n\twarn_or_seq_printf(seq, \"  comm \\\"%s\\\", pid %d, jiffies %lu (age %d.%03ds)\\n\",\n\t\t   object->comm, object->pid, object->jiffies,\n\t\t   msecs_age / 1000, msecs_age % 1000);\n\thex_dump_object(seq, object);\n\twarn_or_seq_printf(seq, \"  backtrace:\\n\");\n\n\tfor (i = 0; i < object->trace_len; i++) {\n\t\tvoid *ptr = (void *)object->trace[i];\n\t\twarn_or_seq_printf(seq, \"    [<%p>] %pS\\n\", ptr, ptr);\n\t}\n}"
  },
  {
    "function_name": "unreferenced_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "375-380",
    "snippet": "static bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define OBJECT_ALLOCATED\t(1 << 0)"
    ],
    "globals_used": [
      "static unsigned long jiffies_min_age;",
      "static unsigned long jiffies_last_scan;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before_eq",
          "args": [
            "object->jiffies + jiffies_min_age",
            "jiffies_last_scan"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "color_white",
          "args": [
            "object"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "color_white",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "358-362",
          "snippet": "static bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define KMEMLEAK_BLACK\t-1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define OBJECT_ALLOCATED\t(1 << 0)\n\nstatic unsigned long jiffies_min_age;\nstatic unsigned long jiffies_last_scan;\n\nstatic bool unreferenced_object(struct kmemleak_object *object)\n{\n\treturn (color_white(object) && object->flags & OBJECT_ALLOCATED) &&\n\t\ttime_before_eq(object->jiffies + jiffies_min_age,\n\t\t\t       jiffies_last_scan);\n}"
  },
  {
    "function_name": "color_gray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "364-368",
    "snippet": "static bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define KMEMLEAK_BLACK\t-1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_gray(const struct kmemleak_object *object)\n{\n\treturn object->min_count != KMEMLEAK_BLACK &&\n\t\tobject->count >= object->min_count;\n}"
  },
  {
    "function_name": "color_white",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "358-362",
    "snippet": "static bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define KMEMLEAK_BLACK\t-1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define KMEMLEAK_BLACK\t-1\n\nstatic bool color_white(const struct kmemleak_object *object)\n{\n\treturn object->count != KMEMLEAK_BLACK &&\n\t\tobject->count < object->min_count;\n}"
  },
  {
    "function_name": "hex_dump_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "332-346",
    "snippet": "static void hex_dump_object(struct seq_file *seq,\n\t\t\t    struct kmemleak_object *object)\n{\n\tconst u8 *ptr = (const u8 *)object->pointer;\n\tsize_t len;\n\n\t/* limit the number of lines to HEX_MAX_LINES */\n\tlen = min_t(size_t, object->size, HEX_MAX_LINES * HEX_ROW_SIZE);\n\n\twarn_or_seq_printf(seq, \"  hex dump (first %zu bytes):\\n\", len);\n\tkasan_disable_current();\n\twarn_or_seq_hex_dump(seq, DUMP_PREFIX_NONE, HEX_ROW_SIZE,\n\t\t\t     HEX_GROUP_SIZE, ptr, len, HEX_ASCII);\n\tkasan_enable_current();\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define HEX_MAX_LINES\t\t2",
      "#define HEX_ASCII\t\t1",
      "#define HEX_GROUP_SIZE\t\t1",
      "#define HEX_ROW_SIZE\t\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_enable_current",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_enable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "43-46",
          "snippet": "void kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_or_seq_hex_dump",
          "args": [
            "seq",
            "DUMP_PREFIX_NONE",
            "HEX_ROW_SIZE",
            "HEX_GROUP_SIZE",
            "ptr",
            "len",
            "HEX_ASCII"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "warn_or_seq_hex_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "314-324",
          "snippet": "static void warn_or_seq_hex_dump(struct seq_file *seq, int prefix_type,\n\t\t\t\t int rowsize, int groupsize, const void *buf,\n\t\t\t\t size_t len, bool ascii)\n{\n\tif (seq)\n\t\tseq_hex_dump(seq, HEX_PREFIX, prefix_type, rowsize, groupsize,\n\t\t\t     buf, len, ascii);\n\telse\n\t\tprint_hex_dump(KERN_WARNING, pr_fmt(HEX_PREFIX), prefix_type,\n\t\t\t       rowsize, groupsize, buf, len, ascii);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define HEX_PREFIX\t\t\"    \""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define HEX_PREFIX\t\t\"    \"\n\nstatic void warn_or_seq_hex_dump(struct seq_file *seq, int prefix_type,\n\t\t\t\t int rowsize, int groupsize, const void *buf,\n\t\t\t\t size_t len, bool ascii)\n{\n\tif (seq)\n\t\tseq_hex_dump(seq, HEX_PREFIX, prefix_type, rowsize, groupsize,\n\t\t\t     buf, len, ascii);\n\telse\n\t\tprint_hex_dump(KERN_WARNING, pr_fmt(HEX_PREFIX), prefix_type,\n\t\t\t       rowsize, groupsize, buf, len, ascii);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_disable_current",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_disable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "48-51",
          "snippet": "void kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_or_seq_printf",
          "args": [
            "seq",
            "\"  hex dump (first %zu bytes):\\n\"",
            "len"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "object->size",
            "HEX_MAX_LINES * HEX_ROW_SIZE"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define HEX_MAX_LINES\t\t2\n#define HEX_ASCII\t\t1\n#define HEX_GROUP_SIZE\t\t1\n#define HEX_ROW_SIZE\t\t16\n\nstatic void hex_dump_object(struct seq_file *seq,\n\t\t\t    struct kmemleak_object *object)\n{\n\tconst u8 *ptr = (const u8 *)object->pointer;\n\tsize_t len;\n\n\t/* limit the number of lines to HEX_MAX_LINES */\n\tlen = min_t(size_t, object->size, HEX_MAX_LINES * HEX_ROW_SIZE);\n\n\twarn_or_seq_printf(seq, \"  hex dump (first %zu bytes):\\n\", len);\n\tkasan_disable_current();\n\twarn_or_seq_hex_dump(seq, DUMP_PREFIX_NONE, HEX_ROW_SIZE,\n\t\t\t     HEX_GROUP_SIZE, ptr, len, HEX_ASCII);\n\tkasan_enable_current();\n}"
  },
  {
    "function_name": "warn_or_seq_hex_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
    "lines": "314-324",
    "snippet": "static void warn_or_seq_hex_dump(struct seq_file *seq, int prefix_type,\n\t\t\t\t int rowsize, int groupsize, const void *buf,\n\t\t\t\t size_t len, bool ascii)\n{\n\tif (seq)\n\t\tseq_hex_dump(seq, HEX_PREFIX, prefix_type, rowsize, groupsize,\n\t\t\t     buf, len, ascii);\n\telse\n\t\tprint_hex_dump(KERN_WARNING, pr_fmt(HEX_PREFIX), prefix_type,\n\t\t\t       rowsize, groupsize, buf, len, ascii);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/atomic.h>",
      "#include <asm/processor.h>",
      "#include <asm/sections.h>",
      "#include <linux/crc32.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/mm.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/err.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/slab.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/pfn.h>",
      "#include <linux/memblock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cache.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/kthread.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define HEX_PREFIX\t\t\"    \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_WARNING",
            "pr_fmt(HEX_PREFIX)",
            "prefix_type",
            "rowsize",
            "groupsize",
            "buf",
            "len",
            "ascii"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_fmt",
          "args": [
            "HEX_PREFIX"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_hex_dump",
          "args": [
            "seq",
            "HEX_PREFIX",
            "prefix_type",
            "rowsize",
            "groupsize",
            "buf",
            "len",
            "ascii"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define HEX_PREFIX\t\t\"    \"\n\nstatic void warn_or_seq_hex_dump(struct seq_file *seq, int prefix_type,\n\t\t\t\t int rowsize, int groupsize, const void *buf,\n\t\t\t\t size_t len, bool ascii)\n{\n\tif (seq)\n\t\tseq_hex_dump(seq, HEX_PREFIX, prefix_type, rowsize, groupsize,\n\t\t\t     buf, len, ascii);\n\telse\n\t\tprint_hex_dump(KERN_WARNING, pr_fmt(HEX_PREFIX), prefix_type,\n\t\t\t       rowsize, groupsize, buf, len, ascii);\n}"
  }
]