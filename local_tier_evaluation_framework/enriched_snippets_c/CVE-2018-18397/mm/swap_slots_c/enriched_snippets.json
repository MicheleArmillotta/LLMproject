[
  {
    "function_name": "get_swap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "310-360",
    "snippet": "swp_entry_t get_swap_page(struct page *page)\n{\n\tswp_entry_t entry, *pentry;\n\tstruct swap_slots_cache *cache;\n\n\tentry.val = 0;\n\n\tif (PageTransHuge(page)) {\n\t\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\t\tget_swap_pages(1, &entry, HPAGE_PMD_NR);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Preemption is allowed here, because we may sleep\n\t * in refill_swap_slots_cache().  But it is safe, because\n\t * accesses to the per-CPU data structure are protected by the\n\t * mutex cache->alloc_lock.\n\t *\n\t * The alloc path here does not touch cache->slots_ret\n\t * so cache->free_lock is not taken.\n\t */\n\tcache = raw_cpu_ptr(&swp_slots);\n\n\tif (likely(check_cache_active() && cache->slots)) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tif (cache->slots) {\nrepeat:\n\t\t\tif (cache->nr) {\n\t\t\t\tpentry = &cache->slots[cache->cur++];\n\t\t\t\tentry = *pentry;\n\t\t\t\tpentry->val = 0;\n\t\t\t\tcache->nr--;\n\t\t\t} else {\n\t\t\t\tif (refill_swap_slots_cache(cache))\n\t\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t\tif (entry.val)\n\t\t\tgoto out;\n\t}\n\n\tget_swap_pages(1, &entry, 1);\nout:\n\tif (mem_cgroup_try_charge_swap(page, entry)) {\n\t\tput_swap_page(page, entry);\n\t\tentry.val = 0;\n\t}\n\treturn entry;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_swap_page",
          "args": [
            "page",
            "entry"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "put_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1225-1270",
          "snippet": "void put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_swap",
          "args": [
            "page",
            "entry"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6449-6488",
          "snippet": "int mem_cgroup_try_charge_swap(struct page *page, swp_entry_t entry)\n{\n\tunsigned int nr_pages = hpage_nr_pages(page);\n\tstruct page_counter *counter;\n\tstruct mem_cgroup *memcg;\n\tunsigned short oldid;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) || !do_swap_account)\n\t\treturn 0;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn 0;\n\n\tif (!entry.val) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\treturn 0;\n\t}\n\n\tmemcg = mem_cgroup_id_get_online(memcg);\n\n\tif (!mem_cgroup_is_root(memcg) &&\n\t    !page_counter_try_charge(&memcg->swap, nr_pages, &counter)) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_MAX);\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\tmem_cgroup_id_put(memcg);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Get references for the tail pages, too */\n\tif (nr_pages > 1)\n\t\tmem_cgroup_id_get_many(memcg, nr_pages - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(memcg), nr_pages);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(memcg, MEMCG_SWAP, nr_pages);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nint mem_cgroup_try_charge_swap(struct page *page, swp_entry_t entry)\n{\n\tunsigned int nr_pages = hpage_nr_pages(page);\n\tstruct page_counter *counter;\n\tstruct mem_cgroup *memcg;\n\tunsigned short oldid;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) || !do_swap_account)\n\t\treturn 0;\n\n\tmemcg = page->mem_cgroup;\n\n\t/* Readahead page, never charged */\n\tif (!memcg)\n\t\treturn 0;\n\n\tif (!entry.val) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\treturn 0;\n\t}\n\n\tmemcg = mem_cgroup_id_get_online(memcg);\n\n\tif (!mem_cgroup_is_root(memcg) &&\n\t    !page_counter_try_charge(&memcg->swap, nr_pages, &counter)) {\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_MAX);\n\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n\t\tmem_cgroup_id_put(memcg);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Get references for the tail pages, too */\n\tif (nr_pages > 1)\n\t\tmem_cgroup_id_get_many(memcg, nr_pages - 1);\n\toldid = swap_cgroup_record(entry, mem_cgroup_id(memcg), nr_pages);\n\tVM_BUG_ON_PAGE(oldid, page);\n\tmod_memcg_state(memcg, MEMCG_SWAP, nr_pages);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_swap_pages",
          "args": [
            "1",
            "&entry",
            "1"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "957-1042",
          "snippet": "int get_swap_pages(int n_goal, swp_entry_t swp_entries[], int entry_size)\n{\n\tunsigned long size = swap_entry_size(entry_size);\n\tstruct swap_info_struct *si, *next;\n\tlong avail_pgs;\n\tint n_ret = 0;\n\tint node;\n\n\t/* Only single cluster request supported */\n\tWARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);\n\n\tavail_pgs = atomic_long_read(&nr_swap_pages) / size;\n\tif (avail_pgs <= 0)\n\t\tgoto noswap;\n\n\tif (n_goal > SWAP_BATCH)\n\t\tn_goal = SWAP_BATCH;\n\n\tif (n_goal > avail_pgs)\n\t\tn_goal = avail_pgs;\n\n\tatomic_long_sub(n_goal * size, &nr_swap_pages);\n\n\tspin_lock(&swap_avail_lock);\n\nstart_over:\n\tnode = numa_node_id();\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {\n\t\t/* requeue si to after same-priority siblings */\n\t\tplist_requeue(&si->avail_lists[node], &swap_avail_heads[node]);\n\t\tspin_unlock(&swap_avail_lock);\n\t\tspin_lock(&si->lock);\n\t\tif (!si->highest_bit || !(si->flags & SWP_WRITEOK)) {\n\t\t\tspin_lock(&swap_avail_lock);\n\t\t\tif (plist_node_empty(&si->avail_lists[node])) {\n\t\t\t\tspin_unlock(&si->lock);\n\t\t\t\tgoto nextsi;\n\t\t\t}\n\t\t\tWARN(!si->highest_bit,\n\t\t\t     \"swap_info %d in list but !highest_bit\\n\",\n\t\t\t     si->type);\n\t\t\tWARN(!(si->flags & SWP_WRITEOK),\n\t\t\t     \"swap_info %d in list but !SWP_WRITEOK\\n\",\n\t\t\t     si->type);\n\t\t\t__del_from_avail_list(si);\n\t\t\tspin_unlock(&si->lock);\n\t\t\tgoto nextsi;\n\t\t}\n\t\tif (size == SWAPFILE_CLUSTER) {\n\t\t\tif (!(si->flags & SWP_FS))\n\t\t\t\tn_ret = swap_alloc_cluster(si, swp_entries);\n\t\t} else\n\t\t\tn_ret = scan_swap_map_slots(si, SWAP_HAS_CACHE,\n\t\t\t\t\t\t    n_goal, swp_entries);\n\t\tspin_unlock(&si->lock);\n\t\tif (n_ret || size == SWAPFILE_CLUSTER)\n\t\t\tgoto check_out;\n\t\tpr_debug(\"scan_swap_map of si %d failed to find offset\\n\",\n\t\t\tsi->type);\n\n\t\tspin_lock(&swap_avail_lock);\nnextsi:\n\t\t/*\n\t\t * if we got here, it's likely that si was almost full before,\n\t\t * and since scan_swap_map() can drop the si->lock, multiple\n\t\t * callers probably all tried to get a page from the same si\n\t\t * and it filled up before we could get one; or, the si filled\n\t\t * up between us dropping swap_avail_lock and taking si->lock.\n\t\t * Since we dropped the swap_avail_lock, the swap_avail_head\n\t\t * list may have been modified; so if next is still in the\n\t\t * swap_avail_head list then try it, otherwise start over\n\t\t * if we have not gotten any slots.\n\t\t */\n\t\tif (plist_node_empty(&next->avail_lists[node]))\n\t\t\tgoto start_over;\n\t}\n\n\tspin_unlock(&swap_avail_lock);\n\ncheck_out:\n\tif (n_ret < n_goal)\n\t\tatomic_long_add((long)(n_goal - n_ret) * size,\n\t\t\t\t&nr_swap_pages);\nnoswap:\n\treturn n_ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "atomic_long_t nr_swap_pages;",
            "static struct plist_head *swap_avail_heads;",
            "static DEFINE_SPINLOCK(swap_avail_lock);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\natomic_long_t nr_swap_pages;\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nint get_swap_pages(int n_goal, swp_entry_t swp_entries[], int entry_size)\n{\n\tunsigned long size = swap_entry_size(entry_size);\n\tstruct swap_info_struct *si, *next;\n\tlong avail_pgs;\n\tint n_ret = 0;\n\tint node;\n\n\t/* Only single cluster request supported */\n\tWARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);\n\n\tavail_pgs = atomic_long_read(&nr_swap_pages) / size;\n\tif (avail_pgs <= 0)\n\t\tgoto noswap;\n\n\tif (n_goal > SWAP_BATCH)\n\t\tn_goal = SWAP_BATCH;\n\n\tif (n_goal > avail_pgs)\n\t\tn_goal = avail_pgs;\n\n\tatomic_long_sub(n_goal * size, &nr_swap_pages);\n\n\tspin_lock(&swap_avail_lock);\n\nstart_over:\n\tnode = numa_node_id();\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {\n\t\t/* requeue si to after same-priority siblings */\n\t\tplist_requeue(&si->avail_lists[node], &swap_avail_heads[node]);\n\t\tspin_unlock(&swap_avail_lock);\n\t\tspin_lock(&si->lock);\n\t\tif (!si->highest_bit || !(si->flags & SWP_WRITEOK)) {\n\t\t\tspin_lock(&swap_avail_lock);\n\t\t\tif (plist_node_empty(&si->avail_lists[node])) {\n\t\t\t\tspin_unlock(&si->lock);\n\t\t\t\tgoto nextsi;\n\t\t\t}\n\t\t\tWARN(!si->highest_bit,\n\t\t\t     \"swap_info %d in list but !highest_bit\\n\",\n\t\t\t     si->type);\n\t\t\tWARN(!(si->flags & SWP_WRITEOK),\n\t\t\t     \"swap_info %d in list but !SWP_WRITEOK\\n\",\n\t\t\t     si->type);\n\t\t\t__del_from_avail_list(si);\n\t\t\tspin_unlock(&si->lock);\n\t\t\tgoto nextsi;\n\t\t}\n\t\tif (size == SWAPFILE_CLUSTER) {\n\t\t\tif (!(si->flags & SWP_FS))\n\t\t\t\tn_ret = swap_alloc_cluster(si, swp_entries);\n\t\t} else\n\t\t\tn_ret = scan_swap_map_slots(si, SWAP_HAS_CACHE,\n\t\t\t\t\t\t    n_goal, swp_entries);\n\t\tspin_unlock(&si->lock);\n\t\tif (n_ret || size == SWAPFILE_CLUSTER)\n\t\t\tgoto check_out;\n\t\tpr_debug(\"scan_swap_map of si %d failed to find offset\\n\",\n\t\t\tsi->type);\n\n\t\tspin_lock(&swap_avail_lock);\nnextsi:\n\t\t/*\n\t\t * if we got here, it's likely that si was almost full before,\n\t\t * and since scan_swap_map() can drop the si->lock, multiple\n\t\t * callers probably all tried to get a page from the same si\n\t\t * and it filled up before we could get one; or, the si filled\n\t\t * up between us dropping swap_avail_lock and taking si->lock.\n\t\t * Since we dropped the swap_avail_lock, the swap_avail_head\n\t\t * list may have been modified; so if next is still in the\n\t\t * swap_avail_head list then try it, otherwise start over\n\t\t * if we have not gotten any slots.\n\t\t */\n\t\tif (plist_node_empty(&next->avail_lists[node]))\n\t\t\tgoto start_over;\n\t}\n\n\tspin_unlock(&swap_avail_lock);\n\ncheck_out:\n\tif (n_ret < n_goal)\n\t\tatomic_long_add((long)(n_goal - n_ret) * size,\n\t\t\t\t&nr_swap_pages);\nnoswap:\n\treturn n_ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cache->alloc_lock"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refill_swap_slots_cache",
          "args": [
            "cache"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "refill_swap_slots_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "265-276",
          "snippet": "static int refill_swap_slots_cache(struct swap_slots_cache *cache)\n{\n\tif (!use_swap_slot_cache || cache->nr)\n\t\treturn 0;\n\n\tcache->cur = 0;\n\tif (swap_slot_cache_active)\n\t\tcache->nr = get_swap_pages(SWAP_SLOTS_CACHE_SIZE,\n\t\t\t\t\t   cache->slots, 1);\n\n\treturn cache->nr;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [
            "#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)"
          ],
          "globals_used": [
            "static bool\tswap_slot_cache_active;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)\n\nstatic bool\tswap_slot_cache_active;\n\nstatic int refill_swap_slots_cache(struct swap_slots_cache *cache)\n{\n\tif (!use_swap_slot_cache || cache->nr)\n\t\treturn 0;\n\n\tcache->cur = 0;\n\tif (swap_slot_cache_active)\n\t\tcache->nr = get_swap_pages(SWAP_SLOTS_CACHE_SIZE,\n\t\t\t\t\t   cache->slots, 1);\n\n\treturn cache->nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cache->alloc_lock"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "check_cache_active() && cache->slots"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_cache_active",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "check_cache_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "93-113",
          "snippet": "static bool check_cache_active(void)\n{\n\tlong pages;\n\n\tif (!swap_slot_cache_enabled || !swap_slot_cache_initialized)\n\t\treturn false;\n\n\tpages = get_nr_swap_pages();\n\tif (!swap_slot_cache_active) {\n\t\tif (pages > num_online_cpus() *\n\t\t    THRESHOLD_ACTIVATE_SWAP_SLOTS_CACHE)\n\t\t\treactivate_swap_slots_cache();\n\t\tgoto out;\n\t}\n\n\t/* if global pool of slot caches too low, deactivate cache */\n\tif (pages < num_online_cpus() * THRESHOLD_DEACTIVATE_SWAP_SLOTS_CACHE)\n\t\tdeactivate_swap_slots_cache();\nout:\n\treturn swap_slot_cache_active;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool\tswap_slot_cache_active;",
            "bool\tswap_slot_cache_enabled;",
            "static bool\tswap_slot_cache_initialized;",
            "static void deactivate_swap_slots_cache(void);",
            "static void reactivate_swap_slots_cache(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic bool\tswap_slot_cache_active;\nbool\tswap_slot_cache_enabled;\nstatic bool\tswap_slot_cache_initialized;\nstatic void deactivate_swap_slots_cache(void);\nstatic void reactivate_swap_slots_cache(void);\n\nstatic bool check_cache_active(void)\n{\n\tlong pages;\n\n\tif (!swap_slot_cache_enabled || !swap_slot_cache_initialized)\n\t\treturn false;\n\n\tpages = get_nr_swap_pages();\n\tif (!swap_slot_cache_active) {\n\t\tif (pages > num_online_cpus() *\n\t\t    THRESHOLD_ACTIVATE_SWAP_SLOTS_CACHE)\n\t\t\treactivate_swap_slots_cache();\n\t\tgoto out;\n\t}\n\n\t/* if global pool of slot caches too low, deactivate cache */\n\tif (pages < num_online_cpus() * THRESHOLD_DEACTIVATE_SWAP_SLOTS_CACHE)\n\t\tdeactivate_swap_slots_cache();\nout:\n\treturn swap_slot_cache_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&swp_slots"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_THP_SWAP"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\n\nswp_entry_t get_swap_page(struct page *page)\n{\n\tswp_entry_t entry, *pentry;\n\tstruct swap_slots_cache *cache;\n\n\tentry.val = 0;\n\n\tif (PageTransHuge(page)) {\n\t\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\t\tget_swap_pages(1, &entry, HPAGE_PMD_NR);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Preemption is allowed here, because we may sleep\n\t * in refill_swap_slots_cache().  But it is safe, because\n\t * accesses to the per-CPU data structure are protected by the\n\t * mutex cache->alloc_lock.\n\t *\n\t * The alloc path here does not touch cache->slots_ret\n\t * so cache->free_lock is not taken.\n\t */\n\tcache = raw_cpu_ptr(&swp_slots);\n\n\tif (likely(check_cache_active() && cache->slots)) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tif (cache->slots) {\nrepeat:\n\t\t\tif (cache->nr) {\n\t\t\t\tpentry = &cache->slots[cache->cur++];\n\t\t\t\tentry = *pentry;\n\t\t\t\tpentry->val = 0;\n\t\t\t\tcache->nr--;\n\t\t\t} else {\n\t\t\t\tif (refill_swap_slots_cache(cache))\n\t\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t\tif (entry.val)\n\t\t\tgoto out;\n\t}\n\n\tget_swap_pages(1, &entry, 1);\nout:\n\tif (mem_cgroup_try_charge_swap(page, entry)) {\n\t\tput_swap_page(page, entry);\n\t\tentry.val = 0;\n\t}\n\treturn entry;\n}"
  },
  {
    "function_name": "free_swap_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "278-308",
    "snippet": "int free_swap_slot(swp_entry_t entry)\n{\n\tstruct swap_slots_cache *cache;\n\n\tcache = raw_cpu_ptr(&swp_slots);\n\tif (likely(use_swap_slot_cache && cache->slots_ret)) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\t/* Swap slots cache may be deactivated before acquiring lock */\n\t\tif (!use_swap_slot_cache || !cache->slots_ret) {\n\t\t\tspin_unlock_irq(&cache->free_lock);\n\t\t\tgoto direct_free;\n\t\t}\n\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * Return slots to global pool.\n\t\t\t * The current swap_map value is SWAP_HAS_CACHE.\n\t\t\t * Set it to 0 to indicate it is available for\n\t\t\t * allocation in global pool\n\t\t\t */\n\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\t\tcache->n_ret = 0;\n\t\t}\n\t\tcache->slots_ret[cache->n_ret++] = entry;\n\t\tspin_unlock_irq(&cache->free_lock);\n\t} else {\ndirect_free:\n\t\tswapcache_free_entries(&entry, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [
      "#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swapcache_free_entries",
          "args": [
            "&entry",
            "1"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "swapcache_free_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1296-1322",
          "snippet": "void swapcache_free_entries(swp_entry_t *entries, int n)\n{\n\tstruct swap_info_struct *p, *prev;\n\tint i;\n\n\tif (n <= 0)\n\t\treturn;\n\n\tprev = NULL;\n\tp = NULL;\n\n\t/*\n\t * Sort swap entries by swap device, so each lock is only taken once.\n\t * nr_swapfiles isn't absolutely correct, but the overhead of sort() is\n\t * so low that it isn't necessary to optimize further.\n\t */\n\tif (nr_swapfiles > 1)\n\t\tsort(entries, n, sizeof(entries[0]), swp_entry_cmp, NULL);\n\tfor (i = 0; i < n; ++i) {\n\t\tp = swap_info_get_cont(entries[i], prev);\n\t\tif (p)\n\t\t\tswap_entry_free(p, entries[i]);\n\t\tprev = p;\n\t}\n\tif (p)\n\t\tspin_unlock(&p->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static unsigned int nr_swapfiles;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\n\nvoid swapcache_free_entries(swp_entry_t *entries, int n)\n{\n\tstruct swap_info_struct *p, *prev;\n\tint i;\n\n\tif (n <= 0)\n\t\treturn;\n\n\tprev = NULL;\n\tp = NULL;\n\n\t/*\n\t * Sort swap entries by swap device, so each lock is only taken once.\n\t * nr_swapfiles isn't absolutely correct, but the overhead of sort() is\n\t * so low that it isn't necessary to optimize further.\n\t */\n\tif (nr_swapfiles > 1)\n\t\tsort(entries, n, sizeof(entries[0]), swp_entry_cmp, NULL);\n\tfor (i = 0; i < n; ++i) {\n\t\tp = swap_info_get_cont(entries[i], prev);\n\t\tif (p)\n\t\t\tswap_entry_free(p, entries[i]);\n\t\tprev = p;\n\t}\n\tif (p)\n\t\tspin_unlock(&p->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cache->free_lock"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cache->free_lock"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cache->free_lock"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "use_swap_slot_cache && cache->slots_ret"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&swp_slots"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\n\nint free_swap_slot(swp_entry_t entry)\n{\n\tstruct swap_slots_cache *cache;\n\n\tcache = raw_cpu_ptr(&swp_slots);\n\tif (likely(use_swap_slot_cache && cache->slots_ret)) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\t/* Swap slots cache may be deactivated before acquiring lock */\n\t\tif (!use_swap_slot_cache || !cache->slots_ret) {\n\t\t\tspin_unlock_irq(&cache->free_lock);\n\t\t\tgoto direct_free;\n\t\t}\n\t\tif (cache->n_ret >= SWAP_SLOTS_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * Return slots to global pool.\n\t\t\t * The current swap_map value is SWAP_HAS_CACHE.\n\t\t\t * Set it to 0 to indicate it is available for\n\t\t\t * allocation in global pool\n\t\t\t */\n\t\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\t\tcache->n_ret = 0;\n\t\t}\n\t\tcache->slots_ret[cache->n_ret++] = entry;\n\t\tspin_unlock_irq(&cache->free_lock);\n\t} else {\ndirect_free:\n\t\tswapcache_free_entries(&entry, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "refill_swap_slots_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "265-276",
    "snippet": "static int refill_swap_slots_cache(struct swap_slots_cache *cache)\n{\n\tif (!use_swap_slot_cache || cache->nr)\n\t\treturn 0;\n\n\tcache->cur = 0;\n\tif (swap_slot_cache_active)\n\t\tcache->nr = get_swap_pages(SWAP_SLOTS_CACHE_SIZE,\n\t\t\t\t\t   cache->slots, 1);\n\n\treturn cache->nr;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [
      "#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)"
    ],
    "globals_used": [
      "static bool\tswap_slot_cache_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_swap_pages",
          "args": [
            "SWAP_SLOTS_CACHE_SIZE",
            "cache->slots",
            "1"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "957-1042",
          "snippet": "int get_swap_pages(int n_goal, swp_entry_t swp_entries[], int entry_size)\n{\n\tunsigned long size = swap_entry_size(entry_size);\n\tstruct swap_info_struct *si, *next;\n\tlong avail_pgs;\n\tint n_ret = 0;\n\tint node;\n\n\t/* Only single cluster request supported */\n\tWARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);\n\n\tavail_pgs = atomic_long_read(&nr_swap_pages) / size;\n\tif (avail_pgs <= 0)\n\t\tgoto noswap;\n\n\tif (n_goal > SWAP_BATCH)\n\t\tn_goal = SWAP_BATCH;\n\n\tif (n_goal > avail_pgs)\n\t\tn_goal = avail_pgs;\n\n\tatomic_long_sub(n_goal * size, &nr_swap_pages);\n\n\tspin_lock(&swap_avail_lock);\n\nstart_over:\n\tnode = numa_node_id();\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {\n\t\t/* requeue si to after same-priority siblings */\n\t\tplist_requeue(&si->avail_lists[node], &swap_avail_heads[node]);\n\t\tspin_unlock(&swap_avail_lock);\n\t\tspin_lock(&si->lock);\n\t\tif (!si->highest_bit || !(si->flags & SWP_WRITEOK)) {\n\t\t\tspin_lock(&swap_avail_lock);\n\t\t\tif (plist_node_empty(&si->avail_lists[node])) {\n\t\t\t\tspin_unlock(&si->lock);\n\t\t\t\tgoto nextsi;\n\t\t\t}\n\t\t\tWARN(!si->highest_bit,\n\t\t\t     \"swap_info %d in list but !highest_bit\\n\",\n\t\t\t     si->type);\n\t\t\tWARN(!(si->flags & SWP_WRITEOK),\n\t\t\t     \"swap_info %d in list but !SWP_WRITEOK\\n\",\n\t\t\t     si->type);\n\t\t\t__del_from_avail_list(si);\n\t\t\tspin_unlock(&si->lock);\n\t\t\tgoto nextsi;\n\t\t}\n\t\tif (size == SWAPFILE_CLUSTER) {\n\t\t\tif (!(si->flags & SWP_FS))\n\t\t\t\tn_ret = swap_alloc_cluster(si, swp_entries);\n\t\t} else\n\t\t\tn_ret = scan_swap_map_slots(si, SWAP_HAS_CACHE,\n\t\t\t\t\t\t    n_goal, swp_entries);\n\t\tspin_unlock(&si->lock);\n\t\tif (n_ret || size == SWAPFILE_CLUSTER)\n\t\t\tgoto check_out;\n\t\tpr_debug(\"scan_swap_map of si %d failed to find offset\\n\",\n\t\t\tsi->type);\n\n\t\tspin_lock(&swap_avail_lock);\nnextsi:\n\t\t/*\n\t\t * if we got here, it's likely that si was almost full before,\n\t\t * and since scan_swap_map() can drop the si->lock, multiple\n\t\t * callers probably all tried to get a page from the same si\n\t\t * and it filled up before we could get one; or, the si filled\n\t\t * up between us dropping swap_avail_lock and taking si->lock.\n\t\t * Since we dropped the swap_avail_lock, the swap_avail_head\n\t\t * list may have been modified; so if next is still in the\n\t\t * swap_avail_head list then try it, otherwise start over\n\t\t * if we have not gotten any slots.\n\t\t */\n\t\tif (plist_node_empty(&next->avail_lists[node]))\n\t\t\tgoto start_over;\n\t}\n\n\tspin_unlock(&swap_avail_lock);\n\ncheck_out:\n\tif (n_ret < n_goal)\n\t\tatomic_long_add((long)(n_goal - n_ret) * size,\n\t\t\t\t&nr_swap_pages);\nnoswap:\n\treturn n_ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "atomic_long_t nr_swap_pages;",
            "static struct plist_head *swap_avail_heads;",
            "static DEFINE_SPINLOCK(swap_avail_lock);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\natomic_long_t nr_swap_pages;\nstatic struct plist_head *swap_avail_heads;\nstatic DEFINE_SPINLOCK(swap_avail_lock);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nint get_swap_pages(int n_goal, swp_entry_t swp_entries[], int entry_size)\n{\n\tunsigned long size = swap_entry_size(entry_size);\n\tstruct swap_info_struct *si, *next;\n\tlong avail_pgs;\n\tint n_ret = 0;\n\tint node;\n\n\t/* Only single cluster request supported */\n\tWARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);\n\n\tavail_pgs = atomic_long_read(&nr_swap_pages) / size;\n\tif (avail_pgs <= 0)\n\t\tgoto noswap;\n\n\tif (n_goal > SWAP_BATCH)\n\t\tn_goal = SWAP_BATCH;\n\n\tif (n_goal > avail_pgs)\n\t\tn_goal = avail_pgs;\n\n\tatomic_long_sub(n_goal * size, &nr_swap_pages);\n\n\tspin_lock(&swap_avail_lock);\n\nstart_over:\n\tnode = numa_node_id();\n\tplist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {\n\t\t/* requeue si to after same-priority siblings */\n\t\tplist_requeue(&si->avail_lists[node], &swap_avail_heads[node]);\n\t\tspin_unlock(&swap_avail_lock);\n\t\tspin_lock(&si->lock);\n\t\tif (!si->highest_bit || !(si->flags & SWP_WRITEOK)) {\n\t\t\tspin_lock(&swap_avail_lock);\n\t\t\tif (plist_node_empty(&si->avail_lists[node])) {\n\t\t\t\tspin_unlock(&si->lock);\n\t\t\t\tgoto nextsi;\n\t\t\t}\n\t\t\tWARN(!si->highest_bit,\n\t\t\t     \"swap_info %d in list but !highest_bit\\n\",\n\t\t\t     si->type);\n\t\t\tWARN(!(si->flags & SWP_WRITEOK),\n\t\t\t     \"swap_info %d in list but !SWP_WRITEOK\\n\",\n\t\t\t     si->type);\n\t\t\t__del_from_avail_list(si);\n\t\t\tspin_unlock(&si->lock);\n\t\t\tgoto nextsi;\n\t\t}\n\t\tif (size == SWAPFILE_CLUSTER) {\n\t\t\tif (!(si->flags & SWP_FS))\n\t\t\t\tn_ret = swap_alloc_cluster(si, swp_entries);\n\t\t} else\n\t\t\tn_ret = scan_swap_map_slots(si, SWAP_HAS_CACHE,\n\t\t\t\t\t\t    n_goal, swp_entries);\n\t\tspin_unlock(&si->lock);\n\t\tif (n_ret || size == SWAPFILE_CLUSTER)\n\t\t\tgoto check_out;\n\t\tpr_debug(\"scan_swap_map of si %d failed to find offset\\n\",\n\t\t\tsi->type);\n\n\t\tspin_lock(&swap_avail_lock);\nnextsi:\n\t\t/*\n\t\t * if we got here, it's likely that si was almost full before,\n\t\t * and since scan_swap_map() can drop the si->lock, multiple\n\t\t * callers probably all tried to get a page from the same si\n\t\t * and it filled up before we could get one; or, the si filled\n\t\t * up between us dropping swap_avail_lock and taking si->lock.\n\t\t * Since we dropped the swap_avail_lock, the swap_avail_head\n\t\t * list may have been modified; so if next is still in the\n\t\t * swap_avail_head list then try it, otherwise start over\n\t\t * if we have not gotten any slots.\n\t\t */\n\t\tif (plist_node_empty(&next->avail_lists[node]))\n\t\t\tgoto start_over;\n\t}\n\n\tspin_unlock(&swap_avail_lock);\n\ncheck_out:\n\tif (n_ret < n_goal)\n\t\tatomic_long_add((long)(n_goal - n_ret) * size,\n\t\t\t\t&nr_swap_pages);\nnoswap:\n\treturn n_ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define use_swap_slot_cache (swap_slot_cache_active && \\\n\t\tswap_slot_cache_enabled && swap_slot_cache_initialized)\n\nstatic bool\tswap_slot_cache_active;\n\nstatic int refill_swap_slots_cache(struct swap_slots_cache *cache)\n{\n\tif (!use_swap_slot_cache || cache->nr)\n\t\treturn 0;\n\n\tcache->cur = 0;\n\tif (swap_slot_cache_active)\n\t\tcache->nr = get_swap_pages(SWAP_SLOTS_CACHE_SIZE,\n\t\t\t\t\t   cache->slots, 1);\n\n\treturn cache->nr;\n}"
  },
  {
    "function_name": "enable_swap_slots_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "241-262",
    "snippet": "int enable_swap_slots_cache(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&swap_slots_cache_enable_mutex);\n\tif (swap_slot_cache_initialized) {\n\t\t__reenable_swap_slots_cache();\n\t\tgoto out_unlock;\n\t}\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"swap_slots_cache\",\n\t\t\t\talloc_swap_slot_cache, free_slot_cache);\n\tif (WARN_ONCE(ret < 0, \"Cache allocation failed (%s), operating \"\n\t\t\t       \"without swap slots cache.\\n\", __func__))\n\t\tgoto out_unlock;\n\n\tswap_slot_cache_initialized = true;\n\t__reenable_swap_slots_cache();\nout_unlock:\n\tmutex_unlock(&swap_slots_cache_enable_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool\tswap_slot_cache_initialized;",
      "static DEFINE_MUTEX(swap_slots_cache_enable_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_slots_cache_enable_mutex"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reenable_swap_slots_cache",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "__reenable_swap_slots_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "82-85",
          "snippet": "static void __reenable_swap_slots_cache(void)\n{\n\tswap_slot_cache_enabled = has_usable_swap();\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool\tswap_slot_cache_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nbool\tswap_slot_cache_enabled;\n\nstatic void __reenable_swap_slots_cache(void)\n{\n\tswap_slot_cache_enabled = has_usable_swap();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "ret < 0",
            "\"Cache allocation failed (%s), operating \"\n\t\t\t       \"without swap slots cache.\\n\"",
            "__func__"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"swap_slots_cache\"",
            "alloc_swap_slot_cache",
            "free_slot_cache"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_slots_cache_enable_mutex"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic bool\tswap_slot_cache_initialized;\nstatic DEFINE_MUTEX(swap_slots_cache_enable_mutex);\n\nint enable_swap_slots_cache(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&swap_slots_cache_enable_mutex);\n\tif (swap_slot_cache_initialized) {\n\t\t__reenable_swap_slots_cache();\n\t\tgoto out_unlock;\n\t}\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"swap_slots_cache\",\n\t\t\t\talloc_swap_slot_cache, free_slot_cache);\n\tif (WARN_ONCE(ret < 0, \"Cache allocation failed (%s), operating \"\n\t\t\t       \"without swap slots cache.\\n\", __func__))\n\t\tgoto out_unlock;\n\n\tswap_slot_cache_initialized = true;\n\t__reenable_swap_slots_cache();\nout_unlock:\n\tmutex_unlock(&swap_slots_cache_enable_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "free_slot_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "233-239",
    "snippet": "static int free_slot_cache(unsigned int cpu)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tdrain_slots_cache_cpu(cpu, SLOTS_CACHE | SLOTS_CACHE_RET, true);\n\tmutex_unlock(&swap_slots_cache_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [
      "#define SLOTS_CACHE_RET 0x2",
      "#define SLOTS_CACHE 0x1"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(swap_slots_cache_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_slots_cache_cpu",
          "args": [
            "cpu",
            "SLOTS_CACHE | SLOTS_CACHE_RET",
            "true"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "drain_slots_cache_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "170-200",
          "snippet": "static void drain_slots_cache_cpu(unsigned int cpu, unsigned int type,\n\t\t\t\t  bool free_slots)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots = NULL;\n\n\tcache = &per_cpu(swp_slots, cpu);\n\tif ((type & SLOTS_CACHE) && cache->slots) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tswapcache_free_entries(cache->slots + cache->cur, cache->nr);\n\t\tcache->cur = 0;\n\t\tcache->nr = 0;\n\t\tif (free_slots && cache->slots) {\n\t\t\tkvfree(cache->slots);\n\t\t\tcache->slots = NULL;\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t}\n\tif ((type & SLOTS_CACHE_RET) && cache->slots_ret) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\tcache->n_ret = 0;\n\t\tif (free_slots && cache->slots_ret) {\n\t\t\tslots = cache->slots_ret;\n\t\t\tcache->slots_ret = NULL;\n\t\t}\n\t\tspin_unlock_irq(&cache->free_lock);\n\t\tif (slots)\n\t\t\tkvfree(slots);\n\t}\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [
            "#define SLOTS_CACHE_RET 0x2",
            "#define SLOTS_CACHE 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);",
            "static void __drain_swap_slots_cache(unsigned int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define SLOTS_CACHE_RET 0x2\n#define SLOTS_CACHE 0x1\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\nstatic void __drain_swap_slots_cache(unsigned int type);\n\nstatic void drain_slots_cache_cpu(unsigned int cpu, unsigned int type,\n\t\t\t\t  bool free_slots)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots = NULL;\n\n\tcache = &per_cpu(swp_slots, cpu);\n\tif ((type & SLOTS_CACHE) && cache->slots) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tswapcache_free_entries(cache->slots + cache->cur, cache->nr);\n\t\tcache->cur = 0;\n\t\tcache->nr = 0;\n\t\tif (free_slots && cache->slots) {\n\t\t\tkvfree(cache->slots);\n\t\t\tcache->slots = NULL;\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t}\n\tif ((type & SLOTS_CACHE_RET) && cache->slots_ret) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\tcache->n_ret = 0;\n\t\tif (free_slots && cache->slots_ret) {\n\t\t\tslots = cache->slots_ret;\n\t\t\tcache->slots_ret = NULL;\n\t\t}\n\t\tspin_unlock_irq(&cache->free_lock);\n\t\tif (slots)\n\t\t\tkvfree(slots);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define SLOTS_CACHE_RET 0x2\n#define SLOTS_CACHE 0x1\n\nstatic DEFINE_MUTEX(swap_slots_cache_mutex);\n\nstatic int free_slot_cache(unsigned int cpu)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tdrain_slots_cache_cpu(cpu, SLOTS_CACHE | SLOTS_CACHE_RET, true);\n\tmutex_unlock(&swap_slots_cache_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "__drain_swap_slots_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "202-231",
    "snippet": "static void __drain_swap_slots_cache(unsigned int type)\n{\n\tunsigned int cpu;\n\n\t/*\n\t * This function is called during\n\t *\t1) swapoff, when we have to make sure no\n\t *\t   left over slots are in cache when we remove\n\t *\t   a swap device;\n\t *      2) disabling of swap slot cache, when we run low\n\t *\t   on swap slots when allocating memory and need\n\t *\t   to return swap slots to global pool.\n\t *\n\t * We cannot acquire cpu hot plug lock here as\n\t * this function can be invoked in the cpu\n\t * hot plug path:\n\t * cpu_up -> lock cpu_hotplug -> cpu hotplug state callback\n\t *   -> memory allocation -> direct reclaim -> get_swap_page\n\t *   -> drain_swap_slots_cache\n\t *\n\t * Hence the loop over current online cpu below could miss cpu that\n\t * is being brought online but not yet marked as online.\n\t * That is okay as we do not schedule and run anything on a\n\t * cpu before it has been marked online. Hence, we will not\n\t * fill any swap slots in slots cache of such cpu.\n\t * There are no slots on such cpu that need to be drained.\n\t */\n\tfor_each_online_cpu(cpu)\n\t\tdrain_slots_cache_cpu(cpu, type, false);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __drain_swap_slots_cache(unsigned int type);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic void __drain_swap_slots_cache(unsigned int type);\n\nstatic void __drain_swap_slots_cache(unsigned int type)\n{\n\tunsigned int cpu;\n\n\t/*\n\t * This function is called during\n\t *\t1) swapoff, when we have to make sure no\n\t *\t   left over slots are in cache when we remove\n\t *\t   a swap device;\n\t *      2) disabling of swap slot cache, when we run low\n\t *\t   on swap slots when allocating memory and need\n\t *\t   to return swap slots to global pool.\n\t *\n\t * We cannot acquire cpu hot plug lock here as\n\t * this function can be invoked in the cpu\n\t * hot plug path:\n\t * cpu_up -> lock cpu_hotplug -> cpu hotplug state callback\n\t *   -> memory allocation -> direct reclaim -> get_swap_page\n\t *   -> drain_swap_slots_cache\n\t *\n\t * Hence the loop over current online cpu below could miss cpu that\n\t * is being brought online but not yet marked as online.\n\t * That is okay as we do not schedule and run anything on a\n\t * cpu before it has been marked online. Hence, we will not\n\t * fill any swap slots in slots cache of such cpu.\n\t * There are no slots on such cpu that need to be drained.\n\t */\n\tfor_each_online_cpu(cpu)\n\t\tdrain_slots_cache_cpu(cpu, type, false);\n}"
  },
  {
    "function_name": "drain_slots_cache_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "170-200",
    "snippet": "static void drain_slots_cache_cpu(unsigned int cpu, unsigned int type,\n\t\t\t\t  bool free_slots)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots = NULL;\n\n\tcache = &per_cpu(swp_slots, cpu);\n\tif ((type & SLOTS_CACHE) && cache->slots) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tswapcache_free_entries(cache->slots + cache->cur, cache->nr);\n\t\tcache->cur = 0;\n\t\tcache->nr = 0;\n\t\tif (free_slots && cache->slots) {\n\t\t\tkvfree(cache->slots);\n\t\t\tcache->slots = NULL;\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t}\n\tif ((type & SLOTS_CACHE_RET) && cache->slots_ret) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\tcache->n_ret = 0;\n\t\tif (free_slots && cache->slots_ret) {\n\t\t\tslots = cache->slots_ret;\n\t\t\tcache->slots_ret = NULL;\n\t\t}\n\t\tspin_unlock_irq(&cache->free_lock);\n\t\tif (slots)\n\t\t\tkvfree(slots);\n\t}\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [
      "#define SLOTS_CACHE_RET 0x2",
      "#define SLOTS_CACHE 0x1"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);",
      "static void __drain_swap_slots_cache(unsigned int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "slots"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cache->free_lock"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swapcache_free_entries",
          "args": [
            "cache->slots_ret",
            "cache->n_ret"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "swapcache_free_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1296-1322",
          "snippet": "void swapcache_free_entries(swp_entry_t *entries, int n)\n{\n\tstruct swap_info_struct *p, *prev;\n\tint i;\n\n\tif (n <= 0)\n\t\treturn;\n\n\tprev = NULL;\n\tp = NULL;\n\n\t/*\n\t * Sort swap entries by swap device, so each lock is only taken once.\n\t * nr_swapfiles isn't absolutely correct, but the overhead of sort() is\n\t * so low that it isn't necessary to optimize further.\n\t */\n\tif (nr_swapfiles > 1)\n\t\tsort(entries, n, sizeof(entries[0]), swp_entry_cmp, NULL);\n\tfor (i = 0; i < n; ++i) {\n\t\tp = swap_info_get_cont(entries[i], prev);\n\t\tif (p)\n\t\t\tswap_entry_free(p, entries[i]);\n\t\tprev = p;\n\t}\n\tif (p)\n\t\tspin_unlock(&p->lock);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "static unsigned int nr_swapfiles;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstatic unsigned int nr_swapfiles;\n\nvoid swapcache_free_entries(swp_entry_t *entries, int n)\n{\n\tstruct swap_info_struct *p, *prev;\n\tint i;\n\n\tif (n <= 0)\n\t\treturn;\n\n\tprev = NULL;\n\tp = NULL;\n\n\t/*\n\t * Sort swap entries by swap device, so each lock is only taken once.\n\t * nr_swapfiles isn't absolutely correct, but the overhead of sort() is\n\t * so low that it isn't necessary to optimize further.\n\t */\n\tif (nr_swapfiles > 1)\n\t\tsort(entries, n, sizeof(entries[0]), swp_entry_cmp, NULL);\n\tfor (i = 0; i < n; ++i) {\n\t\tp = swap_info_get_cont(entries[i], prev);\n\t\tif (p)\n\t\t\tswap_entry_free(p, entries[i]);\n\t\tprev = p;\n\t}\n\tif (p)\n\t\tspin_unlock(&p->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cache->free_lock"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cache->alloc_lock"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cache->alloc_lock"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "swp_slots",
            "cpu"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define SLOTS_CACHE_RET 0x2\n#define SLOTS_CACHE 0x1\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\nstatic void __drain_swap_slots_cache(unsigned int type);\n\nstatic void drain_slots_cache_cpu(unsigned int cpu, unsigned int type,\n\t\t\t\t  bool free_slots)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots = NULL;\n\n\tcache = &per_cpu(swp_slots, cpu);\n\tif ((type & SLOTS_CACHE) && cache->slots) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tswapcache_free_entries(cache->slots + cache->cur, cache->nr);\n\t\tcache->cur = 0;\n\t\tcache->nr = 0;\n\t\tif (free_slots && cache->slots) {\n\t\t\tkvfree(cache->slots);\n\t\t\tcache->slots = NULL;\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t}\n\tif ((type & SLOTS_CACHE_RET) && cache->slots_ret) {\n\t\tspin_lock_irq(&cache->free_lock);\n\t\tswapcache_free_entries(cache->slots_ret, cache->n_ret);\n\t\tcache->n_ret = 0;\n\t\tif (free_slots && cache->slots_ret) {\n\t\t\tslots = cache->slots_ret;\n\t\t\tcache->slots_ret = NULL;\n\t\t}\n\t\tspin_unlock_irq(&cache->free_lock);\n\t\tif (slots)\n\t\t\tkvfree(slots);\n\t}\n}"
  },
  {
    "function_name": "alloc_swap_slot_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "115-168",
    "snippet": "static int alloc_swap_slot_cache(unsigned int cpu)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots, *slots_ret;\n\n\t/*\n\t * Do allocation outside swap_slots_cache_mutex\n\t * as kvzalloc could trigger reclaim and get_swap_page,\n\t * which can lock swap_slots_cache_mutex.\n\t */\n\tslots = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),\n\t\t\t GFP_KERNEL);\n\tif (!slots)\n\t\treturn -ENOMEM;\n\n\tslots_ret = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),\n\t\t\t     GFP_KERNEL);\n\tif (!slots_ret) {\n\t\tkvfree(slots);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&swap_slots_cache_mutex);\n\tcache = &per_cpu(swp_slots, cpu);\n\tif (cache->slots || cache->slots_ret)\n\t\t/* cache already allocated */\n\t\tgoto out;\n\tif (!cache->lock_initialized) {\n\t\tmutex_init(&cache->alloc_lock);\n\t\tspin_lock_init(&cache->free_lock);\n\t\tcache->lock_initialized = true;\n\t}\n\tcache->nr = 0;\n\tcache->cur = 0;\n\tcache->n_ret = 0;\n\t/*\n\t * We initialized alloc_lock and free_lock earlier.  We use\n\t * !cache->slots or !cache->slots_ret to know if it is safe to acquire\n\t * the corresponding lock and use the cache.  Memory barrier below\n\t * ensures the assumption.\n\t */\n\tmb();\n\tcache->slots = slots;\n\tslots = NULL;\n\tcache->slots_ret = slots_ret;\n\tslots_ret = NULL;\nout:\n\tmutex_unlock(&swap_slots_cache_mutex);\n\tif (slots)\n\t\tkvfree(slots);\n\tif (slots_ret)\n\t\tkvfree(slots_ret);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);",
      "static DEFINE_MUTEX(swap_slots_cache_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "slots_ret"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_init_debugfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "2006-2021",
          "snippet": "static int __init memblock_init_debugfs(void)\n{\n\tstruct dentry *root = debugfs_create_dir(\"memblock\", NULL);\n\tif (!root)\n\t\treturn -ENXIO;\n\tdebugfs_create_file(\"memory\", 0444, root,\n\t\t\t    &memblock.memory, &memblock_debug_fops);\n\tdebugfs_create_file(\"reserved\", 0444, root,\n\t\t\t    &memblock.reserved, &memblock_debug_fops);\n#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP\n\tdebugfs_create_file(\"physmem\", 0444, root,\n\t\t\t    &memblock.physmem, &memblock_debug_fops);\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int __init memblock_init_debugfs(void)\n{\n\tstruct dentry *root = debugfs_create_dir(\"memblock\", NULL);\n\tif (!root)\n\t\treturn -ENXIO;\n\tdebugfs_create_file(\"memory\", 0444, root,\n\t\t\t    &memblock.memory, &memblock_debug_fops);\n\tdebugfs_create_file(\"reserved\", 0444, root,\n\t\t\t    &memblock.reserved, &memblock_debug_fops);\n#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP\n\tdebugfs_create_file(\"physmem\", 0444, root,\n\t\t\t    &memblock.physmem, &memblock_debug_fops);\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cache->free_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&cache->alloc_lock"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "swp_slots",
            "cpu"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "SWAP_SLOTS_CACHE_SIZE",
            "sizeof(swp_entry_t)",
            "GFP_KERNEL"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "SWAP_SLOTS_CACHE_SIZE",
            "sizeof(swp_entry_t)",
            "GFP_KERNEL"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\nstatic DEFINE_MUTEX(swap_slots_cache_mutex);\n\nstatic int alloc_swap_slot_cache(unsigned int cpu)\n{\n\tstruct swap_slots_cache *cache;\n\tswp_entry_t *slots, *slots_ret;\n\n\t/*\n\t * Do allocation outside swap_slots_cache_mutex\n\t * as kvzalloc could trigger reclaim and get_swap_page,\n\t * which can lock swap_slots_cache_mutex.\n\t */\n\tslots = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),\n\t\t\t GFP_KERNEL);\n\tif (!slots)\n\t\treturn -ENOMEM;\n\n\tslots_ret = kvcalloc(SWAP_SLOTS_CACHE_SIZE, sizeof(swp_entry_t),\n\t\t\t     GFP_KERNEL);\n\tif (!slots_ret) {\n\t\tkvfree(slots);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&swap_slots_cache_mutex);\n\tcache = &per_cpu(swp_slots, cpu);\n\tif (cache->slots || cache->slots_ret)\n\t\t/* cache already allocated */\n\t\tgoto out;\n\tif (!cache->lock_initialized) {\n\t\tmutex_init(&cache->alloc_lock);\n\t\tspin_lock_init(&cache->free_lock);\n\t\tcache->lock_initialized = true;\n\t}\n\tcache->nr = 0;\n\tcache->cur = 0;\n\tcache->n_ret = 0;\n\t/*\n\t * We initialized alloc_lock and free_lock earlier.  We use\n\t * !cache->slots or !cache->slots_ret to know if it is safe to acquire\n\t * the corresponding lock and use the cache.  Memory barrier below\n\t * ensures the assumption.\n\t */\n\tmb();\n\tcache->slots = slots;\n\tslots = NULL;\n\tcache->slots_ret = slots_ret;\n\tslots_ret = NULL;\nout:\n\tmutex_unlock(&swap_slots_cache_mutex);\n\tif (slots)\n\t\tkvfree(slots);\n\tif (slots_ret)\n\t\tkvfree(slots_ret);\n\treturn 0;\n}"
  },
  {
    "function_name": "check_cache_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "93-113",
    "snippet": "static bool check_cache_active(void)\n{\n\tlong pages;\n\n\tif (!swap_slot_cache_enabled || !swap_slot_cache_initialized)\n\t\treturn false;\n\n\tpages = get_nr_swap_pages();\n\tif (!swap_slot_cache_active) {\n\t\tif (pages > num_online_cpus() *\n\t\t    THRESHOLD_ACTIVATE_SWAP_SLOTS_CACHE)\n\t\t\treactivate_swap_slots_cache();\n\t\tgoto out;\n\t}\n\n\t/* if global pool of slot caches too low, deactivate cache */\n\tif (pages < num_online_cpus() * THRESHOLD_DEACTIVATE_SWAP_SLOTS_CACHE)\n\t\tdeactivate_swap_slots_cache();\nout:\n\treturn swap_slot_cache_active;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool\tswap_slot_cache_active;",
      "bool\tswap_slot_cache_enabled;",
      "static bool\tswap_slot_cache_initialized;",
      "static void deactivate_swap_slots_cache(void);",
      "static void reactivate_swap_slots_cache(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deactivate_swap_slots_cache",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_swap_slots_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "54-60",
          "snippet": "static void deactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = false;\n\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\tmutex_unlock(&swap_slots_cache_mutex);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [
            "#define SLOTS_CACHE_RET 0x2",
            "#define SLOTS_CACHE 0x1"
          ],
          "globals_used": [
            "static bool\tswap_slot_cache_active;",
            "static DEFINE_MUTEX(swap_slots_cache_mutex);",
            "static void deactivate_swap_slots_cache(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define SLOTS_CACHE_RET 0x2\n#define SLOTS_CACHE 0x1\n\nstatic bool\tswap_slot_cache_active;\nstatic DEFINE_MUTEX(swap_slots_cache_mutex);\nstatic void deactivate_swap_slots_cache(void);\n\nstatic void deactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = false;\n\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\tmutex_unlock(&swap_slots_cache_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reactivate_swap_slots_cache",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "reactivate_swap_slots_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "62-67",
          "snippet": "static void reactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = true;\n\tmutex_unlock(&swap_slots_cache_mutex);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool\tswap_slot_cache_active;",
            "static DEFINE_MUTEX(swap_slots_cache_mutex);",
            "static void reactivate_swap_slots_cache(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic bool\tswap_slot_cache_active;\nstatic DEFINE_MUTEX(swap_slots_cache_mutex);\nstatic void reactivate_swap_slots_cache(void);\n\nstatic void reactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = true;\n\tmutex_unlock(&swap_slots_cache_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_swap_pages",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic bool\tswap_slot_cache_active;\nbool\tswap_slot_cache_enabled;\nstatic bool\tswap_slot_cache_initialized;\nstatic void deactivate_swap_slots_cache(void);\nstatic void reactivate_swap_slots_cache(void);\n\nstatic bool check_cache_active(void)\n{\n\tlong pages;\n\n\tif (!swap_slot_cache_enabled || !swap_slot_cache_initialized)\n\t\treturn false;\n\n\tpages = get_nr_swap_pages();\n\tif (!swap_slot_cache_active) {\n\t\tif (pages > num_online_cpus() *\n\t\t    THRESHOLD_ACTIVATE_SWAP_SLOTS_CACHE)\n\t\t\treactivate_swap_slots_cache();\n\t\tgoto out;\n\t}\n\n\t/* if global pool of slot caches too low, deactivate cache */\n\tif (pages < num_online_cpus() * THRESHOLD_DEACTIVATE_SWAP_SLOTS_CACHE)\n\t\tdeactivate_swap_slots_cache();\nout:\n\treturn swap_slot_cache_active;\n}"
  },
  {
    "function_name": "reenable_swap_slots_cache_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "87-91",
    "snippet": "void reenable_swap_slots_cache_unlock(void)\n{\n\t__reenable_swap_slots_cache();\n\tmutex_unlock(&swap_slots_cache_enable_mutex);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(swap_slots_cache_enable_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_slots_cache_enable_mutex"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reenable_swap_slots_cache",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "__reenable_swap_slots_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "82-85",
          "snippet": "static void __reenable_swap_slots_cache(void)\n{\n\tswap_slot_cache_enabled = has_usable_swap();\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool\tswap_slot_cache_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nbool\tswap_slot_cache_enabled;\n\nstatic void __reenable_swap_slots_cache(void)\n{\n\tswap_slot_cache_enabled = has_usable_swap();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic DEFINE_MUTEX(swap_slots_cache_enable_mutex);\n\nvoid reenable_swap_slots_cache_unlock(void)\n{\n\t__reenable_swap_slots_cache();\n\tmutex_unlock(&swap_slots_cache_enable_mutex);\n}"
  },
  {
    "function_name": "__reenable_swap_slots_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "82-85",
    "snippet": "static void __reenable_swap_slots_cache(void)\n{\n\tswap_slot_cache_enabled = has_usable_swap();\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool\tswap_slot_cache_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_usable_swap",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "has_usable_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2498-2507",
          "snippet": "bool has_usable_swap(void)\n{\n\tbool ret = true;\n\n\tspin_lock(&swap_lock);\n\tif (plist_head_empty(&swap_active_head))\n\t\tret = false;\n\tspin_unlock(&swap_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool has_usable_swap(void)\n{\n\tbool ret = true;\n\n\tspin_lock(&swap_lock);\n\tif (plist_head_empty(&swap_active_head))\n\t\tret = false;\n\tspin_unlock(&swap_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nbool\tswap_slot_cache_enabled;\n\nstatic void __reenable_swap_slots_cache(void)\n{\n\tswap_slot_cache_enabled = has_usable_swap();\n}"
  },
  {
    "function_name": "disable_swap_slots_cache_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "70-80",
    "snippet": "void disable_swap_slots_cache_lock(void)\n{\n\tmutex_lock(&swap_slots_cache_enable_mutex);\n\tswap_slot_cache_enabled = false;\n\tif (swap_slot_cache_initialized) {\n\t\t/* serialize with cpu hotplug operations */\n\t\tget_online_cpus();\n\t\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\t\tput_online_cpus();\n\t}\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [
      "#define SLOTS_CACHE_RET 0x2",
      "#define SLOTS_CACHE 0x1"
    ],
    "globals_used": [
      "bool\tswap_slot_cache_enabled;",
      "static bool\tswap_slot_cache_initialized;",
      "static DEFINE_MUTEX(swap_slots_cache_enable_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__drain_swap_slots_cache",
          "args": [
            "SLOTS_CACHE|SLOTS_CACHE_RET"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "__drain_swap_slots_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "202-231",
          "snippet": "static void __drain_swap_slots_cache(unsigned int type)\n{\n\tunsigned int cpu;\n\n\t/*\n\t * This function is called during\n\t *\t1) swapoff, when we have to make sure no\n\t *\t   left over slots are in cache when we remove\n\t *\t   a swap device;\n\t *      2) disabling of swap slot cache, when we run low\n\t *\t   on swap slots when allocating memory and need\n\t *\t   to return swap slots to global pool.\n\t *\n\t * We cannot acquire cpu hot plug lock here as\n\t * this function can be invoked in the cpu\n\t * hot plug path:\n\t * cpu_up -> lock cpu_hotplug -> cpu hotplug state callback\n\t *   -> memory allocation -> direct reclaim -> get_swap_page\n\t *   -> drain_swap_slots_cache\n\t *\n\t * Hence the loop over current online cpu below could miss cpu that\n\t * is being brought online but not yet marked as online.\n\t * That is okay as we do not schedule and run anything on a\n\t * cpu before it has been marked online. Hence, we will not\n\t * fill any swap slots in slots cache of such cpu.\n\t * There are no slots on such cpu that need to be drained.\n\t */\n\tfor_each_online_cpu(cpu)\n\t\tdrain_slots_cache_cpu(cpu, type, false);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __drain_swap_slots_cache(unsigned int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic void __drain_swap_slots_cache(unsigned int type);\n\nstatic void __drain_swap_slots_cache(unsigned int type)\n{\n\tunsigned int cpu;\n\n\t/*\n\t * This function is called during\n\t *\t1) swapoff, when we have to make sure no\n\t *\t   left over slots are in cache when we remove\n\t *\t   a swap device;\n\t *      2) disabling of swap slot cache, when we run low\n\t *\t   on swap slots when allocating memory and need\n\t *\t   to return swap slots to global pool.\n\t *\n\t * We cannot acquire cpu hot plug lock here as\n\t * this function can be invoked in the cpu\n\t * hot plug path:\n\t * cpu_up -> lock cpu_hotplug -> cpu hotplug state callback\n\t *   -> memory allocation -> direct reclaim -> get_swap_page\n\t *   -> drain_swap_slots_cache\n\t *\n\t * Hence the loop over current online cpu below could miss cpu that\n\t * is being brought online but not yet marked as online.\n\t * That is okay as we do not schedule and run anything on a\n\t * cpu before it has been marked online. Hence, we will not\n\t * fill any swap slots in slots cache of such cpu.\n\t * There are no slots on such cpu that need to be drained.\n\t */\n\tfor_each_online_cpu(cpu)\n\t\tdrain_slots_cache_cpu(cpu, type, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_slots_cache_enable_mutex"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define SLOTS_CACHE_RET 0x2\n#define SLOTS_CACHE 0x1\n\nbool\tswap_slot_cache_enabled;\nstatic bool\tswap_slot_cache_initialized;\nstatic DEFINE_MUTEX(swap_slots_cache_enable_mutex);\n\nvoid disable_swap_slots_cache_lock(void)\n{\n\tmutex_lock(&swap_slots_cache_enable_mutex);\n\tswap_slot_cache_enabled = false;\n\tif (swap_slot_cache_initialized) {\n\t\t/* serialize with cpu hotplug operations */\n\t\tget_online_cpus();\n\t\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\t\tput_online_cpus();\n\t}\n}"
  },
  {
    "function_name": "reactivate_swap_slots_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "62-67",
    "snippet": "static void reactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = true;\n\tmutex_unlock(&swap_slots_cache_mutex);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool\tswap_slot_cache_active;",
      "static DEFINE_MUTEX(swap_slots_cache_mutex);",
      "static void reactivate_swap_slots_cache(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic bool\tswap_slot_cache_active;\nstatic DEFINE_MUTEX(swap_slots_cache_mutex);\nstatic void reactivate_swap_slots_cache(void);\n\nstatic void reactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = true;\n\tmutex_unlock(&swap_slots_cache_mutex);\n}"
  },
  {
    "function_name": "deactivate_swap_slots_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
    "lines": "54-60",
    "snippet": "static void deactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = false;\n\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\tmutex_unlock(&swap_slots_cache_mutex);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>",
      "#include <linux/swap_slots.h>"
    ],
    "macros_used": [
      "#define SLOTS_CACHE_RET 0x2",
      "#define SLOTS_CACHE 0x1"
    ],
    "globals_used": [
      "static bool\tswap_slot_cache_active;",
      "static DEFINE_MUTEX(swap_slots_cache_mutex);",
      "static void deactivate_swap_slots_cache(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__drain_swap_slots_cache",
          "args": [
            "SLOTS_CACHE|SLOTS_CACHE_RET"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__drain_swap_slots_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "202-231",
          "snippet": "static void __drain_swap_slots_cache(unsigned int type)\n{\n\tunsigned int cpu;\n\n\t/*\n\t * This function is called during\n\t *\t1) swapoff, when we have to make sure no\n\t *\t   left over slots are in cache when we remove\n\t *\t   a swap device;\n\t *      2) disabling of swap slot cache, when we run low\n\t *\t   on swap slots when allocating memory and need\n\t *\t   to return swap slots to global pool.\n\t *\n\t * We cannot acquire cpu hot plug lock here as\n\t * this function can be invoked in the cpu\n\t * hot plug path:\n\t * cpu_up -> lock cpu_hotplug -> cpu hotplug state callback\n\t *   -> memory allocation -> direct reclaim -> get_swap_page\n\t *   -> drain_swap_slots_cache\n\t *\n\t * Hence the loop over current online cpu below could miss cpu that\n\t * is being brought online but not yet marked as online.\n\t * That is okay as we do not schedule and run anything on a\n\t * cpu before it has been marked online. Hence, we will not\n\t * fill any swap slots in slots cache of such cpu.\n\t * There are no slots on such cpu that need to be drained.\n\t */\n\tfor_each_online_cpu(cpu)\n\t\tdrain_slots_cache_cpu(cpu, type, false);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __drain_swap_slots_cache(unsigned int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic void __drain_swap_slots_cache(unsigned int type);\n\nstatic void __drain_swap_slots_cache(unsigned int type)\n{\n\tunsigned int cpu;\n\n\t/*\n\t * This function is called during\n\t *\t1) swapoff, when we have to make sure no\n\t *\t   left over slots are in cache when we remove\n\t *\t   a swap device;\n\t *      2) disabling of swap slot cache, when we run low\n\t *\t   on swap slots when allocating memory and need\n\t *\t   to return swap slots to global pool.\n\t *\n\t * We cannot acquire cpu hot plug lock here as\n\t * this function can be invoked in the cpu\n\t * hot plug path:\n\t * cpu_up -> lock cpu_hotplug -> cpu hotplug state callback\n\t *   -> memory allocation -> direct reclaim -> get_swap_page\n\t *   -> drain_swap_slots_cache\n\t *\n\t * Hence the loop over current online cpu below could miss cpu that\n\t * is being brought online but not yet marked as online.\n\t * That is okay as we do not schedule and run anything on a\n\t * cpu before it has been marked online. Hence, we will not\n\t * fill any swap slots in slots cache of such cpu.\n\t * There are no slots on such cpu that need to be drained.\n\t */\n\tfor_each_online_cpu(cpu)\n\t\tdrain_slots_cache_cpu(cpu, type, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_slots_cache_mutex"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\n#define SLOTS_CACHE_RET 0x2\n#define SLOTS_CACHE 0x1\n\nstatic bool\tswap_slot_cache_active;\nstatic DEFINE_MUTEX(swap_slots_cache_mutex);\nstatic void deactivate_swap_slots_cache(void);\n\nstatic void deactivate_swap_slots_cache(void)\n{\n\tmutex_lock(&swap_slots_cache_mutex);\n\tswap_slot_cache_active = false;\n\t__drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET);\n\tmutex_unlock(&swap_slots_cache_mutex);\n}"
  }
]