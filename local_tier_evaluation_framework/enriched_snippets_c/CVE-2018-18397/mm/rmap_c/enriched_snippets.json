[
  {
    "function_name": "hugepage_add_new_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1955-1961",
    "snippet": "void hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hugepage_set_anon_rmap",
          "args": [
            "page",
            "vma",
            "address",
            "1"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "__hugepage_set_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1924-1939",
          "snippet": "static void __hugepage_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __hugepage_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "compound_mapcount_ptr(page)",
            "0"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "address < vma->vm_start || address >= vma->vm_end"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\t__hugepage_set_anon_rmap(page, vma, address, 1);\n}"
  },
  {
    "function_name": "hugepage_add_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1941-1953",
    "snippet": "void hugepage_add_anon_rmap(struct page *page,\n\t\t\t    struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tint first;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!anon_vma);\n\t/* address might be in next vma when migration races vma_adjust */\n\tfirst = atomic_inc_and_test(compound_mapcount_ptr(page));\n\tif (first)\n\t\t__hugepage_set_anon_rmap(page, vma, address, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hugepage_set_anon_rmap",
          "args": [
            "page",
            "vma",
            "address",
            "0"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "__hugepage_set_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1924-1939",
          "snippet": "static void __hugepage_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __hugepage_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_and_test",
          "args": [
            "compound_mapcount_ptr(page)"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!anon_vma"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid hugepage_add_anon_rmap(struct page *page,\n\t\t\t    struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tint first;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!anon_vma);\n\t/* address might be in next vma when migration races vma_adjust */\n\tfirst = atomic_inc_and_test(compound_mapcount_ptr(page));\n\tif (first)\n\t\t__hugepage_set_anon_rmap(page, vma, address, 0);\n}"
  },
  {
    "function_name": "__hugepage_set_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1924-1939",
    "snippet": "static void __hugepage_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "address"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!anon_vma"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __hugepage_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}"
  },
  {
    "function_name": "rmap_walk_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1908-1916",
    "snippet": "void rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk_file",
          "args": [
            "page",
            "rwc",
            "true"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1855-1895",
          "snippet": "static void rmap_walk_file(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tif (!locked)\n\t\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void rmap_walk_file(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tif (!locked)\n\t\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_walk_anon",
          "args": [
            "page",
            "rwc",
            "true"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1803-1840",
          "snippet": "static void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = page_anon_vma(page);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_PAGE(!anon_vma, page);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(page, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = page_anon_vma(page);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_PAGE(!anon_vma, page);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(page, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageKsm(page)",
            "page"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}"
  },
  {
    "function_name": "rmap_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1897-1905",
    "snippet": "void rmap_walk(struct page *page, struct rmap_walk_control *rwc)\n{\n\tif (unlikely(PageKsm(page)))\n\t\trmap_walk_ksm(page, rwc);\n\telse if (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, false);\n\telse\n\t\trmap_walk_file(page, rwc, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk_file",
          "args": [
            "page",
            "rwc",
            "false"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1855-1895",
          "snippet": "static void rmap_walk_file(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tif (!locked)\n\t\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void rmap_walk_file(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tif (!locked)\n\t\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_walk_anon",
          "args": [
            "page",
            "rwc",
            "false"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1803-1840",
          "snippet": "static void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = page_anon_vma(page);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_PAGE(!anon_vma, page);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(page, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = page_anon_vma(page);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_PAGE(!anon_vma, page);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(page, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_walk_ksm",
          "args": [
            "page",
            "rwc"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_ksm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2579-2641",
          "snippet": "void rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageKsm(page)"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid rmap_walk(struct page *page, struct rmap_walk_control *rwc)\n{\n\tif (unlikely(PageKsm(page)))\n\t\trmap_walk_ksm(page, rwc);\n\telse if (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, false);\n\telse\n\t\trmap_walk_file(page, rwc, false);\n}"
  },
  {
    "function_name": "rmap_walk_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1855-1895",
    "snippet": "static void rmap_walk_file(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tif (!locked)\n\t\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->done",
          "args": [
            "page"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->rmap_one",
          "args": [
            "page",
            "vma",
            "address",
            "rwc->arg"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->invalid_vma",
          "args": [
            "vma",
            "rwc->arg"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_address",
          "args": [
            "page",
            "vma"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "vma_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "343-355",
          "snippet": "static inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "&mapping->i_mmap",
            "pgoff_start",
            "pgoff_end"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void rmap_walk_file(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tif (!locked)\n\t\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}"
  },
  {
    "function_name": "rmap_walk_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1803-1840",
    "snippet": "static void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = page_anon_vma(page);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_PAGE(!anon_vma, page);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(page, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_unlock_read",
          "args": [
            "anon_vma"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->done",
          "args": [
            "page"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->rmap_one",
          "args": [
            "page",
            "vma",
            "address",
            "rwc->arg"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->invalid_vma",
          "args": [
            "vma",
            "rwc->arg"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_address",
          "args": [
            "page",
            "vma"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "vma_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "343-355",
          "snippet": "static inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_foreach",
          "args": [
            "avc",
            "&anon_vma->rb_root",
            "pgoff_start",
            "pgoff_end"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_walk_anon_lock",
          "args": [
            "page",
            "rwc"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_anon_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1767-1787",
          "snippet": "static struct anon_vma *rmap_walk_anon_lock(struct page *page,\n\t\t\t\t\tstruct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma;\n\n\tif (rwc->anon_lock)\n\t\treturn rwc->anon_lock(page);\n\n\t/*\n\t * Note: remove_migration_ptes() cannot use page_lock_anon_vma_read()\n\t * because that depends on page_mapped(); but not all its usages\n\t * are holding mmap_sem. Users without mmap_sem are required to\n\t * take a reference count to prevent the anon_vma disappearing\n\t */\n\tanon_vma = page_anon_vma(page);\n\tif (!anon_vma)\n\t\treturn NULL;\n\n\tanon_vma_lock_read(anon_vma);\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct anon_vma *rmap_walk_anon_lock(struct page *page,\n\t\t\t\t\tstruct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma;\n\n\tif (rwc->anon_lock)\n\t\treturn rwc->anon_lock(page);\n\n\t/*\n\t * Note: remove_migration_ptes() cannot use page_lock_anon_vma_read()\n\t * because that depends on page_mapped(); but not all its usages\n\t * are holding mmap_sem. Users without mmap_sem are required to\n\t * take a reference count to prevent the anon_vma disappearing\n\t */\n\tanon_vma = page_anon_vma(page);\n\tif (!anon_vma)\n\t\treturn NULL;\n\n\tanon_vma_lock_read(anon_vma);\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!anon_vma",
            "page"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_anon_vma",
          "args": [
            "page"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "page_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "489-498",
          "snippet": "struct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,\n\t\tbool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = page_anon_vma(page);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_PAGE(!anon_vma, page);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(page, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = page_to_pgoff(page);\n\tpgoff_end = pgoff_start + hpage_nr_pages(page) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(page, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}"
  },
  {
    "function_name": "rmap_walk_anon_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1767-1787",
    "snippet": "static struct anon_vma *rmap_walk_anon_lock(struct page *page,\n\t\t\t\t\tstruct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma;\n\n\tif (rwc->anon_lock)\n\t\treturn rwc->anon_lock(page);\n\n\t/*\n\t * Note: remove_migration_ptes() cannot use page_lock_anon_vma_read()\n\t * because that depends on page_mapped(); but not all its usages\n\t * are holding mmap_sem. Users without mmap_sem are required to\n\t * take a reference count to prevent the anon_vma disappearing\n\t */\n\tanon_vma = page_anon_vma(page);\n\tif (!anon_vma)\n\t\treturn NULL;\n\n\tanon_vma_lock_read(anon_vma);\n\treturn anon_vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_lock_read",
          "args": [
            "anon_vma"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_anon_vma",
          "args": [
            "page"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "page_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "489-498",
          "snippet": "struct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwc->anon_lock",
          "args": [
            "page"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct anon_vma *rmap_walk_anon_lock(struct page *page,\n\t\t\t\t\tstruct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma;\n\n\tif (rwc->anon_lock)\n\t\treturn rwc->anon_lock(page);\n\n\t/*\n\t * Note: remove_migration_ptes() cannot use page_lock_anon_vma_read()\n\t * because that depends on page_mapped(); but not all its usages\n\t * are holding mmap_sem. Users without mmap_sem are required to\n\t * take a reference count to prevent the anon_vma disappearing\n\t */\n\tanon_vma = page_anon_vma(page);\n\tif (!anon_vma)\n\t\treturn NULL;\n\n\tanon_vma_lock_read(anon_vma);\n\treturn anon_vma;\n}"
  },
  {
    "function_name": "__put_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1758-1765",
    "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_free",
          "args": [
            "root"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "97-125",
          "snippet": "static inline void anon_vma_free(struct anon_vma *anon_vma)\n{\n\tVM_BUG_ON(atomic_read(&anon_vma->refcount));\n\n\t/*\n\t * Synchronize against page_lock_anon_vma_read() such that\n\t * we can safely hold the lock without the anon_vma getting\n\t * freed.\n\t *\n\t * Relies on the full mb implied by the atomic_dec_and_test() from\n\t * put_anon_vma() against the acquire barrier implied by\n\t * down_read_trylock() from page_lock_anon_vma_read(). This orders:\n\t *\n\t * page_lock_anon_vma_read()\tVS\tput_anon_vma()\n\t *   down_read_trylock()\t\t  atomic_dec_and_test()\n\t *   LOCK\t\t\t\t  MB\n\t *   atomic_read()\t\t\t  rwsem_is_locked()\n\t *\n\t * LOCK should suffice since the actual taking of the lock must\n\t * happen _before_ what follows.\n\t */\n\tmight_sleep();\n\tif (rwsem_is_locked(&anon_vma->root->rwsem)) {\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\n\tkmem_cache_free(anon_vma_cachep, anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_cachep;\n\nstatic inline void anon_vma_free(struct anon_vma *anon_vma)\n{\n\tVM_BUG_ON(atomic_read(&anon_vma->refcount));\n\n\t/*\n\t * Synchronize against page_lock_anon_vma_read() such that\n\t * we can safely hold the lock without the anon_vma getting\n\t * freed.\n\t *\n\t * Relies on the full mb implied by the atomic_dec_and_test() from\n\t * put_anon_vma() against the acquire barrier implied by\n\t * down_read_trylock() from page_lock_anon_vma_read(). This orders:\n\t *\n\t * page_lock_anon_vma_read()\tVS\tput_anon_vma()\n\t *   down_read_trylock()\t\t  atomic_dec_and_test()\n\t *   LOCK\t\t\t\t  MB\n\t *   atomic_read()\t\t\t  rwsem_is_locked()\n\t *\n\t * LOCK should suffice since the actual taking of the lock must\n\t * happen _before_ what follows.\n\t */\n\tmight_sleep();\n\tif (rwsem_is_locked(&anon_vma->root->rwsem)) {\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\n\tkmem_cache_free(anon_vma_cachep, anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&root->refcount"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
  },
  {
    "function_name": "try_to_munlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1742-1756",
    "snippet": "void try_to_munlock(struct page *page)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)TTU_MUNLOCK,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\n\t};\n\n\tVM_BUG_ON_PAGE(!PageLocked(page) || PageLRU(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page) && PageDoubleMap(page), page);\n\n\trmap_walk(page, &rwc);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk",
          "args": [
            "page",
            "&rwc"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1908-1916",
          "snippet": "void rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageCompound(page) && PageDoubleMap(page)",
            "page"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page) || PageLRU(page)",
            "page"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid try_to_munlock(struct page *page)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)TTU_MUNLOCK,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\n\t};\n\n\tVM_BUG_ON_PAGE(!PageLocked(page) || PageLRU(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page) && PageDoubleMap(page), page);\n\n\trmap_walk(page, &rwc);\n}"
  },
  {
    "function_name": "page_not_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1728-1731",
    "snippet": "static int page_not_mapped(struct page *page)\n{\n\treturn !page_mapped(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int page_not_mapped(struct page *page)\n{\n\treturn !page_mapped(page);\n}"
  },
  {
    "function_name": "try_to_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1699-1726",
    "snippet": "bool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapcount_is_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1684-1687",
          "snippet": "static int page_mapcount_is_zero(struct page *page)\n{\n\treturn !total_mapcount(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int page_mapcount_is_zero(struct page *page)\n{\n\treturn !total_mapcount(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_walk",
          "args": [
            "page",
            "&rwc"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1908-1916",
          "snippet": "void rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}"
  },
  {
    "function_name": "page_mapcount_is_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1684-1687",
    "snippet": "static int page_mapcount_is_zero(struct page *page)\n{\n\treturn !total_mapcount(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "total_mapcount",
          "args": [
            "page"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "total_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2505-2526",
          "snippet": "int total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int page_mapcount_is_zero(struct page *page)\n{\n\treturn !total_mapcount(page);\n}"
  },
  {
    "function_name": "invalid_migration_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1679-1682",
    "snippet": "static bool invalid_migration_vma(struct vm_area_struct *vma, void *arg)\n{\n\treturn is_vma_temporary_stack(vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_vma_temporary_stack",
          "args": [
            "vma"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_temporary_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1665-1677",
          "snippet": "bool is_vma_temporary_stack(struct vm_area_struct *vma)\n{\n\tint maybe_stack = vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP);\n\n\tif (!maybe_stack)\n\t\treturn false;\n\n\tif ((vma->vm_flags & VM_STACK_INCOMPLETE_SETUP) ==\n\t\t\t\t\t\tVM_STACK_INCOMPLETE_SETUP)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool is_vma_temporary_stack(struct vm_area_struct *vma)\n{\n\tint maybe_stack = vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP);\n\n\tif (!maybe_stack)\n\t\treturn false;\n\n\tif ((vma->vm_flags & VM_STACK_INCOMPLETE_SETUP) ==\n\t\t\t\t\t\tVM_STACK_INCOMPLETE_SETUP)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool invalid_migration_vma(struct vm_area_struct *vma, void *arg)\n{\n\treturn is_vma_temporary_stack(vma);\n}"
  },
  {
    "function_name": "is_vma_temporary_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1665-1677",
    "snippet": "bool is_vma_temporary_stack(struct vm_area_struct *vma)\n{\n\tint maybe_stack = vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP);\n\n\tif (!maybe_stack)\n\t\treturn false;\n\n\tif ((vma->vm_flags & VM_STACK_INCOMPLETE_SETUP) ==\n\t\t\t\t\t\tVM_STACK_INCOMPLETE_SETUP)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool is_vma_temporary_stack(struct vm_area_struct *vma)\n{\n\tint maybe_stack = vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP);\n\n\tif (!maybe_stack)\n\t\treturn false;\n\n\tif ((vma->vm_flags & VM_STACK_INCOMPLETE_SETUP) ==\n\t\t\t\t\t\tVM_STACK_INCOMPLETE_SETUP)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "try_to_unmap_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1336-1663",
    "snippet": "static bool try_to_unmap_one(struct page *page, struct vm_area_struct *vma,\n\t\t     unsigned long address, void *arg)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = address,\n\t};\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool ret = true;\n\tunsigned long start = address, end;\n\tenum ttu_flags flags = (enum ttu_flags)arg;\n\n\t/* munlock has nothing to gain from examining un-locked vmas */\n\tif ((flags & TTU_MUNLOCK) && !(vma->vm_flags & VM_LOCKED))\n\t\treturn true;\n\n\tif (IS_ENABLED(CONFIG_MIGRATION) && (flags & TTU_MIGRATION) &&\n\t    is_zone_device_page(page) && !is_device_private_page(page))\n\t\treturn true;\n\n\tif (flags & TTU_SPLIT_HUGE_PMD) {\n\t\tsplit_huge_pmd_address(vma, address,\n\t\t\t\tflags & TTU_SPLIT_FREEZE, page);\n\t}\n\n\t/*\n\t * For THP, we have to assume the worse case ie pmd for invalidation.\n\t * For hugetlb, it could be much worse if we need to do pud\n\t * invalidation in the case of pmd sharing.\n\t *\n\t * Note that the page can not be free in this function as call of\n\t * try_to_unmap() must hold a reference on the page.\n\t */\n\tend = min(vma->vm_end, start + (PAGE_SIZE << compound_order(page)));\n\tif (PageHuge(page)) {\n\t\t/*\n\t\t * If sharing is possible, start and end will be adjusted\n\t\t * accordingly.\n\t\t */\n\t\tadjust_range_if_pmd_sharing_possible(vma, &start, &end);\n\t}\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, start, end);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte && (flags & TTU_MIGRATION)) {\n\t\t\tVM_BUG_ON_PAGE(PageHuge(page) || !PageTransCompound(page), page);\n\n\t\t\tset_pmd_migration_entry(&pvmw, page);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * If the page is mlock()d, we cannot swap it out.\n\t\t * If it's recently referenced (perhaps page_referenced\n\t\t * skipped over this mm) then we should reactivate it.\n\t\t */\n\t\tif (!(flags & TTU_IGNORE_MLOCK)) {\n\t\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\t\t/* PTE-mapped THP are never mlocked */\n\t\t\t\tif (!PageTransCompound(page)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Holding pte lock, we do *not* need\n\t\t\t\t\t * mmap_sem here\n\t\t\t\t\t */\n\t\t\t\t\tmlock_vma_page(page);\n\t\t\t\t}\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flags & TTU_MUNLOCK)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_PAGE(!pvmw.pte, page);\n\n\t\tsubpage = page - page_to_pfn(page) + pte_pfn(*pvmw.pte);\n\t\taddress = pvmw.address;\n\n\t\tif (PageHuge(page)) {\n\t\t\tif (huge_pmd_unshare(mm, &address, pvmw.pte)) {\n\t\t\t\t/*\n\t\t\t\t * huge_pmd_unshare unmapped an entire PMD\n\t\t\t\t * page.  There is no way of knowing exactly\n\t\t\t\t * which PMDs may be cached for this mm, so\n\t\t\t\t * we must flush them all.  start/end were\n\t\t\t\t * already adjusted above to cover this range.\n\t\t\t\t */\n\t\t\t\tflush_cache_range(vma, start, end);\n\t\t\t\tflush_tlb_range(vma, start, end);\n\t\t\t\tmmu_notifier_invalidate_range(mm, start, end);\n\n\t\t\t\t/*\n\t\t\t\t * The ref count of the PMD page was dropped\n\t\t\t\t * which is part of the way map counting\n\t\t\t\t * is done for shared PMDs.  Return 'true'\n\t\t\t\t * here.  When there is no other sharing,\n\t\t\t\t * huge_pmd_unshare returns false and we will\n\t\t\t\t * unmap the actual page and drop map count\n\t\t\t\t * to zero.\n\t\t\t\t */\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_MIGRATION) &&\n\t\t    (flags & TTU_MIGRATION) &&\n\t\t    is_zone_device_page(page)) {\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tpteval = ptep_get_and_clear(mm, pvmw.address, pvmw.pte);\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tentry = make_migration_entry(page, 0);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, swp_pte);\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (!(flags & TTU_IGNORE_ACCESS)) {\n\t\t\tif (ptep_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pte)) {\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\tif (should_defer_flush(mm, flags)) {\n\t\t\t/*\n\t\t\t * We clear the PTE but do not flush so potentially\n\t\t\t * a remote CPU could still be writing to the page.\n\t\t\t * If the entry was previously clean then the\n\t\t\t * architecture must guarantee that a clear->dirty\n\t\t\t * transition on a cached TLB entry is written through\n\t\t\t * and traps if the PTE is unmapped.\n\t\t\t */\n\t\t\tpteval = ptep_get_and_clear(mm, address, pvmw.pte);\n\n\t\t\tset_tlb_ubc_flush_pending(mm, pte_dirty(pteval));\n\t\t} else {\n\t\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\t\t}\n\n\t\t/* Move the dirty bit to the page. Now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tset_page_dirty(page);\n\n\t\t/* Update high watermark before we lower rss */\n\t\tupdate_hiwater_rss(mm);\n\n\t\tif (PageHWPoison(page) && !(flags & TTU_IGNORE_HWPOISON)) {\n\t\t\tpteval = swp_entry_to_pte(make_hwpoison_entry(subpage));\n\t\t\tif (PageHuge(page)) {\n\t\t\t\tint nr = 1 << compound_order(page);\n\t\t\t\thugetlb_count_sub(nr, mm);\n\t\t\t\tset_huge_swap_pte_at(mm, address,\n\t\t\t\t\t\t     pvmw.pte, pteval,\n\t\t\t\t\t\t     vma_mmu_pagesize(vma));\n\t\t\t} else {\n\t\t\t\tdec_mm_counter(mm, mm_counter(page));\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t}\n\n\t\t} else if (pte_unused(pteval) && !userfaultfd_armed(vma)) {\n\t\t\t/*\n\t\t\t * The guest indicated that the page content is of no\n\t\t\t * interest anymore. Simply discard the pte, vmscan\n\t\t\t * will take care of the rest.\n\t\t\t * A future reference will then fault in a new zero\n\t\t\t * page. When userfaultfd is active, we must not drop\n\t\t\t * this page though, as its main user (postcopy\n\t\t\t * migration) will not expect userfaults on already\n\t\t\t * copied pages.\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter(page));\n\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else if (IS_ENABLED(CONFIG_MIGRATION) &&\n\t\t\t\t(flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))) {\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tentry = make_migration_entry(subpage,\n\t\t\t\t\tpte_write(pteval));\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t} else if (PageAnon(page)) {\n\t\t\tswp_entry_t entry = { .val = page_private(subpage) };\n\t\t\tpte_t swp_pte;\n\t\t\t/*\n\t\t\t * Store the swap location in the pte.\n\t\t\t * See handle_pte_fault() ...\n\t\t\t */\n\t\t\tif (unlikely(PageSwapBacked(page) != PageSwapCache(page))) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tret = false;\n\t\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t\taddress + PAGE_SIZE);\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* MADV_FREE page check */\n\t\t\tif (!PageSwapBacked(page)) {\n\t\t\t\tif (!PageDirty(page)) {\n\t\t\t\t\t/* Invalidate as we cleared the pte */\n\t\t\t\t\tmmu_notifier_invalidate_range(mm,\n\t\t\t\t\t\taddress, address + PAGE_SIZE);\n\t\t\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\t\t\tgoto discard;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If the page was redirtied, it cannot be\n\t\t\t\t * discarded. Remap the page to page table.\n\t\t\t\t */\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tSetPageSwapBacked(page);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (swap_duplicate(entry) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (list_empty(&mm->mmlist)) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&mm->mmlist))\n\t\t\t\t\tlist_add(&mm->mmlist, &init_mm.mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\tinc_mm_counter(mm, MM_SWAPENTS);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\t/* Invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We should not need to notify here as we reach this\n\t\t\t * case only from freeze_page() itself only call from\n\t\t\t * split_huge_page_to_list() so everything below must\n\t\t\t * be true:\n\t\t\t *   - page is not anonymous\n\t\t\t *   - page is locked\n\t\t\t *\n\t\t\t * So as it is a locked file back page thus it can not\n\t\t\t * be remove from the page cache and replace by a new\n\t\t\t * page before mmu_notifier_invalidate_range_end so no\n\t\t\t * concurrent thread might update its page table to\n\t\t\t * point at new page while a device still is using this\n\t\t\t * page.\n\t\t\t *\n\t\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter_file(page));\n\t\t}\ndiscard:\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() it has be\n\t\t * done above for all cases requiring it to happen under page\n\t\t * table lock before mmu_notifier_invalidate_range_end()\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tpage_remove_rmap(subpage, PageHuge(page));\n\t\tput_page(page);\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "vma->vm_mm",
            "start",
            "end"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "subpage",
            "PageHuge(page)"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "mm_counter_file(page)"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "page"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range",
          "args": [
            "mm",
            "address",
            "address + PAGE_SIZE"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_notifier_invalidate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "235-247",
          "snippet": "void __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "swp_pte"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "swp_pte"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_soft_dirty",
          "args": [
            "pteval"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_mm_counter",
          "args": [
            "mm",
            "MM_SWAPENTS"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mm->mmlist",
            "&init_mm.mmlist"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mm->mmlist"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "pteval"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_unmap_one",
          "args": [
            "mm",
            "vma",
            "address",
            "pteval"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "pteval"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_duplicate",
          "args": [
            "entry"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "swap_duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3443-3450",
          "snippet": "int swap_duplicate(swp_entry_t entry)\n{\n\tint err = 0;\n\n\twhile (!err && __swap_duplicate(entry, 1) == -ENOMEM)\n\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint swap_duplicate(swp_entry_t entry)\n{\n\tint err = 0;\n\n\twhile (!err && __swap_duplicate(entry, 1) == -ENOMEM)\n\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "pteval"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageSwapBacked(page) != PageSwapCache(page)"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "subpage"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "swp_pte"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "swp_pte"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_soft_dirty",
          "args": [
            "pteval"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry",
          "args": [
            "subpage",
            "pte_write(pteval)"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pteval"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "pteval"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_unmap_one",
          "args": [
            "mm",
            "vma",
            "address",
            "pteval"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MIGRATION"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "mm_counter(page)"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_armed",
          "args": [
            "vma"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unused",
          "args": [
            "pteval"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "pteval"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "mm_counter(page)"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_swap_pte_at",
          "args": [
            "mm",
            "address",
            "pvmw.pte",
            "pteval",
            "vma_mmu_pagesize(vma)"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_mmu_pagesize",
          "args": [
            "vma"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "vma_mmu_pagesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "652-655",
          "snippet": "__weak unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)\n{\n\treturn vma_kernel_pagesize(vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\n__weak unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)\n{\n\treturn vma_kernel_pagesize(vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_count_sub",
          "args": [
            "nr",
            "mm"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "make_hwpoison_entry(subpage)"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_hwpoison_entry",
          "args": [
            "subpage"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_hiwater_rss",
          "args": [
            "mm"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "pteval"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush",
          "args": [
            "vma",
            "address",
            "pvmw.pte"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "ptep_clear_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "81-90",
          "snippet": "pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tlb_ubc_flush_pending",
          "args": [
            "mm",
            "pte_dirty(pteval)"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "set_tlb_ubc_flush_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "673-675",
          "snippet": "static void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "pteval"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_get_and_clear",
          "args": [
            "mm",
            "address",
            "pvmw.pte"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_defer_flush",
          "args": [
            "mm",
            "flags"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "should_defer_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "677-680",
          "snippet": "static bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "address",
            "pte_pfn(*pvmw.pte)"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pvmw.pte"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush_young_notify",
          "args": [
            "vma",
            "address",
            "pvmw.pte"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "pvmw.address",
            "pvmw.pte",
            "swp_pte"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "swp_pte"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_soft_dirty",
          "args": [
            "pteval"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry",
          "args": [
            "page",
            "0"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_get_and_clear",
          "args": [
            "mm",
            "pvmw.address",
            "pvmw.pte"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MIGRATION"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_range",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pmd_unshare",
          "args": [
            "mm",
            "&address",
            "pvmw.pte"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pmd_unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4731-4734",
          "snippet": "int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pvmw.pte"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!pvmw.pte",
            "page"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_vma_page",
          "args": [
            "page"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_vma_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "359-359",
          "snippet": "static inline void mlock_vma_page(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_vma_page(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_migration_entry",
          "args": [
            "&pvmw",
            "page"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "set_pmd_migration_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2899-2924",
          "snippet": "void set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageHuge(page) || !PageTransCompound(page)",
            "page"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "page_vma_mapped_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "138-247",
          "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "vma->vm_mm",
            "start",
            "end"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_range_if_pmd_sharing_possible",
          "args": [
            "vma",
            "&start",
            "&end"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_range_if_pmd_sharing_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4736-4739",
          "snippet": "void adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid adjust_range_if_pmd_sharing_possible(struct vm_area_struct *vma,\n\t\t\t\tunsigned long *start, unsigned long *end)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vma->vm_end",
            "start + (PAGE_SIZE << compound_order(page))"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd_address",
          "args": [
            "vma",
            "address",
            "flags & TTU_SPLIT_FREEZE",
            "page"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "split_huge_pmd_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2287-2310",
          "snippet": "void split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,\n\t\tbool freeze, struct page *page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn;\n\n\tpmd = pmd_offset(pud, address);\n\n\t__split_huge_pmd(vma, pmd, address, freeze, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,\n\t\tbool freeze, struct page *page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn;\n\n\tpmd = pmd_offset(pud, address);\n\n\t__split_huge_pmd(vma, pmd, address, freeze, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_device_private_page",
          "args": [
            "page"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MIGRATION"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool try_to_unmap_one(struct page *page, struct vm_area_struct *vma,\n\t\t     unsigned long address, void *arg)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = address,\n\t};\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool ret = true;\n\tunsigned long start = address, end;\n\tenum ttu_flags flags = (enum ttu_flags)arg;\n\n\t/* munlock has nothing to gain from examining un-locked vmas */\n\tif ((flags & TTU_MUNLOCK) && !(vma->vm_flags & VM_LOCKED))\n\t\treturn true;\n\n\tif (IS_ENABLED(CONFIG_MIGRATION) && (flags & TTU_MIGRATION) &&\n\t    is_zone_device_page(page) && !is_device_private_page(page))\n\t\treturn true;\n\n\tif (flags & TTU_SPLIT_HUGE_PMD) {\n\t\tsplit_huge_pmd_address(vma, address,\n\t\t\t\tflags & TTU_SPLIT_FREEZE, page);\n\t}\n\n\t/*\n\t * For THP, we have to assume the worse case ie pmd for invalidation.\n\t * For hugetlb, it could be much worse if we need to do pud\n\t * invalidation in the case of pmd sharing.\n\t *\n\t * Note that the page can not be free in this function as call of\n\t * try_to_unmap() must hold a reference on the page.\n\t */\n\tend = min(vma->vm_end, start + (PAGE_SIZE << compound_order(page)));\n\tif (PageHuge(page)) {\n\t\t/*\n\t\t * If sharing is possible, start and end will be adjusted\n\t\t * accordingly.\n\t\t */\n\t\tadjust_range_if_pmd_sharing_possible(vma, &start, &end);\n\t}\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, start, end);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte && (flags & TTU_MIGRATION)) {\n\t\t\tVM_BUG_ON_PAGE(PageHuge(page) || !PageTransCompound(page), page);\n\n\t\t\tset_pmd_migration_entry(&pvmw, page);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * If the page is mlock()d, we cannot swap it out.\n\t\t * If it's recently referenced (perhaps page_referenced\n\t\t * skipped over this mm) then we should reactivate it.\n\t\t */\n\t\tif (!(flags & TTU_IGNORE_MLOCK)) {\n\t\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\t\t/* PTE-mapped THP are never mlocked */\n\t\t\t\tif (!PageTransCompound(page)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Holding pte lock, we do *not* need\n\t\t\t\t\t * mmap_sem here\n\t\t\t\t\t */\n\t\t\t\t\tmlock_vma_page(page);\n\t\t\t\t}\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flags & TTU_MUNLOCK)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_PAGE(!pvmw.pte, page);\n\n\t\tsubpage = page - page_to_pfn(page) + pte_pfn(*pvmw.pte);\n\t\taddress = pvmw.address;\n\n\t\tif (PageHuge(page)) {\n\t\t\tif (huge_pmd_unshare(mm, &address, pvmw.pte)) {\n\t\t\t\t/*\n\t\t\t\t * huge_pmd_unshare unmapped an entire PMD\n\t\t\t\t * page.  There is no way of knowing exactly\n\t\t\t\t * which PMDs may be cached for this mm, so\n\t\t\t\t * we must flush them all.  start/end were\n\t\t\t\t * already adjusted above to cover this range.\n\t\t\t\t */\n\t\t\t\tflush_cache_range(vma, start, end);\n\t\t\t\tflush_tlb_range(vma, start, end);\n\t\t\t\tmmu_notifier_invalidate_range(mm, start, end);\n\n\t\t\t\t/*\n\t\t\t\t * The ref count of the PMD page was dropped\n\t\t\t\t * which is part of the way map counting\n\t\t\t\t * is done for shared PMDs.  Return 'true'\n\t\t\t\t * here.  When there is no other sharing,\n\t\t\t\t * huge_pmd_unshare returns false and we will\n\t\t\t\t * unmap the actual page and drop map count\n\t\t\t\t * to zero.\n\t\t\t\t */\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_MIGRATION) &&\n\t\t    (flags & TTU_MIGRATION) &&\n\t\t    is_zone_device_page(page)) {\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tpteval = ptep_get_and_clear(mm, pvmw.address, pvmw.pte);\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tentry = make_migration_entry(page, 0);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, swp_pte);\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (!(flags & TTU_IGNORE_ACCESS)) {\n\t\t\tif (ptep_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pte)) {\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\tif (should_defer_flush(mm, flags)) {\n\t\t\t/*\n\t\t\t * We clear the PTE but do not flush so potentially\n\t\t\t * a remote CPU could still be writing to the page.\n\t\t\t * If the entry was previously clean then the\n\t\t\t * architecture must guarantee that a clear->dirty\n\t\t\t * transition on a cached TLB entry is written through\n\t\t\t * and traps if the PTE is unmapped.\n\t\t\t */\n\t\t\tpteval = ptep_get_and_clear(mm, address, pvmw.pte);\n\n\t\t\tset_tlb_ubc_flush_pending(mm, pte_dirty(pteval));\n\t\t} else {\n\t\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\t\t}\n\n\t\t/* Move the dirty bit to the page. Now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tset_page_dirty(page);\n\n\t\t/* Update high watermark before we lower rss */\n\t\tupdate_hiwater_rss(mm);\n\n\t\tif (PageHWPoison(page) && !(flags & TTU_IGNORE_HWPOISON)) {\n\t\t\tpteval = swp_entry_to_pte(make_hwpoison_entry(subpage));\n\t\t\tif (PageHuge(page)) {\n\t\t\t\tint nr = 1 << compound_order(page);\n\t\t\t\thugetlb_count_sub(nr, mm);\n\t\t\t\tset_huge_swap_pte_at(mm, address,\n\t\t\t\t\t\t     pvmw.pte, pteval,\n\t\t\t\t\t\t     vma_mmu_pagesize(vma));\n\t\t\t} else {\n\t\t\t\tdec_mm_counter(mm, mm_counter(page));\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t}\n\n\t\t} else if (pte_unused(pteval) && !userfaultfd_armed(vma)) {\n\t\t\t/*\n\t\t\t * The guest indicated that the page content is of no\n\t\t\t * interest anymore. Simply discard the pte, vmscan\n\t\t\t * will take care of the rest.\n\t\t\t * A future reference will then fault in a new zero\n\t\t\t * page. When userfaultfd is active, we must not drop\n\t\t\t * this page though, as its main user (postcopy\n\t\t\t * migration) will not expect userfaults on already\n\t\t\t * copied pages.\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter(page));\n\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else if (IS_ENABLED(CONFIG_MIGRATION) &&\n\t\t\t\t(flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))) {\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tentry = make_migration_entry(subpage,\n\t\t\t\t\tpte_write(pteval));\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t} else if (PageAnon(page)) {\n\t\t\tswp_entry_t entry = { .val = page_private(subpage) };\n\t\t\tpte_t swp_pte;\n\t\t\t/*\n\t\t\t * Store the swap location in the pte.\n\t\t\t * See handle_pte_fault() ...\n\t\t\t */\n\t\t\tif (unlikely(PageSwapBacked(page) != PageSwapCache(page))) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tret = false;\n\t\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t\taddress + PAGE_SIZE);\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* MADV_FREE page check */\n\t\t\tif (!PageSwapBacked(page)) {\n\t\t\t\tif (!PageDirty(page)) {\n\t\t\t\t\t/* Invalidate as we cleared the pte */\n\t\t\t\t\tmmu_notifier_invalidate_range(mm,\n\t\t\t\t\t\taddress, address + PAGE_SIZE);\n\t\t\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\t\t\tgoto discard;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If the page was redirtied, it cannot be\n\t\t\t\t * discarded. Remap the page to page table.\n\t\t\t\t */\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tSetPageSwapBacked(page);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (swap_duplicate(entry) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (list_empty(&mm->mmlist)) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&mm->mmlist))\n\t\t\t\t\tlist_add(&mm->mmlist, &init_mm.mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\tinc_mm_counter(mm, MM_SWAPENTS);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\t/* Invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We should not need to notify here as we reach this\n\t\t\t * case only from freeze_page() itself only call from\n\t\t\t * split_huge_page_to_list() so everything below must\n\t\t\t * be true:\n\t\t\t *   - page is not anonymous\n\t\t\t *   - page is locked\n\t\t\t *\n\t\t\t * So as it is a locked file back page thus it can not\n\t\t\t * be remove from the page cache and replace by a new\n\t\t\t * page before mmu_notifier_invalidate_range_end so no\n\t\t\t * concurrent thread might update its page table to\n\t\t\t * point at new page while a device still is using this\n\t\t\t * page.\n\t\t\t *\n\t\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter_file(page));\n\t\t}\ndiscard:\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() it has be\n\t\t * done above for all cases requiring it to happen under page\n\t\t * table lock before mmu_notifier_invalidate_range_end()\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tpage_remove_rmap(subpage, PageHuge(page));\n\t\tput_page(page);\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "page_remove_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1297-1331",
    "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deferred_split_huge_page",
          "args": [
            "compound_head(page)"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_mlock",
          "args": [
            "page"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "358-358",
          "snippet": "static inline void clear_page_mlock(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void clear_page_mlock(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageMlocked(page)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "page",
            "NR_ANON_MAPPED"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "-1",
            "&page->_mapcount"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_remove_anon_compound_rmap",
          "args": [
            "page"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_anon_compound_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1252-1288",
          "snippet": "static void page_remove_anon_compound_rmap(struct page *page)\n{\n\tint i, nr;\n\n\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\treturn;\n\n\t/* Hugepages are not counted in NR_ANON_PAGES for now. */\n\tif (unlikely(PageHuge(page)))\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))\n\t\treturn;\n\n\t__dec_node_page_state(page, NR_ANON_THPS);\n\n\tif (TestClearPageDoubleMap(page)) {\n\t\t/*\n\t\t * Subpages can be mapped with PTEs too. Check how many of\n\t\t * themi are still mapped.\n\t\t */\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t} else {\n\t\tnr = HPAGE_PMD_NR;\n\t}\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (nr) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, -nr);\n\t\tdeferred_split_huge_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void page_remove_anon_compound_rmap(struct page *page)\n{\n\tint i, nr;\n\n\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\treturn;\n\n\t/* Hugepages are not counted in NR_ANON_PAGES for now. */\n\tif (unlikely(PageHuge(page)))\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))\n\t\treturn;\n\n\t__dec_node_page_state(page, NR_ANON_THPS);\n\n\tif (TestClearPageDoubleMap(page)) {\n\t\t/*\n\t\t * Subpages can be mapped with PTEs too. Check how many of\n\t\t * themi are still mapped.\n\t\t */\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t} else {\n\t\tnr = HPAGE_PMD_NR;\n\t}\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (nr) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, -nr);\n\t\tdeferred_split_huge_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_file_rmap",
          "args": [
            "page",
            "compound"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_file_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1210-1250",
          "snippet": "static void page_remove_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageHead(page), page);\n\tlock_page_memcg(page);\n\n\t/* Hugepages are not counted in NR_FILE_MAPPED for now. */\n\tif (unlikely(PageHuge(page))) {\n\t\t/* hugetlb pages are always mapped with pmds */\n\t\tatomic_dec(compound_mapcount_ptr(page));\n\t\tgoto out;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__dec_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_lruvec_page_state because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, -nr);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\nout:\n\tunlock_page_memcg(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void page_remove_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageHead(page), page);\n\tlock_page_memcg(page);\n\n\t/* Hugepages are not counted in NR_FILE_MAPPED for now. */\n\tif (unlikely(PageHuge(page))) {\n\t\t/* hugetlb pages are always mapped with pmds */\n\t\tatomic_dec(compound_mapcount_ptr(page));\n\t\tgoto out;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__dec_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_lruvec_page_state because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, -nr);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\nout:\n\tunlock_page_memcg(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
  },
  {
    "function_name": "page_remove_anon_compound_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1252-1288",
    "snippet": "static void page_remove_anon_compound_rmap(struct page *page)\n{\n\tint i, nr;\n\n\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\treturn;\n\n\t/* Hugepages are not counted in NR_ANON_PAGES for now. */\n\tif (unlikely(PageHuge(page)))\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))\n\t\treturn;\n\n\t__dec_node_page_state(page, NR_ANON_THPS);\n\n\tif (TestClearPageDoubleMap(page)) {\n\t\t/*\n\t\t * Subpages can be mapped with PTEs too. Check how many of\n\t\t * themi are still mapped.\n\t\t */\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t} else {\n\t\tnr = HPAGE_PMD_NR;\n\t}\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (nr) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, -nr);\n\t\tdeferred_split_huge_page(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deferred_split_huge_page",
          "args": [
            "page"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_ANON_MAPPED",
            "-nr"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_mlock",
          "args": [
            "page"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "358-358",
          "snippet": "static inline void clear_page_mlock(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void clear_page_mlock(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageMlocked(page)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "-1",
            "&page[i]._mapcount"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageDoubleMap",
          "args": [
            "page"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "page",
            "NR_ANON_THPS"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRANSPARENT_HUGEPAGE"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageHuge(page)"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "-1",
            "compound_mapcount_ptr(page)"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void page_remove_anon_compound_rmap(struct page *page)\n{\n\tint i, nr;\n\n\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\treturn;\n\n\t/* Hugepages are not counted in NR_ANON_PAGES for now. */\n\tif (unlikely(PageHuge(page)))\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))\n\t\treturn;\n\n\t__dec_node_page_state(page, NR_ANON_THPS);\n\n\tif (TestClearPageDoubleMap(page)) {\n\t\t/*\n\t\t * Subpages can be mapped with PTEs too. Check how many of\n\t\t * themi are still mapped.\n\t\t */\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t} else {\n\t\tnr = HPAGE_PMD_NR;\n\t}\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (nr) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, -nr);\n\t\tdeferred_split_huge_page(page);\n\t}\n}"
  },
  {
    "function_name": "page_remove_file_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1210-1250",
    "snippet": "static void page_remove_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageHead(page), page);\n\tlock_page_memcg(page);\n\n\t/* Hugepages are not counted in NR_FILE_MAPPED for now. */\n\tif (unlikely(PageHuge(page))) {\n\t\t/* hugetlb pages are always mapped with pmds */\n\t\tatomic_dec(compound_mapcount_ptr(page));\n\t\tgoto out;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__dec_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_lruvec_page_state because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, -nr);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\nout:\n\tunlock_page_memcg(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_mlock",
          "args": [
            "page"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "358-358",
          "snippet": "static inline void clear_page_mlock(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void clear_page_mlock(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageMlocked(page)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_lruvec_page_state",
          "args": [
            "page",
            "NR_FILE_MAPPED",
            "-nr"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "-1",
            "&page->_mapcount"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "page",
            "NR_SHMEM_PMDMAPPED"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageSwapBacked(page)",
            "page"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "-1",
            "compound_mapcount_ptr(page)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "-1",
            "&page[i]._mapcount"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "compound_mapcount_ptr(page)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageHuge(page)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "compound && !PageHead(page)",
            "page"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void page_remove_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageHead(page), page);\n\tlock_page_memcg(page);\n\n\t/* Hugepages are not counted in NR_FILE_MAPPED for now. */\n\tif (unlikely(PageHuge(page))) {\n\t\t/* hugetlb pages are always mapped with pmds */\n\t\tatomic_dec(compound_mapcount_ptr(page));\n\t\tgoto out;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__dec_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_lruvec_page_state because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, -nr);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\nout:\n\tunlock_page_memcg(page);\n}"
  },
  {
    "function_name": "page_add_file_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1179-1208",
    "snippet": "void page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mod_lruvec_page_state",
          "args": [
            "page",
            "NR_FILE_MAPPED",
            "nr"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_and_test",
          "args": [
            "&page->_mapcount"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_mlock",
          "args": [
            "compound_head(page)"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "358-358",
          "snippet": "static inline void clear_page_mlock(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void clear_page_mlock(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDoubleMap",
          "args": [
            "compound_head(page)"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON_ONCE",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_page_state",
          "args": [
            "page",
            "NR_SHMEM_PMDMAPPED"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "416-419",
          "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageSwapBacked(page)",
            "page"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_and_test",
          "args": [
            "compound_mapcount_ptr(page)"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_and_test",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "compound && !PageTransHuge(page)",
            "page"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}"
  },
  {
    "function_name": "page_add_new_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1150-1170",
    "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__page_set_anon_rmap",
          "args": [
            "page",
            "vma",
            "address",
            "1"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "__page_set_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1025-1046",
          "snippet": "static void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_ANON_MAPPED",
            "nr"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&page->_mapcount",
            "0"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTransCompound(page)",
            "page"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_page_state",
          "args": [
            "page",
            "NR_ANON_THPS"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "416-419",
          "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "compound_mapcount_ptr(page)",
            "0"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageTransHuge(page)",
            "page"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "address < vma->vm_start || address >= vma->vm_end",
            "vma"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
  },
  {
    "function_name": "do_page_add_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1098-1137",
    "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__page_check_anon_rmap",
          "args": [
            "page",
            "vma",
            "address"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "__page_check_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1054-1073",
          "snippet": "static void __page_check_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n#ifdef CONFIG_DEBUG_VM\n\t/*\n\t * The page's anon-rmap details (mapping and index) are guaranteed to\n\t * be set up correctly at this point.\n\t *\n\t * We have exclusion against page_add_anon_rmap because the caller\n\t * always holds the page locked, except if called from page_dup_rmap,\n\t * in which case the page is already known to be setup.\n\t *\n\t * We have exclusion against page_add_new_anon_rmap because those pages\n\t * are initially only visible via the pagetables, and the pte is locked\n\t * over the call to page_add_new_anon_rmap.\n\t */\n\tBUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);\n\tBUG_ON(page_to_pgoff(page) != linear_page_index(vma, address));\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __page_check_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n#ifdef CONFIG_DEBUG_VM\n\t/*\n\t * The page's anon-rmap details (mapping and index) are guaranteed to\n\t * be set up correctly at this point.\n\t *\n\t * We have exclusion against page_add_anon_rmap because the caller\n\t * always holds the page locked, except if called from page_dup_rmap,\n\t * in which case the page is already known to be setup.\n\t *\n\t * We have exclusion against page_add_new_anon_rmap because those pages\n\t * are initially only visible via the pagetables, and the pte is locked\n\t * over the call to page_add_new_anon_rmap.\n\t */\n\tBUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);\n\tBUG_ON(page_to_pgoff(page) != linear_page_index(vma, address));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__page_set_anon_rmap",
          "args": [
            "page",
            "vma",
            "address",
            "flags & RMAP_EXCLUSIVE"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "__page_set_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1025-1046",
          "snippet": "static void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageKsm(page)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_ANON_MAPPED",
            "nr"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_page_state",
          "args": [
            "page",
            "NR_ANON_THPS"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "416-419",
          "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_and_test",
          "args": [
            "&page->_mapcount"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_and_test",
          "args": [
            "mapcount"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageTransHuge(page)",
            "page"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
  },
  {
    "function_name": "page_add_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1087-1091",
    "snippet": "void page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tdo_page_add_anon_rmap(page, vma, address, compound ? RMAP_COMPOUND : 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_page_add_anon_rmap",
          "args": [
            "page",
            "vma",
            "address",
            "compound ? RMAP_COMPOUND : 0"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1098-1137",
          "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tdo_page_add_anon_rmap(page, vma, address, compound ? RMAP_COMPOUND : 0);\n}"
  },
  {
    "function_name": "__page_check_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1054-1073",
    "snippet": "static void __page_check_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n#ifdef CONFIG_DEBUG_VM\n\t/*\n\t * The page's anon-rmap details (mapping and index) are guaranteed to\n\t * be set up correctly at this point.\n\t *\n\t * We have exclusion against page_add_anon_rmap because the caller\n\t * always holds the page locked, except if called from page_dup_rmap,\n\t * in which case the page is already known to be setup.\n\t *\n\t * We have exclusion against page_add_new_anon_rmap because those pages\n\t * are initially only visible via the pagetables, and the pte is locked\n\t * over the call to page_add_new_anon_rmap.\n\t */\n\tBUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);\n\tBUG_ON(page_to_pgoff(page) != linear_page_index(vma, address));\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_to_pgoff(page) != linear_page_index(vma, address)"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "address"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_anon_vma(page)->root != vma->anon_vma->root"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_anon_vma",
          "args": [
            "page"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "page_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "489-498",
          "snippet": "struct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __page_check_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n#ifdef CONFIG_DEBUG_VM\n\t/*\n\t * The page's anon-rmap details (mapping and index) are guaranteed to\n\t * be set up correctly at this point.\n\t *\n\t * We have exclusion against page_add_anon_rmap because the caller\n\t * always holds the page locked, except if called from page_dup_rmap,\n\t * in which case the page is already known to be setup.\n\t *\n\t * We have exclusion against page_add_new_anon_rmap because those pages\n\t * are initially only visible via the pagetables, and the pte is locked\n\t * over the call to page_add_new_anon_rmap.\n\t */\n\tBUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);\n\tBUG_ON(page_to_pgoff(page) != linear_page_index(vma, address));\n#endif\n}"
  },
  {
    "function_name": "__page_set_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1025-1046",
    "snippet": "static void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "address"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!anon_vma"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\treturn;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}"
  },
  {
    "function_name": "page_move_anon_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "1000-1016",
    "snippet": "void page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg page_referenced()'s\n\t * PageAnon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "page->mapping",
            "(struct address_space *) anon_vma"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!anon_vma",
            "vma"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg page_referenced()'s\n\t * PageAnon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n}"
  },
  {
    "function_name": "page_mkclean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "965-987",
    "snippet": "int page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk",
          "args": [
            "page",
            "&rwc"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1908-1916",
          "snippet": "void rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}"
  },
  {
    "function_name": "invalid_mkclean_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "957-963",
    "snippet": "static bool invalid_mkclean_vma(struct vm_area_struct *vma, void *arg)\n{\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool invalid_mkclean_vma(struct vm_area_struct *vma, void *arg)\n{\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "page_mkclean_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "883-955",
    "snippet": "static bool page_mkclean_one(struct page *page, struct vm_area_struct *vma,\n\t\t\t    unsigned long address, void *arg)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = address,\n\t\t.flags = PVMW_SYNC,\n\t};\n\tunsigned long start = address, end;\n\tint *cleaned = arg;\n\n\t/*\n\t * We have to assume the worse case ie pmd for invalidation. Note that\n\t * the page can not be free from this function.\n\t */\n\tend = min(vma->vm_end, start + (PAGE_SIZE << compound_order(page)));\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, start, end);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\tunsigned long cstart;\n\t\tint ret = 0;\n\n\t\tcstart = address = pvmw.address;\n\t\tif (pvmw.pte) {\n\t\t\tpte_t entry;\n\t\t\tpte_t *pte = pvmw.pte;\n\n\t\t\tif (!pte_dirty(*pte) && !pte_write(*pte))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\t\tentry = ptep_clear_flush(vma, address, pte);\n\t\t\tentry = pte_wrprotect(entry);\n\t\t\tentry = pte_mkclean(entry);\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tret = 1;\n\t\t} else {\n#ifdef CONFIG_TRANSPARENT_HUGE_PAGECACHE\n\t\t\tpmd_t *pmd = pvmw.pmd;\n\t\t\tpmd_t entry;\n\n\t\t\tif (!pmd_dirty(*pmd) && !pmd_write(*pmd))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_page(vma, address, page_to_pfn(page));\n\t\t\tentry = pmdp_huge_clear_flush(vma, address, pmd);\n\t\t\tentry = pmd_wrprotect(entry);\n\t\t\tentry = pmd_mkclean(entry);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmd, entry);\n\t\t\tcstart &= PMD_MASK;\n\t\t\tret = 1;\n#else\n\t\t\t/* unexpected pmd-mapped page? */\n\t\t\tWARN_ON_ONCE(1);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tif (ret)\n\t\t\t(*cleaned)++;\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "vma->vm_mm",
            "start",
            "end"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vma->vm_mm",
            "address",
            "pmd",
            "entry"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkclean",
          "args": [
            "entry"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_wrprotect",
          "args": [
            "entry"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_huge_clear_flush",
          "args": [
            "vma",
            "address",
            "pmd"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_huge_clear_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "124-134",
          "snippet": "pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t    pmd_t *pmdp)\n{\n\tpmd_t pmd;\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON((pmd_present(*pmdp) && !pmd_trans_huge(*pmdp) &&\n\t\t\t   !pmd_devmap(*pmdp)) || !pmd_present(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t    pmd_t *pmdp)\n{\n\tpmd_t pmd;\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON((pmd_present(*pmdp) && !pmd_trans_huge(*pmdp) &&\n\t\t\t   !pmd_devmap(*pmdp)) || !pmd_present(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "address",
            "page_to_pfn(page)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "*pmd"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "*pmd"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "address",
            "pte",
            "entry"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkclean",
          "args": [
            "entry"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_wrprotect",
          "args": [
            "entry"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush",
          "args": [
            "vma",
            "address",
            "pte"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ptep_clear_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "81-90",
          "snippet": "pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "address",
            "pte_pfn(*pte)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pte"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "*pte"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "*pte"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "page_vma_mapped_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "138-247",
          "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "vma->vm_mm",
            "start",
            "end"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vma->vm_end",
            "start + (PAGE_SIZE << compound_order(page))"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool page_mkclean_one(struct page *page, struct vm_area_struct *vma,\n\t\t\t    unsigned long address, void *arg)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = address,\n\t\t.flags = PVMW_SYNC,\n\t};\n\tunsigned long start = address, end;\n\tint *cleaned = arg;\n\n\t/*\n\t * We have to assume the worse case ie pmd for invalidation. Note that\n\t * the page can not be free from this function.\n\t */\n\tend = min(vma->vm_end, start + (PAGE_SIZE << compound_order(page)));\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, start, end);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\tunsigned long cstart;\n\t\tint ret = 0;\n\n\t\tcstart = address = pvmw.address;\n\t\tif (pvmw.pte) {\n\t\t\tpte_t entry;\n\t\t\tpte_t *pte = pvmw.pte;\n\n\t\t\tif (!pte_dirty(*pte) && !pte_write(*pte))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\t\tentry = ptep_clear_flush(vma, address, pte);\n\t\t\tentry = pte_wrprotect(entry);\n\t\t\tentry = pte_mkclean(entry);\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tret = 1;\n\t\t} else {\n#ifdef CONFIG_TRANSPARENT_HUGE_PAGECACHE\n\t\t\tpmd_t *pmd = pvmw.pmd;\n\t\t\tpmd_t entry;\n\n\t\t\tif (!pmd_dirty(*pmd) && !pmd_write(*pmd))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_page(vma, address, page_to_pfn(page));\n\t\t\tentry = pmdp_huge_clear_flush(vma, address, pmd);\n\t\t\tentry = pmd_wrprotect(entry);\n\t\t\tentry = pmd_mkclean(entry);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmd, entry);\n\t\t\tcstart &= PMD_MASK;\n\t\t\tret = 1;\n#else\n\t\t\t/* unexpected pmd-mapped page? */\n\t\t\tWARN_ON_ONCE(1);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tif (ret)\n\t\t\t(*cleaned)++;\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\n\treturn true;\n}"
  },
  {
    "function_name": "page_referenced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "836-881",
    "snippet": "int page_referenced(struct page *page,\n\t\t    int is_locked,\n\t\t    struct mem_cgroup *memcg,\n\t\t    unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct page_referenced_arg pra = {\n\t\t.mapcount = total_mapcount(page),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t*vm_flags = 0;\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tif (!page_rmapping(page))\n\t\treturn 0;\n\n\tif (!is_locked && (!PageAnon(page) || PageKsm(page))) {\n\t\twe_locked = trylock_page(page);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_page_referenced_vma;\n\t}\n\n\trmap_walk(page, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tunlock_page(page);\n\n\treturn pra.referenced;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_walk",
          "args": [
            "page",
            "&rwc"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1908-1916",
          "snippet": "void rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_rmapping",
          "args": [
            "page"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "page_rmapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "460-464",
          "snippet": "void *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "total_mapcount",
          "args": [
            "page"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "total_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2505-2526",
          "snippet": "int total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_referenced(struct page *page,\n\t\t    int is_locked,\n\t\t    struct mem_cgroup *memcg,\n\t\t    unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct page_referenced_arg pra = {\n\t\t.mapcount = total_mapcount(page),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t*vm_flags = 0;\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tif (!page_rmapping(page))\n\t\treturn 0;\n\n\tif (!is_locked && (!PageAnon(page) || PageKsm(page))) {\n\t\twe_locked = trylock_page(page);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_page_referenced_vma;\n\t}\n\n\trmap_walk(page, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tunlock_page(page);\n\n\treturn pra.referenced;\n}"
  },
  {
    "function_name": "invalid_page_referenced_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "815-824",
    "snippet": "static bool invalid_page_referenced_vma(struct vm_area_struct *vma, void *arg)\n{\n\tstruct page_referenced_arg *pra = arg;\n\tstruct mem_cgroup *memcg = pra->memcg;\n\n\tif (!mm_match_cgroup(vma->vm_mm, memcg))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_match_cgroup",
          "args": [
            "vma->vm_mm",
            "memcg"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool invalid_page_referenced_vma(struct vm_area_struct *vma, void *arg)\n{\n\tstruct page_referenced_arg *pra = arg;\n\tstruct mem_cgroup *memcg = pra->memcg;\n\n\tif (!mm_match_cgroup(vma->vm_mm, memcg))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "page_referenced_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "753-813",
    "snippet": "static bool page_referenced_one(struct page *page, struct vm_area_struct *vma,\n\t\t\tunsigned long address, void *arg)\n{\n\tstruct page_referenced_arg *pra = arg;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = address,\n\t};\n\tint referenced = 0;\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\taddress = pvmw.address;\n\n\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tpra->vm_flags |= VM_LOCKED;\n\t\t\treturn false; /* To break the loop */\n\t\t}\n\n\t\tif (pvmw.pte) {\n\t\t\tif (ptep_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pte)) {\n\t\t\t\t/*\n\t\t\t\t * Don't treat a reference through\n\t\t\t\t * a sequentially read mapping as such.\n\t\t\t\t * If the page has been used in another mapping,\n\t\t\t\t * we will catch it; if this other mapping is\n\t\t\t\t * already gone, the unmap path will have set\n\t\t\t\t * PG_referenced or activated the page.\n\t\t\t\t */\n\t\t\t\tif (likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\treferenced++;\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {\n\t\t\tif (pmdp_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pmd))\n\t\t\t\treferenced++;\n\t\t} else {\n\t\t\t/* unexpected pmd-mapped page? */\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tpra->mapcount--;\n\t}\n\n\tif (referenced)\n\t\tclear_page_idle(page);\n\tif (test_and_clear_page_young(page))\n\t\treferenced++;\n\n\tif (referenced) {\n\t\tpra->referenced++;\n\t\tpra->vm_flags |= vma->vm_flags;\n\t}\n\n\tif (!pra->mapcount)\n\t\treturn false; /* To break the loop */\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_clear_page_young",
          "args": [
            "page"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_idle",
          "args": [
            "page"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_clear_flush_young_notify",
          "args": [
            "vma",
            "address",
            "pvmw.pmd"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRANSPARENT_HUGEPAGE"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(vma->vm_flags & VM_SEQ_READ)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush_young_notify",
          "args": [
            "vma",
            "address",
            "pvmw.pte"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "page_vma_mapped_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "138-247",
          "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool page_referenced_one(struct page *page, struct vm_area_struct *vma,\n\t\t\tunsigned long address, void *arg)\n{\n\tstruct page_referenced_arg *pra = arg;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = address,\n\t};\n\tint referenced = 0;\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\taddress = pvmw.address;\n\n\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tpra->vm_flags |= VM_LOCKED;\n\t\t\treturn false; /* To break the loop */\n\t\t}\n\n\t\tif (pvmw.pte) {\n\t\t\tif (ptep_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pte)) {\n\t\t\t\t/*\n\t\t\t\t * Don't treat a reference through\n\t\t\t\t * a sequentially read mapping as such.\n\t\t\t\t * If the page has been used in another mapping,\n\t\t\t\t * we will catch it; if this other mapping is\n\t\t\t\t * already gone, the unmap path will have set\n\t\t\t\t * PG_referenced or activated the page.\n\t\t\t\t */\n\t\t\t\tif (likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\treferenced++;\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {\n\t\t\tif (pmdp_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pmd))\n\t\t\t\treferenced++;\n\t\t} else {\n\t\t\t/* unexpected pmd-mapped page? */\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tpra->mapcount--;\n\t}\n\n\tif (referenced)\n\t\tclear_page_idle(page);\n\tif (test_and_clear_page_young(page))\n\t\treferenced++;\n\n\tif (referenced) {\n\t\tpra->referenced++;\n\t\tpra->vm_flags |= vma->vm_flags;\n\t}\n\n\tif (!pra->mapcount)\n\t\treturn false; /* To break the loop */\n\n\treturn true;\n}"
  },
  {
    "function_name": "mm_find_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "710-742",
    "snippet": "pmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "pmde"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmde"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "address"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "address"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_present",
          "args": [
            "*p4d"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "address"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pgd"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "address"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}"
  },
  {
    "function_name": "page_address_in_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "687-708",
    "snippet": "unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "address < vma->vm_start || address >= vma->vm_end"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vma_address",
          "args": [
            "page",
            "vma"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "336-341",
          "snippet": "static inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_anon_vma",
          "args": [
            "page"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "page_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "489-498",
          "snippet": "struct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}"
  },
  {
    "function_name": "should_defer_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "677-680",
    "snippet": "static bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "set_tlb_ubc_flush_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "673-675",
    "snippet": "static void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n}"
  },
  {
    "function_name": "flush_tlb_batched_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "659-671",
    "snippet": "void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n\tif (mm->tlb_flush_batched) {\n\t\tflush_tlb_mm(mm);\n\n\t\t/*\n\t\t * Do not allow the compiler to re-order the clearing of\n\t\t * tlb_flush_batched before the tlb is flushed.\n\t\t */\n\t\tbarrier();\n\t\tmm->tlb_flush_batched = false;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_mm",
          "args": [
            "mm"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid flush_tlb_batched_pending(struct mm_struct *mm)\n{\n\tif (mm->tlb_flush_batched) {\n\t\tflush_tlb_mm(mm);\n\n\t\t/*\n\t\t * Do not allow the compiler to re-order the clearing of\n\t\t * tlb_flush_batched before the tlb is flushed.\n\t\t */\n\t\tbarrier();\n\t\tmm->tlb_flush_batched = false;\n\t}\n}"
  },
  {
    "function_name": "should_defer_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "629-642",
    "snippet": "static bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\tbool should_defer = false;\n\n\tif (!(flags & TTU_BATCH_FLUSH))\n\t\treturn false;\n\n\t/* If remote CPUs need to be flushed then defer batch the flush */\n\tif (cpumask_any_but(mm_cpumask(mm), get_cpu()) < nr_cpu_ids)\n\t\tshould_defer = true;\n\tput_cpu();\n\n\treturn should_defer;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_any_but",
          "args": [
            "mm_cpumask(mm)",
            "get_cpu()"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_cpumask",
          "args": [
            "mm"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\tbool should_defer = false;\n\n\tif (!(flags & TTU_BATCH_FLUSH))\n\t\treturn false;\n\n\t/* If remote CPUs need to be flushed then defer batch the flush */\n\tif (cpumask_any_but(mm_cpumask(mm), get_cpu()) < nr_cpu_ids)\n\t\tshould_defer = true;\n\tput_cpu();\n\n\treturn should_defer;\n}"
  },
  {
    "function_name": "set_tlb_ubc_flush_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "602-623",
    "snippet": "static void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tarch_tlbbatch_add_mm(&tlb_ubc->arch, mm);\n\ttlb_ubc->flush_required = true;\n\n\t/*\n\t * Ensure compiler does not re-order the setting of tlb_flush_batched\n\t * before the PTE is cleared.\n\t */\n\tbarrier();\n\tmm->tlb_flush_batched = true;\n\n\t/*\n\t * If the PTE was dirty then it's best to assume it's writable. The\n\t * caller must use try_to_unmap_flush_dirty() or try_to_unmap_flush()\n\t * before the page is queued for IO.\n\t */\n\tif (writable)\n\t\ttlb_ubc->writable = true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_tlbbatch_add_mm",
          "args": [
            "&tlb_ubc->arch",
            "mm"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tarch_tlbbatch_add_mm(&tlb_ubc->arch, mm);\n\ttlb_ubc->flush_required = true;\n\n\t/*\n\t * Ensure compiler does not re-order the setting of tlb_flush_batched\n\t * before the PTE is cleared.\n\t */\n\tbarrier();\n\tmm->tlb_flush_batched = true;\n\n\t/*\n\t * If the PTE was dirty then it's best to assume it's writable. The\n\t * caller must use try_to_unmap_flush_dirty() or try_to_unmap_flush()\n\t * before the page is queued for IO.\n\t */\n\tif (writable)\n\t\ttlb_ubc->writable = true;\n}"
  },
  {
    "function_name": "try_to_unmap_flush_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "594-600",
    "snippet": "void try_to_unmap_flush_dirty(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (tlb_ubc->writable)\n\t\ttry_to_unmap_flush();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_unmap_flush",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap_flush_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "594-600",
          "snippet": "void try_to_unmap_flush_dirty(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (tlb_ubc->writable)\n\t\ttry_to_unmap_flush();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid try_to_unmap_flush_dirty(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (tlb_ubc->writable)\n\t\ttry_to_unmap_flush();\n}"
  },
  {
    "function_name": "try_to_unmap_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "581-591",
    "snippet": "void try_to_unmap_flush(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (!tlb_ubc->flush_required)\n\t\treturn;\n\n\tarch_tlbbatch_flush(&tlb_ubc->arch);\n\ttlb_ubc->flush_required = false;\n\ttlb_ubc->writable = false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_tlbbatch_flush",
          "args": [
            "&tlb_ubc->arch"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid try_to_unmap_flush(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (!tlb_ubc->flush_required)\n\t\treturn;\n\n\tarch_tlbbatch_flush(&tlb_ubc->arch);\n\ttlb_ubc->flush_required = false;\n\ttlb_ubc->writable = false;\n}"
  },
  {
    "function_name": "page_unlock_anon_vma_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "569-572",
    "snippet": "void page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_unlock_read",
          "args": [
            "anon_vma"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}"
  },
  {
    "function_name": "page_lock_anon_vma_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "507-567",
    "snippet": "struct anon_vma *page_lock_anon_vma_read(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the page is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!page_mapped(page)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_anon_vma",
          "args": [
            "anon_vma"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_read",
          "args": [
            "anon_vma"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&anon_vma->refcount"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_read",
          "args": [
            "anon_vma"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&anon_vma->refcount"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&root_anon_vma->rwsem"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&root_anon_vma->rwsem"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "anon_vma->root"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_lock_anon_vma_read(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the page is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!page_mapped(page)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}"
  },
  {
    "function_name": "page_get_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "464-498",
    "snippet": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "anon_vma"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&anon_vma->refcount"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}"
  },
  {
    "function_name": "anon_vma_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "432-439",
    "snippet": "void __init anon_vma_init(void)\n{\n\tanon_vma_cachep = kmem_cache_create(\"anon_vma\", sizeof(struct anon_vma),\n\t\t\t0, SLAB_TYPESAFE_BY_RCU|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tanon_vma_ctor);\n\tanon_vma_chain_cachep = KMEM_CACHE(anon_vma_chain,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *anon_vma_cachep;",
      "static struct kmem_cache *anon_vma_chain_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "anon_vma_chain",
            "SLAB_PANIC|SLAB_ACCOUNT"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"anon_vma\"",
            "sizeof(struct anon_vma)",
            "0",
            "SLAB_TYPESAFE_BY_RCU|SLAB_PANIC|SLAB_ACCOUNT",
            "anon_vma_ctor"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "517-523",
          "snippet": "struct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_cachep;\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nvoid __init anon_vma_init(void)\n{\n\tanon_vma_cachep = kmem_cache_create(\"anon_vma\", sizeof(struct anon_vma),\n\t\t\t0, SLAB_TYPESAFE_BY_RCU|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tanon_vma_ctor);\n\tanon_vma_chain_cachep = KMEM_CACHE(anon_vma_chain,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT);\n}"
  },
  {
    "function_name": "anon_vma_ctor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "423-430",
    "snippet": "static void anon_vma_ctor(void *data)\n{\n\tstruct anon_vma *anon_vma = data;\n\n\tinit_rwsem(&anon_vma->rwsem);\n\tatomic_set(&anon_vma->refcount, 0);\n\tanon_vma->rb_root = RB_ROOT_CACHED;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&anon_vma->refcount",
            "0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&anon_vma->rwsem"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void anon_vma_ctor(void *data)\n{\n\tstruct anon_vma *anon_vma = data;\n\n\tinit_rwsem(&anon_vma->rwsem);\n\tatomic_set(&anon_vma->refcount, 0);\n\tanon_vma->rb_root = RB_ROOT_CACHED;\n}"
  },
  {
    "function_name": "unlink_anon_vmas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "376-421",
    "snippet": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_chain_free",
          "args": [
            "avc"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "132-135",
          "snippet": "static void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_chain_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&avc->same_vma"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "anon_vma"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "anon_vma->degree"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "avc",
            "next",
            "&vma->anon_vma_chain",
            "same_vma"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_anon_vma_root",
          "args": [
            "root"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_anon_vma_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "243-247",
          "snippet": "static inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&avc->same_vma"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&anon_vma->rb_root.rb_root"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_remove",
          "args": [
            "avc",
            "&anon_vma->rb_root"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "86-90",
          "snippet": "void anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nvoid anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_anon_vma_root",
          "args": [
            "root",
            "anon_vma"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "lock_anon_vma_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "231-241",
          "snippet": "static inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "avc",
            "next",
            "&vma->anon_vma_chain",
            "same_vma"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}"
  },
  {
    "function_name": "anon_vma_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "315-374",
    "snippet": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\n\t/* Don't bother if the parent process has no anon_vma here. */\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\n\t/* Drop inherited anon_vma, we'll reuse existing or allocate new. */\n\tvma->anon_vma = NULL;\n\n\t/*\n\t * First, attach the new VMA to the parent VMA's anon_vmas,\n\t * so rmap can find non-COWed pages in child processes.\n\t */\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\n\t/* An existing anon_vma has been reused, all done then. */\n\tif (vma->anon_vma)\n\t\treturn 0;\n\n\t/* Then add our own anon_vma. */\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\n\t/*\n\t * The root anon_vma's spinlock is the lock actually used when we\n\t * lock any of the anon_vmas in this anon_vma tree.\n\t */\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\t/*\n\t * With refcounts, an anon_vma can stay around longer than the\n\t * process it belongs to. The root anon_vma needs to be pinned until\n\t * this anon_vma is freed, because the lock lives in the root.\n\t */\n\tget_anon_vma(anon_vma->root);\n\t/* Mark this anon_vma as the one where our new (COWed) pages go. */\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\n\treturn 0;\n\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink_anon_vmas",
          "args": [
            "vma"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_anon_vmas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "376-421",
          "snippet": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "anon_vma"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "anon_vma"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_chain_link",
          "args": [
            "vma",
            "avc",
            "anon_vma"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "137-145",
          "snippet": "static void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "anon_vma"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_anon_vma",
          "args": [
            "anon_vma->root"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "page_get_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "464-498",
          "snippet": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_chain_alloc",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "127-130",
          "snippet": "static inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_chain_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_alloc",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "78-95",
          "snippet": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t/* Reference for first vma */\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_cachep;\n\nstatic inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t/* Reference for first vma */\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_clone",
          "args": [
            "vma",
            "pvma"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "261-308",
          "snippet": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\n\t/* Don't bother if the parent process has no anon_vma here. */\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\n\t/* Drop inherited anon_vma, we'll reuse existing or allocate new. */\n\tvma->anon_vma = NULL;\n\n\t/*\n\t * First, attach the new VMA to the parent VMA's anon_vmas,\n\t * so rmap can find non-COWed pages in child processes.\n\t */\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\n\t/* An existing anon_vma has been reused, all done then. */\n\tif (vma->anon_vma)\n\t\treturn 0;\n\n\t/* Then add our own anon_vma. */\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\n\t/*\n\t * The root anon_vma's spinlock is the lock actually used when we\n\t * lock any of the anon_vmas in this anon_vma tree.\n\t */\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\t/*\n\t * With refcounts, an anon_vma can stay around longer than the\n\t * process it belongs to. The root anon_vma needs to be pinned until\n\t * this anon_vma is freed, because the lock lives in the root.\n\t */\n\tget_anon_vma(anon_vma->root);\n\t/* Mark this anon_vma as the one where our new (COWed) pages go. */\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\n\treturn 0;\n\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "anon_vma_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "261-308",
    "snippet": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink_anon_vmas",
          "args": [
            "dst"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_anon_vmas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "376-421",
          "snippet": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_anon_vma_root",
          "args": [
            "root"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_anon_vma_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "243-247",
          "snippet": "static inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_chain_link",
          "args": [
            "dst",
            "avc",
            "anon_vma"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "137-145",
          "snippet": "static void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_anon_vma_root",
          "args": [
            "root",
            "anon_vma"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "lock_anon_vma_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "231-241",
          "snippet": "static inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_chain_alloc",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "127-130",
          "snippet": "static inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_chain_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!avc"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "pavc",
            "&src->anon_vma_chain",
            "same_vma"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "unlock_anon_vma_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "243-247",
    "snippet": "static inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->rwsem"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}"
  },
  {
    "function_name": "lock_anon_vma_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "231-241",
    "snippet": "static inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->rwsem"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->rwsem"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "root"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}"
  },
  {
    "function_name": "__anon_vma_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "175-221",
    "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_chain_free",
          "args": [
            "avc"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "132-135",
          "snippet": "static void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_chain_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "avc"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "allocated"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "allocated"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "anon_vma"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_chain_link",
          "args": [
            "vma",
            "avc",
            "anon_vma"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "137-145",
          "snippet": "static void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!vma->anon_vma"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "anon_vma"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!anon_vma"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_alloc",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "78-95",
          "snippet": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t/* Reference for first vma */\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_cachep;\n\nstatic inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t/* Reference for first vma */\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_mergeable_anon_vma",
          "args": [
            "vma"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "find_mergeable_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1288-1318",
          "snippet": "struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma;\n\tstruct vm_area_struct *near;\n\n\tnear = vma->vm_next;\n\tif (!near)\n\t\tgoto try_prev;\n\n\tanon_vma = reusable_anon_vma(near, vma, near);\n\tif (anon_vma)\n\t\treturn anon_vma;\ntry_prev:\n\tnear = vma->vm_prev;\n\tif (!near)\n\t\tgoto none;\n\n\tanon_vma = reusable_anon_vma(near, near, vma);\n\tif (anon_vma)\n\t\treturn anon_vma;\nnone:\n\t/*\n\t * There's no absolute need to look only at touching neighbours:\n\t * we could search further afield for \"compatible\" anon_vmas.\n\t * But it would probably just be a waste of time searching,\n\t * or lead to too many vmas hanging off the same anon_vma.\n\t * We're trying to allow mprotect remerging later on,\n\t * not trying to minimize memory used for anon_vmas.\n\t */\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma;\n\tstruct vm_area_struct *near;\n\n\tnear = vma->vm_next;\n\tif (!near)\n\t\tgoto try_prev;\n\n\tanon_vma = reusable_anon_vma(near, vma, near);\n\tif (anon_vma)\n\t\treturn anon_vma;\ntry_prev:\n\tnear = vma->vm_prev;\n\tif (!near)\n\t\tgoto none;\n\n\tanon_vma = reusable_anon_vma(near, near, vma);\n\tif (anon_vma)\n\t\treturn anon_vma;\nnone:\n\t/*\n\t * There's no absolute need to look only at touching neighbours:\n\t * we could search further afield for \"compatible\" anon_vmas.\n\t * But it would probably just be a waste of time searching,\n\t * or lead to too many vmas hanging off the same anon_vma.\n\t * We're trying to allow mprotect remerging later on,\n\t * not trying to minimize memory used for anon_vmas.\n\t */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_chain_alloc",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_chain_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "127-130",
          "snippet": "static inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *anon_vma_chain_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "anon_vma_chain_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "137-145",
    "snippet": "static void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_insert",
          "args": [
            "avc",
            "&anon_vma->rb_root"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "72-84",
          "snippet": "INTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nINTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&avc->same_vma",
            "&vma->anon_vma_chain"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}"
  },
  {
    "function_name": "anon_vma_chain_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "132-135",
    "snippet": "static void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *anon_vma_chain_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "anon_vma_chain_cachep",
            "anon_vma_chain"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}"
  },
  {
    "function_name": "anon_vma_chain_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "127-130",
    "snippet": "static inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *anon_vma_chain_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "anon_vma_chain_cachep",
            "gfp"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}"
  },
  {
    "function_name": "anon_vma_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "97-125",
    "snippet": "static inline void anon_vma_free(struct anon_vma *anon_vma)\n{\n\tVM_BUG_ON(atomic_read(&anon_vma->refcount));\n\n\t/*\n\t * Synchronize against page_lock_anon_vma_read() such that\n\t * we can safely hold the lock without the anon_vma getting\n\t * freed.\n\t *\n\t * Relies on the full mb implied by the atomic_dec_and_test() from\n\t * put_anon_vma() against the acquire barrier implied by\n\t * down_read_trylock() from page_lock_anon_vma_read(). This orders:\n\t *\n\t * page_lock_anon_vma_read()\tVS\tput_anon_vma()\n\t *   down_read_trylock()\t\t  atomic_dec_and_test()\n\t *   LOCK\t\t\t\t  MB\n\t *   atomic_read()\t\t\t  rwsem_is_locked()\n\t *\n\t * LOCK should suffice since the actual taking of the lock must\n\t * happen _before_ what follows.\n\t */\n\tmight_sleep();\n\tif (rwsem_is_locked(&anon_vma->root->rwsem)) {\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\n\tkmem_cache_free(anon_vma_cachep, anon_vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *anon_vma_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "anon_vma_cachep",
            "anon_vma"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "anon_vma"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "anon_vma"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&anon_vma->root->rwsem"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "atomic_read(&anon_vma->refcount)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&anon_vma->refcount"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_cachep;\n\nstatic inline void anon_vma_free(struct anon_vma *anon_vma)\n{\n\tVM_BUG_ON(atomic_read(&anon_vma->refcount));\n\n\t/*\n\t * Synchronize against page_lock_anon_vma_read() such that\n\t * we can safely hold the lock without the anon_vma getting\n\t * freed.\n\t *\n\t * Relies on the full mb implied by the atomic_dec_and_test() from\n\t * put_anon_vma() against the acquire barrier implied by\n\t * down_read_trylock() from page_lock_anon_vma_read(). This orders:\n\t *\n\t * page_lock_anon_vma_read()\tVS\tput_anon_vma()\n\t *   down_read_trylock()\t\t  atomic_dec_and_test()\n\t *   LOCK\t\t\t\t  MB\n\t *   atomic_read()\t\t\t  rwsem_is_locked()\n\t *\n\t * LOCK should suffice since the actual taking of the lock must\n\t * happen _before_ what follows.\n\t */\n\tmight_sleep();\n\tif (rwsem_is_locked(&anon_vma->root->rwsem)) {\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\n\tkmem_cache_free(anon_vma_cachep, anon_vma);\n}"
  },
  {
    "function_name": "anon_vma_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
    "lines": "78-95",
    "snippet": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t/* Reference for first vma */\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/tlb.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/export.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *anon_vma_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&anon_vma->refcount",
            "1"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "anon_vma_cachep",
            "GFP_KERNEL"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *anon_vma_cachep;\n\nstatic inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t/* Reference for first vma */\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}"
  }
]